-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint64_t ConvertStringTo64Bit(const char* idstring);
	const char* FormatDateTimeString(int64_t time, const char* uiformat);
	Color GetChatAuthorColor(const char* authorname);
	int64_t GetCurrentUTCDataTime(void);
	const char* GetUserData(const char* name);
	bool IsVentureSeasonSupported(void);
	void NotifyChatMessageRead(void);
	void SetUserData(const char* name, const char* value);
]]

local menu = {
	name = "ChatWindow",
	active = false,
	userColors = {},
	mouseover = {},
	editboxstate = { text = "" },
	privatemessages = {},
	privateMessageIndex = 0,
	selectedPrivateMessages = 0,
}

local function init()
	-- register callbacks
	registerForEvent("chatMessageReceived", getElement("Scene.UIContract"), menu.onChatMessageReceived)
	RegisterEvent("announcementReceived", menu.onAnnouncementReceived)
	RegisterEvent("chatreported", menu.onChatReported)
	RegisterEvent("showchatwindow", function () return menu.toggleChatWindow() end)

	-- init variables
	menu.isStartmenu = C.IsStartmenu()

	SetScript("onHotkey", menu.onHotkey)

	-- register menu
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
end


--- config ---

local config = {
	layer = 3,
	contextLayer = 2,
	width = 400,
	frameBackgroundFactor = 1.3,
	currentVersion = 3,
	frameXDefault = 50,
	frameYDefault = Helper.viewHeight / 2,
	frameSizeDefault = "normal",
	timeout = 5,
	fadeout = 2,
	mouseOutRange = 100,
	contextMenuWidth = 260,
	announcementAgeCutOff = 3600,
}

-- __CORE_CHAT_WINDOW = {
--		version = number	-- data version
--		x = number			-- frame x offset
--		y = number			-- frame y offset
--		size = number		-- frame size
--		announcements = {}	-- announcement buffer
-- }
__CORE_CHAT_WINDOW = __CORE_CHAT_WINDOW or { version = config.currentVersion, x = config.frameXDefault, y = config.frameYDefault, size = config.frameSizeDefault, announcements = {} }
-- patch
if __CORE_CHAT_WINDOW.version <= 1 then
	__CORE_CHAT_WINDOW = { version = 2, x = config.frameXDefault, y = config.frameYDefault, size = config.frameSizeDefault }
end
if __CORE_CHAT_WINDOW.version <= 2 then
	__CORE_CHAT_WINDOW.announcements = {}
end
__CORE_CHAT_WINDOW.version = config.currentVersion


--- widget hooks ---

function menu.onHotkey(action)
	if action == "INPUT_ACTION_SHOW_CHAT_WINDOW" then
		menu.toggleChatWindow()
	end
end

function menu.onChatMessageReceived()
	if menu.shown then
		menu.messagesOutdated = true

		local messagetexts = menu.messagetexts
		if menu.selectedPrivateMessages > 0 then
			messagetexts = menu.privatemessages[menu.selectedPrivateMessages].messages
		end

		if menu.active then
			local toprow = GetTopRow(menu.chatTable)
			if toprow == ((#messagetexts < menu.numchatlines) and 3 or (#messagetexts + 3 - menu.numchatlines)) then
				menu.settoprow = nil
			else
				menu.settoprow = toprow
			end
		else
			if menu.fadetoprow == ((#messagetexts < menu.numchatlines) and 3 or (#messagetexts + 3 - menu.numchatlines)) then
				menu.settoprow = nil
			end
		end
		if not menu.dragging then
			if menu.typing then
				menu.activateeditbox = true
			end
			menu.onShowMenu()
		end
	end
end

function menu.onAnnouncementReceived(_, message)
	if (#__CORE_CHAT_WINDOW.announcements == 0) or (__CORE_CHAT_WINDOW.announcements[#__CORE_CHAT_WINDOW.announcements].text ~= message) then
		-- have to convert timestamp to string for saving in uidata.xml
		table.insert(__CORE_CHAT_WINDOW.announcements, { text = message, prefix = "\27M" .. ReadText(1001, 12109) .. ReadText(1001, 120) .. " ", timestamp = tostring(C.GetCurrentUTCDataTime() * 1000), announcement = true })
		if not menu.shown then
			menu.toggleChatWindow(true)
		end
	end
end

function menu.onChatReported(_, timestamp)
	if menu.shown then
		menu.messagesOutdated = true
		menu.onShowMenu()
	end
end

--- helper functions ---

function menu.toggleChatWindow(noeditboxactivation)
	if (not menu.shown) or (not menu.active) or next(Helper.chatParams) then
		menu.active = true
		menu.lastInteraction = getElapsedTime()
		Helper.setChatUpdateHandler(menu)
		menu.messagesOutdated = true
		menu.settoprow = nil

		if (not menu.shown) and (not noeditboxactivation) then
			menu.activateeditbox = true
		end

		if next(Helper.chatParams) then
			_, menu.selectedPrivateMessages = menu.getPrivateMessages(Helper.chatParams.id, Helper.chatParams.name)
			if menu.selectedPrivateMessages > menu.privateMessageIndex + 2 then
				menu.privateMessageIndex = menu.selectedPrivateMessages - 2
			elseif menu.selectedPrivateMessages < menu.privateMessageIndex then
				menu.privateMessageIndex = menu.selectedPrivateMessages
			end
			Helper.chatParams = {}
		end

		menu.onShowMenu()
	else
		menu.closeMenu("close")
	end
end

function menu.cleanup()
	menu.chatFrame = nil
	menu.active = false
	menu.dragging = nil
	menu.fadefactor = nil
	menu.islocked = nil

	menu.contextMenuMode = nil
	menu.contextMenuData = {}
	menu.mouseOutBox = nil
	
	menu.shown = nil
	menu.mouseover = {}
end

function menu.getChatColor(author, authorid, userid)
	if not menu.userColors[author] then
		if authorid == userid then
			menu.userColors[author] = Helper.color.playergreen
		else
			local color = C.GetChatAuthorColor(author)
			menu.userColors[author] = { r = color.red, g = color.green, b = color.blue, a = color.alpha }
		end
	end
	return menu.userColors[author]
end

function menu.getMessageReceiverID(userid, groupid)
	menu.chatgroups = menu.chatgroups or {}
	if not menu.chatgroups[groupid] then
		menu.chatgroups[groupid] = OnlineGetChatGroupUsers(groupid)
		if not next(menu.chatgroups[groupid]) then
			menu.chatgroups[groupid] = nil
			return -1, ""
		end
	end
	for _, user in ipairs(menu.chatgroups[groupid]) do
		if user.id ~= userid then
			return user.id, user.name
		end
	end
	return -1, ""
end

function menu.getPrivateMessages(receiverid, receivername, groupid, timestamp)
	local currentlastmessageread = groupid and C.ConvertStringTo64Bit(C.GetUserData("chat_group_" .. groupid)) or 0

	for i, entry in ipairs(menu.privatemessages) do
		if entry.receiverid == receiverid then
			if groupid and (menu.privatemessages[i].groupid == nil) then
				menu.privatemessages[i].groupid = groupid
			end
			if menu.privatemessages[i].hidden and ((not timestamp) or (timestamp > currentlastmessageread)) then
				menu.privatemessages[i].hidden = false
			end
			return menu.privatemessages[i].messages, i
		end
	end

	table.insert(menu.privatemessages, { receiverid = receiverid, name = receivername, groupid = groupid, hiden = (not timestamp) or (timestamp > currentlastmessageread), messages = {} })
	return menu.privatemessages[#menu.privatemessages].messages, #menu.privatemessages
end

function menu.getChatMessages()
	if menu.messagesOutdated then
		local username, userid = OnlineGetUserName()
		local fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
		menu.messagetexts = {}
		for i in ipairs(menu.privatemessages) do
			menu.privatemessages[i].messages = {}
		end

		local prevdate = ""
		local messages = OnlineGetChatMessages()
		for i, message in ipairs(messages) do
			local color = menu.getChatColor(message.author, message.authorid, userid)

			local timestamp = C.ConvertStringTo64Bit(tostring(message.time))
			local date = ffi.string(C.FormatDateTimeString(timestamp / 1000, "%Y-%m-%d"))
			if date ~= prevdate then
				prevdate = date
				table.insert(menu.messagetexts, { line = -1, text = "--- " .. date .. " ---", prefix = nil, timestamp = timestamp, authorid = message.authorid, datedivider = true })
			end

			local prefix = ffi.string(C.FormatDateTimeString(timestamp / 1000, "%H:%M")) .. " " .. Helper.convertColorToText(color) .. message.author .. "\27X" .. ReadText(1001, 120) .. " "
			local indent = C.GetTextWidth(prefix, Helper.standardFont, fontsize) + Helper.scaleX(Helper.standardTextOffsetx)

			local lines = GetTextLines(message.reported and ReadText(1001, 12116) or message.text, Helper.standardFont, fontsize, menu.width - indent - Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
			for j, line in ipairs(lines) do
				local text = message.reported and (Helper.convertColorToText(Helper.color.grey) .. line .. "\27X") or line

				if message.isprivate then
					local receiverid, receivername = menu.getMessageReceiverID(userid, message.groupid)
					if receiverid >= 0 then
						local messages, receiverid = menu.getPrivateMessages(receiverid, receivername, message.groupid, timestamp)
						table.insert(messages, { line = j, text = text, prefix = (j == 1) and prefix or nil, timestamp = timestamp, author = message.author, authorcolor = color, reported = message.reported, authorid = message.authorid })
					end
				else
					table.insert(menu.messagetexts, { line = j, text = text, prefix = (j == 1) and prefix or nil, timestamp = timestamp, author = message.author, authorcolor = color, reported = message.reported, authorid = message.authorid })
				end
			end
		end

		local announcementagecutoff = (C.GetCurrentUTCDataTime() - config.announcementAgeCutOff) * 1000
		for i = #__CORE_CHAT_WINDOW.announcements, 1, -1 do
			local announcement = Helper.tableCopy(__CORE_CHAT_WINDOW.announcements[i])
			announcement.timestamp = C.ConvertStringTo64Bit(announcement.timestamp)
			if announcement.timestamp < announcementagecutoff then
				table.remove(__CORE_CHAT_WINDOW.announcements, i)
			else
				local indent = C.GetTextWidth(announcement.prefix, Helper.standardFont, fontsize) + Helper.scaleX(Helper.standardTextOffsetx)
				local lines = GetTextLines(announcement.text, Helper.standardFont, fontsize, menu.width - indent - Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
				for j, line in ipairs(lines) do
					local announcementline = Helper.tableCopy(announcement)
					announcementline.text = "\27M" .. line .. "\27X"
					if j > 1 then
						announcementline.prefix = nil
					end
					announcementline.line = j
					table.insert(menu.messagetexts, announcementline)
				end
			end
		end
		table.sort(menu.messagetexts, menu.sortMessages)

		menu.messagesOutdated = nil
	end
end

function menu.sortMessages(a, b)
	if a.timestamp == b.timestamp then
		if a.authorid == b.authorid then
			return a.line < b.line
		end
		return a.authorid < b.authorid
	end
	return a.timestamp < b.timestamp
end

function menu.buttonDrag()
	local x, y = GetLocalMousePosition()
	local framex, framey = GetFramePosition(menu.chatFrame.id)

	menu.dragoffset = { x = x + Helper.viewWidth / 2 - framex, y = Helper.viewHeight / 2 - y - framey }
	menu.dragging = not menu.dragging
end

function menu.buttonReportMessage(timestamp, author)
	OpenMenu("MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "chat", "Inappropriate chat message", ConvertStringToLuaID(tostring(timestamp)), author } }, nil) -- hardcoded text only visible in venture server moderator interface
	menu.mouseover = {}
	menu.islocked = true
	menu.closeContextMenu(true)
end

function menu.buttonReportUser(userid)
	OpenMenu("MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "user", "Offensive user name", nil, nil, nil, userid } }, nil) -- hardcoded text only visible in venture server moderator interface
	menu.mouseover = {}
	menu.islocked = true
	menu.closeContextMenu(true)
end

function menu.buttonContactMessage(menu, userid, username)
	_, menu.selectedPrivateMessages = menu.getPrivateMessages(userid, username)
	if menu.selectedPrivateMessages > menu.privateMessageIndex + 2 then
		menu.privateMessageIndex = menu.selectedPrivateMessages - 2
	elseif menu.selectedPrivateMessages < menu.privateMessageIndex then
		menu.privateMessageIndex = menu.selectedPrivateMessages
	end
	menu.closeContextMenu(true)
	menu.onShowMenu()
end

function menu.buttonNextChannel()
	menu.selectedPrivateMessages = math.min(#menu.privatemessages, menu.selectedPrivateMessages + 1)
	if menu.selectedPrivateMessages > menu.privateMessageIndex + 2 then
		menu.privateMessageIndex = menu.selectedPrivateMessages - 2
	end
	menu.settoprow = nil
	menu.onShowMenu()
end

function menu.buttonPrevChannel()
	menu.selectedPrivateMessages = math.max(0, menu.selectedPrivateMessages - 1)
	if menu.selectedPrivateMessages < menu.privateMessageIndex then
		menu.privateMessageIndex = menu.selectedPrivateMessages
	end
	menu.settoprow = nil
	menu.onShowMenu()
end

function menu.buttonClosePrivateChat(idx)
	local entry = menu.privatemessages[idx]
	table.remove(menu.privatemessages, idx)
	menu.selectedPrivateMessages = math.min(menu.selectedPrivateMessages, #menu.privatemessages)
	if entry.groupid then
		C.SetUserData("chat_group_" .. entry.groupid, tostring(entry.messages[#entry.messages].timestamp))
		C.NotifyChatMessageRead()
	end
	menu.onShowMenu()
end

function menu.checkboxMute(_, checked)
	local userdataid = "chat_general_muted"
	if menu.selectedPrivateMessages > 0 then
		local entry = menu.privatemessages[menu.selectedPrivateMessages]
		userdataid = entry.groupid and ("chat_group_" .. entry.groupid .. "_muted") or ""
	end
	C.SetUserData(userdataid, checked and "1" or "0")
end

function menu.editboxActivated()
	menu.typing = true
	if menu.normalBackground then
		menu.activateeditbox = true
		menu.onShowMenu()
	end
end

function menu.editboxMessageChanged(_, text)
	menu.editboxstate.text = text

	-- kuertee start: signal md
	AddUITriggeredEvent("Chat_Window_API", "text_entered", {terms = {""}, text = text})
	-- kuertee end
end

function menu.editboxMessageCursorChanged(_, cursorpos, shiftstartpos)
	menu.editboxstate.cursorpos = cursorpos
	menu.editboxstate.shiftstartpos = shiftstartpos
end

function menu.editboxSendMessage(_, text, textchanged, isconfirmed, wastableclick)
	menu.typing = nil
	if not wastableclick then
		menu.editboxstate = { text = "" }
	end
	if (text == "") or wastableclick then
		menu.onShowMenu()
		return
	end

	local parameter = ""
	if string.sub(text, 1, 1) ~= "/" then
		-- no special command - interpret as chat message
		local userid = 0
		if menu.selectedPrivateMessages > 0 then
			userid = menu.privatemessages[menu.selectedPrivateMessages].receiverid
		end
		OnlineSendChatMessage(text, userid)
	elseif #text == 1 then
		DebugError("Invalid syntax. No command specified.")
		return -- abort command execution
	elseif string.sub(text, 2, 2) == " " then
		DebugError("Invalid syntax. A command must not be prefixed by whitespaces.")
		return -- abort command execution
	else
		-- otherwise we have a command
		-- check if we have (a) command parameter(s)
		local pos = string.find(text, " ") or 0

		-- subsitude the parameter (if any)
		if pos ~= 0 then
			parameter = string.sub(text, pos + 1) -- skip " "
		end

		-- substitude the command (strip the leading / and the parameter(s))
		text = string.sub(text, 2, pos - 1)

		-- finally execute the command	
		ExecuteDebugCommand(text, parameter)
	end

	menu.onShowMenu()
end

function menu.tabIconColor(messageindex)
	local userdataid = "chat_general_muted"
	if messageindex > 0 then
		local entry = menu.privatemessages[messageindex]
		userdataid = entry.groupid and ("chat_group_" .. entry.groupid .. "_muted") or ""
	end
	local muted = ffi.string(C.GetUserData(userdataid)) == "1"
	return muted and Helper.color.white or Helper.color.transparent
end

function menu.closeContextMenu(skiptoplevelmenu)
	if menu.contextMenuMode then
		Helper.clearFrame(menu, config.contextLayer)
		menu.contextMenuMode = nil
		menu.mouseOutBox = nil

		if not skiptoplevelmenu then
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
				OpenMenu("TopLevelMenu", { 0, 0 }, nil)
			end
		end
	end
end

--- menus ---

function menu.displayChat()
	Helper.clearDataForRefresh(menu, config.layer)

	local framebackgroundcolor = Helper.tableCopy(Helper.color.semitransparent)
	local textcolor = Helper.tableCopy(Helper.color.grey)
	local boxtextcolor = Helper.tableCopy(Helper.defaultEditBoxBackgroundColor)
	local linecolor = Helper.tableCopy(Helper.defaultSimpleBackgroundColor)
	if menu.fadefactor then
		framebackgroundcolor.a = menu.fadefactor * framebackgroundcolor.a
		textcolor.a = math.max(1, menu.fadefactor * textcolor.a)
		boxtextcolor.a = menu.fadefactor * boxtextcolor.a
		linecolor.a = menu.fadefactor * linecolor.a
	end

	menu.chatFrame = Helper.createFrameHandle(menu, {
		layer = config.layer,
		x = __CORE_CHAT_WINDOW.x,
		y = __CORE_CHAT_WINDOW.y,
		width = menu.width,
		height = menu.height,
		standardButtons = {},
		startAnimation = false,
		playerControls = true,
		viewHelperType = "Chat",
	})

	menu.table = {
		width = menu.width,
		x = 0,
	}

	local numcols = 10
	local ftable = menu.chatFrame:addTable(numcols, {
		tabOrder = menu.active and 2 or 0,
		x = menu.table.x,
		width = menu.table.width,
		highlightMode = "off",
		reserveScrollBar = false
	})
	local buttonWidth = Helper.scaleY(Helper.standardButtonHeight)
	local remainingWidth = menu.table.width - 4 * (buttonWidth + Helper.borderSize)
	local tabWidth = math.floor((remainingWidth - 2 * Helper.borderSize) / 3)
	ftable:setColWidth(1, buttonWidth, false)
	ftable:setColWidth(3, buttonWidth, false)
	ftable:setColWidth(4, tabWidth - buttonWidth - Helper.borderSize, false)
	ftable:setColWidth(5, buttonWidth, false)
	ftable:setColWidth(6, tabWidth - buttonWidth - Helper.borderSize, false)
	ftable:setColWidth(7, buttonWidth, false)
	ftable:setColWidth(8, buttonWidth, false)
	ftable:setColWidth(9, buttonWidth, false)
	ftable:setColWidth(10, math.max(buttonWidth, Helper.scrollbarWidth), false)

	-- header
	local row = ftable:addRow(menu.active, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = menu.active and (menu.selectedPrivateMessages > 0) }):setIcon("widget_arrow_left_01")
	row[1].handlers.onClick = menu.buttonPrevChannel

	menu.privateMessageIndex = math.max(0, math.min(#menu.privatemessages, menu.privateMessageIndex))
	local col = 2
	local shown = 0
	local messageindex = menu.privateMessageIndex
	while (shown < 3) and (messageindex <= #menu.privatemessages) do
		if messageindex == 0 then
			row[col]:setColSpan(2):createButton({ active = menu.active, bgColor = (menu.selectedPrivateMessages == 0) and Helper.defaultArrowRowBackgroundColor or nil }):setText(C.IsVentureSeasonSupported() and ReadText(1001, 11648) or ReadText(1001, 12101)):setIcon("menu_sound_off", { scaling = false, color = function () return menu.tabIconColor(0) end, width = buttonWidth, height = buttonWidth, x = tabWidth - buttonWidth })
			row[col].handlers.onClick = function () menu.selectedPrivateMessages = 0; menu.settoprow = nil; menu.onShowMenu() end
			col = col + 2
			shown = shown + 1
			messageindex = messageindex + 1
		else
			local i = messageindex
			local entry = menu.privatemessages[i]
			if not entry.hidden then
				local width = row[col]:getWidth() + Helper.borderSize
				row[col]:setBackgroundColSpan(2):createButton({ scaling = false, active = menu.active, bgColor = (menu.selectedPrivateMessages == i) and Helper.defaultArrowRowBackgroundColor or nil, width = width, height = Helper.scaleY(Helper.standardButtonHeight) }):setText(entry.name, { scaling = true }):setIcon("menu_sound_off", { color = function () return menu.tabIconColor(i) end, width = buttonWidth, height = buttonWidth, x = width - buttonWidth })
				row[col].handlers.onClick = function () menu.selectedPrivateMessages = i; menu.settoprow = nil; menu.onShowMenu() end
				row[col + 1]:createButton({ active = menu.active, bgColor = (menu.selectedPrivateMessages == i) and Helper.defaultArrowRowBackgroundColor or nil, width = Helper.standardButtonHeight }):setIcon("widget_cross_01")
				row[col + 1].handlers.onClick = function () menu.buttonClosePrivateChat(i) end
				col = col + 2
				shown = shown + 1
			end
			messageindex = messageindex + 1
		end
	end

	row[8]:createButton({ active = menu.active and (menu.selectedPrivateMessages < #menu.privatemessages) }):setIcon("widget_arrow_right_01")
	row[8].handlers.onClick = menu.buttonNextChannel

	row[9]:createButton({
		active = menu.active,
		bgColor = function () return menu.dragging and Helper.color.green or Helper.defaultButtonBackgroundColor end,
		highlightColor = function () return menu.dragging and Helper.color.green or Helper.defaultButtonHighlightColor end,
		mouseOverText = ReadText(1026, 12101),
	}):setIcon("menu_move")
	row[9].handlers.onClick = menu.buttonDrag

	row[10]:createButton({ active = menu.active, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 12102), ReadText(1001, 2670))), width = Helper.standardButtonHeight }):setIcon("widget_cross_01")
	row[10].handlers.onClick = function () menu.closeMenu() end

	-- line
	local row = ftable:addRow(false, { fixed = true, bgColor = linecolor })
	row[1]:setColSpan(numcols):createText(" ", { fontsize = 1, minRowHeight = 2 })

	local headerheight = ftable:getFullHeight()
	local messagetexts = menu.messagetexts
	if menu.selectedPrivateMessages > 0 then
		messagetexts = menu.privatemessages[menu.selectedPrivateMessages].messages
	end

	-- empty lines
	if #messagetexts < menu.numchatlines then
		for i = 1, menu.numchatlines - #messagetexts do
			local row = ftable:addRow(menu.active, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(numcols):createText("")
		end
	end

	-- message lines
	local indent = 0
	local fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
	for i, entry in ipairs(messagetexts) do
		if menu.active or (i >= menu.fadetoprow - 2) and (i < menu.fadetoprow - 2 + menu.numchatlines) then
			local row = ftable:addRow((menu.active and (not entry.datedivider) and (not entry.announcement)) and { timestamp = entry.timestamp, author = entry.author, authorcolor = entry.authorcolor, reported = entry.reported, announcement = entry.announcement, authorid = entry.authorid } or nil, { bgColor = Helper.color.transparent })
			if entry.prefix then
				indent = C.GetTextWidth(entry.prefix, Helper.standardFont, fontsize) + Helper.scaleX(Helper.standardTextOffsetx)
				row[1]:setColSpan(numcols):createText(entry.prefix .. entry.text, { color = menu.active and Helper.color.white or textcolor })
			elseif entry.datedivider then
				
				row[1]:setColSpan(numcols):createText(entry.text, { color = menu.active and Helper.color.white or textcolor, halign = "center" })
			else
				row[1]:setColSpan(numcols):createText(entry.text, { scaling = false, x = indent, fontsize = fontsize, minRowHeight = Helper.scaleY(Helper.standardTextHeight), color = menu.active and Helper.color.white or Helper.color.grey })
			end
		end
	end

	menu.settoprow = menu.settoprow or ((#messagetexts < menu.numchatlines) and 3 or (#messagetexts + 3 - menu.numchatlines))

	ftable:setTopRow(menu.settoprow)
	ftable:setSelectedRow(#messagetexts + 2)

	ftable.properties.maxVisibleHeight = headerheight + menu.numchatlines * (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize)

	if menu.chatFrame.properties.y + ftable.properties.maxVisibleHeight > Helper.viewHeight then
		__CORE_CHAT_WINDOW.y = Helper.viewHeight - ftable.properties.maxVisibleHeight
		menu.chatFrame.properties.y = __CORE_CHAT_WINDOW.y
		menu.chatFrame.properties.height = ftable.properties.maxVisibleHeight
	end

	-- editbox and options
	numcols = 4
	local ftable2 = menu.chatFrame:addTable(numcols, { tabOrder = menu.active and 1 or 0, x = menu.table.x, width = menu.table.width })
	ftable2:setColWidth(1, Helper.standardButtonHeight)

	local row = ftable2:addRow(menu.active, { fixed = true, bgColor = Helper.color.transparent })
	if menu.active then
		row[1]:setColSpan(numcols):createEditBox({ height = Helper.standardButtonHeight, description = ReadText(1001, 12108), maxChars = 255, selectTextOnActivation = false }):setText(menu.editboxstate.text, {  }):setHotkey("INPUT_STATE_ADDON_CHATWINDOW_COMMANDBAR", { displayIcon = true })
		row[1].handlers.onEditBoxActivated = menu.editboxActivated
		row[1].handlers.onTextChanged = menu.editboxMessageChanged
		row[1].handlers.onCursorChanged = menu.editboxMessageCursorChanged
		row[1].handlers.onEditBoxDeactivated = menu.editboxSendMessage
	else
		row[1]:setColSpan(numcols):createBoxText("", { boxColor = boxtextcolor })
	end

	--local row = ftable2:addRow(menu.active, { fixed = true, bgColor = Helper.color.transparent })
	--row[1]:createButton({ active = menu.active }):setText(ReadText(1001, 12106), { halign = "center" })
	--row[1].handlers.onClick = function () menu.options = not menu.options; menu.onShowMenu() end

	--if menu.options then
		local row = ftable2:addRow(menu.active, { fixed = true, bgColor = Helper.color.transparent })
		local userdataid = "chat_general_muted"
		if menu.selectedPrivateMessages > 0 then
			local entry = menu.privatemessages[menu.selectedPrivateMessages]
			userdataid = entry.groupid and ("chat_group_" .. entry.groupid .. "_muted") or ""
		end
		local muted = ffi.string(C.GetUserData(userdataid)) == "1"
		row[1]:createCheckBox(muted, { active = menu.active, width = Helper.standardButtonHeight })
		row[1].handlers.onClick = menu.checkboxMute
		row[2]:createText(ReadText(1001, 12107), { halign = "left" })

		local sizeoptions = {
			{ id = "small",		text = ReadText(1001, 12102),	icon = "", displayremoveoption = false },
			{ id = "normal",	text = ReadText(1001, 12103),	icon = "", displayremoveoption = false },
			{ id = "large",		text = ReadText(1001, 12104),	icon = "", displayremoveoption = false },
		}
		row[4]:createDropDown(sizeoptions, { startOption = __CORE_CHAT_WINDOW.size, height = Helper.standardButtonHeight, textOverride = ReadText(1001, 12105), active = menu.active }):setTextProperties({ halign = "center" })
		row[4].handlers.onDropDownConfirmed = function (_, id) __CORE_CHAT_WINDOW.size = id; menu.messagesOutdated = true; menu.settoprrow = nil; menu.onShowMenu() end
	--end

	ftable.properties.nextTable = ftable2.index
	ftable2.properties.prevTable = ftable.index

	local height = ftable:getVisibleHeight()
	ftable2.properties.y = ftable.properties.y + height + Helper.borderSize

	local height2 = ftable2:getFullHeight()
	menu.height = ftable2.properties.y + height2
	ftable2.properties.y = ftable.properties.y + height + Helper.borderSize
	menu.chatFrame.properties.height = menu.height
	if menu.activateeditbox then
		menu.chatFrame:setBackground("solid", { color = Helper.color.semitransparent, width = 2 * Helper.viewWidth, height = 2 * Helper.viewHeight })
		menu.chatFrame.properties.playerControls = false
		menu.normalBackground = false
	else
		menu.chatFrame:setBackground("gui_chat_background_01", { color = framebackgroundcolor, width = menu.width * config.frameBackgroundFactor, height = menu.height * config.frameBackgroundFactor })
		menu.normalBackground = true
	end

	if menu.chatFrame.properties.x + menu.chatFrame.properties.width > Helper.viewWidth then
		__CORE_CHAT_WINDOW.x = Helper.viewWidth - menu.chatFrame.properties.width
		menu.chatFrame.properties.x = __CORE_CHAT_WINDOW.x
	end

	if menu.chatFrame.properties.y + menu.chatFrame.properties.height > Helper.viewHeight then
		__CORE_CHAT_WINDOW.y = Helper.viewHeight - menu.chatFrame.properties.height
		menu.chatFrame.properties.y = __CORE_CHAT_WINDOW.y
	end

	menu.chatFrame:display()
end

function menu.createContextFrame(data, x, y, width, nomouseout)
	if Helper.topLevelMenu then
		local topLevelMenu = Helper.topLevelMenu
		Helper.closeMenu(topLevelMenu, "close")
		topLevelMenu.cleanup()
	end
	Helper.topLevelMenu = nil

	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local contextmenuwidth = width or menu.contextMenuWidth

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		width = contextmenuwidth,
		x = x,
		y = 0,
		autoFrameHeight = true,
		startAnimation = false,
		playerControls = true,
		viewHelperType = "Chat",
	})

	if menu.contextMenuMode == "report" then
		menu.createReportContext(menu.contextFrame)
	end

	if menu.contextFrame.properties.x + contextmenuwidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - contextmenuwidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()

	if not nomouseout then
		menu.mouseOutBox = {
			x1 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2                    - config.mouseOutRange,
			x2 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2 + contextmenuwidth + config.mouseOutRange,
			y1 = - menu.contextFrame.properties.y + Helper.viewHeight / 2                    + config.mouseOutRange,
			y2 = - menu.contextFrame.properties.y + Helper.viewHeight / 2 - height           - config.mouseOutRange
		}
	end
end

function menu.createReportContext(frame)
	local data = menu.contextMenuData.rowdata

	local ftable = frame:addTable(1, { tabOrder = 4, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(data.author, Helper.headerRowCenteredProperties)
	row[1].properties.color = data.authorcolor

	local _, userid = OnlineGetUserName()
	if data.authorid ~= userid then
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({  }):setText(ReadText(1001, 12115))
		row[1].handlers.onClick = function () return menu.buttonContactMessage(menu, data.authorid, data.author) end
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 12110), Helper.subHeaderTextProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({  }):setText(ReadText(1001, 12111))
	row[1].handlers.onClick = function () return menu.buttonReportUser(data.authorid) end
	
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = (not data.reported) and (not data.announcement) }):setText(ReadText(1001, 12112))
	row[1].handlers.onClick = function () return menu.buttonReportMessage(data.timestamp, data.author) end
end

--- Helper hooks ---

function menu.onShowMenu()
	menu.shown = true
	menu.typing = nil

	menu.width = Helper.scaleX(config.width)
	menu.numchatlines = 9
	if __CORE_CHAT_WINDOW.size == "small" then
		menu.width = math.floor(menu.width * 2 / 3)
		menu.numchatlines = 6
	elseif __CORE_CHAT_WINDOW.size == "large" then
		menu.width = math.floor(menu.width * 5 / 3)
		menu.numchatlines = 15
	end
	menu.height = Helper.viewHeight - __CORE_CHAT_WINDOW.y

	menu.getChatMessages()

	menu.displayChat()
end

function menu.viewCreated(layer, ...)
	if layer == config.layer then
		menu.chatTable, menu.optionTable = ...
	end
end

menu.updateInterval = 0.01
function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.dragging then
		menu.lastInteraction = curtime

		local x, y = GetLocalMousePosition()
		__CORE_CHAT_WINDOW.x = math.max(0, math.min(Helper.viewWidth - menu.width, Helper.viewWidth / 2 + x - menu.dragoffset.x))
		__CORE_CHAT_WINDOW.y = math.max(0, math.min(Helper.viewHeight - menu.height, Helper.viewHeight / 2 - y - menu.dragoffset.y))

		if menu.settoprow then
			menu.settoprow = GetTopRow(menu.chatTable)
		end
		menu.onShowMenu()
		return
	end

	if menu.typing then
		menu.lastInteraction = curtime
	end

	if next(menu.mouseover) then
		menu.lastInteraction = curtime
	end

	if menu.islocked then
		menu.lastInteraction = curtime
	end

	if menu.lastInteraction + config.timeout + config.fadeout < curtime then
		menu.closeMenu()
		return
	elseif menu.lastInteraction + config.timeout < curtime then
		if menu.active then
			menu.active = false
			menu.closeContextMenu()
			menu.fadetoprow = GetTopRow(menu.chatTable)
		end

		menu.fadefactor = 1 - (curtime - menu.lastInteraction - config.timeout) / config.fadeout
		menu.onShowMenu()
		return
	elseif menu.fadefactor then
		menu.active = true
		menu.fadefactor = nil
		menu.onShowMenu()
		return
	end

	if menu.mouseOutBox then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.activateeditbox then
		menu.activateeditbox = nil
		Helper.activateEditBox(menu.optionTable, 1, 1, menu.editboxstate.cursorpos, menu.editboxstate.shiftstartpos)
	end

	menu.chatFrame:update()
end

function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	if not menu.fadefactor then
		menu.lastInteraction = getElapsedTime()
	end
	local messagetexts = menu.messagetexts
	local userdataid = "chat_general"
	if menu.selectedPrivateMessages > 0 then
		local entry = menu.privatemessages[menu.selectedPrivateMessages]
		messagetexts = entry.messages
		userdataid = entry.groupid and ("chat_group_" .. entry.groupid) or ""
	end
	if (userdataid ~= "") and (#messagetexts > 0) then
		local toprow = GetTopRow(menu.chatTable)
		local lastshownline = math.max(1, math.min(#messagetexts, toprow + menu.numchatlines - 1))
		local lastmessageread = messagetexts[lastshownline].timestamp

		local currentlastmessageread = C.ConvertStringTo64Bit(C.GetUserData(userdataid))
		if lastmessageread > currentlastmessageread then
			C.SetUserData(userdataid, tostring(lastmessageread))
			C.NotifyChatMessageRead()
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if uitable == menu.chatTable then
		local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
		if type(rowdata) == "table" then
			local username, userid = OnlineGetUserName()
			if rowdata.authorid ~= userid then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end

				menu.contextMenuMode = "report"
				menu.contextMenuData = { rowdata = rowdata }
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y, Helper.scaleX(config.contextMenuWidth))
			end
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.mouseover[uitable] = true
end

function menu.onTableMouseOut(uitable, row)
	menu.mouseover[uitable] = nil
end

function menu.onRowChangedSound(row, rowdata, uitable, layer, modified, input, source)
	if not menu.dragging then
		PlaySound("ui_positive_hover_normal")
	end
end

function menu.onButtonOverSound(uitable, row, col, button, input)
	if not menu.dragging then
		if not menu.sound_selectedelement or button ~= menu.sound_selectedelement then
			if input == "mouse" then
				if (not menu.sound_buttonOverLock) then
					PlaySound("ui_positive_hover_normal")
					menu.sound_buttonOverLock = true
				end
			end
		end
		menu.sound_selectedelement = button
	end
end

function menu.closeMenu()
	Helper.clearChatUpdateHandler()
	Helper.clearFrame(menu, config.layer)
	menu.closeContextMenu()
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer)
	if layer == config.contextLayer then
		menu.closeContextMenu()
		return
	end
	menu.closeMenu()
end

function menu.callback(param)
	if param == "unlock" then
		menu.islocked = nil
	end
end

--- init ---

init()
﻿-- param == { 0, 0 }

-- modes: 

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef uint64_t UniverseID;
	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* id;
		const char* name;
		bool possible;
	} DroneModeInfo;
	typedef struct {
		UniverseID softtargetID;
		const char* softtargetConnectionName;
	} SofttargetDetails;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		UniverseID contextid;
		const char* path;
		const char* group;
	} UpgradeGroup2;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	bool CanActivateSeta(bool checkcontext);
	bool CanCancelConstruction(UniverseID containerid, BuildTaskID id);
	bool CanContainerEquipShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerSupplyShip(UniverseID containerid, UniverseID shipid);
	bool CanPlayerStandUp(void);
	bool CanStartTravelMode(UniverseID objectid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	const char* GetCurrentAmmoOfWeapon(UniverseID weaponid);
	const char* GetCurrentDroneMode(UniverseID defensibleid, const char* dronetype);
	UILogo GetCurrentPlayerLogo(void);
	uint32_t GetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetDroneModes(DroneModeInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* dronetype);
	UniverseID GetEnvironmentObject();
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDroneModes(UniverseID defensibleid, const char* dronetype);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumUnavailableUnits(UniverseID defensibleid, const char* cat);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	const char* GetObjectIDCode(UniverseID objectid);
	const char* GetPlayerCurrentControlGroup(void);
	UniverseID GetPlayerID(void);
	UniverseID GetPlayerObjectID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	UniverseID GetPlayerShipID(void);
	SofttargetDetails GetSofttarget(void);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	const char* GetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool GetUp(void);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetWeaponMode(UniverseID weaponid);
	bool HasShipFlightAssist(UniverseID shipid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsDroneTypeArmed(UniverseID defensibleid, const char* dronetype);
	bool IsDroneTypeBlocked(UniverseID defensibleid, const char* dronetype);
	bool IsPlayerControlGroupValid(void);
	bool IsTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool IsWeaponArmed(UniverseID weaponid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	bool QuickDock();
	bool RequestDockAt(UniverseID containerid, bool checkonly);
	void SetAllTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllTurretModes(UniverseID defensibleid, const char* mode);
	void SetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary, uint32_t groupidx);
	void SetDroneMode(UniverseID defensibleid, const char* dronetype, const char* mode);
	void SetDroneTypeArmed(UniverseID defensibleid, const char* dronetype, bool arm);
	void SetSubordinateGroupDockAtCommander(UniverseID controllableid, int group, bool value);
	void SetTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, bool arm);
	void SetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, const char* mode);
	void SetWeaponArmed(UniverseID weaponid, bool arm);
	void SetWeaponGroup(UniverseID defensibleid, UniverseID weaponid, bool primary, uint32_t groupidx, bool value);
	void SetWeaponMode(UniverseID weaponid, const char* mode);
	bool ShouldSubordinateGroupDockAtCommander(UniverseID controllableid, int group);
	void StartPlayerActivity(const char* activityid);
	void StopPlayerActivity(const char* activityid);
	bool ToggleAutoPilot(bool checkonly);
	void ToggleFlightAssist();
	const char* UndockPlayerShip(bool checkonly);
]]

-- menu variable - used by Helper and used for dynamic variables (e.g. inventory content, etc.)
local menu = {
	name = "DockedMenu"
}

-- config variable - put all static setup here
local config = {
	modes = {
		[1] = { id = "travel",			name = ReadText(1002, 1158),	stoptext = ReadText(1002, 1159),	action = 303 },
		[2] = { id = "scan",			name = ReadText(1002, 1156),	stoptext = ReadText(1002, 1157),	action = 304 },
		[3] = { id = "scan_longrange",	name = ReadText(1002, 1155),	stoptext = ReadText(1002, 1160),	action = 305 },
		[4] = { id = "seta",			name = ReadText(1001, 1132),	stoptext = ReadText(1001, 8606),	action = 225 },
	},
	consumables = {
		{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites,		callback = C.LaunchSatellite },
		{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons,		callback = C.LaunchNavBeacon },
		{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes,	callback = C.LaunchResourceProbe },
		{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers,		callback = C.LaunchLaserTower },
		{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines,			callback = C.LaunchMine },
	},
	inactiveButtonProperties = { bgColor = Helper.defaultUnselectableButtonBackgroundColor, highlightColor = Helper.defaultUnselectableButtonHighlightColor },
	activeButtonTextProperties = { halign = "center" },
	inactiveButtonTextProperties = { halign = "center", color = Helper.color.grey },
	dronetypes = {
		{ id = "orecollector",	name = ReadText(20214, 500) },
		{ id = "gascollector",	name = ReadText(20214, 400) },
		{ id = "defence",		name = ReadText(20214, 300) },
		{ id = "transport",		name = ReadText(20214, 900) },
	},
}

-- kuertee start:
local callbacks = {}
-- kuertee end

-- init menu and register with Helper
local function init()
	--print("Initializing")
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	menu.init = true
	registerForEvent("gameplanchange", getElement("Scene.UIContract"), menu.onGamePlanChange)
	RegisterEvent("conversationCancelled", menu.onConvEnds)
	RegisterEvent("conversationFinished", menu.onConvEnds)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_docked.xpl.init - kuertee")
end
-- kuertee end

function menu.onGamePlanChange(_, mode)
	if menu.init then
		if (mode == "cockpit") or (mode == "external") then
			local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if ((occupiedship ~= 0) and GetComponentData(occupiedship, "isdocked")) or ((controlpost ~= "") and (controlpost ~= "pilotcontrol")) then
				OpenMenu("DockedMenu", { 0, 0 }, nil)
			end
			menu.init = nil
		elseif (mode == "firstperson") or (mode == "externalfirstperson") then
			menu.init = nil
		end
	end
end

function menu.onConvEnds()
	if not Helper.hasConversationReturnHandler then
		local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
		local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
		if ((occupiedship ~= 0) and GetComponentData(occupiedship, "isdocked")) or ((controlpost ~= "") and (controlpost ~= "pilotcontrol")) then
			OpenMenu("DockedMenu", { 0, 0 }, nil)
		end
	end
end

-- cleanup variables in menu, no need for the menu variable to keep all the data while the menu is not active
function menu.cleanup()
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.topLevelOffsetY = nil

	--print("Cleaning Up")
	UnregisterEvent("playerUndock", menu.close)
	UnregisterEvent("playerGetUp", menu.close)
	menu.currentcontainer = nil
	--menu.topcontainer = nil
	menu.currentplayership = nil
	menu.secondarycontrolpost = nil
	menu.mode = nil
	menu.buildInProgress = nil
	menu.buildToCancel = nil
	menu.turrets = {}
	menu.turretgroups = {}

	menu.frame = nil
	menu.table_toplevel = nil
	menu.table_topleft = nil
	menu.table_header = nil
end

function menu.onShowMenu()
	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	-- close the menu if player either undocks or gets up while the menu is open.
	RegisterEvent("playerUndock", menu.close)
	RegisterEvent("playerGetUp", menu.close)

	--print("Showing Menu")
	menu.currentplayership = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
	if (controlpost ~= "") and (controlpost ~= "pilotcontrol") then
		menu.secondarycontrolpost = true
	end

	if menu.currentplayership ~= 0 then
		if GetComponentData(menu.currentplayership, "isdocked") then
			menu.mode = "docked"
			menu.currentcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(menu.currentplayership, "container", false)))
		else
			menu.mode = "cockpit"
			menu.currentcontainer = menu.currentplayership
		end
	else
		menu.currentcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(C.GetPlayerID(), "container", false)))
		if C.IsComponentClass(menu.currentcontainer, "ship") and (not GetComponentData(menu.currentcontainer, "isdocked")) then
			menu.mode = "cockpit"
		else
			menu.mode = "docked"
		end
	end
	--menu.topcontainer = ConvertStringTo64Bit(tostring(C.GetTopLevelContainer(menu.currentplayership)))
	--print("current player ship: " .. ffi.string(C.GetComponentName(menu.currentplayership)) .. ", currentcontainer: " .. ffi.string(C.GetComponentName(menu.currentcontainer)) .. ", topcontainer: " .. ffi.string(C.GetComponentName(menu.topcontainer)))

	menu.selectedRows = {}
	menu.selectedCols = {}
	-- init selection
	menu.firsttime = getElapsedTime() + 0.35

	-- add content
	menu.display()
end

function menu.display()
	Helper.removeAllWidgetScripts(menu)

	local width = Helper.viewWidth
	local height = Helper.viewHeight
	local xoffset = 0
	local yoffset = 0

	menu.frame = Helper.createFrameHandle(menu, { width = width, x = xoffset, y = yoffset, backgroundID = "solid", backgroundColor = Helper.color.semitransparent, standardButtons = (((menu.mode == "docked") and (menu.currentplayership ~= 0)) or menu.secondarycontrolpost) and {} or { close = true, back = true } })

	menu.createTopLevel(menu.frame)

	local table_topleft, table_header, table_button, row

	local isdocked = (menu.currentplayership ~= 0) and GetComponentData(menu.currentplayership, "isdocked")
	local ownericon, owner, shiptrader, isdock, canbuildships, isplayerowned, issupplyship, canhavetradeoffers, aipilot = GetComponentData(menu.currentcontainer, "ownericon", "owner", "shiptrader", "isdock", "canbuildships", "isplayerowned", "issupplyship", "canhavetradeoffers", "aipilot")
	local cantrade = canhavetradeoffers and isdock
	local canwareexchange = isplayerowned and ((not C.IsComponentClass(menu.currentcontainer, "ship")) or aipilot) 
	--NB: equipment docks currently do not have ship traders
	local dockedplayerships = {}
	Helper.ffiVLA(dockedplayerships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.currentcontainer, "player")
	local canequip = false
	local cansupply = false
	for _, ship in ipairs(dockedplayerships) do
		if C.CanContainerEquipShip(menu.currentcontainer, ship) then
			canequip = true
		end
		if isplayerowned and C.CanContainerSupplyShip(menu.currentcontainer, ship) then
			cansupply = true
		end
	end
	local canmodifyship = (shiptrader ~= nil) and (canequip or cansupply) and isdock
	local canbuyship = (shiptrader ~= nil) and canbuildships and isdock
	--print("cantrade: " .. tostring(cantrade) .. ", canbuyship: " .. tostring(canbuyship) .. ", canmodifyship: " .. tostring(canmodifyship))

	width = (width / 3) - Helper.borderSize

	-- set up a new table
	table_topleft = menu.frame:addTable(1, { tabOrder = 0, width = Helper.playerInfoConfig.width, height = Helper.playerInfoConfig.height, x = Helper.playerInfoConfig.offsetX, y = Helper.playerInfoConfig.offsetY, scaling = false })

	row = table_topleft:addRow(false, { fixed = true, bgColor = Helper.color.transparent60 })
	local icon = row[1]:createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = Helper.playerInfoConfig.height, height = Helper.playerInfoConfig.height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, Helper.playerInfoConfig.width - Helper.playerInfoConfig.height - Helper.borderSize))
	icon:setText(Helper.playerInfoConfigTextLeft,	{ fontsize = Helper.playerInfoConfig.fontsize, halign = "left",  x = Helper.playerInfoConfig.height + Helper.borderSize, y = (Helper.playerInfoConfig.height - textheight) / 2 })
	icon:setText2(Helper.playerInfoConfigTextRight,	{ fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize,          y = (Helper.playerInfoConfig.height - textheight) / 2 })

	local xoffset = (Helper.viewWidth - width) / 2
	local yoffset = 25

	table_header = menu.frame:addTable(11, { tabOrder = 1, width = width, x = xoffset, y = menu.topLevelOffsetY + Helper.borderSize + yoffset })
	table_header:setColWidth(1, math.floor((width - 2 * Helper.borderSize) / 3), false)
	table_header:setColWidth(3, Helper.standardTextHeight)
	table_header:setColWidth(4, Helper.standardTextHeight)
	table_header:setColWidth(5, Helper.standardTextHeight)
	table_header:setColWidth(6, Helper.standardTextHeight)
	table_header:setColWidth(8, Helper.standardTextHeight)
	table_header:setColWidth(9, Helper.standardTextHeight)
	table_header:setColWidth(10, Helper.standardTextHeight)
	table_header:setColWidth(11, Helper.standardTextHeight)
	table_header:setDefaultColSpan(1, 1)
	table_header:setDefaultColSpan(2, 5)
	table_header:setDefaultColSpan(7, 5)
	table_header:setDefaultBackgroundColSpan(1, 11)

	local row = table_header:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	local color = Helper.color.white
	if isplayerowned then
		if menu.currentcontainer == C.GetPlayerObjectID() then
			color = Helper.color.playergreen
		else
			color = Helper.color.green
		end
	end
	row[1]:setColSpan(11):createText(menu.currentcontainer and ffi.string(C.GetComponentName(menu.currentcontainer)) or "", Helper.headerRowCenteredProperties)
	row[1].properties.color = color

	height = Helper.scaleY(Helper.standardTextHeight)

	local row = table_header:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	if menu.mode == "cockpit" then
		row[2]:createText(ffi.string(C.GetObjectIDCode(menu.currentcontainer)), { halign = "center", color = color })
	else
		row[1]:createIcon(ownericon, { width = height, height = height, x = row[1]:getWidth() - height, scaling = false })
		row[2]:createText(function() return GetComponentData(menu.currentcontainer, "ownername") end, { halign = "center" })
		row[7]:createText(function() return "[" .. GetUIRelation(GetComponentData(menu.currentcontainer, "owner")) .. "]" end, { halign = "left" })
	end

	table_header:addEmptyRow(yoffset)

	if menu.mode == "cockpit" then
		local row = table_header:addRow("buttonRow1", { bgColor = Helper.color.transparent, fixed = true })
		row[1]:createButton(config.inactiveButtonProperties):setText("", config.inactiveButtonTextProperties)	-- dummy
		local active = ((menu.currentplayership ~= 0) or menu.secondarycontrolpost) and C.CanPlayerStandUp()
		row[2]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 277), helpOverlayID = "docked_getup", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 20014), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Get Up"
		if active then
			row[2].handlers.onClick = menu.buttonGetUp
		end
		row[7]:createButton({ mouseOverText = GetLocalizedKeyName("action", 316), helpOverlayID = "docked_shipinformation", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 8602), { halign = "center" })	-- "Ship Information"
		row[7].handlers.onClick = menu.buttonShipInfo

		local row = table_header:addRow("buttonRow3", { bgColor = Helper.color.transparent, fixed = true })
		local currentactivity = GetPlayerActivity()
		if currentactivity ~= "none" then
			local text = ""
			for _, entry in ipairs(config.modes) do
				if entry.id == currentactivity then
					text = entry.stoptext
					break
				end
			end
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			row[2]:createButton(active and {helpOverlayID = "docked_stopmode", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(text, active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Stop Mode"
			if active then
				row[2].handlers.onClick = menu.buttonStopMode
				row[2].properties.uiTriggerID = "stopmode"
			end
		else
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			local modes = {}
			if active then
				for _, entry in ipairs(config.modes) do
					local entryactive = menu.currentplayership ~= 0
					local visible = true
					if entry.id == "travel" then
						entryactive = entryactive and C.CanStartTravelMode(menu.currentplayership)
					elseif entry.id == "seta" then
						entryactive = true
						visible = C.CanActivateSeta(false)
					end
					local mouseovertext = GetLocalizedKeyName("action", entry.action)
					if visible then
						table.insert(modes, { id = entry.id, text = entry.name, icon = "", displayremoveoption = false, active = entryactive, mouseovertext = mouseovertext })
					end
				end
			end
			row[2]:createDropDown(modes, {
				helpOverlayID = "docked_modes",		
				helpOverlayText = " ", 
				helpOverlayHighlightOnly = true, 
				height = Helper.standardButtonHeight,
				startOption = "",
				textOverride = ReadText(1002, 1001),
				bgColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
				highlightColor = active and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor
			}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Modes
			if active then
				row[2].handlers.onDropDownConfirmed = menu.dropdownMode
				row[2].properties.uiTriggerID = "startmode"
			end
		end
		local civilian, military, isinhighway = {}, {}, false
		if menu.currentplayership ~= 0 then
			for _, consumabledata in ipairs(config.consumables) do
				local numconsumable = consumabledata.getnum(menu.currentplayership)
				if numconsumable > 0 then
					local consumables = ffi.new("AmmoData[?]", numconsumable)
					numconsumable = consumabledata.getdata(consumables, numconsumable, menu.currentplayership)
					for j = 0, numconsumable - 1 do
						if consumables[j].amount > 0 then
							local macro = ffi.string(consumables[j].macro)
							if consumabledata.type == "civilian" then
								table.insert(civilian, { id = consumabledata.id .. ":" .. macro, text = GetMacroData(macro, "name"), text2 = "(" .. consumables[j].amount .. ")", icon = "", displayremoveoption = false })
							else
								table.insert(military, { id = consumabledata.id .. ":" .. macro, text = GetMacroData(macro, "name"), text2 = "(" .. consumables[j].amount .. ")", icon = "", displayremoveoption = false })
							end
						end
					end
				end
			end
			isinhighway = C.GetContextByClass(menu.currentplayership, "highway", false) ~= 0
		end
		local active = (#civilian > 0) and (not isinhighway)
		local mouseovertext = ""
		if #civilian == 0 then
			mouseovertext = ReadText(1026, 7818)
		elseif isinhighway then
			mouseovertext = ReadText(1026, 7845)
		end
		row[1]:createDropDown(civilian, {
			helpOverlayID = "docked_deploy_civ",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
			height = Helper.standardButtonHeight,
			startOption = "",
			textOverride = ReadText(1001, 8607),
			text2Override = " ",
			bgColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
			highlightColor = active and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
			mouseOverText = mouseovertext,
		}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties):setText2Properties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Deploy Civilian
		row[1].properties.text2.halign = "right"
		row[1].properties.text2.x = Helper.standardTextOffsetx
		if active then
			row[1].handlers.onDropDownConfirmed = menu.dropdownDeploy
		end
		local active = (#military > 0) and (not isinhighway)
		local mouseovertext = ""
		if #military == 0 then
			mouseovertext = ReadText(1026, 7819)
		elseif isinhighway then
			mouseovertext = ReadText(1026, 7845)
		end
		row[7]:createDropDown(military, {
			helpOverlayID = "docked_deploy_mil",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
			height = Helper.standardButtonHeight,
			startOption = "",
			textOverride = ReadText(1001, 8608),
			text2Override = " ",
			bgColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
			highlightColor = active and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
			mouseOverText = mouseovertext,
		}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties):setText2Properties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Deploy Military
		row[7].properties.text2.halign = "right"
		row[7].properties.text2.x = Helper.standardTextOffsetx
		if active then
			row[7].handlers.onDropDownConfirmed = menu.dropdownDeploy
		end

		local row = table_header:addRow("buttonRow2", { bgColor = Helper.color.transparent, fixed = true })
		local active = (menu.currentplayership ~= 0) and C.HasShipFlightAssist(menu.currentplayership)
		row[1]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 221), helpOverlayID = "docked_flightassist", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8604), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Flight Assist"
		if active then
			row[1].handlers.onClick = menu.buttonFlightAssist
		end
		row[2]:createButton({ bgColor = menu.dockButtonBGColor, highlightColor = menu.dockButtonHighlightColor, helpOverlayID = "docked_dock", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 8605), { halign = "center", color = menu.dockButtonTextColor })	-- "Dock"
		row[2].properties.mouseOverText = GetLocalizedKeyName("action", 175)
		row[2].handlers.onClick = menu.buttonDock
		local active = (menu.currentplayership ~= 0) and C.ToggleAutoPilot(true)
		row[7]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 179), helpOverlayID = "docked_autopilot", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8603), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Autopilot"
		if active then
			row[7].handlers.onClick = menu.buttonAutoPilot
		end

		-- start: kuertee call-back
		if callbacks ["display_on_after_main_interactions"] then
  			for _, callback in ipairs (callbacks ["display_on_after_main_interactions"]) do
  				callback (table_header)
  			end
  		end
		-- end: kuertee call-back

		if menu.currentplayership ~= 0 then
			local weapons = {}
			local numslots = tonumber(C.GetNumUpgradeSlots(menu.currentplayership, "", "weapon"))
			for j = 1, numslots do
				local current = C.GetUpgradeSlotCurrentComponent(menu.currentplayership, "weapon", j)
				if current ~= 0 then
					table.insert(weapons, current)
				end
			end
			local pilot = GetComponentData(menu.currentplayership, "assignedpilot")
			menu.currentammo = {}
			if #weapons > 0 then
				table_header:addEmptyRow(yoffset)

				local titlerow = table_header:addRow(false, { bgColor = Helper.color.transparent })
				titlerow[1]:setColSpan(11):createText(ReadText(1001, 9409), Helper.headerRowCenteredProperties)
				titlerow[1].properties.helpOverlayID = "docked_weaponconfig"
				titlerow[1].properties.helpOverlayText = " "
				titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
				titlerow[1].properties.helpOverlayHighlightOnly = true
				titlerow[1].properties.helpOverlayScaling = false

				local row = table_header:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:createText(ReadText(1001, 9410), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 9411), { font = Helper.standardFontBold, halign = "center" })
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

				-- active weapon groups
				local row = table_header:addRow("weaponconfig_active", { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createText(ReadText(1001, 11218))
				row[7]:setColSpan(1)
				for j = 1, 4 do
					row[2 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(menu.currentplayership, true) == j end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight, symbol = "arrow", bgColor = function () return menu.checkboxWeaponGroupColor(j, true) end })
					row[2 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(menu.currentplayership, true, j) end
				end
				for j = 1, 4 do
					row[7 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(menu.currentplayership, false) == j end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight, symbol = "arrow", bgColor = function () return menu.checkboxWeaponGroupColor(j, false) end })
					row[7 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(menu.currentplayership, false, j) end
				end
				table_header:addEmptyRow(Helper.standardTextHeight / 2)

				for _, weapon in ipairs(weapons) do
					local numweapongroups = C.GetNumWeaponGroupsByWeapon(menu.currentplayership, weapon)
					local rawweapongroups = ffi.new("UIWeaponGroup[?]", numweapongroups)
					numweapongroups = C.GetWeaponGroupsByWeapon(rawweapongroups, numweapongroups, menu.currentplayership, weapon)
					local uiweapongroups = { primary = {}, secondary = {} }
					for j = 0, numweapongroups-1 do
						if rawweapongroups[j].primary then
							uiweapongroups.primary[rawweapongroups[j].idx] = true
						else
							uiweapongroups.secondary[rawweapongroups[j].idx] = true
						end
					end

					local row = table_header:addRow("weaponconfig", { bgColor = Helper.color.transparent })
					row[1]:setColSpan(2):createText(ffi.string(C.GetComponentName(weapon)))
					row[7]:setColSpan(1)
					for j = 1, 4 do
						row[2 + j]:createCheckBox(uiweapongroups.primary[j], { width = Helper.standardTextHeight, height = Helper.standardTextHeight, bgColor = function () return menu.checkboxWeaponGroupColor(j, true) end })
						row[2 + j].handlers.onClick = function() menu.checkboxWeaponGroup(menu.currentplayership, weapon, true, j, not uiweapongroups.primary[j]) end
					end
					for j = 1, 4 do
						row[7 + j]:createCheckBox(uiweapongroups.secondary[j], { width = Helper.standardTextHeight, height = Helper.standardTextHeight, bgColor = function () return menu.checkboxWeaponGroupColor(j, false) end })
						row[7 + j].handlers.onClick = function() menu.checkboxWeaponGroup(menu.currentplayership, weapon, false, j, not uiweapongroups.secondary[j]) end
					end
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

					if C.IsComponentClass(weapon, "missilelauncher") then
						local nummissiletypes = C.GetNumAllMissiles(menu.currentplayership)
						local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
						nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, menu.currentplayership)

						local weaponmacro = GetComponentData(ConvertStringTo64Bit(tostring(weapon)), "macro")
						local dropdowndata = {}
						for j = 0, nummissiletypes-1 do
							local ammomacro = ffi.string(missilestoragetable[j].macro)
							if C.IsAmmoMacroCompatible(weaponmacro, ammomacro) then
								table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name"), icon = "", displayremoveoption = false})
							end
						end

						-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
						menu.currentammo[tostring(weapon)] = "empty"
						local dropdownactive = true
						if #dropdowndata == 0 then
							dropdownactive = false
							table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
						else
							-- NB: currentammomacro can be null
							menu.currentammo[tostring(weapon)] = ffi.string(C.GetCurrentAmmoOfWeapon(weapon))
						end

						local row = table_header:addRow("ammo_config", { bgColor = Helper.color.transparent })
						row[1]:createText("    " .. ReadText(1001, 2800) .. ReadText(1001, 120))	-- Ammunition, :
						row[2]:setColSpan(10):createDropDown(dropdowndata, { startOption = function () return menu.getDropDownOption(weapon) end, active = dropdownactive })
						row[2].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(weapon, newammomacro) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					elseif pilot and C.IsComponentClass(weapon, "bomblauncher") then
						local pilot64 = ConvertIDTo64Bit(pilot)
						local numbombtypes = C.GetNumAllInventoryBombs(pilot64)
						local bombstoragetable = ffi.new("AmmoData[?]", numbombtypes)
						numbombtypes = C.GetAllInventoryBombs(bombstoragetable, numbombtypes, pilot64)

						local weaponmacro = GetComponentData(ConvertStringTo64Bit(tostring(weapon)), "macro")
						local dropdowndata = {}
						for j = 0, numbombtypes-1 do
							local ammomacro = ffi.string(bombstoragetable[j].macro)
							if C.IsAmmoMacroCompatible(weaponmacro, ammomacro) then
								table.insert(dropdowndata, { id = ammomacro, text = GetMacroData(ammomacro, "name"), icon = "", displayremoveoption = false })
							end
						end

						-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
						menu.currentammo[tostring(weapon)] = "empty"
						local dropdownactive = true
						if #dropdowndata == 0 then
							dropdownactive = false
							table.insert(dropdowndata, { id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false })	-- Out of ammo
						else
							-- NB: currentammomacro can be null
							menu.currentammo[tostring(weapon)] = ffi.string(C.GetCurrentAmmoOfWeapon(weapon))
						end

						local row = table_header:addRow("ammo_config", { bgColor = Helper.color.transparent })
						row[1]:createText("    " .. ReadText(1001, 2800) .. ReadText(1001, 120))	-- Ammunition, :
						row[2]:setColSpan(10):createDropDown(dropdowndata, { startOption = function () return menu.getDropDownOption(weapon) end, active = dropdownactive })
						row[2].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(weapon, newammomacro) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				end
			end

			local hasonlytugturrets = true
			menu.turrets = {}
			local numslots = tonumber(C.GetNumUpgradeSlots(menu.currentplayership, "", "turret"))
			for j = 1, numslots do
				local groupinfo = C.GetUpgradeSlotGroup(menu.currentplayership, "", "turret", j)
				if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
					local current = C.GetUpgradeSlotCurrentComponent(menu.currentplayership, "turret", j)
					if current ~= 0 then
						table.insert(menu.turrets, current)
						if not GetComponentData(ConvertStringTo64Bit(tostring(current)), "istugweapon") then
							hasonlytugturrets = false
						end
					end
				end
			end

			menu.turretgroups = {}
			local turretsizecounts = {}
			local n = C.GetNumUpgradeGroups(menu.currentplayership, "")
			local buf = ffi.new("UpgradeGroup2[?]", n)
			n = C.GetUpgradeGroups2(buf, n, menu.currentplayership, "")
			for i = 0, n - 1 do
				if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
					local group = { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }
					local groupinfo = C.GetUpgradeGroupInfo2(menu.currentplayership, "", group.context, group.path, group.group, "turret")
					if (groupinfo.count > 0) then
						group.operational = groupinfo.operational
						group.currentcomponent = groupinfo.currentcomponent
						group.currentmacro = ffi.string(groupinfo.currentmacro)
						group.slotsize = ffi.string(groupinfo.slotsize)
						group.sizecount = 0

						if group.slotsize ~= "" then
							if turretsizecounts[group.slotsize] then
								turretsizecounts[group.slotsize] = turretsizecounts[group.slotsize] + 1
							else
								turretsizecounts[group.slotsize] = 1
							end
							group.sizecount = turretsizecounts[group.slotsize]
						end

						table.insert(menu.turretgroups, group)
						
						if not GetComponentData(ConvertStringTo64Bit(tostring(group.currentcomponent)), "istugweapon") then
							hasonlytugturrets = false
						end
					end
				end
			end

			if #menu.turretgroups > 0 then
				table.sort(menu.turretgroups, Helper.sortSlots)
			end

			if (#menu.turrets > 0) or (#menu.turretgroups > 0) then
				table_header:addEmptyRow(yoffset)

				local row = table_header:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(11):createText(ReadText(1001, 8612), Helper.headerRowCenteredProperties)

				local row = table_header:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:createText(ReadText(1001, 8620), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 12),   { font = Helper.standardFontBold, halign = "center" })

				local row = table_header:addRow("turret_config", { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 2963))

				-- Start Subsystem Targeting Orders callback
				local sto_callbackVal
				if callbacks ["sto_addTurretBehavioursDockMenu"] then
				  for _, callback in ipairs (callbacks ["sto_addTurretBehavioursDockMenu"]) do
				    sto_callbackVal = callback (row)
				  end
				end
				if not sto_callbackVal then
					row[2]:setColSpan(5):createDropDown(Helper.getTurretModes(nil, not hasonlytugturrets), { startOption = function () return menu.getDropDownTurretModeOption(menu.currentplayership, "all") end, helpOverlayID = "docked_turretconfig_modes", helpOverlayText = " ", helpOverlayHighlightOnly = true  })
					row[2].handlers.onDropDownConfirmed = function(_, newturretmode) C.SetAllTurretModes(menu.currentplayership, newturretmode) end
				end
				-- End Subsystem Targeting Orders callback
				row[7]:setColSpan(5):createButton({ helpOverlayID = "docked_turretconfig_arm", helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(function () return menu.areTurretsArmed(menu.currentplayership) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
				row[7].handlers.onClick = function () return C.SetAllTurretsArmed(menu.currentplayership, not menu.areTurretsArmed(menu.currentplayership)) end

				local turretscounter = 0
				for i, turret in ipairs(menu.turrets) do
					local row = table_header:addRow("turret_config", { bgColor = Helper.color.transparent })
					turretscounter = turretscounter + 1
					local turretname = ffi.string(C.GetComponentName(turret))
					local mouseovertext = ""
					local textwidth = C.GetTextWidth(turretname, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)) + Helper.scaleX(Helper.standardTextOffsetx)
					if (textwidth > row[1]:getWidth()) then
						mouseovertext = turretname
					end
					row[1]:createText(turretname, { mouseOverText = mouseovertext })
					row[2]:setColSpan(5):createDropDown(Helper.getTurretModes(turret), { startOption = function () return menu.getDropDownTurretModeOption(turret) end, helpOverlayID = "docked_turrets_modes".. turretscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true  })
					row[2].handlers.onDropDownConfirmed = function(_, newturretmode) C.SetWeaponMode(turret, newturretmode) end
					row[7]:setColSpan(5):createButton({helpOverlayID = "docked_turrets_arm" .. turretscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true   }):setText(function () return C.IsWeaponArmed(turret) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[7].handlers.onClick = function () return C.SetWeaponArmed(turret, not C.IsWeaponArmed(turret)) end
				end

				local turretgroupscounter = 0
				for i, group in ipairs(menu.turretgroups) do
					local row = table_header:addRow("turret_config", { bgColor = Helper.color.transparent })
					turretgroupscounter = turretgroupscounter + 1
					local groupname = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")
					local mouseovertext = ""
					local textwidth = C.GetTextWidth(groupname, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)) + Helper.scaleX(Helper.standardTextOffsetx)
					if (textwidth > row[1]:getWidth()) then
						mouseovertext = groupname
					end
					row[1]:createText(groupname, { color = (group.operational > 0) and Helper.color.white or Helper.color.red, mouseOverText = mouseovertext })
					row[2]:setColSpan(5):createDropDown(Helper.getTurretModes(group.currentcomponent ~= 0 and group.currentcomponent or nil), { startOption = function () return menu.getDropDownTurretModeOption(menu.currentplayership, group.context, group.path, group.group) end, active = group.operational > 0, helpOverlayID = "docked_turretgroups_modes".. turretgroupscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true  })
					row[2].handlers.onDropDownConfirmed = function(_, newturretmode) C.SetTurretGroupMode2(menu.currentplayership, group.context, group.path, group.group, newturretmode) end
					row[7]:setColSpan(5):createButton({ helpOverlayID = "docked_turretgroups_arm" .. turretgroupscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(function () return C.IsTurretGroupArmed(menu.currentplayership, group.context, group.path, group.group) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[7].handlers.onClick = function () return C.SetTurretGroupArmed(menu.currentplayership, group.context, group.path, group.group, not C.IsTurretGroupArmed(menu.currentplayership, group.context, group.path, group.group)) end
				end
			end

			menu.drones = {}
			for _, dronetype in ipairs(config.dronetypes) do
				if C.GetNumStoredUnits(menu.currentplayership, dronetype.id, false) > 0 then
					local entry = {
						type = dronetype.id,
						name = dronetype.name,
						current = ffi.string(C.GetCurrentDroneMode(menu.currentplayership, dronetype.id)),
						modes = {},
					}
					local n = C.GetNumDroneModes(menu.currentplayership, dronetype.id)
					local buf = ffi.new("DroneModeInfo[?]", n)
					n = C.GetDroneModes(buf, n, menu.currentplayership, dronetype.id)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						if (id ~= "trade") or (id == entry.current) then
							table.insert(entry.modes, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
						end
					end
					table.insert(menu.drones, entry)
				end
			end

			if #menu.drones > 0 then
				table_header:addEmptyRow(yoffset)

				local row = table_header:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(11):createText(ReadText(1001, 8619), Helper.headerRowCenteredProperties)

				local row = table_header:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:createText(ReadText(1001, 8620), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 12), { font = Helper.standardFontBold, halign = "center" })

				for _, entry in ipairs(menu.drones) do
					local isblocked = C.IsDroneTypeBlocked(menu.currentplayership, entry.type)
					local row = table_header:addRow("drone_config", { bgColor = Helper.color.transparent })
					row[1]:createText(function () return entry.name .. " (" .. (C.IsDroneTypeArmed(menu.currentplayership, entry.type) and (C.GetNumUnavailableUnits(menu.currentplayership, entry.type) .. "/") or "") .. C.GetNumStoredUnits(menu.currentplayership, entry.type, false) ..")" end, { color = isblocked and Helper.color.warningorange or nil })
					row[2]:setColSpan(5):createDropDown(entry.modes, { startOption = function () return ffi.string(C.GetCurrentDroneMode(menu.currentplayership, entry.type)) end, active = not isblocked })
					row[2].handlers.onDropDownConfirmed = function (_, newdronemode) C.SetDroneMode(menu.currentplayership, entry.type, newdronemode) end
					row[7]:setColSpan(5):createButton({ active = not isblocked }):setText(function () return C.IsDroneTypeArmed(menu.currentplayership, entry.type) and ReadText(1001, 8622) or ReadText(1001, 8623) end, { halign = "center" })
					row[7].handlers.onClick = function () return C.SetDroneTypeArmed(menu.currentplayership, entry.type, not C.IsDroneTypeArmed(menu.currentplayership, entry.type)) end
					row[7].properties.helpOverlayID = "docked_drones_" .. entry.type
					row[7].properties.helpOverlayText = " "
					row[7].properties.helpOverlayHighlightOnly = true 
				end
			end
			-- subordinates
			local subordinates = GetSubordinates(menu.currentplayership)
			local groups = {}
			local usedassignments = {}
			for _, subordinate in ipairs(subordinates) do
				local purpose, shiptype = GetComponentData(subordinate, "primarypurpose", "shiptype")
				local group = GetComponentData(subordinate, "subordinategroup")
				if group and group > 0 then
					if groups[group] then
						table.insert(groups[group].subordinates, subordinate)
						if shiptype == "resupplier" then
							groups[group].numassignableresupplyships = groups[group].numassignableresupplyships + 1
						end
						if purpose == "mine" then
							groups[group].numassignableminingships = groups[group].numassignableminingships + 1
						end
						if shiptype == "tug" then
							groups[group].numassignabletugships = groups[group].numassignabletugships + 1
						end
					else
						local assignment = ffi.string(C.GetSubordinateGroupAssignment(menu.currentplayership, group))
						usedassignments[assignment] = i
						groups[group] = { assignment = assignment, subordinates = { subordinate }, numassignableresupplyships = (shiptype == "resupplier") and 1 or 0, numassignableminingships = (purpose == "mine") and 1 or 0, numassignabletugships= (shiptype == "tug") and 1 or 0 }
					end
				end
			end

			if #subordinates > 0 then
				table_header:addEmptyRow(yoffset)

				local row = table_header:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(11):createText(ReadText(1001, 8626), Helper.headerRowCenteredProperties)

				local row = table_header:addRow(false, { bgColor = Helper.color.unselectable })
				row[1]:createText(ReadText(1001, 8627), { font = Helper.standardFontBold, halign = "center" })
				row[2]:createText(ReadText(1001, 8373), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 8628), { font = Helper.standardFontBold, halign = "center" })

				for i = 1, 10 do
					if groups[i] then
						local supplyactive = (groups[i].numassignableresupplyships == #groups[i].subordinates) and ((not usedassignments["supplyfleet"]) or (usedassignments["supplyfleet"] == i))
						local subordinateassignments = {
							[1] = { id = "defence",			text = ReadText(20208, 40301),	icon = "",	displayremoveoption = false },
							[2] = { id = "supplyfleet",		text = ReadText(20208, 40701),	icon = "",	displayremoveoption = false, active = supplyactive, mouseovertext = supplyactive and "" or ReadText(1026, 8601) },
						}

						if C.IsComponentClass(menu.currentplayership, "station") then
							local miningactive = (groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i))
							table.insert(subordinateassignments, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false, active = miningactive, mouseovertext = miningactive and "" or ReadText(1026, 8602) })
							local tradeactive = (not usedassignments["trade"]) or (usedassignments["trade"] == i)
							table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, active = tradeactive, mouseovertext = tradeactive and ((groups[i].numassignableminingships > 0) and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8607)) or "") or ReadText(1026, 7840) })
							local tradeforbuildstorageactive = (groups[i].numassignableminingships == 0) and ((not usedassignments["tradeforbuildstorage"]) or (usedassignments["tradeforbuildstorage"] == i))
							table.insert(subordinateassignments, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false, active = tradeforbuildstorageactive, mouseovertext = tradeforbuildstorageactive and "" or ReadText(1026, 8603) })
							local salvageactive = (groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i))
							table.insert(subordinateassignments, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false, active = salvageactive, mouseovertext = salvageactive and "" or ReadText(1026, 8610) })
						elseif C.IsComponentClass(menu.currentplayership, "ship") then
							-- position defence
							local shiptype = GetComponentData(menu.currentplayership, "shiptype")
							local parentcommander = ConvertIDTo64Bit(GetCommander(menu.currentplayership))
							local isfleetcommander = (not parentcommander) and (#subordinates > 0)
							if (shiptype == "carrier") and isfleetcommander then
								table.insert(subordinateassignments, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false })
							end
							table.insert(subordinateassignments, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
							table.insert(subordinateassignments, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
							table.insert(subordinateassignments, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
							table.insert(subordinateassignments, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
							local active = true
							local mouseovertext = ""
							local buf = ffi.new("Order")
							if not C.GetDefaultOrder(buf, menu.currentplayership) then
								active = false
								mouseovertext = ReadText(1026, 8606)
							end
							table.insert(subordinateassignments, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
							if shiptype == "resupplier" then
								table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false })
							end
						end

						local isdockingpossible = false
						for _, subordinate in ipairs(groups[i].subordinates) do
							if IsDockingPossible(subordinate, menu.currentplayership) then
								isdockingpossible = true
								break
							end
						end
						local active = true
						local mouseovertext = ""
						if not GetComponentData(menu.currentplayership, "hasshipdockingbays") then
							active = false
							mouseovertext = ReadText(1026, 8604)
						elseif not isdockingpossible then
							active = false
							mouseovertext = ReadText(1026, 8605)
						end

						local row = table_header:addRow("subordinate_config", { bgColor = Helper.color.transparent })
						row[1]:createText(function () menu.updateSubordinateGroupInfo(); return ReadText(20401, i) .. (menu.subordinategroups[i] and (" (" .. ((not C.ShouldSubordinateGroupDockAtCommander(menu.currentplayership, i)) and ((#menu.subordinategroups[i].subordinates - menu.subordinategroups[i].numdockedatcommander) .. "/") or "") .. #menu.subordinategroups[i].subordinates ..")") or "") end, { color = isblocked and Helper.color.warningorange or nil })
						row[2]:setColSpan(5):createDropDown(subordinateassignments, { startOption = function () menu.updateSubordinateGroupInfo(); return menu.subordinategroups[i] and menu.subordinategroups[i].assignment or "" end })
						row[2].handlers.onDropDownConfirmed = function(_, newassignment) Helper.dropdownAssignment(_, nil, i, menu.currentplayership, newassignment) end
						
						-- Start Reactive Docking callback
						local rd_callbackVal
						if callbacks ["rd_addReactiveDockingDockMenu"] then
				  			for _, callback in ipairs (callbacks ["rd_addReactiveDockingDockMenu"]) do
				    			rd_callbackVal = callback (row, menu.currentplayership, i, active, mouseovertext)
				  			end
						end
						if not rd_callbackVal then
							row[7]:setColSpan(5):createButton({ active = active, mouseOverText = mouseovertext }):setText(function () return C.ShouldSubordinateGroupDockAtCommander(menu.currentplayership, i) and ReadText(1001, 8630) or ReadText(1001, 8629) end, { halign = "center" })
							row[7].handlers.onClick = function () return C.SetSubordinateGroupDockAtCommander(menu.currentplayership, i, not C.ShouldSubordinateGroupDockAtCommander(menu.currentplayership, i)) end
						end
						-- End Reactive Docking callback
					end
				end
			end
		end
	else
		local row = table_header:addRow("buttonRow1", { bgColor = Helper.color.transparent, fixed = true })
		local active = canwareexchange
		local mouseovertext
		if (not active) and isplayerowned then
			if C.IsComponentClass(menu.currentcontainer, "ship") then
				mouseovertext = ReadText(1026, 7830)
			end
		end
		row[1]:createButton(active and { helpOverlayID = "docked_transferwares", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8618), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Transfer Wares"
		if active then
			row[1].handlers.onClick = function() return menu.buttonTrade(true) end
		else
			row[1].properties.mouseOverText = mouseovertext
		end
		local active = (menu.currentplayership ~= 0) or menu.secondarycontrolpost
		row[2]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 277), helpOverlayID = "docked_getup", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 20014), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Get Up"
		row[2].handlers.onClick = menu.buttonGetUp
		local active = menu.currentplayership ~= 0
		row[7]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 316), helpOverlayID = "docked_shipinfo", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8602), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Ship Information"
		if active then
			row[7].handlers.onClick = menu.buttonDockedShipInfo
		end

		local row = table_header:addRow("buttonRow2", { bgColor = Helper.color.transparent, fixed = true })
		local active = canbuyship
		row[1]:createButton(active and {helpOverlayID = "docked_buyships", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 8008), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Buy Ships"
		if active then
			row[1].handlers.onClick = menu.buttonBuyShip
		end
		local active = cantrade
		row[2]:createButton(active and {helpOverlayID = "docked_trade", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 9005), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Trade"
		if active then
			row[2].handlers.onClick = function() return menu.buttonTrade(false) end
			row[2].properties.uiTriggerID = "docked_trade"
		end
		local active = canmodifyship
		row[7]:createButton(active and {helpOverlayID = "docked_upgrade_repair", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(issupplyship and ReadText(1001, 7877) or ReadText(1001, 7841), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Upgrade / Repair Ship
		if dockedplayerships[1] and (not canequip) then
			row[7].properties.mouseOverText = (C.IsComponentClass(dockedplayerships[1], "ship_l") or C.IsComponentClass(dockedplayerships[1], "ship_xl")) and ReadText(1026, 7807) or ReadText(1026, 7806)
		elseif not isdock then
			row[7].properties.mouseOverText = ReadText(1026, 8014)
		end
		if active then
			row[7].handlers.onClick = menu.buttonModifyShip
		end

		local row = table_header:addRow("buttonRow3", { bgColor = Helper.color.transparent, fixed = true })
		local currentactivity = GetPlayerActivity()
		if currentactivity ~= "none" then
			local text = ""
			for _, entry in ipairs(config.modes) do
				if entry.id == currentactivity then
					text = entry.stoptext
					break
				end
			end
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			row[1]:createButton(active and {helpOverlayID = "docked_stopmode", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(text, active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Stop Mode"
			if active then
				row[1].handlers.onClick = menu.buttonStopMode
				row[1].properties.uiTriggerID = "stopmode"
			end
		else
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			local modes = {}
			if active then
				for _, entry in ipairs(config.modes) do
					local entryactive = menu.currentplayership ~= 0
					local visible = true
					if entry.id == "travel" then
						entryactive = entryactive and C.CanStartTravelMode(menu.currentplayership)
					elseif entry.id == "seta" then
						entryactive = true
						visible = C.CanActivateSeta(false)
					end
					local mouseovertext = GetLocalizedKeyName("action", entry.action)
					if visible then
						table.insert(modes, { id = entry.id, text = entry.name, icon = "", displayremoveoption = false, active = entryactive, mouseovertext = mouseovertext })
					end
				end
			end
			row[1]:createDropDown(modes, {
				helpOverlayID = "docked_modes",		
				helpOverlayText = " ", 
				helpOverlayHighlightOnly = true, 
				height = Helper.standardButtonHeight,
				startOption = "",
				textOverride = ReadText(1002, 1001),
				bgColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
				highlightColor = active and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor
			}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Modes
			if active then
				row[1].handlers.onDropDownConfirmed = menu.dropdownMode
				row[1].properties.uiTriggerID = "startmode"
			end
		end
		if menu.currentplayership ~= 0 then
			row[2]:createButton({ mouseOverText = GetLocalizedKeyName("action", 175), bgColor = menu.undockButtonBGColor, highlightColor = menu.undockButtonHighlightColor, helpOverlayID = "docked_undock", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1002, 20013), { halign = "center", color = menu.undockButtonTextColor })	-- "Undock"
			row[2].handlers.onClick = menu.buttonUndock
		else
			row[2]:createButton({ mouseOverText = GetLocalizedKeyName("action", 175), helpOverlayID = "docked_gotoship", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 7305), { halign = "center" })	-- "Go to Ship"
			row[2].handlers.onClick = menu.buttonGoToShip
		end
		row[7]:createButton(config.inactiveButtonProperties):setText("", config.inactiveButtonTextProperties)	-- dummy

		-- start: kuertee call-back
		if callbacks ["display_on_after_main_interactions"] then
  			for _, callback in ipairs (callbacks ["display_on_after_main_interactions"]) do
  				callback (table_header)
  			end
  		end
		-- end: kuertee call-back

		local row = table_header:addRow(false, { bgColor = Helper.color.transparent, fixed = true })
		row[1]:setColSpan(11):createBoxText(menu.infoText, { halign = "center", color = Helper.color.warningorange, boxColor = menu.infoBoxColor })
	end


	if menu.table_header then
		table_header:setTopRow(GetTopRow(menu.table_header))
		table_header:setSelectedRow(menu.selectedRows.header or Helper.currentTableRow[menu.table_header])
		table_header:setSelectedCol(menu.selectedCols.header or Helper.currentTableCol[menu.table_header] or 0)
	else
		table_header:setSelectedRow(menu.selectedRows.header)
		table_header:setSelectedCol(menu.selectedCols.header or 0)
	end
	menu.selectedRows.header = nil
	menu.selectedCols.header = nil

	table_header.properties.maxVisibleHeight = Helper.viewHeight - table_header.properties.y - Helper.frameBorder
	menu.frame.properties.height = math.min(Helper.viewHeight, table_header:getVisibleHeight() + table_header.properties.y + Helper.scaleY(Helper.standardButtonHeight))

	-- display view/frame
	menu.frame:display()
end

-- handle created frames
function menu.viewCreated(layer, ...)
	menu.table_toplevel, menu.table_topleft, menu.table_header = ...
end

function menu.isDockButtonActive()
	local docktarget = 0
	local softtarget = C.GetSofttarget().softtargetID
	local environmenttarget = C.GetEnvironmentObject()
	if softtarget ~= 0 then
		docktarget = C.GetContextByClass(softtarget, "container", true)
	elseif environmenttarget ~= 0 then
		docktarget = C.GetContextByClass(environmenttarget, "container", true)
	end
	return (menu.currentplayership ~= 0) and (GetComponentData(menu.currentplayership, "isdocking") or ((docktarget ~= 0) and C.RequestDockAt(docktarget, true)))
end

function menu.dockButtonBGColor()
	return menu.isDockButtonActive() and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor
end

function menu.dockButtonHighlightColor()
	return menu.isDockButtonActive() and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor
end

function menu.dockButtonTextColor()
	return menu.isDockButtonActive() and Helper.color.white or Helper.color.grey
end

function menu.isUndockButtonActive()
	return (menu.currentplayership ~= 0) and GetComponentData(menu.currentplayership, "isdocked") and (ffi.string(C.UndockPlayerShip(true)) == "granted") and ((not menu.buildInProgress) or C.CanCancelConstruction(menu.currentcontainer, menu.buildInProgress))
end

function menu.undockButtonBGColor()
	return menu.isUndockButtonActive() and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor
end

function menu.undockButtonHighlightColor()
	return menu.isUndockButtonActive() and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor
end

function menu.undockButtonTextColor()
	return menu.isUndockButtonActive() and Helper.color.white or Helper.color.grey
end

function menu.updateSubordinateGroupInfo()
	local curtime = getElapsedTime()
	if (not menu.lastSubordinateGroupUpdate) or (curtime > menu.lastSubordinateGroupUpdate) then
		menu.lastSubordinateGroupUpdate = curtime
		local subordinates = GetSubordinates(menu.currentplayership)
		menu.subordinategroups = {}
		for _, subordinate in ipairs(subordinates) do
			local subordinate64 = ConvertIDTo64Bit(subordinate)
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if menu.subordinategroups[group] then
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == menu.currentplayership
					if isdocked then
						menu.subordinategroups[group].numdockedatcommander = menu.subordinategroups[group].numdockedatcommander + 1
					end
					table.insert(menu.subordinategroups[group].subordinates, subordinate)
				else
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == menu.currentplayership
					menu.subordinategroups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(menu.currentplayership, group)), subordinates = { subordinate }, numdockedatcommander = isdocked and 1 or 0 }
				end
			end
		end
	end
end

function menu.infoText()
	if ffi.string(C.UndockPlayerShip(true)) == "tradecomputerbusy" then
		menu.haswarning = true
		return ReadText(1001, 8609)
	end
	if menu.currentplayership ~= 0 then
		local constructions = {}
		-- builds in progress
		local n = C.GetNumBuildTasks(menu.currentcontainer, 0, true, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.currentcontainer, 0, true, true)
		for i = 0, n - 1 do
			table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
		end
		-- other builds
		menu.buildInProgress, menu.buildToCancel = nil, nil
		local n = C.GetNumBuildTasks(menu.currentcontainer, 0, false, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.currentcontainer, 0, false, true)
		for i = 0, n - 1 do
			table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
		end
		for _, entry in ipairs(constructions) do
			if (entry.component == menu.currentplayership) then
				menu.haswarning = true
				if entry.inprogress then
					menu.buildInProgress = entry.id
					if C.CanCancelConstruction(menu.currentcontainer, menu.buildInProgress) then
						-- warning but allow undock
						menu.buildToCancel = { entry.id, tonumber(entry.price) }
						return ReadText(1001, 8611)
					else
						-- may not be aborted
						return ReadText(1001, 8610) .. " (" .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(entry.buildercomponent), "%h:%M:%S") .. ")"
					end
				else
					-- warning but allow undock
					menu.buildToCancel = { entry.id, tonumber(entry.price) }
					return ReadText(1001, 8611)
				end
			end
		end
	end
	menu.haswarning = nil
	return ""
end

function menu.infoBoxColor()
	if menu.haswarning then
		return Helper.color.warningorange
	end
	return Helper.color.transparent
end

function menu.checkboxWeaponGroupColor(groupidx, primary)
	return (C.GetDefensibleActiveWeaponGroup(menu.currentplayership, primary) == groupidx) and Helper.color.checkboxgroup or Helper.defaultCheckBoxBackgroundColor
end

function menu.getDropDownOption(weapon)
	local currentweapon = ffi.string(C.GetCurrentAmmoOfWeapon(weapon))
	if menu.currentammo[tostring(weapon)] ~= currentweapon then
		menu.currentammo[tostring(weapon)] = currentweapon
	end
	return menu.currentammo[tostring(weapon)]
end

function menu.getDropDownTurretModeOption(defensibleorturret, context, path, group)
	if (context == nil) and (path == nil) and (group == nil) then
		return ffi.string(C.GetWeaponMode(defensibleorturret))
	elseif context == "all" then
		local allmode
		for i, turret in ipairs(menu.turrets) do
			local mode = ffi.string(C.GetWeaponMode(turret))
			if allmode == nil then
				allmode = mode
			elseif allmode ~= mode then
				allmode = ""
				break
			end
		end
		for i, group in ipairs(menu.turretgroups) do
			if group.operational > 0 then
				local mode = ffi.string(C.GetTurretGroupMode2(defensibleorturret, group.context, group.path, group.group))
				if allmode == nil then
					allmode = mode
				elseif allmode ~= mode then
					allmode = ""
					break
				end
			end
		end
		return allmode or ""
	end
	return ffi.string(C.GetTurretGroupMode2(defensibleorturret, context, path, group))
end

function menu.areTurretsArmed(defensibleorturret)
	local alldisarmed = true
	for i, turret in ipairs(menu.turrets) do
		if C.IsWeaponArmed(turret) then
			alldisarmed = false
			break
		end
	end
	for i, group in ipairs(menu.turretgroups) do
		if group.operational > 0 then
			if C.IsTurretGroupArmed(defensibleorturret, group.context, group.path, group.group) then
				alldisarmed = false
				break
			end
		end
	end
	return not alldisarmed
end

function menu.createTopLevel(frame)
	menu.topLevelOffsetY = Helper.createTopLevelTab(menu, menu.mode, frame, "", nil, (menu.mode == "cockpit") or (menu.currentplayership == 0))
end

function menu.onTabScroll(direction)
	if direction == "right" then
		Helper.scrollTopLevel(menu, menu.mode, 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, menu.mode, -1)
	end
end

function menu.onInputModeChanged(_, mode)
	menu.display()
end

-- widget scripts
function menu.buttonGetUp()
	if not C.GetUp() then
		DebugError("failed getting up.")
	end
end

function menu.buttonGoToShip()
	Helper.closeMenuAndOpenNewMenu(menu, "PlatformUndockMenu", { 0, 0 }, true)
	menu.cleanup()
end

function menu.buttonBuyShip()
	local shiptrader = GetComponentData(menu.currentcontainer, "shiptrader")
	if not shiptrader then
		DebugError("menu.buttonBuyShip called but " .. ffi.string(C.GetComponentName(menu.currentcontainer)) .. " has no shiptrader.")
		return
	end
	Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, menu.currentcontainer, "purchase", {} })
	menu.cleanup()
end

function menu.buttonModifyShip()
	local shiptrader = GetComponentData(menu.currentcontainer, "shiptrader")
	if not shiptrader then
		DebugError("menu.buttonModifyShip called but " .. ffi.string(C.GetComponentName(menu.currentcontainer)) .. " has no shiptrader.")
		return
	end
	Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, menu.currentcontainer, "upgrade", {}, true })
	menu.cleanup()
end

function menu.buttonTrade(iswareexchange)
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "tradecontext", {menu.currentcontainer, nil, iswareexchange} })
	menu.cleanup()
end

function menu.buttonUndock()
	if menu.isUndockButtonActive() then
		if menu.buildToCancel then
			Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "abortupgrade", { menu.currentcontainer, menu.buildToCancel[1], menu.buildToCancel[2] } }, true)
			menu.cleanup()
		else
			Helper.closeMenu(menu, "close")
			menu.cleanup()
			if ffi.string(C.UndockPlayerShip(false)) ~= "granted" then
				DebugError("failed undocking.")
			end
		end
	end
end

function menu.buttonShipInfo()
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", menu.currentcontainer } })
	menu.cleanup()
end

function menu.buttonDockedShipInfo()
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", menu.currentplayership } })
	menu.cleanup()
end

function menu.buttonAutoPilot()
	C.ToggleAutoPilot(false)
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

function menu.buttonDock()
	if menu.isDockButtonActive() then
		C.QuickDock()
	end
end

function menu.buttonFlightAssist()
	C.ToggleFlightAssist()
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

function menu.buttonStopMode()
	C.StopPlayerActivity(GetPlayerActivity())
	menu.display()
end

function menu.dropdownMode(_, id)
	C.StartPlayerActivity(id)
	menu.refresh = getElapsedTime() + 0.11
end

function menu.dropdownDeploy(_, idstring)
	local id, macro = string.match(idstring, "(.+):(.+)")
	for _, entry in ipairs(config.consumables) do
		if entry.id == id then
			entry.callback(menu.currentplayership, macro)
			PlaySound("ui_ship_interaction_deploy")
		end
	end
	menu.display()
end

function menu.checkboxWeaponGroup(objectid, weaponid, primary, group, active)
	C.SetWeaponGroup(objectid, weaponid, primary, group, active)
	menu.display()
end

menu.updateInterval = 0.1

-- hook to update the menu while it is being displayed
function menu.onUpdate()
	local curtime = getElapsedTime()
 	if menu.secondarycontrolpost then
		if C.IsComponentClass(menu.currentcontainer, "ship") then
			local docked = GetComponentData(menu.currentcontainer, "isdocked")
			if docked ~= (menu.mode == "docked") then
				menu.mode = docked and "docked" or "cockpit"
				menu.refresh = curtime - 1
			end
		end
	end

	if menu.refresh and (menu.refresh < curtime) then
		menu.refresh = nil
		menu.display()
		return
	end

	if menu.firsttime and (menu.firsttime < curtime) then
		SelectRow(menu.table_header, 5)
		SelectColumn(menu.table_header, 2)
		menu.firsttime = nil
	end

	--print("On Update")
	menu.frame:update()
end

-- hook if the highlighted row is changed (is also called on menu creation)
function menu.onRowChanged(row, rowdata)
	--print("Row Changed")
	menu.frame:update()
end

-- hook if the highlighted row is selected
function menu.onSelectElement()
	--print("Element Selected")
end

function menu.close()
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

-- hook if the menu is being closed
function menu.onCloseElement(dueToClose)
	if ((menu.mode == "docked") and (menu.currentplayership ~= 0)) or menu.secondarycontrolpost then
		if dueToClose == "back" then
			Helper.closeMenuAndOpenNewMenu(menu, "OptionsMenu", nil)
			menu.cleanup()
		end
	else
		Helper.closeMenu(menu, dueToClose)
		menu.cleanup()
	end
end

-- kuetee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- 
	-- sto_addTurretBehavioursDockMenu ()
	-- (true | false) = rd_addReactiveDockingDockMenu (row, menu.currentplayership, i, active, mouseovertext)
	-- display_on_after_main_interactions (ftable)
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuerte end

init()
﻿
-- section == gMain_map
-- param == { 0, 0, showzone, focuscomponent [, history] [, mode, modeparam] [, showmultiverse] [, focusoffset] }
 
-- modes: - "orderparam_object",	param: { returnfunction, paramdata, toprow, ordercontrollable } 
--		  - "orderparam_position",	param: { returnfunction, paramdata, toprow, ordercontrollable } 
--		  - "selectbuildlocation",	param: { returnsection, { 0, 0, trader, buildership_or_module, object, macro } }
--		  - "tradecontext",			param: { station, initialtradingship, iswareexchange, shadyOnly, loop, trader }
--		  - "selectCV",				param: { buildstorage }
--		  - "infomode",				param: { mode, ... }
--		  - "boardingcontext",		param: { target, boardingships }
--		  - "hire",					param: { returnsection, npc_or_context, ishiring[, npctemplate] }
--		  - "sellships",			param: { shipyard, ships }
--		  - "dropwarescontext",		param: { mode, entity }
--		  - "renamecontext",		param: { component, renamefleet }
--		  - "changelogocontext",	param: { component }
--		  - "selectComponent",		param: { returnsection, classlist[, category][, playerowned][, customheading] }
--		  - "crewtransfercontext",	param: { othership, ship }
--		  - "ventureconsole",		param: { ventureplatform }
--		  - "venturepatroninfo",	param: { ventureplatform }
--		  - "venturereport",		param: { mode, reason[, timestamp, author][, transactionid] }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t AIOrderID;
	typedef int32_t BlacklistID;
	typedef uint64_t BuildTaskID;
	typedef int32_t FightRuleID;
	typedef uint64_t MissionID;
	typedef uint64_t NPCSeed;
	typedef uint64_t TradeID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		const char* id;
		const char* text;
	} BoardingBehaviour;
	typedef struct {
		const char* id;
		const char* text;
	} BoardingPhase;
	typedef struct {
		uint32_t approach;
		uint32_t insertion;
	} BoardingRiskThresholds;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* newroleid;
		NPCSeed seed;
		uint32_t amount;
	} CrewTransferContainer;
	typedef struct {
		const char* id;
		const char* name;
	} ControlPostInfo;
	typedef struct {
		UniverseID entity;
		UniverseID personcontrollable;
		NPCSeed personseed;
	} GenericActor;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
	} ResponseInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
		uint32_t numresponses;
		const char* defaultresponse;
		bool ask;
	} SignalInfo;
	typedef struct {
		const char* name;
		const char* transport;
		uint32_t spaceused;
		uint32_t capacity;
	} StorageInfo;
	typedef struct {
		int x;
		int y;
	} Coord2D;
	typedef struct {
		float x;
		float y;
		float z;
	} Coord3D;
	typedef struct {
		float dps;
		uint32_t quadranttextid;
	} DPSData;
	typedef struct {
		const char* id;
		const char* name;
		bool possible;
	} DroneModeInfo;
	typedef struct {
		const char* factionID;
		const char* factionName;
		const char* factionIcon;
	} FactionDetails;
	typedef struct {
		const char* icon;
		const char* caption;
	} MissionBriefingIconInfo;
	typedef struct {
		const char* missionName;
		const char* missionDescription;
		int difficulty;
		int upkeepalertlevel;
		const char* threadType;
		const char* mainType;
		const char* subType;
		const char* subTypeName;
		const char* faction;
		int64_t reward;
		const char* rewardText;
		size_t numBriefingObjectives;
		int activeBriefingStep;
		const char* opposingFaction;
		const char* license;
		float timeLeft;
		double duration;
		bool abortable;
		bool hasObjective;
		UniverseID associatedComponent;
		UniverseID threadMissionID;
	} MissionDetails;
	typedef struct {
		const char* id;
		const char* name;
	} MissionGroupDetails;
	typedef struct {
		MissionID missionid;
		uint32_t amount;
		uint32_t numskills;
		SkillInfo* skills;
	} MissionNPCInfo;
	typedef struct {
		const char* text;
		const char* actiontext;
		const char* detailtext;
		int step;
		bool failed;
		bool completedoutofsequence;
	} MissionObjectiveStep3;
	typedef struct {
		uint32_t id;
		bool ispin;
		bool ishome;
	} MultiverseMapPickInfo;
	typedef struct {
		NPCSeed seed;
		const char* roleid;
		int32_t tierid;
		const char* name;
		int32_t combinedskill;
	} NPCInfo;
	typedef struct {
		const char* chapter;
		const char* onlineid;
	} OnlineMissionInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* icon;
		const char* description;
		const char* category;
		const char* categoryname;
		bool infinite;
		uint32_t requiredSkill;
	} OrderDefinition;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
		bool isoverride;
	} Order2;
	typedef struct {
		uint32_t id;
		AIOrderID orderid;
		const char* orderdef;
		const char* message;
		double timestamp;
		bool wasdefaultorder;
		bool wasinloop;
	} OrderFailure;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		const char* id;
		const char* name;
	} ProductionMethodInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		UniverseID context;
		const char* group;
		UniverseID component;
	} ShieldGroup;
	typedef struct {
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
	} Skill2;
	typedef struct {
		UniverseID softtargetID;
		const char* softtargetConnectionName;
	} SofttargetDetails;
	typedef struct {
		const char* max;
		const char* current;
	} SoftwareSlot;
	typedef struct {
		UniverseID controllableid;
		int group;
	} SubordinateGroup;
	typedef struct {
		uint32_t id;
		UniverseID owningcontrollable;
		size_t owningorderidx;
		bool reached;
	} SyncPointInfo2;
	typedef struct {
		const char* reason;
		NPCSeed person;
		NPCSeed partnerperson;
	} UICrewExchangeResult;
	typedef struct {
		const char* shape;
		const char* name;
		uint32_t requiredSkill;
		float radius;
		bool rollMembers;
		bool rollFormation;
		size_t maxShipsPerLine;
	} UIFormationInfo;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		const char* icon;
		Color color;
		uint32_t volume_s;
		uint32_t volume_m;
		uint32_t volume_l;
	} UIMapTradeVolumeParameter;
	typedef struct {
		const char* id;
		const char* name;
	} UIModuleSet;
	typedef struct {
		const float x;
		const float y;
		const float z;
		const float yaw;
		const float pitch;
		const float roll;
	} UIPosRot;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	typedef struct {
		bool primary;
		uint32_t idx;
	} UIWeaponGroup;
	typedef struct {
		UniverseID contextid;
		const char* path;
		const char* group;
	} UpgradeGroup2;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		const char* id;
		const char* icon;
		const char* factoryname;
		const char* factorydesc;
		const char* factorymapicon;
		const char* factoryhudicon;
		uint32_t tier;
	} WareGroupInfo;
	typedef struct {
		UniverseID reserverid;
		const char* ware;
		uint32_t amount;
		bool isbuyreservation;
		double eta;
		TradeID tradedealid;
		MissionID missionid;
		bool isvirtual;
		bool issupply;
	} WareReservationInfo2;
	typedef struct {
		const char* ware;
		int32_t current;
		int32_t max;
	} WareYield;
	typedef struct {
		const char* id;
		const char* name;
		bool active;
	} WeaponSystemInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;
	typedef struct {
		const char* wareid;
		int32_t amount;
	} YieldInfo;

	typedef struct {
		UIPosRot offset;
		float cameradistance;
	} HoloMapState;
	typedef struct {
		UniverseID target;
		UIWareAmount* wares;
		uint32_t numwares;
	} MissionWareDeliveryInfo;
	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	typedef struct {
		const char* objectiveText;
		float timeout;
		const char* progressname;
		uint32_t curProgress;
		uint32_t maxProgress;
		size_t numTargets;
	} MissionObjective2;
	bool AbortBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	void AbortMission(MissionID missionid);
	bool AddAttackerToBoardingOperation(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid, const char* actionid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	UniverseID AddHoloMap(const char* texturename, float x0, float x1, float y0, float y1, float aspectx, float aspecty);
	void AddPlayerMoney(int64_t money);
	void AddResearch(const char* wareid);
	void AddSimilarMapComponentsToSelection(UniverseID holomapid, UniverseID componentid);
	bool AdjustOrder(UniverseID controllableid, size_t idx, size_t newidx, bool enabled, bool forcestates, bool checkonly);
	bool AreVenturesCompatible(void);
	bool AreVenturesEnabled(void);
	const char* AssignHiredActor(GenericActor actor, UniverseID targetcontrollableid, const char* postid, const char* roleid, bool checkonly);
	bool GetAskToSignalForControllable(const char* signalid, UniverseID controllableid);
	bool GetAskToSignalForFaction(const char* signalid, const char* factionid);
	uint32_t GetAttackersOfBoardingOperation(UniverseID* result, uint32_t resultlen, UniverseID defensibletargetid, const char* boarderfactionid);
	bool CanContainerMineTransport(UniverseID containerid, const char* transportname);
	bool CanContainerTransport(UniverseID containerid, const char* transportname);
	bool CanControllableHaveAnyTrainees(UniverseID controllableid);
	bool CanControllableHaveControlEntity(UniverseID controllableid, const char* postid);
	bool CanPlayerCommTarget(UniverseID componentid);
	const char* CanTeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool force);
	void ChangeMapBuildPlot(UniverseID holomapid, float x, float y, float z);
	void CheatDockingTraffic(void);
	void CheatLiveStreamViewChannels(void);
	void ClearSelectedMapComponents(UniverseID holomapid);
	void ClearMapBuildPlot(UniverseID holomapid);
	void ClearMapObjectFilter(UniverseID holomapid);
	void ClearMapOrderParamObjectFilter(UniverseID holomapid);
	void ClearMapTradeFilterByMinTotalVolume(UniverseID holomapid);
	void ClearMapTradeFilterByPlayerOffer(UniverseID holomapid, bool buysellswitch);
	void ClearMapTradeFilterByWare(UniverseID holomapid);
	void ClearMapTradeFilterByWillingToTradeWithPlayer(UniverseID holomapid);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint64_t ConvertStringTo64Bit(const char* idstring);
	bool CreateBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid, uint32_t approachthreshold, uint32_t insertionthreshold);
	uint32_t CreateDeployToStationOrder(UniverseID controllableid);
	UniverseID CreateNPCFromPerson(NPCSeed person, UniverseID controllableid);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool default);
	uint32_t CreateOrder3(UniverseID controllableid, const char* orderid, bool defaultorder, bool isoverride, bool istemp);
	bool DropCargo(UniverseID containerid, const char* wareid, uint32_t amount);
	void EnableAllCheats(void);
	bool EnableOrder(UniverseID controllableid, size_t idx);
	bool EnablePlannedDefaultOrder(UniverseID controllableid, bool checkonly);
	void EndGuidance(void);
	bool ExtendBuildPlot(UniverseID stationid, Coord3D poschange, Coord3D negchange, bool allowreduction);
	bool FilterComponentByText(UniverseID componentid, uint32_t numtexts, const char** textarray, bool includecontainedobjects);
	bool FilterComponentForDefaultOrderParamObjectMode(UniverseID componentid, UniverseID ordercontrollableid, bool planned, size_t paramidx);
	bool FilterComponentForMapMode(UniverseID componentid, const char** classes, uint32_t numclasses, int32_t playerowned, bool allowentitydeliverymissionobject);
	bool FilterComponentForOrderParamObjectMode(UniverseID componentid, UniverseID ordercontrollableid, size_t orderidx, size_t paramidx);
	uint64_t GetActiveMissionID();
	uint32_t GetAllBoardingBehaviours(BoardingBehaviour* result, uint32_t resultlen);
	uint32_t GetAllBoardingPhases(BoardingPhase* result, uint32_t resultlen);
	uint32_t GetAllControlPosts(ControlPostInfo* result, uint32_t resultlen);
	uint32_t GetAllCountermeasures(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllInventoryBombs(AmmoData* result, uint32_t resultlen, UniverseID entityid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMissiles(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllModuleSets(UIModuleSet* result, uint32_t resultlen);
	uint32_t GetAllowedWeaponSystems(WeaponSystemInfo* result, uint32_t resultlen, UniverseID defensibleid, size_t orderidx, bool usedefault);
	uint32_t GetAllResponsesToSignal(ResponseInfo* result, uint32_t resultlen, const char* signalid);
	uint32_t GetAllSignals(SignalInfo* result, uint32_t resultlen);
	uint32_t GetAllWareGroups(WareGroupInfo* result, uint32_t resultlen);
	const char* GetBoardingActionOfAttacker(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid);
	uint32_t GetBoardingCasualtiesOfTier(int32_t marinetierskilllevel, UniverseID defensibletargetid, const char* boarderfactionid);
	bool GetBoardingMarineTierAmountsFromAttacker(uint32_t* resultmarinetieramounts, int32_t* inputmarinetierskilllevels, uint32_t inputnummarinetiers, UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid);
	BoardingRiskThresholds GetBoardingRiskThresholds(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetBoardingStrengthFromOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetBoardingStrengthOfControllableTierAmounts(UniverseID controllableid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	int64_t GetBuilderHiringFee(void);
	UniverseID GetBuildMapStationLocation2(UniverseID holomapid, UIPosRot* location);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	Coord3D GetBuildPlotCenterOffset(UniverseID stationid);
	int64_t GetBuildPlotPayment(UniverseID stationid, bool* positionchanged);
	int64_t GetBuildPlotPrice(UniverseID sectorid, UIPosRot location, float x, float y, float z, const char* factionid);
	Coord3D GetBuildPlotSize(UniverseID stationid);
	double GetBuildTaskDuration(UniverseID containerid, BuildTaskID id);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetCargoTransportTypes(StorageInfo* result, uint32_t resultlen, UniverseID containerid, bool merge, bool aftertradeorders);
	Coord2D GetCenteredMousePos(void);
	UniverseID GetCommonContext(UniverseID componentid, UniverseID othercomponentid, bool includeself, bool includeother, UniverseID limitid, bool includelimit);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	int GetConfigSetting(const char*const setting);
	const char* GetContainerBuildMethod(UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	uint32_t GetContainerWareReservations2(WareReservationInfo2* result, uint32_t resultlen, UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	UniverseID GetContextByRealClass(UniverseID componentid, const char* classname, bool includeself);
	BlacklistID GetControllableBlacklistID(UniverseID controllableid, const char* listtype, const char* defaultgroup);
	FightRuleID GetControllableFightRuleID(UniverseID controllableid, const char* listtype);
	const char* GetCurrentAmmoOfWeapon(UniverseID weaponid);
	const char* GetCurrentBoardingPhase(UniverseID defensibletargetid, const char* boarderfactionid);
	float GetCurrentBuildProgress(UniverseID containerid);
	const char* GetCurrentDroneMode(UniverseID defensibleid, const char* dronetype);
	UILogo GetCurrentFleetLogo(UniverseID controllableid);
	uint32_t GetCurrentMissionOffers(uint64_t* result, uint32_t resultlen, bool showninbbs);
	UILogo GetCurrentPlayerLogo(void);
	int64_t GetCurrentUTCDataTime(void);
	bool GetDefaultOrder(Order* result, UniverseID controllableid);
	bool GetDefaultOrderFailure(OrderFailure* result, UniverseID controllableid);
	const char* GetDefaultResponseToSignalForControllable(const char* signalid, UniverseID controllableid);
	const char* GetDefaultResponseToSignalForFaction(const char* signalid, const char* factionid);
	uint32_t GetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary);
	uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	uint32_t GetDefensibleDeployableCapacity(UniverseID defensibleid);
	float GetDefensibleLoadoutLevel(UniverseID defensibleid);
	uint32_t GetDiscoveredSectorResources(WareYield* result, uint32_t resultlen, UniverseID sectorid);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetDroneModes(DroneModeInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* dronetype);
	int32_t GetEntityCombinedSkill(UniverseID entityid, const char* role, const char* postid);
	FactionDetails GetFactionDetails(const char* factionid);
	const char* GetFleetName(UniverseID controllableid);
	uint32_t GetFormationShapes(UIFormationInfo* result, uint32_t resultlen);
	uint32_t GetFreeCountermeasureStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreeDeployableStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreeMissileStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreePeopleCapacity(UniverseID controllableid);
	uint32_t GetIllegalToFactions(const char** result, uint32_t resultlen, const char* wareid);
	UniverseID GetInstantiatedPerson(NPCSeed person, UniverseID controllableid);
	uint32_t GetMapComponentMissions(MissionID* result, uint32_t resultlen, UniverseID holomapid, UniverseID componentid);
	UniverseID GetMapFocusComponent(UniverseID holomapid);
	UniverseID GetMapPositionOnEcliptic2(UniverseID holomapid, UIPosRot* position, bool adaptiveecliptic, UniverseID eclipticsectorid, UIPosRot eclipticoffset);
	uint32_t GetMapRenderedComponents(UniverseID* result, uint32_t resultlen, UniverseID holomapid);
	uint32_t GetMapSelectedComponents(UniverseID* result, uint32_t resultlen, UniverseID holomapid);
	void GetMapState(UniverseID holomapid, HoloMapState* state);
	UIMapTradeVolumeParameter GetMapTradeVolumeParameter(void);
	uint32_t GetMaxProductionStorage(UIWareAmount* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetMineablesAtSectorPos(YieldInfo* result, uint32_t resultlen, UniverseID sectorid, Coord3D position);
	Coord3D GetMinimumBuildPlotCenterOffset(UniverseID stationid);
	Coord3D GetMinimumBuildPlotSize(UniverseID stationid);
	MissionBriefingIconInfo GetMissionBriefingIcon(MissionID missionid);
	void GetMissionDeliveryWares(MissionWareDeliveryInfo* result, MissionID missionid);
	MissionGroupDetails GetMissionGroupDetails(MissionID missionid);
	const char* GetMissionHelpOverlayID(MissionID missionid);
	MissionObjective2 GetMissionIDObjective2(uint64_t missionid);
	MissionDetails GetMissionIDDetails(uint64_t missionid);
	MissionObjectiveStep3 GetMissionObjectiveStep3(uint64_t missionid, size_t objectiveIndex);
	OnlineMissionInfo GetMissionOnlineInfo(MissionID missionid);
	uint32_t GetMissionThreadSubMissions(MissionID* result, uint32_t resultlen, MissionID missionid);
	uint32_t GetNumAllBoardingBehaviours(void);
	uint32_t GetNumAllBoardingPhases(void);
	uint32_t GetNumAllControlPosts(void);
	uint32_t GetNumAllCountermeasures(UniverseID defensibleid);
	uint32_t GetNumAllInventoryBombs(UniverseID entityid);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllMissiles(UniverseID defensibleid);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumAllModuleSets();
	uint32_t GetNumAllowedWeaponSystems(void);
	uint32_t GetNumAllRaces(void);
	uint32_t GetNumAllResponsesToSignal(const char* signalid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllSignals(void);
	uint32_t GetNumAllWareGroups(void);
	uint32_t GetNumAttackersOfBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetNumBoardingMarinesFromOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumCargoTransportTypes(UniverseID containerid, bool merge);
	uint32_t GetNumContainerWareReservations2(UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	uint32_t GetNumCurrentMissionOffers(bool showninbbs);
	uint32_t GetNumDiscoveredSectorResources(UniverseID sectorid);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDroneModes(UniverseID defensibleid, const char* dronetype);
	uint32_t GetNumFormationShapes(void);
	uint32_t GetNumIllegalToFactions(const char* wareid);
	uint32_t GetNumMapComponentMissions(UniverseID holomapid, UniverseID componentid);
	uint32_t GetNumMapRenderedComponents(UniverseID holomapid);
	uint32_t GetNumMapSelectedComponents(UniverseID holomapid);
	uint32_t GetNumMaxProductionStorage(UniverseID containerid);
	uint32_t GetNumMineablesAtSectorPos(UniverseID sectorid, Coord3D position);
	uint32_t GetNumMissionDeliveryWares(MissionID missionid);
	uint32_t GetNumMissionThreadSubMissions(MissionID missionid);
	uint32_t GetNumObjectsWithSyncPoint(uint32_t syncid, bool onlyreached);
	uint32_t GetNumOrderDefinitions(void);
	uint32_t GetNumOrderFailures(UniverseID controllableid, bool includelooporders);
	uint32_t GetNumOrderLocationData(UniverseID controllableid, size_t orderidx, bool usedefault);
	uint32_t GetNumOrders(UniverseID controllableid);
	uint32_t GetNumPeopleAfterOrders(UniverseID controllableid, int32_t numorders);
	uint32_t GetNumPersonSuitableControlPosts(UniverseID controllableid, UniverseID personcontrollableid, NPCSeed person, bool free);
	size_t GetNumPlannedStationModules(UniverseID defensibleid, bool includeall);
	uint32_t GetNumPlayerBuildMethods(void);
	uint32_t GetNumPlayerLogos(bool includestandard, bool includecustom);
	uint32_t GetNumPlayerShipBuildTasks(bool isinprogress, bool includeupgrade);
	uint32_t GetNumRequestedMissionNPCs(UniverseID containerid);
	uint32_t GetNumSkills(void);
	uint32_t GetNumShieldGroups(UniverseID defensibleid);
	uint32_t GetNumSoftwareSlots(UniverseID controllableid, const char* macroname);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumSubordinatesOfGroup(UniverseID commanderid, int group);
	uint32_t GetNumSuitableControlPosts(UniverseID controllableid, UniverseID entityid, bool free);
	uint32_t GetNumTiersOfRole(const char* role);
	size_t GetNumTradeComputerOrders(UniverseID controllableid);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	size_t GetNumVirtualUpgradeSlots(UniverseID objectid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumWareBlueprintOwners(const char* wareid);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetNumWeaponGroupsByWeapon(UniverseID defensibleid, UniverseID weaponid);
	const char* GetObjectIDCode(UniverseID objectid);
	UIPosRot GetObjectPositionInSector(UniverseID objectid);
	bool GetOrderDefinition(OrderDefinition* result, const char* orderdef);
	uint32_t GetOrderDefinitions(OrderDefinition* result, uint32_t resultlen);
	uint32_t GetOrderFailures(OrderFailure* result, uint32_t resultlen, UniverseID controllableid, bool includelooporders);
	AIOrderID GetOrderID(UniverseID controllableid, size_t orderidx);
	uint32_t GetOrderLocationData(UniverseID* result, uint32_t resultlen, UniverseID controllableid, size_t orderidx, bool usedefault);
	uint32_t GetOrderLoopSkillLimit();
	size_t GetOrderQueueCurrentIdx(UniverseID controllableid);
	size_t GetOrderQueueFirstLoopIdx(UniverseID controllableid, bool* isvalid);
	uint32_t GetOrders(Order* result, uint32_t resultlen, UniverseID controllableid);
	uint32_t GetOrders2(Order2* result, uint32_t resultlen, UniverseID controllableid);
	FactionDetails GetOwnerDetails(UniverseID componentid);
	Coord3D GetPaidBuildPlotCenterOffset(UniverseID stationid);
	Coord3D GetPaidBuildPlotSize(UniverseID stationid);
	UniverseID GetParentComponent(UniverseID componentid);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPeopleAfterOrders(NPCInfo* result, uint32_t resultlen, UniverseID controllableid, int32_t numorders);
	uint32_t GetPeopleCapacity(UniverseID controllableid, const char* macroname, bool includecrew);
	int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
	const char* GetPersonName(NPCSeed person, UniverseID controllableid);
	const char* GetPersonRole(NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkills3(SkillInfo* result, uint32_t resultlen, NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkillsForAssignment(Skill2* result, NPCSeed person, UniverseID controllableid, const char* role, const char* postid);
	uint32_t GetPersonSuitableControlPosts(ControlPostInfo* result, uint32_t resultlen, UniverseID controllableid, UniverseID personcontrollableid, NPCSeed person, bool free);
	int32_t GetPersonTier(NPCSeed npc, const char* role, UniverseID controllableid);
	UniverseID GetPickedMapComponent(UniverseID holomapid);
	SubordinateGroup GetPickedMapInterSectorDefence(UniverseID holomapid);
	MissionID GetPickedMapMission(UniverseID holomapid);
	UniverseID GetPickedMapMissionOffer(UniverseID holomapid);
	UniverseID GetPickedMapOrder(UniverseID holomapid, Order* result, bool* intermediate);
	uint32_t GetPickedMapSyncPoint(UniverseID holomapid);
	UniverseID GetPickedMapSyncPointOwningOrder(UniverseID holomapid, Order* result);
	TradeID GetPickedMapTradeOffer(UniverseID holomapid);
	MultiverseMapPickInfo GetPickedMultiverseMapPlayer(UniverseID holomapid);
	bool GetPlannedDefaultOrder(Order* result, UniverseID controllableid);
	size_t GetPlannedStationModules(UIConstructionPlanEntry* result, uint32_t resultlen, UniverseID defensibleid, bool includeall);
	const char* GetPlayerBuildMethod(void);
	uint32_t GetPlayerBuildMethods(ProductionMethodInfo* result, uint32_t resultlen);
	UniverseID GetPlayerComputerID(void);
	UniverseID GetPlayerContainerID(void);
	UniverseID GetPlayerControlledShipID(void);
	float GetPlayerGlobalLoadoutLevel(void);
	UniverseID GetPlayerID(void);
	uint32_t GetPlayerLogos(UILogo* result, uint32_t resultlen, bool includestandard, bool includecustom);
	UniverseID GetPlayerObjectID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	uint32_t GetPlayerShipBuildTasks(BuildTaskInfo* result, uint32_t resultlen, bool isinprogress, bool includeupgrade);
	bool GetPlayerGlobalTradeLoopCargoReservationSetting(void);
	UIPosRot GetPlayerTargetOffset(void);
	const char* GetRealComponentClass(UniverseID componentid);
	uint32_t GetRequestedMissionNPCs(MissionNPCInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetRoleTierNPCs(NPCSeed* result, uint32_t resultlen, UniverseID controllableid, const char* role, int32_t skilllevel);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	uint32_t GetRoleTiers2(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role, bool includearriving);
	UniverseID GetSectorControlStation(UniverseID sectorid);
	uint64_t GetSectorPopulation(UniverseID sectorid);
	uint32_t GetShieldGroups(ShieldGroup* result, uint32_t resultlen, UniverseID defensibleid);
	int32_t GetShipCombinedSkill(UniverseID shipid);
	bool GetShipTradeLoopCargoReservationSetting(UniverseID shipid);
	SofttargetDetails GetSofttarget(void);
	uint32_t GetSoftwareSlots(SoftwareSlot* result, uint32_t resultlen, UniverseID controllableid, const char* macroname);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	UIPosRot GetSubordinateGroupProtectedPosition(UniverseID controllableid, int group);
	UniverseID GetSubordinateGroupProtectedSector(UniverseID controllableid, int group);
	uint32_t GetSubordinatesOfGroup(UniverseID* result, uint32_t resultlen, UniverseID commanderid, int group);
	uint32_t GetSuitableControlPosts(ControlPostInfo* result, uint32_t resultlen, UniverseID controllableid, UniverseID entityid, bool free);
	bool GetSyncPointAutoRelease(uint32_t syncid, bool checkall);
	bool GetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool checkall);
	bool GetSyncPointInfo2(UniverseID controllableid, size_t orderidx, SyncPointInfo2* result);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	uint32_t GetTiersOfRole(RoleTierData* result, uint32_t resultlen, const char* role);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	int64_t GetTradeWareBudget(UniverseID containerid);
	const char* GetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetVirtualUpgradeSlotCurrentMacro(UniverseID defensibleid, const char* upgradetypename, size_t slot);
	uint32_t GetWareBlueprintOwners(const char** result, uint32_t resultlen, const char* wareid);
	uint32_t GetWareReservationsForWare(UniverseID containerid, const char* wareid, bool buy);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetWeaponGroupsByWeapon(UIWeaponGroup* result, uint32_t resultlen, UniverseID defensibleid, UniverseID weaponid);
	const char* GetWeaponMode(UniverseID weaponid);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	UniverseID GetZoneAt(UniverseID sectorid, UIPosRot* uioffset);
	bool HasAcceptedOnlineMission(void);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasControllableAnyOrderFailures(UniverseID controllableid);
	bool HasControllableOwnBlacklist(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnFightRule(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnResponse(UniverseID controllableid, const char* signalid);
	bool HasPersonArrived(UniverseID controllableid, NPCSeed person);
	bool HasShipTradeLoopCargoReservationOverride(UniverseID shipid);
	bool HasSubordinateAssignment(UniverseID controllableid, const char* assignment);
	bool IsAmmoMacroCompatible(const char* weaponmacroname, const char* ammomacroname);
	bool IsBuilderBusy(UniverseID shipid);
	bool IsComponentBlacklisted(UniverseID componentid, const char* listtype, const char* defaultgroup, UniverseID controllableid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsComponentOperational(UniverseID componentid);
	bool IsComponentWrecked(UniverseID componentid);
	bool IsContainerTradingWithFactionRescricted(UniverseID containerid, const char* factionid);
	bool IsContestedSector(UniverseID sectorid);
	bool IsControlPressed(void);
	bool IsCurrentBuildMapPlotPositionDiscovered(UniverseID sectorid, UIPosRot location, float x, float y, float z);
	bool IsCurrentBuildMapPlotValid(UniverseID holomapid);
	bool IsCurrentOrderCritical(UniverseID controllableid);
	bool IsDefensibleBeingBoardedBy(UniverseID defensibleid, const char* factionid);
	bool IsDroneTypeArmed(UniverseID defensibleid, const char* dronetype);
	bool IsDroneTypeBlocked(UniverseID defensibleid, const char* dronetype);
	bool IsExternalTargetMode();
	bool IsExternalViewActive();
	bool IsFactionHQ(UniverseID stationid);
	bool IsIconValid(const char* iconid);
	bool IsInfoUnlockedForPlayer(UniverseID componentid, const char* infostring);
	bool IsKnownToPlayer(UniverseID componentid);
	bool IsMasterVersion(void);
	bool IsMissionLimitReached(bool includeupkeep, bool includeguidance, bool includeplot);
	bool IsObjectKnown(const UniverseID componentid);
	bool IsOrderLoopable(const char* orderdefid);
	bool IsOrderSelectableFor(const char* orderdefid, UniverseID controllableid);
	bool IsPerson(NPCSeed person, UniverseID controllableid);
	bool IsPersonTransferScheduled(UniverseID controllableid, NPCSeed person);
	bool IsPlayerCameraTargetViewPossible(UniverseID targetid, bool force);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
	bool IsShiftPressed(void);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsStoryFeatureUnlocked(const char* featureid);
	bool IsTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool IsUICoverOverridden(void);
	bool IsUnit(UniverseID controllableid);
	bool IsVentureSeasonSupported(void);
	bool IsWeaponArmed(UniverseID weaponid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	void PayBuildPlotSize(UniverseID stationid, Coord3D plotsize, Coord3D plotcenter);
	UICrewExchangeResult PerformCrewExchange2(UniverseID controllableid, UniverseID partnercontrollableid, NPCSeed* npcs, uint32_t numnpcs, NPCSeed* partnernpcs, uint32_t numpartnernpcs, NPCSeed captainfromcontainer, NPCSeed captainfrompartner, bool exchangecaptains, bool checkonly);
	bool QuickMenuAccess(const char* menu);
	void ReassignPeople(UniverseID controllableid, CrewTransferContainer* reassignedcrew, uint32_t amount);
	void ReleasePersonFromCrewTransfer(UniverseID controllableid, NPCSeed person);
	void ReleaseOrderSyncPoint(uint32_t syncid);
	void ReleaseOrderSyncPointFromOrder(UniverseID controllableid, size_t idx);
	bool RemoveAllOrders(UniverseID controllableid);
	bool RemoveAttackerFromBoardingOperation(UniverseID defensibleboarderid);
	bool RemoveBuildPlot(UniverseID stationid);
	bool RemoveCommander2(UniverseID controllableid);
	void RemoveDefaultOrderFailure(UniverseID controllableid);
	void RemoveHoloMap(void);
	bool RemoveOrder(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly);
	void RemoveOrderFailure(UniverseID controllableid, uint32_t id);
	void RemoveOrderSyncPointID(UniverseID controllableid, size_t orderidx);
	void RemovePerson(UniverseID controllableid, NPCSeed person);
	void RemovePlannedDefaultOrder(UniverseID controllableid);
	void RemoveShipTradeLoopCargoReservationOverride(UniverseID shipid);
	UniverseID ReserveBuildPlot(UniverseID sectorid, const char* factionid, const char* set, UIPosRot location, float x, float y, float z);
	void ResetOrderLoop(UniverseID controllableid);
	bool ResetResponseToSignalForControllable(const char* signalid, UniverseID controllableid);
	void RevealEncyclopedia(void);
	void RevealMap(void);
	void RevealStations(void);
	bool SetActiveMission(MissionID missionid);
	void SelectSimilarMapComponents(UniverseID holomapid, UniverseID componentid);
	void SellPlayerShip(UniverseID shipid, UniverseID shipyardid);
	void SetAllMissileTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllMissileTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllNonMissileTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllNonMissileTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllowedWeaponSystems(UniverseID defensibleid, size_t orderidx, bool usedefault, WeaponSystemInfo* uiweaponsysteminfo, uint32_t numuiweaponsysteminfo);
	void SetAllTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllTurretsArmed(UniverseID defensibleid, bool arm);
	bool SetAmmoOfWeapon(UniverseID weaponid, const char* newammomacro);
	void SetCheckBoxChecked2(const int checkboxid, bool checked, bool update);
	bool SetCommander(UniverseID controllableid, UniverseID commanderid, const char* assignment);
	void SetConfigSetting(const char*const setting, const bool value);
	void SetContainerBuildMethod(UniverseID containerid, const char* buildmethodid);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetControllableBlacklist(UniverseID controllableid, BlacklistID id, const char* listtype, bool value);
	void SetControllableFightRule(UniverseID controllableid, FightRuleID id, const char* listtype, bool value);
	bool SetDefaultResponseToSignalForControllable(const char* newresponse, bool ask, const char* signalid, UniverseID controllableid);
	bool SetDefaultResponseToSignalForFaction(const char* newresponse, bool ask, const char* signalid, const char* factionid);
	void SetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary, uint32_t groupidx);
	void SetDefensibleLoadoutLevel(UniverseID defensibleid, float value);
	void SetDroneMode(UniverseID defensibleid, const char* dronetype, const char* mode);
	void SetDroneTypeArmed(UniverseID defensibleid, const char* dronetype, bool arm);
	void SetEditBoxText(const int editboxid, const char* text);
	void SetFleetLogo(UniverseID controllableid, UILogo logo);
	void SetFleetName(UniverseID controllableid, const char* fleetname);
	void SetFocusMapComponent(UniverseID holomapid, UniverseID componentid, bool resetplayerpan);
	void SetFocusMapOrder(UniverseID holomapid, UniverseID controllableid, size_t orderidx, bool resetplayerpan);
	UIFormationInfo SetFormationShape(UniverseID objectid, const char* formationshape);
	bool SetEntityToPost(UniverseID controllableid, UniverseID entityid, const char* postid);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetMapDefaultOrderParamObjectFilter(UniverseID holomapid, UniverseID ordercontrollableid, bool planned, size_t paramidx);
	void SetMapFactionRelationColorOption(UniverseID holomapid, bool value);
	void SetMapFilterString(UniverseID holomapid, uint32_t numtexts, const char** textarray);
	void SetMapObjectFilter(UniverseID holomapid, const char** classes, uint32_t numclasses, int32_t playerowned, bool allowentitydeliverymissionobject);
	void SetMapOrderParamObjectFilter(UniverseID holomapid, UniverseID ordercontrollableid, size_t orderidx, size_t paramidx);
	void SetMapPanOffset(UniverseID holomapid, UniverseID offsetcomponentid);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetMapRelativeMousePosition(UniverseID holomapid, bool valid, float x, float y);
	void SetMapRenderAllAllyOrderQueues(UniverseID holomapid, bool value);
	void SetMapRenderAllGateConnections(UniverseID holomapid, bool value);
	void SetMapRenderAllOrderQueues(UniverseID holomapid, bool value);
	void SetMapRenderCivilianShips(UniverseID holomapid, bool value);
	void SetMapRenderEclipticLines(UniverseID holomapid, bool value);
	void SetMapRenderMissionGuidance(UniverseID holomapid, MissionID missionid);
	void SetMapRenderMissionOffers(UniverseID holomapid, bool value);
	void SetMapRenderResourceInfo(UniverseID holomapid, bool value);
	void SetMapRenderSatelliteRadarRange(UniverseID holomapid, bool value);
	void SetMapRenderSelectionLines(UniverseID holomapid, bool value);
	void SetMapRenderTradeOffers(UniverseID holomapid, bool value);
	void SetMapRenderWrecks(UniverseID holomapid, bool value);
	void SetMapSelectedFleetCommander(UniverseID holomapid, UniverseID controllableid);
	void SetMapState(UniverseID holomapid, HoloMapState state);
	void SetMapStationInfoBoxMargin(UniverseID holomapid, const char* margin, uint32_t width);
	void SetMapTargetDistance(UniverseID holomapid, float distance);
	void SetMapTopTradesCount(UniverseID holomapid, uint32_t count);
	void SetMapTradeFilterByMaxPrice(UniverseID holomapid, int64_t price);
	void SetMapTradeFilterByMinTotalVolume(UniverseID holomapid, uint32_t minvolume);
	void SetMapTradeFilterByPlayerOffer(UniverseID holomapid, bool buysellswitch, bool enable);
	void SetMapTradeFilterByWare(UniverseID holomapid, const char** wareids, uint32_t numwareids);
	void SetMapTradeFilterByWareTransport(UniverseID holomapid, const char** transporttypes, uint32_t numtransporttypes);
	void SetMapTradeFilterByWillingToTradeWithPlayer(UniverseID holomapid);
	void SetMapAlertFilter(UniverseID holomapid, uint32_t alertlevel);
	bool SetOrderLoop(UniverseID controllableid, size_t orderidx, bool checkonly);
	bool SetOrderSyncPointID(UniverseID controllableid, size_t orderidx, uint32_t syncid, bool checkonly);
	void SetPlayerCameraCockpitView(bool force);
	void SetPlayerCameraTargetView(UniverseID targetid, bool force);
	void SetSelectedMapComponent(UniverseID holomapid, UniverseID componentid);
	void SetSelectedMapComponents(UniverseID holomapid, UniverseID* componentids, uint32_t numcomponentids);
	void SetShipTradeLoopCargoReservationOverride(UniverseID shipid, bool value);
	bool SetSofttarget(UniverseID componentid, const char*const connectionname);
	void SetSubordinateGroupDockAtCommander(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupProtectedLocation(UniverseID controllableid, int group, UniverseID sectorid, UIPosRot offset);
	void SetSyncPointAutoRelease(uint32_t syncid, bool all, bool any);
	void SetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool all, bool any);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	void SetTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, bool arm);
	void SetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, const char* mode);
	void SetUICoverOverride(bool override);
	void SetWeaponArmed(UniverseID weaponid, bool arm);
	void SetWeaponGroup(UniverseID defensibleid, UniverseID weaponid, bool primary, uint32_t groupidx, bool value);
	void SetWeaponMode(UniverseID weaponid, const char* mode);
	bool ShouldSubordinateGroupDockAtCommander(UniverseID controllableid, int group);
	void ShowBuildPlotPlacementMap(UniverseID holomapid, UniverseID sectorid);
	void ShowMultiverseMap(UniverseID holomapid);
	void ShowUniverseMap2(UniverseID holomapid, bool setoffset, bool showzone, bool forcebuildershipicons, UniverseID startsectorid, UIPosRot startpos);
	void SignalObjectWithNPCSeedAndMissionID(UniverseID objecttosignalid, const char* param, MissionID missionid, NPCSeed person, UniverseID controllableid);
	bool StartBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void ZoomMap(UniverseID holomapid, float zoomstep);
	void StartMapBoxSelect(UniverseID holomapid, bool selectenemies);
	void StopMapBoxSelect(UniverseID holomapid);
	bool TeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool instant, bool force);
	bool ToggleAutoPilot(bool checkonly);
	bool UpdateAttackerOfBoardingOperation(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid, const char* actionid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	bool UpdateBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid, uint32_t approachthreshold, uint32_t insertionthreshold);
	void UpdateMapBuildPlot(UniverseID holomapid);
	bool WasSessionOnline(void);
]]

local utf8 = require("utf8")

local menu = {
	name = "MapMenu",
	white = { r = 255, g = 255, b = 255, a = 100 },
	grey = { r = 128, g = 128, b = 128, a = 100 },
	darkgrey = { r = 64, g = 64, b = 64, a = 100 },
	red = { r = 255, g = 0, b = 0, a = 100 },
	green = { r = 0, g = 255, b = 0, a = 100 },
	infoTableMode = "objectlist",
	ventureMode = C.IsVentureSeasonSupported() and "ventureseason" or "venturelogbook",
	displayedFilterLayer = "layer_trade",
	mouseCursorOverrides = { [1] = "default" },
	currentMouseCursor = "default",
	picking = true,
	missionOfferMode = "normal",
	missionMode = "plot",
	expandedMissionGroups = {},
	infoMode = { left = "objectinfo", right = "objectinfo" },
	seasonMode = { left = "currentseason", right = "currentseason" },
	highlightLeftBar = {},
	objectMode = "objectall",
	propertyMode = "propertyall",
	objectSorterType = "name",
	propertySorterType = "name",
	crewSort = "role",
	crewRole = "current",
	showMultiverse = false,
	cachedOrderFailures = {},
}

local config = {
	mainFrameLayer = 6,
	infoFrameLayer2 = 5,
	infoFrameLayer = 4,
	contextFrameLayer = 2,

	complexOrderParams = {
		["trade"] = {
			[1] = { id = "trade_location", name = ReadText(1001, 2943), type = "object", inputparams = { class = "sector" }, value = function (data) return next(data) and data.station and GetComponentData(data.station, "zoneid") or nil end },
			[2] = { id = "trade_partner", name = ReadText(1001, 23), type = "object", inputparams = { class = "container" }, value = function (data) return data.station end },
			[3] = { id = "trade_ware", name = ReadText(1001, 7104), type = "trade_ware", value = function (data) return next(data) and data.ware and {data.isbuyoffer, data.ware} or nil end },
			[4] = { id = "trade_amount", name = ReadText(1001, 6521), type = "trade_amount", value = function (data) return data.ware and {data.desiredamount, data.amount} or nil end },
			data = function (value) return (value and IsValidTrade(value) and menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue")) and GetTradeData(value, ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))) or {} end
		}
	},
	moduletypes = {
		{ type = "moduletypes_production", name = ReadText(1001, 2421) },
		{ type = "moduletypes_build",      name = ReadText(1001, 2439) },
		{ type = "moduletypes_storage",    name = ReadText(1001, 2422) },
		{ type = "moduletypes_habitation", name = ReadText(1001, 2451) },
		{ type = "moduletypes_welfare",    name = ReadText(1001, 9620) },
		{ type = "moduletypes_dock",       name = ReadText(1001, 2452) },
		{ type = "moduletypes_defence",    name = ReadText(1001, 2424) },
		{ type = "moduletypes_processing", name = ReadText(1001, 9621) },
		{ type = "moduletypes_other",      name = ReadText(1001, 2453) },
		{ type = "moduletypes_venture",    name = ReadText(1001, 2454) },
	},
	stateKeys = {
		{"mode"},
		{"modeparam"},
		{"lastactivetable"},
		{"focuscomponent", "UniverseID"},
		{"currentsector", "UniverseID"},
		{"selectedcomponents"},
		{"searchtext"},
		{"infoTableMode"},
		{"ventureMode"},
		{"searchTableMode"},
		{"infoSubmenuObject", "UniverseID"},
		{"showMultiverse", "bool"},
		{"objectMode"},
		{"propertyMode"},
		{"seasonMode"},
	},
	leftBar = {
		{ name = ReadText(1001, 3224),	icon = "mapst_objectlist",			mode = "objectlist",	helpOverlayID = "map_sidebar_objectlist",			helpOverlayText = ReadText(1028, 3201) },
		{ name = ReadText(1001, 1000),	icon = "mapst_propertyowned",		mode = "propertyowned",	helpOverlayID = "map_sidebar_propertyowned",		helpOverlayText = ReadText(1028, 3203) },
		{ spacing = true },
		{ name = ReadText(1001, 3324),	icon = "mapst_mission_offers",		mode = "missionoffer",	helpOverlayID = "map_sidebar_mission_offers",		helpOverlayText = ReadText(1028, 3205) },
		{ name = ReadText(1001, 3323),	icon = "mapst_mission_accepted",	mode = "mission",		helpOverlayID = "map_sidebar_mission_accepted",		helpOverlayText = ReadText(1028, 3207) },
		{ spacing = true },
		{ name = ReadText(1001, 2427),	icon = "mapst_information",			mode = "info",			helpOverlayID = "map_sidebar_information",			helpOverlayText = ReadText(1028, 3209) },
		{ spacing = true },
		{ name = ReadText(1001, 3226),	icon = "mapst_plotmanagement",		mode = "plots",			helpOverlayID = "map_sidebar_plotmanagement",		helpOverlayText = ReadText(1028, 3211) },
		{ spacing = true,																			condition = IsCheatVersion }, -- (cheats only)
		{ name = "Cheats",				icon = "mapst_cheats",				mode = "cheats",		condition = IsCheatVersion }, -- (cheats only)
	},
	leftBarMultiverse = {
		{ name = ReadText(1001, 11288),	icon = "vt_season",					mode = "ventureseason",		helpOverlayID = "multimap_season",				helpOverlayText = ReadText(1028, 3263),		condition = C.IsVentureSeasonSupported },
		{ spacing = true,		condition = C.IsVentureSeasonSupported },
		{ name = ReadText(1001, 11318),	icon = "vt_mission",				mode = "ventureoperation",	helpOverlayID = "multimap_operation",			helpOverlayText = ReadText(1028, 3266),		condition = C.IsVentureSeasonSupported },
		{ name = ReadText(1001, 11319),	icon = "vt_logbook",				mode = "venturelogbook",	helpOverlayID = "multimap_logbook",				helpOverlayText = ReadText(1028, 3267) },
		{ spacing = true, },
		{ name = ReadText(1001, 7720),	icon = "vt_inventory",				mode = "ventureinventory",	helpOverlayID = "multimap_inventory",			helpOverlayText = ReadText(1028, 3269) },
		{ name = ReadText(1001, 11386),	icon = "vt_contactlist",			mode = "venturecontacts",	helpOverlayID = "multimap_contacts",			helpOverlayText = ReadText(1028, 3275),		condition = C.IsVentureSeasonSupported },
	},
	rightBar = {
		{ name = ReadText(1001, 3227),	icon = "mapst_filtersystem",		mode = "filter",		helpOverlayID = "mapst_filter",						helpOverlayText = ReadText(1028, 3212) },
		{ name = ReadText(1001, 9801),	icon = "mapst_legend",				mode = "legend",		helpOverlayID = "mapst_legend",						helpOverlayText = ReadText(1028, 3213) },
		{ spacing = true },
		{ name = ReadText(1001, 2427),	icon = "mapst_information",			mode = "info",			helpOverlayID = "map_sidebar_information2",			helpOverlayText = ReadText(1028, 3209) },
	},
	infoCategories = {
		{ category = "objectinfo",				name = ReadText(1001, 2427),	icon = "mapst_information",			helpOverlayID = "mapst_ao_information",			helpOverlayText = ReadText(1028, 3234) },
		{ category = "objectcrew",				name = ReadText(1001, 80),		icon = "shipbuildst_crew",			helpOverlayID = "mapst_ao_info_crew",			helpOverlayText = ReadText(1028, 3237) },
		{ category = "objectloadout",			name = ReadText(1001, 9413),	icon = "mapst_loadout",				helpOverlayID = "mapst_ao_info_loadout",		helpOverlayText = ReadText(1028, 3238) },
		{ category = "objectlogbook",			name = ReadText(1001, 5700),	icon = "pi_logbook",				helpOverlayID = "mapst_ao_info_logbook",		helpOverlayText = ReadText(1028, 3238) },
		{ empty = true },
		{ category = "orderqueue",				name = ReadText(1001, 8360),	icon = "mapst_ao_orderqueue",		helpOverlayID = "mapst_ao_orderqueue",			helpOverlayText = ReadText(1028, 3235) },
		{ category = "orderqueue_advanced",		name = ReadText(1001, 8361),	icon = "mapst_orderqueue_advanced",	helpOverlayID = "mapst_ao_orderqueue_advanced",	helpOverlayText = ReadText(1028, 3236) },
		{ category = "standingorders",			name = ReadText(1001, 8396),	icon = "mapst_standing_orders",		helpOverlayID = "mapst_ao_standing_orders",		helpOverlayText = ReadText(1028, 3239) },
	},
	objectCategories = {
		{ category = "objectall",				name = ReadText(1001, 8380),	icon = "mapst_objectlist",			helpOverlayID = "mapst_ol_objectlist",			helpOverlayText = ReadText(1028, 3220) },
		{ category = "stations",				name = ReadText(1001, 8379),	icon = "mapst_ol_stations",			helpOverlayID = "mapst_ol_stations",			helpOverlayText = ReadText(1028, 3221) },
		{ category = "ships",					name = ReadText(1001, 6),		icon = "mapst_ol_ships",			helpOverlayID = "mapst_ol_fleets",				helpOverlayText = ReadText(1028, 3222) },
		{ category = "deployables",				name = ReadText(1001, 1332),	icon = "mapst_ol_deployables",		helpOverlayID = "mapst_ol_deployables",			helpOverlayText = ReadText(1028, 3226) },
	},
	propertyCategories = {
		{ category = "propertyall",				name = ReadText(1001, 8380),	icon = "mapst_propertyowned",		helpOverlayID = "mapst_po_propertyowned",		helpOverlayText = ReadText(1028, 3220) },
		{ category = "stations",				name = ReadText(1001, 8379),	icon = "mapst_ol_stations",			helpOverlayID = "mapst_po_stations",			helpOverlayText = ReadText(1028, 3221) },
		{ category = "fleets",					name = ReadText(1001, 8326),	icon = "mapst_ol_fleets",			helpOverlayID = "mapst_po_fleets",				helpOverlayText = ReadText(1028, 3223) },
		{ category = "unassignedships",			name = ReadText(1001, 8327),	icon = "mapst_ol_unassigned",		helpOverlayID = "mapst_po_unassigned",			helpOverlayText = ReadText(1028, 3224) },
		{ category = "inventoryships",			name = ReadText(1001, 8381),	icon = "mapst_ol_inventory",		helpOverlayID = "mapst_po_inventory",			helpOverlayText = ReadText(1028, 3225) },
		{ category = "deployables",				name = ReadText(1001, 1332),	icon = "mapst_ol_deployables",		helpOverlayID = "mapst_po_deployables",			helpOverlayText = ReadText(1028, 3226) },
	},
	seasonCategories = {
		{ category = "currentseason",			name = ReadText(1001, 11322),	icon = "vt_season_current",			helpOverlayID = "mapst_ven_curseason",			helpOverlayText = ReadText(1028, 3270) },
		{ category = "coalition",				name = ReadText(1001, 11323),	icon = "vt_guild",					helpOverlayID = "mapst_ven_coalitions",			helpOverlayText = ReadText(1028, 3271) },
		{ category = "ventureteam",				name = ReadText(1001, 11320),	icon = "vt_team",					helpOverlayID = "multimap_team",				helpOverlayText = ReadText(1028, 3268) },
		{ category = "pastseasons",				name = ReadText(1001, 11324),	icon = "vt_season_previous",		helpOverlayID = "mapst_ven_pastseason",			helpOverlayText = ReadText(1028, 3264) },
	},
	layers = {
		{ name = ReadText(1001, 3252),	shortname = ReadText(1001, 11626),	icon = "mapst_fs_trade",		mode = "layer_trade",		helpOverlayID = "layer_trade",		helpOverlayText = ReadText(1028, 3214)  },
		{ name = ReadText(1001, 8329),	shortname = ReadText(1001, 11629),	icon = "mapst_fs_mining",		mode = "layer_mining",		helpOverlayID = "layer_mining",		helpOverlayText = ReadText(1028, 3216)  },
		{ name = ReadText(1001, 3254),	shortname = ReadText(1001, 11628),	icon = "mapst_fs_other",		mode = "layer_other",		helpOverlayID = "layer_other",		helpOverlayText = ReadText(1028, 3217)  },
	},
	layersettings = {
		["layer_trade"] = {
			callback = function (value) return C.SetMapRenderTradeOffers(menu.holomap, value) end,
			[1] = {
				caption = ReadText(1001, 46),
				info = ReadText(1001, 3279),
				overrideText = ReadText(1001, 8378),
				type = "multiselectlist",
				id = "trade_wares",
				callback = function (...) return menu.filterTradeWares(...) end,
				listOptions = function (...) return menu.getFilterTradeWaresOptions(...) end,
				displayOption = function (option) return "\27[maptr_supply] " .. GetWareData(option, "name") end,
			},
			[2] = {
				caption = ReadText(1001, 1400),
				type = "checkbox",
				callback = function (...) return menu.filterTradeStorage(...) end,
				[1] = {
					id = "trade_storage_container",
					name = ReadText(20205, 100),
					info = ReadText(1001, 3280),
					param = "container",
				},
				[2] = {
					id = "trade_storage_solid",
					name = ReadText(20205, 200),
					info = ReadText(1001, 3281),
					param = "solid",
				},
				[3] = {
					id = "trade_storage_liquid",
					name = ReadText(20205, 300),
					info = ReadText(1001, 3282),
					param = "liquid",
				},
				[4] = {
					id = "trade_storage_condensate",
					name = ReadText(20205, 1100),
					info = ReadText(1001, 11614),
					param = "condensate",
				},
			},
			[3] = {
				caption = ReadText(1001, 2808),
				type = "slidercell",
				callback = function (...) return menu.filterTradePrice(...) end,
				[1] = {
					id = "trade_price_maxprice",
					name = ReadText(1001, 3284),
					info = ReadText(1001, 3283),
					param = "maxprice",
					scale = {
						min       = 0,
						max       = 10000,
						step      = 1,
						suffix    = ReadText(1001, 101),
						exceedmax = true
					}
				},
			},
			[4] = {
				caption = ReadText(1001, 8357),
				type = "dropdown",
				callback = function (...) return menu.filterTradeVolume(...) end,
				[1] = {
					id = "trade_volume",
					info = ReadText(1001, 8358),
					listOptions = function (...) return menu.getFilterTradeVolumeOptions(...) end,
					param = "volume"
				},
			},
			[5] = {
				caption = ReadText(1001, 11205),
				type = "dropdown",
				callback = function (...) return menu.filterTradePlayerOffer(...) end,
				[1] = {
					id = "trade_playeroffer_buy",
					info = ReadText(1001, 11209),
					listOptions = function (...) return menu.getFilterTradePlayerOfferOptions(true) end,
					param = "playeroffer_buy"
				},
				[2] = {
					id = "trade_playeroffer_sell",
					info = ReadText(1001, 11210),
					listOptions = function (...) return menu.getFilterTradePlayerOfferOptions(false) end,
					param = "playeroffer_sell"
				},
			},
			[6] = {
				caption = ReadText(1001, 11240),
				type = "checkbox",
				callback = function (...) return menu.filterTradeRelation(...) end,
				[1] = {
					id = "trade_relation_enemy",
					name = ReadText(1001, 11241),
					info = ReadText(1001, 11242),
					param = "enemy",
				},
			},
			[7] = {
				caption = ReadText(1001, 8343),
				type = "slidercell",
				callback = function (...) return menu.filterTradeOffer(...) end,
				[1] = {
					id = "trade_offer_number",
					name = ReadText(1001, 8344),
					info = ReadText(1001, 8345),
					param = "number",
					scale = {
						min       = 0,
						minSelect = 1,
						max       = 5,
						step      = 1,
						exceedmax = true,
					}
				},
			},
		},
		["layer_fight"] = {},
		["layer_think"] = {},
		["layer_build"] = {},
		["layer_diplo"] = {},
		["layer_mining"] = {
			callback = function (value) return menu.filterMining(value) end,
			[1] = {
				caption = ReadText(1001, 8330),
				type = "checkbox",
				callback = function (...) return menu.filterMiningResources(...) end,
				[1] = {
					id = "mining_resource_display",
					name = ReadText(1001, 8331),
					info = ReadText(1001, 8332),
					param = "display"
				},
			},
		},
		["layer_other"] = {
			callback = function (value) return menu.filterOther(value) end,
			[1] = {
				caption = ReadText(1001, 3285),
				type = "dropdown",
				callback = function (...) return menu.filterThinkAlert(...) end,
				[1] = {
					info = ReadText(1001, 3286),
					id = "think_alert",
					listOptions = function (...) return menu.getFilterThinkAlertOptions(...) end,
					param = "alert"
				},
			},
			[2] = {
				caption = ReadText(1001, 11204),
				type = "checkbox",
				callback = function (...) return menu.filterThinkDiplomacy(...) end,
				[1] = {
					id = "think_diplomacy_factioncolor",
					name = ReadText(1001, 11203),
					param = "factioncolor",
				},
				[2] = {
					id = "think_diplomacy_highlightvisitor",
					name = ReadText(1001, 11216),
					info = ReadText(1001, 11217),
					param = "highlightvisitors",
				},
			},
			[3] = {
				caption = ReadText(1001, 2664),
				type = "checkbox",
				callback = function (...) return menu.filterOtherMisc(...) end,
				[1] = {
					id = "other_misc_ecliptic",
					name = ReadText(1001, 3297),
					info = ReadText(1001, 3298),
					param = "ecliptic",
				},
				[2] = {
					id = "other_misc_wrecks",
					name = ReadText(1001, 8382),
					info = ReadText(1001, 8383),
					param = "wrecks",
				},
				[3] = {
					id = "other_misc_selection_lines",
					name = ReadText(1001, 11214),
					info = ReadText(1001, 11215),
					param = "selectionlines",
				},
				[4] = {
					id = "other_misc_gate_connections",
					name = ReadText(1001, 11243),
					info = ReadText(1001, 11244),
					param = "gateconnections",
				},
				[5] = {
					id = "other_misc_opacity",
					name = ReadText(1001, 11245),
					info = ReadText(1001, 11246),
					param = "opacity",
				},
				[6] = {
					id = "other_misc_coveroverride",
					name = ReadText(1001, 11604),
					info = ReadText(1001, 11605),
					param = "coveroverride",
					active = Helper.isPlayerCovered,
				},
				[7] = {
					id = "other_misc_rendersatelliteradarrange",
					name = ReadText(1001, 11637),
					info = ReadText(1001, 11638),
					param = "rendersatelliteradarrange",
				},
			},
			[4] = {
				caption = ReadText(1001, 8336),
				type = "checkbox",
				callback = function (...) return menu.filterOtherShip(...) end,
				[1] = {
					id = "other_misc_orderqueue",
					name = ReadText(1001, 3287),
					info = ReadText(1001, 8372),
					param = "orderqueue",
				},
				[2] = {
					id = "other_misc_allyorderqueue",
					name = ReadText(1001, 8370),
					info = ReadText(1001, 8371),
					param = "allyorderqueue",
				},
			},
			[5] = {
				caption = ReadText(1001, 8335),
				type = "checkbox",
				callback = function (...) return menu.filterOtherStation(...) end,
				[1] = {
					id = "other_misc_missions",
					name = ReadText(1001, 3291),
					info = ReadText(1001, 3292),
					param = "missions",
				},
				[2] = {
					id = "other_misc_civilian",
					name = ReadText(1001, 8333),
					info = ReadText(1001, 8334),
					param = "civilian",
				},
			},
		},
	},
	mapfilterversion = 20,

	-- custom default row properties, different from Helper defaults
	mapRowHeight = Helper.standardTextHeight,
	mapFontSize = Helper.standardFontSize,
	plotPairedDimension = { posX = "negX", negX = "posX", posY = "negY", negY = "posY", posZ = "negZ", negZ = "posZ" },
	maxPlotSize = 20,
	cameraResetThresholdAngle = 2, -- in degrees

	contextBorder = 5,

	classOrder = {
		["station"]		= 1,
		["ship_xl"]		= 2,
		["ship_l"]		= 3,
		["ship_m"]		= 4,
		["ship_s"]		= 5,
		["ship_xs"]		= 6,
	},
	purposeOrder = {
		["fight"]		= 1,
		["auxiliary"]	= 2,
		["build"]		= 3,
		["mine"]		= 4,
		["trade"]		= 5,
	},

	missionMainTypeOrder = {
		["plot"] = 1,
		["tutorial"] = 2,
		["generic"] = 3,
		["upkeep"] = 4,
		["guidance"] = 5,
	},

	missionOfferCategories = {
		{ category = "plot",		name = ReadText(1001, 3340),	icon = "mapst_mission_main",		helpOverlayID = "mapst_mission_offer_plot",			helpOverlayText = ReadText(1028, 3240) },
		{ category = "guild",		name = ReadText(1001, 3331),	icon = "mapst_mission_guild",		helpOverlayID = "mapst_mission_offer_guild",		helpOverlayText = ReadText(1028, 3227) },
		{ category = "coalition",	name = ReadText(1001, 8801),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_offer_coalition",	helpOverlayText = "",					showtab = false },
		{ category = "other",		name = ReadText(1001, 3332),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_offer_other",		helpOverlayText = ReadText(1028, 3228) },
	},

	missionOfferTabs = {
		{ category = "normal",		name = ReadText(1001, 3324),	icon = "mapst_mission_offers",		helpOverlayID = "mapst_mission_offer_tab_normal",		helpOverlayText = ReadText(1028, 3273) },
		{ category = "operation",	name = ReadText(1001, 11318),	icon = "vt_season",					helpOverlayID = "mapst_mission_offer_tab_operation",	helpOverlayText = ReadText(1028, 3274) },
	},

	missionCategories = {
		{ category = "plot",		name = ReadText(1001, 3341),	icon = "mapst_mission_main",		helpOverlayID = "mapst_mission_active_main",		helpOverlayText = ReadText(1028, 3241) },
		{ category = "guild",		name = ReadText(1001, 3333),	icon = "mapst_mission_guild",		helpOverlayID = "mapst_mission_active_guild",		helpOverlayText = ReadText(1028, 3229),	showtab = false },
		{ category = "coalition",	name = ReadText(1001, 8801),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_active_coalition",	helpOverlayText = "",					showtab = false },
		{ category = "other",		name = ReadText(1001, 3334),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_active_other",		helpOverlayText = ReadText(1028, 3230),	showtab = false },
		{ category = "upkeep",		name = ReadText(1001, 3305),	icon = "mapst_mission_upkeep",		helpOverlayID = "mapst_mission_active_upkeep",		helpOverlayText = ReadText(1028, 3231) },
		{ category = "guidance",	name = ReadText(1001, 3329),	icon = "mapst_mission_guidance",	helpOverlayID = "mapst_mission_active_guidance",	helpOverlayText = ReadText(1028, 3232) },
	},

	missionContextWidth = 400,
	missionContextIconWidthFactor = 0.4,

	autopilotmarker = ">> ",
	softtargetmarker_l = "> ",

	tradeContextMenuWidth = math.min(Helper.scaleX(900), 0.5 * Helper.viewWidth + Helper.scrollbarWidth),
	tradeContextMenuInfoBorder = 15,

	legend = {
		-- hexes
		{ icon = "maplegend_hexagon_fog_01",		text = ReadText(10002, 606),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth },														-- Unknown location
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9806),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = { r = 255, g = 0, b = 0, a = 100 } },		-- Mineral Region
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9807),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = { r = 0, g = 0, b = 255, a = 100 }  },		-- Gas Region
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9812),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = { r = 255, g = 0, b = 255, a = 100 }  },	-- Mineral/Gas Region
		-- highways, gates, etc
		{ icon = "solid",							text = ReadText(1001, 9809),	width = Helper.sidebarWidth,	height = Helper.standardTextHeight / 2,	minRowHeight = Helper.sidebarWidth / 2 },	-- Jump Gate Connection
		{ icon = "maplegend_hw_01",					text = ReadText(20001, 601),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth / 2,	color = "superhighwaycolor" },					-- Superhighway
		{ icon = "maplegend_hw_01",					text = ReadText(20001, 501),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth / 2,	color = "highwaycolor" },						-- Local Highway
		{ icon = "mapob_jumpgate",					text = ReadText(20001, 701),	color = "gatecolor" },			-- Jump Gate
		{ icon = "mapob_transorbital_accelerator",	text = ReadText(20001, 1001),	color = "gatecolor" },			-- Accelarator
		{ icon = "mapob_superhighway",				text = ReadText(1001, 9810),	color = "highwaygatecolor" },	-- Superhighway Gate
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5200),	color = "playercolor" },		-- Owned
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5202),	color = "friendcolor" },		-- Neutral
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5201),	color = "enemycolor" },			-- Enemy
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5212),	color = "hostilecolor" },		-- Hostile
		-- stations
		{ text = ReadText(1001, 4) },																																					-- Stations
		{ icon = "mapob_playerhq",					text = ReadText(20102, 2011),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "playercolor" },	-- Headquarters
		{ icon = "maplegend_hq_01",					text = ReadText(1001, 9808),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Faction Headquarters
		{ icon = "mapob_shipyard",					text = ReadText(1001, 92),		width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Shipyard
		{ icon = "mapob_wharf",						text = ReadText(1001, 9805),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Wharf
		{ icon = "mapob_equipmentdock",				text = ReadText(1001, 9804),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Equipment Dock
		{ icon = "mapob_tradestation",				text = ReadText(1001, 9803),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Trading Station
		{ icon = "mapob_defensestation",			text = ReadText(1001, 9802),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Defence Platform
		{ icon = "mapob_piratestation",				text = ReadText(20102, 1511),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Free Port
		{ station_factory_placeholder = true },
		{ icon = "mapob_factory",					text = ReadText(20102, 1001),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Factory
		-- xl ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5041) },					-- Ships: XL
		{ icon = "ship_xl_fight_01",				text = ReadText(1001, 9816),	color = "friendcolor" },	-- Fighter
		{ icon = "ship_xl_neutral_01",				text = ReadText(1001, 9820),	color = "friendcolor" },	-- Auxiliary
		--{ icon = "ship_xl_mine_01",				text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_xl_build_01",				text = ReadText(1001, 9821),	color = "friendcolor" },	-- Builder
		-- l ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5031) },					-- Ships: L
		{ icon = "ship_l_fight_01",					text = ReadText(1001, 9816),	color = "friendcolor" },	-- Fighter
		{ icon = "ship_l_trade_01",					text = ReadText(1001, 9819),	color = "friendcolor" },	-- Freighter
		{ icon = "ship_l_mine_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		-- m ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5021) },					-- Ships: M
		{ icon = "ship_m_fight_01",					text = ReadText(1001, 9816),	color = "friendcolor" },	-- Fighter
		{ icon = "ship_m_trade_01",					text = ReadText(1001, 9817),	color = "friendcolor" },	-- Transporter
		{ icon = "ship_m_mine_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		-- s ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5011) },					-- Ships: S
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 9816),	color = "friendcolor" },	-- Fighter
		{ icon = "ship_s_trade_01",					text = ReadText(1001, 9817),	color = "friendcolor" },	-- Transporter
		{ icon = "ship_s_mine_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		-- xs ships
		{ text = ReadText(1001, 22) },																			-- Units
		{ icon = "ship_xs_fight_01",				text = ReadText(20101, 100401),	color = "friendcolor" },	-- Defence Drone
		{ icon = "ship_xs_trade_01",				text = ReadText(20101, 100101),	color = "friendcolor" },	-- Cargo Drone
		{ icon = "ship_xs_mine_01",					text = ReadText(20101, 100501),	color = "friendcolor" },	-- Mining Drone
		{ icon = "ship_xs_neutral_01",				text = ReadText(20101, 110201),	color = "friendcolor" },	-- Civilian Ship
		{ icon = "ship_xs_build_01",				text = ReadText(20101, 100301),	color = "friendcolor" },	-- Building Drone
		-- trade offers
		{ text = ReadText(1001, 1113) },																		-- Trade Offers
		{ icon = "maptr_illegal",					text = ReadText(1001, 9813) },								-- Illegal Trades
		{ icon = "maptr_buildstorage",				text = ReadText(1001, 11032) },								-- Station COnstruction Trades
		{ icon = "maptr_supply",					text = ReadText(1001, 9814) },								-- Supply Trades
		{ icon = "maptr_hexagon",					text = ReadText(1001, 9815),	color = { r = 91, g = 148, b = 188, a = 100 } },	-- Trade Volume
		-- misc
		{ text = ReadText(1001, 2664) },																								-- Misc
		{ icon = "mapob_lasertower_xs",				text = ReadText(20201, 20501),	color = "friendcolor" },							-- Laser Tower Mk1
		{ icon = "mapob_lasertower_s",				text = ReadText(20201, 20601),	color = "friendcolor" },							-- Laser Tower Mk2
		{ icon = "mapob_mine",						text = ReadText(20201, 20201),	color = "friendcolor" },							-- Mine
		{ icon = "solid",							text = ReadText(1001, 1304),	width = 4,	height = 4,	color = "missilecolor" },	-- Missiles
		{ icon = "mapob_satellite_01",				text = ReadText(20201, 20301),	color = "friendcolor" },							-- Satellite
		{ icon = "mapob_satellite_02",				text = ReadText(20201, 20401),	color = "friendcolor" },							-- Advanced Satellite
		{ icon = "mapob_resourceprobe",				text = ReadText(20201, 20701),	color = "friendcolor" },							-- Resource Probe
		{ icon = "mapob_navbeacon",					text = ReadText(20201, 20801),	color = "friendcolor" },							-- Nav Beacon
		{ icon = "mapob_poi",						text = ReadText(1001, 9811),	color = "friendcolor" },							-- Point of Interest
		{ icon = "mapob_unknown",					text = ReadText(20109, 5001) },														-- Unknown Object
		{ icon = "npc_factionrep",					text = ReadText(20208, 10601),	color = "friendcolor" },							-- Faction Representative
		{ icon = "npc_missionactor",				text = ReadText(30260, 1901),	color = "missioncolor" },							-- Person of Interest
		{ icon = "npc_shadyguy",					text = ReadText(20208, 10801),	color = "friendcolor" },							-- Black Marketeer
		{ icon = "missiontype_fight",				text = ReadText(1001, 3291),	color = "missioncolor" },							-- Mission Offers
		{ icon = "mapob_missiontarget",				text = ReadText(1001, 3325),	color = "missioncolor" },							-- Accepted Missions
		-- orders
		{ text = ReadText(1001, 8360) },												-- Behaviours
		{ icon = "order_movegeneric",				text = ReadText(1041, 541) },		-- Fly
		{ icon = "order_wait",						text = ReadText(1041, 101) },		-- Hold Position
		{ icon = "order_waitforsignal",				text = ReadText(1041, 111) },		-- Wait for Signal
		{ icon = "order_dockat",					text = ReadText(1041, 441) },		-- Dock
		{ icon = "order_dockandwait",				text = ReadText(1041, 451) },		-- Dock and Wait
		{ icon = "order_undock",					text = ReadText(1041, 531) },		-- Undock
		{ icon = "order_follow",					text = ReadText(1041, 321) },		-- Follow Ship

		{ icon = "order_attack",					text = ReadText(1041, 431) },		-- Attack
		{ icon = "order_attackinrange",				text = ReadText(1041, 631) },		-- Attack targets in range
		{ icon = "order_patrol",					text = ReadText(1041, 391) },		-- Patrol
		{ icon = "order_protectposition",			text = ReadText(1041, 381) },		-- Protect Position
		{ icon = "order_police",					text = ReadText(1041, 671) },		-- Police
		{ icon = "order_plunder",					text = ReadText(1041, 231) },		-- Plunder
		{ icon = "order_board",						text = ReadText(1041, 421) },		-- Board
		{ icon = "order_escort",					text = ReadText(1041, 411) },		-- Escort Ship
		{ icon = "order_recon",						text = ReadText(1041, 291) },		-- Recon
		{ icon = "order_flee",						text = ReadText(1041, 551) },		-- Flee

		{ icon = "order_findbuildtasks",			text = ReadText(1041, 491) },		-- Find Build Tasks
		{ icon = "order_deploytostation",			text = ReadText(1041, 511) },		-- Deploy to Station

		{ icon = "order_explore",					text = ReadText(1041, 311) },		-- Explore
		{ icon = "order_exploreupdate",				text = ReadText(1041, 301) },		-- Revisit known stations

		{ icon = "order_miningroutine",				text = ReadText(1041, 561) },		-- Mine Resources

		{ icon = "order_tradeperform",				text = ReadText(1041, 171) },		-- Execute Trade
		{ icon = "order_tradeexchange",				text = ReadText(1041, 121) },		-- Ware Exchange
		{ icon = "order_traderoutine",				text = ReadText(1041, 161) },		-- AutoTrade
		{ icon = "order_player_docktotrade",		text = ReadText(1041, 461) },		-- Dock to Trade
		{ icon = "order_disitributewares",			text = ReadText(1041, 181) },		-- Distribute Wares
		{ icon = "order_crewexchange",				text = ReadText(1041, 681) },		-- Transfer Crew

		{ icon = "order_supplyfleet",				text = ReadText(1041, 641) },		-- Supply Fleet
		{ icon = "order_getsupplies",				text = ReadText(1041, 621) },		-- Get Supplies
		{ icon = "order_resupply",					text = ReadText(1041, 191) },		-- Repair and Resupply
		{ icon = "order_restocksubordinates",		text = ReadText(1041, 201) },		-- Restock Subordinates
		{ icon = "order_recallsubordinates",		text = ReadText(1041, 221) },		-- Recall Subordinates
		{ icon = "order_assigncommander",			text = ReadText(1041, 521) },		-- Assign to new Commander
		{ icon = "order_equip",						text = ReadText(1041, 501) },		-- Change Equipment

		{ icon = "order_collect",					text = ReadText(1041, 481) },		-- Collect
		{ icon = "order_collectdropsinradius",		text = ReadText(1041, 571) },		-- Collect Drops
		{ icon = "order_collectlockbox",			text = ReadText(1041, 661) },		-- Collect Lockbox
		{ icon = "order_deployobjectatposition",	text = ReadText(1041, 471) },		-- Deploy Object At Position
		{ icon = "order_depositinventory",			text = ReadText(1041, 651) },		-- Deposit Inventory
	},

	dropInventoryWidth = 500,
	crewTransferWidth = 600,
	renameWidth = 300,
	changeLogoWidth = 450,
	orderqueueContextWidth = 350,
	tradeLoopWidth = 500,
	venturePatronWidth = 400,
	hireContextWidth = 350,
	ventureTeamContextWidth = 260,
	ventureContactContextWidth = 260,

	orderDragSupport = {
	--	order name					position parameter
		["MoveWait"]				= 1,
		["CollectDropsInRadius"]	= 1,
		["SalvageInRadius"]			= 1,
		["DeployObjectAtPosition"]	= 1,
		["AttackInRange"]			= 1,
		["ProtectPosition"]			= 1,
		["MiningCollect"]			= 1,
		["MiningPlayer"]			= 1,
		["Explore"]					= 2,
		["ExploreUpdate"]			= 2,
	},

	assignments = {
		["defence"]					= { name = ReadText(20208, 40301) },
		["positiondefence"]			= { name = ReadText(20208, 41501) },
		["attack"]					= { name = ReadText(20208, 40901) },
		["interception"]			= { name = ReadText(20208, 41001) },
		["bombardment"]				= { name = ReadText(20208, 41601) },
		["follow"]					= { name = ReadText(20208, 41301) },
		["supplyfleet"]				= { name = ReadText(20208, 40701) },
		["mining"]					= { name = ReadText(20208, 40201) },
		["trade"]					= { name = ReadText(20208, 40101) },
		["tradeforbuildstorage"]	= { name = ReadText(20208, 40801) },
		["assist"]					= { name = ReadText(20208, 41201) },
		["salvage"]					= { name = ReadText(20208, 41401) },
	},

	infoLogbook = {
		category = "all",
		pageSize = 100,
		queryLimit = 1000,
	},

	ventureSeasons = {
		maxDescRows = 12,
	},

	plots = {
		maxPlotRows = 10,
	},
}

__CORE_DETAILMONITOR_MAPFILTER = __CORE_DETAILMONITOR_MAPFILTER or {
	version = config.mapfilterversion,
	["layer_trade"] = true,
	["layer_fight"] = false,
	["layer_think"] = true,
	["layer_build"] = false,
	["layer_diplo"] = false,
	["layer_mining"] = true,
	["layer_other"] = true,
	["trade_storage_container"] = true,
	["trade_storage_solid"] = true,
	["trade_storage_liquid"] = true,
	["trade_storage_condensate"] = true,
	["trade_price_maxprice"] = 0,
	["trade_playeroffer_buy"] = 0,
	["trade_playeroffer_sell"] = 0,
	["trade_offer_number"] = 3,
	["trade_relation_enemy"] = true,
	["trade_volume"] = 0,
	["think_alert"] = 1,
	["think_diplomacy_factioncolor"] = false,
	["think_diplomacy_highlightvisitor"] = true,
	["mining_resource_display"] = true,
	["other_misc_orderqueue"] = true,
	["other_misc_allyorderqueue"] = true,
	["other_misc_missions"] = true,
	["other_misc_ecliptic"] = true,
	["other_misc_civilian"] = true,
	["other_misc_wrecks"] = true,
	["other_misc_selection_lines"] = true,
	["other_misc_opacity"] = false,
	["other_misc_gate_connections"] = false,
	["other_misc_coveroverride"] = false,
	["other_misc_rendersatelliteradarrange"] = true,
}

-- kuertee start:
local callbacks = {}
local distanceTool_from_component
local distanceTool_from_posRot
local distanceTool_to_component
local distanceTool_to_posRot
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	menu.extendedmoduletypes = {}
	menu.extendedsubordinates = {}
	menu.extendeddockedships = {}
	menu.extendedconstruction = {}
	menu.extendedproperty = { ships = true, stations = true }
	menu.extendedorders = {}
	menu.extendedinfo = {}
	menu.infoTablePersistentData = {
		left = {
			crew = { ["object"] = nil, ["capacity"] = 0, ["total"] = 0, ["current"] = { ["total"] = 0, ["roles"] = {} }, ["reassigned"] = { ["total"] = 0, ["roles"] = {} }, ["unassigned"] = { ["total"] = 0, ["persons"] = {} } },
			cashtransferdetails = {},
			macrostolaunch = {},
			drops = {},
			venturelogbook = { curPage = 1, searchtext = "" },
			pastseasons = { curPage = 1, searchtext = "" },
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
			claimedOutcomes = {},
		},
		right = {
			crew = { ["object"] = nil, ["capacity"] = 0, ["total"] = 0, ["current"] = { ["total"] = 0, ["roles"] = {} }, ["reassigned"] = { ["total"] = 0, ["roles"] = {} }, ["unassigned"] = { ["total"] = 0, ["persons"] = {} } },
			cashtransferdetails = {},
			macrostolaunch = {},
			drops = {},
			venturelogbook = { curPage = 1, searchtext = "" },
			pastseasons = { curPage = 1, searchtext = "" },
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
			claimedOutcomes = {},
		},
	}
	menu.holomap = 0

	if __CORE_DETAILMONITOR_MAPFILTER.version < config.mapfilterversion then
		menu.upgradeMapFilterVersion()
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_map.xpl.init - kuertee")
end
-- kuertee end

function menu.createLegend()
	if menu.haslegend then
		return
	end
	menu.haslegend = true

	for i = 1, #config.legend do
		local entry = config.legend[i]
		if entry.station_factory_placeholder then
			local waregroups = {}
			local n = C.GetNumAllWareGroups()
			local buf = ffi.new("WareGroupInfo[?]", n)
			n = C.GetAllWareGroups(buf, n)
			for j = 0, n - 1 do
				if buf[j].tier > 0 then
					table.insert(waregroups, { icon = ffi.string(buf[j].factorymapicon), text = ffi.string(buf[j].factoryname), tier = buf[j].tier })
				end
			end
			table.sort(waregroups, menu.sortWareGroupsByTier)

			for j, group in ipairs(waregroups) do
				if j == 1 then
					config.legend[i] = { icon = group.icon, text = group.text, width = 0.8 * Helper.sidebarWidth, height = 0.8 * Helper.sidebarWidth, color = "friendcolor" }
				else
					table.insert(config.legend, i + j - 1, { icon = group.icon, text = group.text, width = 0.8 * Helper.sidebarWidth, height = 0.8 * Helper.sidebarWidth, color = "friendcolor" })
				end
			end
		end
	end
end

function menu.sortWareGroupsByTier(a, b)
	if a.tier == b.tier then
		return a.text < b.text
	end
	return a.tier > b.tier
end

function menu.cleanup()
	if not menu.minimized then
		if (menu.mode == nil) or (menu.mode == "selectbuildlocation") then
			menu.state = menu.onSaveState()
		end

		UnregisterAddonBindings("ego_detailmonitor")
		menu.arrowsRegistered = nil
		UnregisterEvent("updateHolomap", menu.updateHolomap)
		UnregisterEvent("info_updatePeople", menu.infoUpdatePeople)
		UnregisterEvent("mapfilter", menu.filterUpdate)

		if menu.contextMenuMode == "trade" then
			if C.IsComponentOperational(menu.contextMenuData.currentShip) then
				SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
			end
			if menu.contextMenuData.wareexchange then
				if C.IsComponentOperational(menu.contextMenuData.component) then
					SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), false)
				end
			end
		end
		unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
		end
	end

	if Helper.hasExtension("multiverse") then
		Helper.callExtensionFunction("multiverse", "cleanup", menu)
	end

	if menu.mode == "hire" then
		menu.searchTableMode = nil
	elseif menu.mode == "selectCV" then
		for k, v in pairs(menu.layerBackup) do
			__CORE_DETAILMONITOR_MAPFILTER[k] = v
			if k == "think_diplomacy_highlightvisitor" then
				C.SetConfigSetting("highlightvisitors", v)
			end
		end
	end

	menu.title = nil
	menu.activatemap = nil
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.mode = nil
	menu.modeparam = {}
	menu.createInfoFrameRunning = nil
	menu.createInfoFrame2Running = nil
	menu.createMainFrameRunning = nil
	menu.lastUpdateHolomapTime = nil
	menu.noupdate = nil
	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end
	menu.autopilottarget = nil
	menu.softtarget = nil
	menu.lastactivetable = nil
	menu.focuscomponent = nil
	menu.currentsector = nil
	menu.selectedcomponents = {}
	menu.closemapwithmenu = nil
	menu.oldmode = nil
	menu.oldInfoTableMode = nil
	menu.cachedOrderFailures = {}

	menu.boardingData = {}
	menu.boardingtable_shipselection = {}
	menu.queuecontextrefresh = nil
	menu.contexttoprow = nil
	menu.contextselectedrow = nil

	menu.infoSubmenuObject = nil
	menu.infoTablePersistentData.left.crew.object = nil
	menu.infoTablePersistentData.right.crew.object = nil
	menu.infoTablePersistentData.left.resetcrew = nil
	menu.infoTablePersistentData.right.resetcrew = nil
	menu.infoTablePersistentData.left.cashtransferdetails = {}
	menu.infoTablePersistentData.right.cashtransferdetails = {}
	menu.infoTablePersistentData.left.macrostolaunch = {}
	menu.infoTablePersistentData.right.macrostolaunch = {}
	menu.infoTablePersistentData.left.drops = {}
	menu.infoTablePersistentData.right.drops = {}
	menu.infoTablePersistentData.left.planneddefaultorderloop = nil
	menu.infoTablePersistentData.right.planneddefaultorderloop = nil
	menu.infoTablePersistentData.left.planneddefaultorderiscopy = nil
	menu.infoTablePersistentData.right.planneddefaultorderiscopy = nil
	if menu.infoTablePersistentData.left.orderqueuemode and (menu.infoTablePersistentData.left.orderqueuemode.mode == "plandefaultorder") then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData.left.orderqueuemode.curobject)
	end
	menu.infoTablePersistentData.left.orderqueuemode = nil
	if menu.infoTablePersistentData.right.orderqueuemode and (menu.infoTablePersistentData.right.orderqueuemode.mode == "plandefaultorder") then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData.right.orderqueuemode.curobject)
	end
	menu.infoTablePersistentData.right.orderqueuemode = nil

	menu.plots = {}
	menu.plotDoNotUpdate = nil
	menu.table_plotlist = {}
	menu.plotsliders = {}
	menu.plotbuttons = {}
	menu.plots_initialized = nil
	--menu.setplotrow = nil
	--menu.setplottoprow = nil
	-- do not clean this up to reselect the last selected plot if re-accessing the map. for example, from the station configuration menu.
	--menu.plotData = {}

	menu.missionOfferList = {}
	menu.missionList = {}
	menu.missionDoNotUpdate = nil

	menu.rendertargetWidth = nil
	menu.rendertargetHeight = nil
	menu.editboxHeight = nil
	menu.sideBarWidth = nil

	menu.searchtext = {}
	menu.holomapcolor = {}
	menu.ownerDetails = nil

	menu.buttonline = nil
	menu.orderdefs = {}
	menu.orderdefsbycategory = {}

	menu.turrets = {}
	menu.turretgroups = {}

	menu.mainFrame = nil
	menu.infoFrame = nil
	menu.infoFrame2 = nil
	menu.infoTableData = {}
	menu.contextMenuMode = nil
	menu.contextMenuData = {}
	menu.contextFrame = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	menu.highlightedbordercomponent = nil
	menu.highlightedbordermoduletype = nil
	menu.highlightedplannedmodule = nil
	menu.highlightedbordersection = nil
	menu.highlightedborderstationcategory = nil
	menu.selectedstationcategory = nil
	menu.highlightedconstruction = nil
	menu.selectedconstruction = nil
	menu.selectedfleetcommander = nil

	menu.lock = nil
	menu.leftdown = nil
	menu.rightdown = nil

	menu.panningmap = nil
	menu.rotatingmap = nil
	menu.orderdrag = nil
	menu.intersectordrag = nil

	menu.refreshed = nil
	menu.picking = true
	menu.pickstate = nil

	if menu.map then
		SetMouseOverOverride(menu.map, nil)
	end

	menu.searchField = nil
	menu.sideBar = nil
	selectedShipsTable = nil
	menu.topLevel = nil
	menu.map = nil

	menu.infoTable = nil
	menu.infoTable2 = nil
	menu.infoTable3 = nil
	menu.infoTableRight = nil
	menu.infoTableRight2 = nil
	menu.infoTableRight3 = nil

	menu.contextMenu = nil

	if menu.sound_ambient then
		StopPlayingSound(menu.sound_ambient)
	end
	if menu.sound_panmap then
		StopPlayingSound(menu.sound_panmap)
	end
	if menu.sound_rotatemap and menu.sound_rotatemap.sound then
		StopPlayingSound(menu.sound_rotatemap.sound)
	end
	if menu.sound_zoom then
		StopPlayingSound(menu.sound_zoom)
	end
	menu.sound_ambient = nil
	menu.sound_panmap = nil
	menu.sound_rotatemap = nil
	menu.sound_zoom = nil

	menu.sound_selectedelement = nil

	menu.lastzoom = nil
	menu.zoom_newdir = nil

	menu.clearMouseCursorOverrides()

	C.SetUICoverOverride(false)
	__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false
end

-- Menu member functions

-- button scripts
function menu.updateMapAndInfoFrame()
	if menu.holomap ~= 0 then
		C.ClearSelectedMapComponents(menu.holomap)
	end
	menu.createInfoFrame()
end

function menu.buttonBoardingAddShip()
	-- TODO: implement boarding_selectplayerobject mode and return to boarding menu if object is selected.
	--if not menu.boardingData.contextmenudata then
	--	menu.boardingData.contextmenudata = menu.contextMenuData
	--end
	menu.mode = "boarding_selectplayerobject"
	menu.infoTableMode = "propertyowned"
	menu.boardingData.changed = true
	menu.closeContextMenu()
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.buttonBoardingRemoveShip(shipid)
	menu.boardingData.shipdata[shipid] = nil
	for i, locship in ipairs(menu.contextMenuData.boarders) do
		if locship == shipid then
			table.remove(menu.contextMenuData.boarders, i)
			break
		end
	end
	for i, locship in ipairs(menu.boardingData.ships) do
		if locship == shipid then
			table.remove(menu.boardingData.ships, i)
			break
		end
	end
	if not C.RemoveAttackerFromBoardingOperation(shipid) then
		DebugError("Failed to remove " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. " from boarding operation.")
	end
	menu.boardingData.changed = true
	if #menu.boardingData.ships > 0 then
		menu.refreshContextFrame()
	else
		menu.closeContextMenu()
	end
end

function menu.buttonUpdateBoardingOperation(alreadystarted)
	--print("risk 1 threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold) .. ", risk 2 threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold))
	if not alreadystarted then
		if not C.CreateBoardingOperation(menu.boardingData.target, "player", menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold, menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold) then
			DebugError("Failed to create boarding operation involving target: " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	else
		C.UpdateBoardingOperation(menu.boardingData.target, "player", menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold, menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold)
	end

	for _, shipid in pairs(menu.boardingData.ships) do
		--print("adding " .. ffi.string(C.GetComponentName(shipid)))
		menu.addShipToBoardingOperation(shipid, menu.boardingData.shipdata[shipid])
	end

	if not alreadystarted then
		if not C.StartBoardingOperation(menu.boardingData.target, "player") then
			DebugError("Failed to start boarding operation involving target: " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	end

	-- reset boarding data to retrieve new information from boarding operation.
	menu.boardingData.ships = {}
	menu.boardingData.shipdata = {}
	menu.boardingData.changed = false
	-- in case of emergency, press below.
	--C.AbortBoardingOperation(menu.boardingData.target, "player")
	menu.refreshContextFrame()
end

function menu.buttonExtendModuleType(station, type)
	menu.extendModuleType(station, type)

	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendSubordinate(name, group)
	if menu.isSubordinateExtended(name, group) then
		if menu.extendedsubordinates[name .. group] == false then
			menu.extendedsubordinates[name .. group] = nil
		else
			menu.extendedsubordinates[name .. group] = false
		end
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "subordinates" .. name .. group
	else
		menu.extendedsubordinates[name .. group] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendDockedShips(name, isstation)
	if menu.isDockedShipsExtended(name, isstation) then
		if isstation then
			menu.extendeddockedships[name] = nil
		else
			menu.extendeddockedships[name] = false
		end
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "dockedships"
	else
		menu.extendeddockedships[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendConstruction(name)
	if menu.isConstructionExtended(name) then
		menu.extendedconstruction[name] = nil
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "constructions"
	else
		menu.extendedconstruction[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendProperty(name)
	if menu.isPropertyExtended(name) then
		menu.extendedproperty[name] = nil
		menu.addSelectedComponent(ConvertStringTo64Bit(name), true)
	else
		menu.extendedproperty[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendOrder(controllable, orderidx, instance, row, col)
	menu.extendOrder(controllable, orderidx, instance)
	if instance == "left" then
		menu.refreshInfoFrame(row, col)
	elseif instance == "right" then
		menu.refreshInfoFrame2(row, col)
	end
end

function menu.handlePlannedDefaultOrder(instance, confirmed, callback)
	if ((instance == "left") and (menu.infoTableMode == "info")) or ((instance == "right") and (menu.searchTableMode == "info")) then
		if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			if confirmed then
				C.RemovePlannedDefaultOrder(menu.infoTablePersistentData[instance].orderqueuemode.curobject)
				menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
				menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
				menu.infoTablePersistentData[instance].orderqueuemode = nil

				menu.closeContextMenu()
			else
				menu.contextMenuMode = "userquestion"
				menu.contextMenuData = { mode = "discardplanneddefaultbehaviour", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, callback = callback }

				menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
				return false
			end
		end
	end
	return true
end

function menu.handlePlannedDefaultOrderRendertargetSelect(confirmed)
	if not menu.handlePlannedDefaultOrder("left", confirmed, function () return menu.handlePlannedDefaultOrderRendertargetSelect(true) end) then
		return false
	end
	if not menu.handlePlannedDefaultOrder("right", confirmed, function () return menu.handlePlannedDefaultOrderRendertargetSelect(true) end) then
		return false
	end
	if confirmed then
		if menu.infoTableMode == "info" then
			menu.refreshInfoFrame(nil, 0)
		elseif menu.searchTableMode == "info" then
			menu.refreshInfoFrame2(nil, 0)
		end
	end
	return true
end

function menu.buttonToggleObjectList(objectlistparam, confirmed, override)
	-- kuertee start: callback
	if callbacks ["buttonToggleObjectList_on_start"] then
		for _, callback in ipairs (callbacks ["buttonToggleObjectList_on_start"]) do
			callback (objectlistparam, config)
		end
	end
	-- kuertee end: callback

	local oldidx, newidx
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local count = 1
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.mode then
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.infoTableMode then
							oldidx = count
						end
						if mode == objectlistparam then
							newidx = count
						end
					end
				else
					if entry.mode == menu.infoTableMode then
						oldidx = count
					end
					if entry.mode == objectlistparam then
						newidx = count
					end
				end
			end
			count = count + 1
		end
		if oldidx and newidx then
			break
		end
	end

	if not menu.handlePlannedDefaultOrder("left", confirmed, function () menu.buttonToggleObjectList(objectlistparam, true) end) then
		return
	end

	local deactivate = false
	if override == nil then
		if menu.showMultiverse then
			deactivate = menu.ventureMode == objectlistparam
		else
			deactivate = menu.infoTableMode == objectlistparam
		end
	else
		deactivate = not override
	end

	if newidx then
		Helper.updateButtonColor(menu.sideBar, newidx, 1, Helper.defaultArrowRowBackgroundColor)
	end
	if oldidx then
		Helper.updateButtonColor(menu.sideBar, oldidx, 1, Helper.defaultButtonBackgroundColor)
	end

	menu.createInfoFrameRunning = true
	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureinventory") or (menu.ventureMode == "ventureseason") or (menu.ventureMode == "venturecontacts") then
			Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, menu.ventureMode, objectlistparam)
		end
	else
		if (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
				if Helper.hasExtension("multiverse") then
					Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
					Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureoperation", objectlistparam)
				end
			end
			menu.missionModeCurrent = nil
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
	end
	AddUITriggeredEvent(menu.name, objectlistparam, menu.infoTableMode == objectlistparam and "off" or "on")
	if deactivate then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.topRows.infotableleft = menu.settoprow
		PlaySound("ui_negative_back")
		if menu.showMultiverse then
			menu.ventureMode = nil
		else
			menu.infoTableMode = nil
		end
		if oldidx then
			SelectRow(menu.sideBar, oldidx)
		end
	else
		menu.settoprow = nil
		menu.topRows.infotableleft = nil
		menu.infoTable = nil
		menu.infoTable2 = nil
		PlaySound("ui_positive_select")
		if (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
		if menu.showMultiverse then
			menu.ventureMode = objectlistparam
		else
			menu.infoTableMode = objectlistparam
		end
		if newidx then
			SelectRow(menu.sideBar, newidx)
		end
		if menu.infoTableMode == "plots" then
			menu.updatePlotData("plots_new", true)
			menu.storeCurrentPlots()
			--menu.plotDoNotUpdate = true
			menu.mode = "selectbuildlocation"
			C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
		elseif (menu.mode ~= "selectCV") and (menu.mode ~= "hire") and (menu.mode ~= "orderparam_object") and (menu.mode ~= "selectComponent") then
			menu.plots_initialized = nil
			menu.plotData = {}
			menu.mode = nil
			menu.removeMouseCursorOverride(3)
			if not menu.showMultiverse then
				local mapstate = ffi.new("HoloMapState")
				C.GetMapState(menu.holomap, mapstate)
				local startpos = ffi.new("UIPosRot")
				C.ShowUniverseMap2(menu.holomap, false, false, false, 0, startpos)
				C.SetMapState(menu.holomap, mapstate)
			end
		end
		if menu.infoTableMode == "missionoffer" then
			menu.updateMissionOfferList(true)
		end
		Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
		menu.applyFilterSettings()
	end
	menu.setrow = nil
	menu.setcol = nil
	menu.selectedRows.infotableleft = nil
	menu.selectedCols.infotableleft = nil
	menu.topRows.infotable2 = nil
	menu.selectedRows.infotable2 = nil
	menu.selectedCols.infotable2 = nil
	menu.refreshMainFrame = true
	menu.createInfoFrame()
end

function menu.deactivateObjectList(confirmed)
	local oldidx
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local count = 1
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.mode then
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.infoTableMode then
							oldidx = count
						end
					end
				else
					if entry.mode == menu.infoTableMode then
						oldidx = count
					end
				end
			end
			count = count + 1
		end
		if oldidx then
			break
		end
	end

	if not menu.handlePlannedDefaultOrder("left", confirmed, function () menu.deactivateObjectList(true) end) then
		return
	end

	if oldidx then
		Helper.updateButtonColor(menu.sideBar, oldidx, 1, Helper.defaultButtonBackgroundColor)
	end

	menu.createInfoFrameRunning = true
	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureinventory") or (menu.ventureMode == "ventureseason") or (menu.ventureMode == "venturecontacts") then
			Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, menu.ventureMode, menu.ventureMode)
		end
	else
		if (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
				if Helper.hasExtension("multiverse") then
					Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
					Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureoperation", "ventureoperation")
				end
			end
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
	end
	
	menu.settoprow = GetTopRow(menu.infoTable)
	PlaySound("ui_negative_back")
	if menu.showMultiverse then
		menu.ventureMode = nil
	else
		menu.infoTableMode = nil
	end
	if oldidx then
		SelectRow(menu.sideBar, oldidx)
	end

	menu.refreshMainFrame = true
	menu.createInfoFrame()
end

function menu.deactivateSearchTable()	
	menu.searchTableMode = nil	
	menu.refreshMainFrame = true
end

function menu.buttonToggleRightBar(searchlistmode, confirmed)
	if not menu.handlePlannedDefaultOrder("right", confirmed, function () menu.buttonToggleRightBar(searchlistmode, true) end) then
		return
	end

	AddUITriggeredEvent(menu.name, searchlistmode, menu.searchTableMode == searchlistmode and "off" or menu.displayedFilterLayer)
	if menu.searchTableMode == searchlistmode then
		PlaySound("ui_negative_back")
		menu.searchTableMode = nil
	else
		PlaySound("ui_positive_select")
		menu.searchTableMode = searchlistmode
		menu.disregardFilterTable = true
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame2()
end

function menu.buttonResetView()
	if menu.holomap and (menu.holomap ~= 0) then
		C.ResetMapPlayerRotation(menu.holomap)
		C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
		if menu.infoTableMode == "objectlist" then
			menu.refreshInfoFrame()
		end
	end
end

function menu.buttonNewOrder(orderid, default, instance)
	if orderid then
		if orderid == "TradePerform" then
			Helper.closeMenuForNewConversation(menu, "gTrade_offerselect", ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), { 0, 0, true, ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)) })
			menu.cleanup()
		elseif orderid == "loop" then
			menu.infoTablePersistentData[instance].planneddefaultorderloop = { curobject = menu.infoSubmenuObject }
			menu.closeContextMenu()
			menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
			menu.refreshInfoFrame()
		elseif menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
			C.CreateOrder(menu.infoSubmenuObject, orderid, default)
			local buf = ffi.new("Order")
			if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
				menu.infoTableData[instance].planneddefaultorder.state = ffi.string(buf.state)
				menu.infoTableData[instance].planneddefaultorder.statename = ffi.string(buf.statename)
				menu.infoTableData[instance].planneddefaultorder.orderdef = ffi.string(buf.orderdef)
				menu.infoTableData[instance].planneddefaultorder.actualparams = tonumber(buf.actualparams)
				menu.infoTableData[instance].planneddefaultorder.enabled = buf.enabled
				menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
				menu.infoTablePersistentData[instance].planneddefaultorderloop = nil

				local found = false
				for _, orderdef in ipairs(menu.orderdefs) do
					if (orderdef.id == menu.infoTableData[instance].planneddefaultorder.orderdef) then
						menu.infoTableData[instance].planneddefaultorder.orderdefref = orderdef
						found = true
						break
					end
				end
				if not found then
					DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
				end
			end

			menu.closeContextMenu()
			if default then
				menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
			else
				menu.infoTablePersistentData[instance].selectedorder = { #menu.infoTableData[instance].orders + 1 }
				menu.extendOrder(menu.infoSubmenuObject, #menu.infoTableData[instance].orders + 1, instance)
			end
			menu.refreshInfoFrame()
		else
			DebugError("menu.buttonNewOrder: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
		end
	else
		menu.contextMenuMode = "neworder"
		menu.contextMenuData = { default = default, instance = instance }
		local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
		if instance == "right" then
			offsetx = Helper.viewWidth - offsetx - Helper.scaleX(config.orderqueueContextWidth)
		end
		menu.createContextFrame(Helper.scaleX(config.orderqueueContextWidth), Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
	end
end

function menu.buttonOrderUp(order, instance)
	local oldidx, newidx, enable
	oldidx = order
	if menu.infoTableData[instance].disabledmarker == order then
		newidx = order
		enable = true
	else
		newidx = order - 1
		enable = menu.infoTableData[instance].orders[order].enabled
	end

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.AdjustOrder(menu.infoSubmenuObject, oldidx, newidx, enable, false, false) then
			menu.swapExtendedOrder(menu.infoSubmenuObject, oldidx, newidx, instance)
			menu.resetOrderParamMode()
		end
	else
		DebugError("menu.buttonOrderUp: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonOrderDown(order, instance)
	local oldidx, newidx, enable
	oldidx = order
	if menu.infoTableData[instance].disabledmarker == order + 1 then
		newidx = order
		enable = false
	else
		newidx = order + 1
		enable = menu.infoTableData[instance].orders[order].enabled
	end

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.AdjustOrder(menu.infoSubmenuObject, oldidx, newidx, enable, false, false) then
			menu.swapExtendedOrder(menu.infoSubmenuObject, oldidx, newidx, instance)
			menu.resetOrderParamMode()
		end
	else
		DebugError("menu.buttonOrderDown: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonRemoveOrder(order, instance)
	if menu.removeOrder(order, instance) then
		menu.resetOrderParamMode()
	end
end

function menu.removeOrder(orderidx, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.RemoveOrder(menu.infoSubmenuObject, orderidx, false, false) then
			menu.removeExtendedOrder(menu.infoSubmenuObject, orderidx, instance)
			if orderidx == #menu.infoTableData[instance].orders then
				menu.infoTablePersistentData[instance].selectedorder = (orderidx > 1) and { (orderidx - 1), object = menu.infoSubmenuObject } or nil
			end
			if menu.infoTablePersistentData[instance].selectedorder and (type(menu.infoTablePersistentData[instance].selectedorder[1]) == "number") then
				menu.infoTablePersistentData[instance].selectedorder = { math.min(menu.infoTablePersistentData[instance].selectedorder[1], #menu.infoTableData[instance].orders - 1), object = menu.infoSubmenuObject }
			end
		
			return true
		end
	else
		DebugError("menu.removeOrder: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	return false
end

function menu.buttonStartOrders(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		for i, order in ipairs(menu.infoTableData[instance].orders) do
			if order.state == "disabled" then
				C.EnableOrder(menu.infoSubmenuObject, i)
			end
			if order.state == "setup" then
				break
			end
		end
		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonStartOrders: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonDeleteAllOrders(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		for i = #menu.infoTableData[instance].orders, 1, -1 do
			if C.RemoveOrder(menu.infoSubmenuObject, i, false, false) then
				menu.removeExtendedOrder(menu.infoSubmenuObject, i, instance)
			end
		end
		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonDeleteAllOrders: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonDefaultOrderDiscard(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		C.RemovePlannedDefaultOrder(menu.infoSubmenuObject)
	else
		DebugError("menu.buttonDefaultOrderDiscard: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
	menu.infoTablePersistentData[instance].orderqueuemode = nil
	menu.refreshInfoFrame(0, 0)
end

function menu.buttonDefaultOrderConfirm(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if menu.infoTablePersistentData[instance].planneddefaultorderloop then
			C.RemoveAllOrders(menu.infoSubmenuObject)
			C.CreateOrder(menu.infoSubmenuObject, "Wait", true)
			C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
			C.SetOrderLoop(menu.infoSubmenuObject, 0, false)
		else
			C.ResetOrderLoop(menu.infoSubmenuObject)
			C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
		end
	else
		DebugError("menu.buttonDefaultOrderConfirm: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
	menu.infoTablePersistentData[instance].orderqueuemode = nil
	menu.refreshInfoFrame(0, 0)
end

function menu.buttonSetOrderParam(order, param, index, value, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local paramdata
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		elseif order == "planneddefault" then
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		else
			paramdata = menu.infoTableData[instance].orders[order].params[param]
		end

		local paramtype, oldvalue
		if paramdata.type == "list" then
			paramtype = paramdata.inputparams.type
			if not paramtype then
				DebugError("Order parameter of type 'list' does not specify a input parameter 'type' [Florian]")
			end
			if index then
				oldvalue = paramdata.value[index]
			end
		else
			paramtype = paramdata.type
			oldvalue = paramdata.value
		end

		if paramtype == "bool" then
			SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, not (oldvalue ~= 0))
			menu.refreshInfoFrame()
		elseif paramtype == "object" then
			menu.currentInfoMode = { menu.infoTableMode, menu.infoMode.left }
			menu.infoTableMode = "objectlist"
			menu.mode = "orderparam_object"
			local controllable = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))
			local toprow = 1
			if instance == "left" then
				toprow = GetTopRow(menu.infoTable)
			elseif instance == "right" then
				toprow = GetTopRow(menu.infoTableRight)
			end
			menu.modeparam = { function (value) return menu.setOrderParamFromMode(controllable, order, param, index, value, instance) end, paramdata, toprow, controllable, order, param }

			if type(menu.modeparam[5]) == "string" then
				C.SetMapDefaultOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
			else
				C.SetMapOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
			end

			local orderdefid
			if order == "default" then
				orderdefid = menu.infoTableData[instance].defaultorder.orderdefref.id
			elseif order == "planneddefault" then
				orderdefid = menu.infoTableData[instance].planneddefaultorder.orderdefref.id
			else
				orderdefid = menu.infoTableData[instance].orders[order].orderdefref.id
			end
			if (orderdefid == "Attack") then
				menu.setMouseCursorOverride("targetred", 3)
			else
				menu.setMouseCursorOverride("target", 3)
			end

			menu.settoprow = 0

			menu.closeContextMenu()
			menu.refreshInfoFrame()
			menu.refreshMainFrame = true
		elseif paramtype == "sector" then
			if value then
				local object64 = ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))
				if (paramdata.type == "list") and (type(value) == "table") then
					local skip = true

					local sorted = {}
					for sector in pairs(value) do
						table.insert(sorted, ConvertStringTo64Bit(sector))
					end
					-- we want to re-add the complete list to keep it alphabetical
					if not paramdata.value then
						-- no values yet, we need to set
						skip = false
					else
						if #paramdata.value ~= #sorted then
							-- number is not the same, we need to set
							skip = false
						else
							for _, sector in ipairs(paramdata.value) do
								if not value[tostring(sector)] then
									-- exisiting value not in new list, we need to set
									skip = false
									break
								end
							end
							-- if skip is still true here, all existing values are in the new list and previous check excludes the case of only new entries added, nothing to do
						end
						if not skip then
							-- remove all old
							for listidx = #paramdata.value, 1, -1 do
								RemoveOrderListParam(object64, order, param, listidx)
							end
						end
					end
					if not skip then
						-- add all new
						table.sort(sorted, Helper.sortComponentName)
						for _, sector in ipairs(sorted) do
							SetOrderParam(object64, order, param, nil, ConvertStringToLuaID(tostring(sector)))
						end
					end
				else
					SetOrderParam(object64, order, param, index, ConvertStringToLuaID(tostring(value)))
				end
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_sector"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		elseif paramtype == "ware" then
			if value then
				local object64 = ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))
				if (paramdata.type == "list") and (type(value) == "table") then
					local skip = true

					local sorted = {}
					for ware in pairs(value) do
						table.insert(sorted, ware)
					end
					-- we want to re-add the complete list to keep it alphabetical
					if not paramdata.value then
						-- no values yet, we need to set
						skip = false
					else
						if #paramdata.value ~= #sorted then
							-- number is not the same, we need to set
							skip = false
						else
							for _, ware in ipairs(paramdata.value) do
								if not value[ware] then
									-- exisiting value not in new list, we need to set
									skip = false
									break
								end
							end
							-- if skip is still true here, all existing values are in the new list and previous check excludes the case of only new entries added, nothing to do
						end
						if not skip then
							-- remove all old
							for listidx = #paramdata.value, 1, -1 do
								RemoveOrderListParam(object64, order, param, listidx)
							end
						end
					end
					if not skip then
						-- add all new
						table.sort(sorted, Helper.sortWareName)
						for _, ware in ipairs(sorted) do
							SetOrderParam(object64, order, param, nil, ware)
						end
					end
				else
					SetOrderParam(object64, order, param, index, value)
				end
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_ware"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		elseif paramtype == "macro" then
			-- TODO
		elseif paramtype == "position" then
			menu.currentInfoMode = { menu.infoTableMode, menu.infoMode.left }
			menu.mode = "orderparam_position"
			local controllable = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))
			local toprow = 1
			if instance == "left" then
				toprow = GetTopRow(menu.infoTable)
			elseif instance == "right" then
				toprow = GetTopRow(menu.infoTableRight)
			end
			menu.modeparam = { function (value) return menu.setOrderParamFromMode(controllable, order, param, index, value, instance) end, paramdata, toprow, controllable }

			menu.setMouseCursorOverride("target", 3)

			menu.settoprow = 0
			menu.closeContextMenu()
			menu.refreshInfoFrame()
		elseif paramtype == "formationshape" then
			if value then
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_formationshape"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		else
			DebugError("Unsupported order parameter type '" .. tostring(paramtype) .. "' [Florian]")
		end
	else
		DebugError("menu.buttonSetOrderParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.slidercellSetOrderParam(order, param, index, value, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local paramdata
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		elseif order == "planneddefault" then
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		else
			paramdata = menu.infoTableData[instance].orders[order].params[param]
		end

		local type, oldvalue
		if paramdata.type == "list" then
			type = paramdata.inputparams.type
			if not type then
				DebugError("Order parameter of type 'list' does not specify a input parameter 'type' [Florian]")
			end
			if index then
				oldvalue = paramdata.value[index]
			end
		else
			type = paramdata.type
			oldvalue = paramdata.value
		end

		if type == "number" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
			end
		elseif type == "length" then
			if value then
				menu.noupdate = true
				if paramdata.inputparams.step >= 1000 then
					value = value * 1000
				end
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
			end
		elseif type == "time" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value * 60)
			end
		elseif type == "money" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value * 100)
			end
		end
	else
		DebugError("menu.slidercellSetOrderParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
	menu.noupdate = false
	menu.refreshInfoFrame()
end

function menu.buttonRemoveListParam(order, param, index, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
		end

		RemoveOrderListParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index)

		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonRemoveListParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonNewPlot()
	--print("x: " .. tostring(menu.plotData.size.x) .. ", y: " .. tostring(menu.plotData.size.y) .. ", z: " .. tostring(menu.plotData.size.z))
	menu.plotData.active = true
	C.ChangeMapBuildPlot(menu.holomap, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
end

function menu.buttonRemovePlot(station)
	if not station then
		DebugError("menu.buttonRemovePlot called with no station set. station: " .. tostring(station))
		return
	end

	local newselection = nil
	if menu.plotData.component == station then
		newselection = "plots_new"
	end
	local breaknext = nil
	for i, plot in ipairs(menu.plots) do
		if station == plot.station then
			if C.RemoveBuildPlot(station) then
				plot.removed = true
				breaknext = true
			end
		elseif breaknext then
			if newselection then
				newselection = plot.station
			end
			break
		end
	end

	if newselection then
		menu.updatePlotData(newselection, true)
	end
	menu.refreshInfoFrame()
end

function menu.buttonToggleMultiverseMap()
	if (not C.AreVenturesCompatible()) or ((not C.IsVentureSeasonSupported()) and (not C.WasSessionOnline())) then
		return
	end

	menu.closeContextMenu()
	if menu.showMultiverse then
		menu.showMultiverse = false
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
		end

		menu.mode = nil
		menu.removeMouseCursorOverride(3)

		local startpos = ffi.new("UIPosRot")
		C.ShowUniverseMap2(menu.holomap, false, false, false, 0, startpos)

		if menu.normalmapstate then
			C.SetMapState(menu.holomap, menu.normalmapstate)
			menu.normalmapstate = nil
		end
	else
		menu.showMultiverse = true
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
		end

		menu.mode = nil
		menu.plots_initialized = nil
		menu.plotData = {}
		menu.seasonMode.left = "currentseason"
		menu.removeMouseCursorOverride(3)

		Helper.callExtensionFunction("multiverse", "getVentures")
		Helper.updateVenturePlatforms()

		menu.normalmapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, menu.normalmapstate)

		C.ShowMultiverseMap(menu.holomap)

		local isonline = Helper.isOnlineGame()
		local operationRewardPending = Helper.hasVentureRewards()
		if C.IsVentureSeasonSupported() and (not isonline) then
			menu.contextMenuMode = "onlinemode"
			menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight }
			menu.createContextFrame(nil, nil, nil, nil, 0)
		elseif operationRewardPending then
			menu.contextMenuMode = "onlinereward"
			menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, rewardentries = OnlineGetLogbookRewards() }
			menu.createContextFrame(nil, nil, nil, nil, 0)
		end
	end
	AddUITriggeredEvent(menu.name, "venture_map", menu.showMultiverse)
	menu.refreshMainFrame = true
	menu.selectedRows.propertytabs = 1
	menu.selectedCols.propertytabs = 1
	menu.refreshInfoFrame(0, 0)
	Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
	menu.applyFilterSettings()
end

function menu.buttonConvertVentureSave()
	SaveOnlineGame()

	menu.closeContextMenu()
end

function menu.buttonConfirmConvertVentureSave()
	menu.contextMenuMode = "onlinemode"
	menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, confirmoverwrite = true }
	menu.createContextFrame(nil, nil, nil, nil, 0)
end

function menu.editboxInfoLogbookPageActivated(widget, instance)
	menu.noupdate = true
	if menu.logbookPageEditBox and (widget == menu.logbookPageEditBox.id) then
		C.SetEditBoxText(menu.logbookPageEditBox.id, tostring(menu.infoTablePersistentData[instance].logbookData.curPage))
	end
end

function menu.editboxInfoLogbookPage(instance, text, textchanged)
	local logbookdata = menu.infoTablePersistentData[instance].logbookData
	local newpage = tonumber(text)
	if newpage and (newpage ~= logbookdata.curPage) then
		logbookdata.curPage = math.max(1, math.min(newpage, logbookdata.numPages))
		menu.refreshInfoFrame()
	else
		C.SetEditBoxText(menu.logbookPageEditBox.id, logbookdata.curPage .. " / " .. logbookdata.numPages)
	end
	menu.noupdate = false
end

function menu.orderMoveWait(component, sector, offset, playerprecise, clear)
	if not C.IsOrderSelectableFor("MoveWait", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "MoveWait", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
		if playerprecise then
			SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 5, nil, true)
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.selectCV(component)
	local convertedComponent = ConvertStringTo64Bit(tostring(component))
	local isplayerowned, isenemy = GetComponentData(convertedComponent, "isplayerowned", "isenemy")
	if (not C.IsBuilderBusy(component)) and (not isenemy) then
		if not isplayerowned then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney >= fee then
				TransferPlayerMoneyTo(fee, convertedComponent)
			else
				return
			end
		end

		menu.orderDeployToStation(component, ConvertIDTo64Bit(menu.modeparam[1]), true)

		Helper.closeMenu(menu, "back")
		menu.cleanup()
	end
end

function menu.orderDeployToStation(component, station, clear)
	if not C.IsOrderSelectableFor("DeployToStation", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateDeployToStationOrder(component)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(station)))
		C.EnableOrder(component, orderidx)
	end
end

function menu.orderAttack(component, target, clear)
	if not C.IsOrderSelectableFor("Attack", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderAttackMultiple(component, maintarget, secondarytargets, clear)
	if not C.IsOrderSelectableFor("Attack", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(maintarget)))
		for _, secondarytarget in ipairs(secondarytargets) do
			SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 2, nil, ConvertStringToLuaID(tostring(secondarytarget)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectDeployables(component, deployables, clear)
	if not C.IsOrderSelectableFor("CollectDeployables", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDeployables", false)
	if orderidx > 0 then
		for _, deployable in ipairs(deployables) do
			SetOrderParam(ConvertStringTo64Bit(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(deployable)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.buttonContextTrade(wareexchange)
	menu.contextMenuMode = "trade"
	menu.contextMenuData = { component = menu.contextMenuData.component, currentShip = menu.contextMenuData.currentShip, shadyOnly = menu.contextMenuData.shadyOnly, orders = {}, xoffset = menu.contextMenuData.xoffset, yoffset = menu.contextMenuData.yoffset, wareexchange = wareexchange }

	local numwarerows, numinforows = menu.initTradeContextData()
	menu.updateTradeContextDimensions(numwarerows, numinforows)

	if menu.contextMenuData.xoffset + menu.tradeContext.width > Helper.viewWidth - Helper.frameBorder then
		menu.contextMenuData.xoffset = Helper.viewWidth - menu.tradeContext.width - Helper.frameBorder
	end
	local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize
	if menu.contextMenuData.yoffset + height > Helper.viewHeight - Helper.frameBorder then
		menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
	end

	menu.createContextFrame(menu.tradeContext.width, height, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonContextTradeLoop()
	menu.contextMenuMode = "tradeloop"
	menu.contextMenuData = { component = ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), currentShip = menu.contextMenuData.currentShip, orders = {}, xoffset = menu.contextMenuData.xoffset, yoffset = menu.contextMenuData.yoffset, loop = menu.contextMenuData.loop, reservecargo = true }

	menu.createContextFrame(config.tradeLoopWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonContextResearch()
	Helper.closeMenuAndOpenNewMenu(menu, "ResearchMenu", {0, 0}, true)
	menu.cleanup()
end

function menu.buttonConfirmTrade()
	-- Station buys first
	for id, amount in pairs(menu.contextMenuData.orders) do
		if amount > 0 then
			AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), amount, menu.contextMenuData.immediate)
		end
	end
	-- Station sells
	for id, amount in pairs(menu.contextMenuData.orders) do
		if amount < 0 then
			AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), -amount, menu.contextMenuData.immediate)
		end
	end
	if menu.contextMenuData.immediate then
		SignalObject(ConvertStringTo64Bit(tostring(C.GetPlayerID())), "docked_player_trade_added", ConvertStringToLuaID(tostring(menu.contextMenuData.immediateObject)))
	end
	menu.closeContextMenu("back")
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.buttonConfirmTradeLoop()
	local volume = GetWareData(menu.contextMenuData.ware, "volume")

	local orderidx = C.CreateOrder(menu.contextMenuData.currentShip, menu.contextMenuData.loop, false)
	if orderidx > 0 then
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 1, nil, menu.contextMenuData.ware)
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 4, nil, ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 5, nil, (menu.contextMenuData.amount or ((menu.contextMenuData.loop == "SingleBuy") and menu.contextMenuData.max or 0)))
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 7, nil, (menu.contextMenuData.price or GetWareData(menu.contextMenuData.ware, "avgprice")) * 100)
		C.EnableOrder(menu.contextMenuData.currentShip, orderidx)
	end

	menu.closeContextMenu("back")
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.buttonCancelTrade()
	menu.closeContextMenu("back")
end

function menu.buttonDockToTrade()
	local ship = menu.contextMenuData.currentShip
	local container = menu.contextMenuData.component
	if not C.IsOrderSelectableFor("Player_DockToTrade", ship) then
		return
	end
	local orderidx = C.CreateOrder(ship, "Player_DockToTrade", false)
	if orderidx > 0 then
		SetOrderParam(ship, orderidx, 1, nil, ConvertStringToLuaID(tostring(container)))
		C.EnableOrder(ship, orderidx)
	end

	menu.closeContextMenu("back")
end

function menu.buttonMissionAbort()
	C.AbortMission(menu.contextMenuData.missionid)
	menu.closeContextMenu()
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionBriefing()
	local missionid
	if menu.contextMenuData.threadMissionID ~= 0 then
		missionid = menu.contextMenuData.threadMissionID
	else
		missionid = menu.contextMenuData.missionid
	end
	menu.closeContextMenu()
	Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), false })
	menu.cleanup()
end

function menu.buttonMissionActivate()
	local active = menu.contextMenuData.missionid == C.GetActiveMissionID()
	for _, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
		if submissionEntry.active then
			active = true
		end
	end
	if active then
		C.SetActiveMission(0)
	else
		C.SetActiveMission(menu.contextMenuData.missionid)
		PlaySound("ui_mission_set_active")

		-- kuertee start: callback
		if callbacks ["buttonMissionActivate_on_activate"] then
			-- get active mission first, because the clicked item may have been a group
			local activeMissionId
			local numMissions = GetNumMissions ()
			for i = 1, numMissions do
				local entry = mapMenu.getMissionInfoHelper (i)
				if entry.active then
					activeMissionId = entry.ID
				end
			end
			for _, callback in ipairs (callbacks ["buttonMissionActivate_on_activate"]) do
				-- callback (menu.contextMenuData.missionid)
				callback (activeMissionId)
			end
		end
		-- kuertee end: callback

	end
	menu.closeContextMenu()
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionDeliverWares()
	SignalObject(ConvertStringTo64Bit(tostring(menu.contextMenuData.deliveryWares.target)), "ware_mission_delivery", ConvertStringToLuaID(tostring(menu.contextMenuData.missionid)))
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionOfferBriefing()
	local offerid = menu.contextMenuData.missionid
	menu.closeContextMenu()
	Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, offerid, true })
	menu.cleanup()
end

function menu.buttonMissionOfferAccept()
	local offerid = menu.contextMenuData.missionid
	local offeractor = menu.contextMenuData.offeractor
	local onlinechapter = menu.contextMenuData.onlinechapter
	menu.closeContextMenu()

	if onlinechapter ~= "" then
		if C.HasAcceptedOnlineMission() then
			if #menu.missionList["coalition"] > 0 then
				C.AbortMission(ConvertStringTo64Bit(menu.missionList["coalition"][1].ID))
			else
				DebugError("menu.buttonMissionOfferAccept(): Could not find accepted online mission. Aborting.")
				return
			end
		end
	end
	SignalObject(offeractor, "accept", ConvertStringToLuaID(tostring(offerid)))

	if menu.missionOfferList then
		local found = false
		for i, entry in ipairs(menu.missionOfferList["plot"] or {}) do
			if ConvertStringTo64Bit(entry.ID) == offerid then
				found = true
				entry.accepted = true
				menu.highlightLeftBar["mission"] = true
				menu.refreshMainFrame = true
				break
			end
		end
		if not found then
			for _, data in ipairs(menu.missionOfferList["guild"] or {}) do
				for _, entry in ipairs(data.missions) do
					if ConvertStringTo64Bit(entry.ID) == offerid then
						found = true
						entry.accepted = true
						menu.highlightLeftBar["mission"] = true
						menu.refreshMainFrame = true
						break
					end
				end
				if found then
					break
				end
			end
		end
		if not found then
			for i, entry in ipairs(menu.missionOfferList["other"] or {}) do
				if ConvertStringTo64Bit(entry.ID) == offerid then
					found = true
					entry.accepted = true
					menu.highlightLeftBar["mission"] = true
					menu.refreshMainFrame = true
					break
				end
			end
		end
	end
	menu.refreshIF = getElapsedTime()
	if onlinechapter ~= "" then
		menu.refreshMissionContext = { id = offerid, time = menu.refreshIF + 0.1 }
	end
end

function menu.buttonSellShips()
	TransferMoneyToPlayer(menu.contextMenuData.totalprice, menu.contextMenuData.shipyard, "sellship") -- add eventtype
	for i, data in ipairs(menu.contextMenuData.ships) do
		if #data[2] == 0 then
			C.SellPlayerShip(data[1], menu.contextMenuData.shipyard)
		end
	end
	menu.closeContextMenu()
end

function menu.buttonInfoSubMode(mode, col, instance, confirmed)
	if mode ~= menu.infoMode[instance] then
		if (menu.infoMode[instance] == "orderqueue") or (menu.infoMode[instance] == "orderqueue_advanced") then
			if (mode ~= "orderqueue") and (mode ~= "orderqueue_advanced") then
				if not menu.handlePlannedDefaultOrder(instance, confirmed, function () menu.buttonInfoSubMode(mode, col, instance, true) end) then
					return
				end
			end
		end

		menu.infoMode[instance] = mode

		AddUITriggeredEvent(menu.name, menu.infoMode[instance])

		menu.selectedRows["orderHeaderTable" .. instance] = 1
		menu.selectedCols["orderHeaderTable" .. instance] = col
		menu.settoprow = 1
		if instance == "left" then
			menu.refreshInfoFrame(1, 0)
		elseif instance == "right" then
			menu.refreshInfoFrame2(1, 0)
		end
	end
end

function menu.buttonObjectSubMode(mode, col)
	if mode ~= menu.objectMode then
		menu.objectMode = mode

		AddUITriggeredEvent(menu.name, menu.objectMode)

		menu.selectedRows.propertytabs = 1
		menu.selectedCols.propertytabs = col
		menu.refreshInfoFrame(1, col)
	end
end

function menu.buttonPropertySubMode(mode, col)
	if mode ~= menu.propertyMode then
		menu.propertyMode = mode

		AddUITriggeredEvent(menu.name, menu.propertyMode)

		menu.selectedRows.propertytabs = 1
		menu.selectedCols.propertytabs = col
		menu.refreshInfoFrame(1, col)
	end
end

function menu.buttonMissionSubMode(mode, col)
	if mode ~= menu.missionMode then
		menu.closeContextMenu()
		menu.missionMode = mode
		menu.updateMissions()

		AddUITriggeredEvent(menu.name, menu.missionMode)

		menu.missionModeCurrent = "tabs"
		menu.refreshInfoFrame(0, 0)
	end
end

function menu.buttonMissionOfferSubMode(mode, col)
	if mode ~= menu.missionOfferMode then
		menu.closeContextMenu()
		menu.missionOfferMode = mode
		if menu.missionOfferMode ~= "operation" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
			end
		end
		menu.updateMissionOfferList(true)

		AddUITriggeredEvent(menu.name, menu.missionOfferMode)

		menu.missionModeCurrent = "tabs"
		menu.refreshInfoFrame(0, 0)
	end
end

function menu.buttonVentureSeasonSubMode(mode, col, instance)
	if mode ~= menu.seasonMode[instance] then
		menu.seasonMode[instance] = mode

		AddUITriggeredEvent(menu.name, menu.seasonMode[instance])

		menu.selectedRows["ventureSeasonHeaderTable" .. instance] = 1
		menu.selectedCols["ventureSeasonHeaderTable" .. instance] = col
		menu.settoprow = 1
		if instance == "left" then
			menu.refreshInfoFrame(1, 0, 1, 0)
		elseif instance == "right" then
			menu.refreshInfoFrame2(1, 0, 1, 0)
		end
	end
end

function menu.buttonExpandMissionGroup(id, row, contextCallback)
	menu.missionModeCurrent = id
	if menu.expandedMissionGroups[id] then
		menu.expandedMissionGroups[id] = false
	else
		menu.expandedMissionGroups[id] = true
	end
	menu.setrow = row
	menu.closeContextMenu()
	if contextCallback then
		contextCallback()
	end
	menu.refreshInfoFrame()
end

function menu.onMissionOfferRemoved(event, id)
	if id == menu.contextMenuData.missionid then
		menu.contextMenuData.expired = true

		Helper.removeButtonScripts(menu, menu.contextbottomtable, menu.contextMenuData.bottomLines, 1)
		SetCellContent(menu.contextbottomtable, Helper.createButton(Helper.createTextInfo(ReadText(1001, 6402), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight), menu.contextMenuData.bottomLines, 1)
		Helper.removeButtonScripts(menu, menu.contextbottomtable, menu.contextMenuData.bottomLines, 2)
		SetCellContent(menu.contextbottomtable, Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight), menu.contextMenuData.bottomLines, 2)
	end
end

function menu.onMissionRemoved(event, id)
	if id == menu.contextMenuData.missionid then
		menu.contextMenuData.expired = true

		Helper.removeButtonScripts(menu, menu.contextbottomtable, menu.contextMenuData.bottomLines - 1, 1)
		SetCellContent(menu.contextbottomtable, Helper.createButton(Helper.createTextInfo(ReadText(1001, 6403), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight), menu.contextMenuData.bottomLines - 1, 1)
		Helper.removeButtonScripts(menu, menu.contextbottomtable, menu.contextMenuData.bottomLines - 1, 2)
		SetCellContent(menu.contextbottomtable, Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight), menu.contextMenuData.bottomLines - 1, 2)

		Helper.removeButtonScripts(menu, menu.contextbottomtable, menu.contextMenuData.bottomLines, 1)
		SetCellContent(menu.contextbottomtable, Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight), menu.contextMenuData.bottomLines, 1)
	end
end

function menu.buttonSelectSector()
	if menu.checkForOrderParamObject(menu.currentsector) then
		menu.modeparam[1](ConvertStringToLuaID(tostring(menu.currentsector)))
	end
end

function menu.buttonRemoveOrderSyncPoint(orderidx, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local order = menu.infoTableData[instance].orders[orderidx]

		C.RemoveOrderSyncPointID(menu.infoSubmenuObject, orderidx)
		if instance == "left" then
			menu.refreshInfoFrame()
		elseif instance == "right" then
			menu.refreshInfoFrame2()
		end
	else
		DebugError("menu.buttonRemoveOrderSyncPoint: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonSetFilterLayer(mode, row, col)
	__CORE_DETAILMONITOR_MAPFILTER[mode] = not __CORE_DETAILMONITOR_MAPFILTER[mode]
	AddUITriggeredEvent(menu.name, mode .. "_toggle", __CORE_DETAILMONITOR_MAPFILTER[mode] and "true" or "false")
	menu.applyFilterSettings()
	menu.refreshMainFrame = true
end

function menu.filterUpdate(_, params)
	local setting, value = string.match(params, "(.+);(.+)")

	if value == "true" then
		value = true
	elseif value == "false" then
		value = false
	else
		value = tonumber(value) or 0
	end
	__CORE_DETAILMONITOR_MAPFILTER[setting] = value
	menu.refreshFilterSettings = true
end

function menu.buttonFilterSwitch(mode, row, col)
	if menu.displayedFilterLayer ~= mode then
		menu.displayedFilterLayer = mode

		AddUITriggeredEvent(menu.name, menu.displayedFilterLayer)

		menu.refreshMainFrame = true
	end
end

function menu.buttonWeaponConfig(component, orderidx, usedefault, instance)
	menu.contextMenuMode = "weaponconfig"
	menu.contextMenuData = { component = component, orderidx = orderidx, usedefault = usedefault, weaponsystems = {}, instance = instance }

	local n = C.GetNumAllowedWeaponSystems()
	local buf = ffi.new("WeaponSystemInfo[?]", n)
	n = C.GetAllowedWeaponSystems(buf, n, ConvertIDTo64Bit(component), menu.contextMenuData.orderidx or 0, menu.contextMenuData.usedefault)
	for i = 0, n - 1 do
		table.insert(menu.contextMenuData.weaponsystems, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), active = buf[i].active })
	end
	if not menu.contextMenuData.usedefault then
		for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
			if entry.id == "default" then
				menu.contextMenuData.default = entry.active
			end
		end
	end
	
	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
	if instance == "right" then
		offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
	end
	menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
end

function menu.buttonClearWeaponConfig()
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		menu.contextMenuData.weaponsystems[i].active = false
	end
	menu.createContextFrame()
end

function menu.buttonCancelWeaponConfig()
	menu.closeContextMenu()
end

function menu.buttonConfirmWeaponConfig()
	local weaponsystems = ffi.new("WeaponSystemInfo[?]", #menu.contextMenuData.weaponsystems)
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		weaponsystems[i - 1].id = Helper.ffiNewString(entry.id)
		weaponsystems[i - 1].active = entry.active
	end
	C.SetAllowedWeaponSystems(menu.contextMenuData.component, menu.contextMenuData.orderidx or 0, menu.contextMenuData.usedefault, weaponsystems, #menu.contextMenuData.weaponsystems)
	menu.closeContextMenu()
end

function menu.buttonHire()
	local playerMoney = GetPlayerMoney()	
	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0
	local fee
	if ishiring and npc then
		fee = GetNPCBlackboard(npc, "$HiringFee")
	else
		fee = 0
	end
	if fee then
		fee = RoundTotalTradePrice(fee) * menu.hiringdiscounts.totalfactor
	else
		DebugError("menu.buttonHire(): Could not find hiring fee. [Florian]")
		fee = 0
	end

	if (not ishiring) or (playerMoney >= fee) then
		C.ClearMapObjectFilter(menu.holomap)
		if ishiring then
			TransferPlayerMoneyTo(fee, GetContextByClass(npc or object, "container", true))
		end
		if menu.contextMenuData.hireIsMission then
			if npc then
				SignalObject(ConvertStringTo64Bit(tostring(menu.contextMenuData.hireObject)), "npc_mission_delivery", ConvertStringToLuaID(menu.contextMenuData.hireRole), ConvertStringToLuaID(tostring(npc)))
				menu.closeContextMenu()
				menu.onCloseElement("close")
			else
				C.SignalObjectWithNPCSeedAndMissionID(menu.contextMenuData.hireObject, "npctemplate_mission_delivery", ConvertStringTo64Bit(menu.contextMenuData.hireRole), npcseed, object)
				menu.closeContextMenu()
				menu.onCloseElement("back")
			end
		elseif menu.modeparam[1] == "signal" then
			-- actor must be either entity or person (controllable and seed)
			local actor = { entity = npc, personcontrollable = object, personseed = npcseed }
			C.AssignHiredActor(actor, menu.contextMenuData.hireObject, menu.contextMenuData.hireIsPost and menu.contextMenuData.hireRole or nil, not menu.contextMenuData.hireIsPost and menu.contextMenuData.hireRole or nil, false)
			menu.closeContextMenu()
			menu.onCloseElement("back")
		else
			Helper.closeMenuForSection(menu, menu.modeparam[1], { ConvertStringToLuaID(tostring(menu.contextMenuData.hireObject)), menu.contextMenuData.hireRole, menu.contextMenuData.hireIsPost })
			menu.cleanup()
		end
	else
		menu.closeContextMenu()
		menu.refreshMainFrame = true
	end
end

function menu.buttonSelectHandler()
	if menu.mode == "selectCV" then
		menu.selectCV(menu.contextMenuData.component)
	elseif menu.mode == "orderparam_object" then
		if menu.checkForOrderParamObject(menu.contextMenuData.component) then
			menu.modeparam[1](ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
		end
	elseif menu.mode == "selectComponent" then

		-- kuertee start: callback
		if menu.modeparam[6] ~= nil then
			-- if selectComponent returnsection is nil, then do a AddUITriggeredEvent instead
			-- DebugError ("kuertee_menu_map.ui.buttonSelectHandler menu.contextMenuData.component " .. tostring (menu.contextMenuData.component))
			-- DebugError ("kuertee_menu_map.ui.buttonSelectHandler menu.contextMenuData.component " .. tostring (ConvertStringToLuaID (tostring (menu.contextMenuData.component))))
			AddUITriggeredEvent (menu.modeparam[6], "select_component", ConvertStringToLuaID (tostring (menu.contextMenuData.component)))
			menu.mode = menu.old_mode
			menu.modeparam = menu.old_modeparam
			menu.infoTableMode = menu.old_infoTableMode
			menu.closeContextMenu()
			menu.refreshMainFrame = true
			menu.refreshInfoFrame()
			return

			-- DebugError ("kuertee_menu_map buttonSelectHandler menu.modeparam [1]: " .. tostring (menu.modeparam [1]))
			-- if menu.checkForSelectComponent(menu.contextMenuData.component) then
		elseif menu.checkForSelectComponent(menu.contextMenuData.component) then
			-- kuertee end: callback

			C.ClearMapObjectFilter(menu.holomap)
			Helper.closeMenuForSection(menu, menu.modeparam[1], { ConvertStringToLuaID(tostring(menu.contextMenuData.component)) })
			menu.cleanup()
		end
	end
	menu.closeContextMenu()
end

function menu.buttonRemoveAssignment()
	if C.RemoveCommander2(menu.infoSubmenuObject) then
		C.CreateOrder(menu.infoSubmenuObject, "Wait", true)
		C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
	end

	menu.refreshInfoFrame()
end

function menu.plotModeUpdateValue(dimension, valchange)
	local axis = "x"
	local bigaxis = "X"
	if dimension == "posY" or dimension == "negY" then
		axis = "y"
		bigaxis = "Y"
	elseif dimension == "posZ" or dimension == "negZ" then
		axis = "z"
		bigaxis = "Z"
	end
	menu.plotData.size[axis] = menu.plotData.dimensions["pos" .. bigaxis] + menu.plotData.dimensions["neg" .. bigaxis]
	menu.plotModeUpdatePrice()
	menu.updatePlotSize(dimension, axis, valchange)
end

function menu.plotModeUpdatePrice()
	if not menu.plotData.price then
		return
	end
	--print("size.x: " .. tostring(menu.plotData.size.x * 1000) .. ", boughtrawsize.x: " .. tostring(menu.plotData.boughtrawsize.x) .. ". size.y: " .. tostring(menu.plotData.size.y * 1000) .. ", boughtrawsize.y: " .. tostring(menu.plotData.boughtrawsize.y) .. ". size.z: " .. tostring(menu.plotData.size.z * 1000) .. ", boughtrawsize.z: " .. tostring(menu.plotData.boughtrawsize.z))
	local numchanged = 3
	local x = menu.plotData.size.x * 1000
	if x == menu.plotData.boughtrawsize.x then
		numchanged = numchanged - 1
	end
	local y = menu.plotData.size.y * 1000
	if y == menu.plotData.boughtrawsize.y then
		numchanged = numchanged - 1
	end
	local z = menu.plotData.size.z * 1000
	if z == menu.plotData.boughtrawsize.z then
		numchanged = numchanged - 1
	end

	local owner = GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.component)), "owner")
	local buf = ffi.new("bool[1]", 0)
	local plotpayment = tonumber(C.GetBuildPlotPayment(menu.plotData.component, buf))
	local haspositionchanged = buf[0]
	menu.plotData.price = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, x, y, z, owner)) - plotpayment
	menu.plotData.affordable = GetPlayerMoney() >= menu.plotData.price

	menu.plotData.fullypaid = menu.plotData.price <= 0
end

function menu.buttonBuyPlot()
	local station = menu.plotData.component
	local size = { x = menu.plotData.size.x * 1000, y = menu.plotData.size.y * 1000, z = menu.plotData.size.z * 1000 }
	if not menu.plotData.price or GetPlayerMoney() < menu.plotData.price then
		DebugError("menu.buttonBuyPlot() called but there is no price or the player cannot afford the plot. price: " .. tostring(menu.plotData.price) .. ", player cash: " .. tostring(GetPlayerMoney()))
		return
	end
	local offset = C.GetBuildPlotCenterOffset(station)
	for _, plot in ipairs(menu.plots) do
		if plot.station == station then
			plot.boughtrawcenteroffset = offset
			break
		end
	end
	local controlstation = C.GetSectorControlStation(menu.plotData.sector)
	TransferPlayerMoneyTo(menu.plotData.price, ConvertStringTo64Bit(tostring(controlstation)))
	C.PayBuildPlotSize(station, size, offset)
	menu.updatePlotData()
	menu.refreshInfoFrame()
end

function menu.buttonDropPilotInventory(pilot, wares)
	menu.contextMenuMode = "dropwares"
	menu.contextMenuData = { mode = "inventory", entity = pilot, wares = wares }

	local height = (#wares + 4) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
	if instance == "right" then
		offsetx = Helper.viewWidth - offsetx - config.dropInventoryWidth
	end
	local offsety = (Helper.viewHeight + menu.infoTableOffsetY - height) / 2
	if offsety + height > Helper.viewHeight then
		offsety = menu.infoTableOffsetY
	end

	menu.createContextFrame(config.dropInventoryWidth, nil, offsetx, offsety)
end

function menu.buttonFireCrew(instance, object)
	for _, entry in ipairs(menu.infoTablePersistentData[instance].crew.unassigned.persons) do
		C.RemovePerson(object, entry.person)
	end

	menu.closeContextMenu()
	menu.updatePeopleInfo = getElapsedTime()
end

function menu.buttonConfirmUserQuestion()
	if menu.contextMenuData.saveOption then
		__CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] = true
	end

	if menu.contextMenuData.mode == "markashostile" then
		C.SetRelationBoostToFaction(menu.contextMenuData.controllable, "player", "markedashostile", -1, 1, 600)
		menu.closeContextMenu()
	end
end

function menu.buttonObjectSorter(sorttype)
	if menu.objectSorterType == sorttype then
		menu.objectSorterType = sorttype .. "inverse"
	else
		menu.objectSorterType = sorttype
	end
	menu.refreshInfoFrame()
end

function menu.buttonPropertySorter(sorttype)
	if menu.propertySorterType == sorttype then
		menu.propertySorterType = sorttype .. "inverse"
	else
		menu.propertySorterType = sorttype
	end
	menu.refreshInfoFrame()
end

function menu.buttonDeploy(instance)
	local infomacrostolaunch = menu.infoTablePersistentData[instance].macrostolaunch
	if next(infomacrostolaunch) then
		if infomacrostolaunch.mine then
			C.LaunchMine(menu.infoSubmenuObject, infomacrostolaunch.mine)
		elseif infomacrostolaunch.navbeacon then
			C.LaunchNavBeacon(menu.infoSubmenuObject, infomacrostolaunch.navbeacon)
		elseif infomacrostolaunch.satellite then
			C.LaunchSatellite(menu.infoSubmenuObject, infomacrostolaunch.satellite)
		elseif infomacrostolaunch.lasertower then
			C.LaunchLaserTower(menu.infoSubmenuObject, infomacrostolaunch.lasertower)
		elseif infomacrostolaunch.resourceprobe then
			C.LaunchResourceProbe(menu.infoSubmenuObject, infomacrostolaunch.resourceprobe)
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonLogbookInteraction(entry)
	if IsValidComponent(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(entry.interactioncomponent), true)
		elseif entry.interaction == "guidance" then
			local convertedInteractionComponent = ConvertIDTo64Bit(entry.interactioncomponent)
			if convertedInteractionComponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(convertedInteractionComponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.buttonInfoLogbookClearQuestion(instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "clearlogbook", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonInfoLogbookClear(instance)
	menu.closeContextMenu()
	local logbookdata = menu.infoTablePersistentData[instance].logbookData
	if #logbookdata.logbook > 0 then
		for i = #logbookdata.logbook, 1, -1 do
			local entry = logbookdata.logbook[i]
			RemoveLogbookEntry(entry.index)
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonEditTradeRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonEditBlacklist()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonEditFightRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.slidercellPlotValue(_, value, dimension, fullsize)
	if not dimension then
		DebugError("menu.slidercellPlotValue(): no dimension passed in.")
		return
	end
	if fullsize then
		menu.plotData.size[dimension] = value
		menu.updatePlotSize()
	else
		local valchange = value - menu.plotData.dimensions[dimension]
		menu.plotData.dimensions[dimension] = value
		menu.plotModeUpdateValue(dimension, valchange)
	end
end

function menu.tradeContextCostAndStorageUpdateHelper(storagetype, ware)
	menu.updateTradeCost()
	if not menu.contextMenuData.wareexchange then
		-- profit
		local profit = menu.contextMenuData.referenceprofit
		local profitcolor = Helper.color.white
		if profit < 0 then
			profitcolor = Helper.color.red
		elseif profit > 0 then
			profitcolor = Helper.color.green
		end
		Helper.updateCellText(menu.contextbuttontable, menu.tradeContext.numinforows + 1, 3 + menu.tradeContext.coloffset, ConvertMoneyString(profit, false, true, nil, true) .. " " .. ReadText(1001, 101), profitcolor)
		-- transaction value
		local total = menu.contextMenuData.totalbuyprofit - menu.contextMenuData.totalsellcost
		local transactioncolor = Helper.color.white
		if total < 0 then
			transactioncolor = Helper.color.red
		elseif total > 0 then
			transactioncolor = Helper.color.green
		end
		Helper.updateCellText(menu.contextbuttontable, menu.tradeContext.numinforows + 2, 3 + menu.tradeContext.coloffset, ConvertMoneyString(total, false, true, nil, true) .. " " .. ReadText(1001, 101), transactioncolor)
	end
	-- ship
	for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
		if waredata.ware == ware then
			local content = menu.getTradeContextRowContent(waredata)
			if content[2].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, 2, content[2].text, content[2].color)
			end
			if content[3].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, 3, content[3].text, content[3].color)
			end
			if content[6].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, waredata.sellcol, content[6].text, content[6].color)
			end
			if content[7].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, waredata.buycol, content[7].text, content[7].color)
			end
			break
		end
	end

	-- storage
	local storagecontent = menu.getTradeContextShipStorageContent()
	for i, content in ipairs(storagecontent) do
		if i <= menu.tradeContext.numinforows then
			Helper.setSliderCellValue(menu.contextbuttontable, 2 + i, 1, content.scale.start)
		end
	end
	if menu.contextMenuData.wareexchange then
		storagecontent = menu.getTradeContextShipStorageContent(true)
		for i, content in ipairs(storagecontent) do
			if i <= menu.tradeContext.numinforows then
				Helper.setSliderCellValue(menu.contextbuttontable, 2 + i, 2, content.scale.start)
			end
		end
	end
end

function menu.orderAmountHelper(sellid, buyid, newvalue)
	if newvalue > 0 then
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = 0
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = newvalue
		end
	elseif newvalue < 0 then
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = newvalue
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = 0
		end
	else
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = 0
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = 0
		end
	end
end

function menu.slidercellBoardingAssignedMarines(ship, marinelevel, newvalue)
	local change = newvalue - menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel]
	--print("assigned group marines: " .. menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel] .. ", newvalue: " .. tostring(newvalue) .. ", change: " .. tostring(change))

	menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel] = newvalue
	--print("recording " .. tostring(newvalue) .. " assigned group marines from " .. ffi.string(C.GetComponentName(ship)))

	if (change > 0) then
		--print("adding")
		if (newvalue > menu.boardingData.shipdata[ship].marines[marinelevel]) then
			local numtoadd = menu.boardingData.shipdata[ship].marines[marinelevel]
			local remaining = newvalue - numtoadd
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = numtoadd
			--print("recording " .. tostring(numtoadd) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)) .. ". remaining: " .. tostring(remaining))

			if remaining > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. " " .. tostring(subordinate) .. " level: " .. tostring(marinelevel) .. ", subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].marines[marinelevel]) .. ", assigned subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel]))
					if menu.boardingData.shipdata[subordinate].marines[marinelevel] and (menu.boardingData.shipdata[subordinate].marines[marinelevel] > 0) then
						numtoadd = math.min(remaining, menu.boardingData.shipdata[subordinate].marines[marinelevel])
						remaining = remaining - numtoadd
						menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] = numtoadd
						--print("recording " .. tostring(numtoadd) .. " assigned marines from " .. ffi.string(C.GetComponentName(subordinate)) .. ". remaining: " .. tostring(remaining))
						if remaining < 1 then
							--print("done adding")
							break
						end
					end
				end
			end
		else
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = newvalue
			--print("recording " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)))
		end
	else
		--print("removing. change: " .. tostring(change) .. ", numassignedmarines: " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]))
		if (-change > menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) then
			local numtosubtract = menu.boardingData.shipdata[ship].assignedmarines[marinelevel]
			local remaining = -change - numtosubtract
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = menu.boardingData.shipdata[ship].assignedmarines[marinelevel] - numtosubtract

			if remaining > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. " " .. tostring(subordinate) .. " level: " .. tostring(marinelevel) .. ", assigned subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel]))
					if (menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] > 0) then
						numtosubtract = math.min(remaining, menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel])
						remaining = remaining - numtosubtract
						menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] = menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] - numtosubtract
						--print("recording removal of " .. tostring(numtosubtract) .. " assigned marines from " .. ffi.string(C.GetComponentName(subordinate)) .. ". remaining: " .. tostring(remaining))
						if remaining < 1 then
							--print("done removing")
							break
						end
					end
				end
			end
		else
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = menu.boardingData.shipdata[ship].assignedmarines[marinelevel] + change
			--print("recording " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)))
		end
	end
	menu.boardingData.changed = true
end

function menu.slidercellShipCargo(sellid, buyid, ware, cargoamount, value)
	menu.tradeAmountChanged = ware

	local oldsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local oldbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0
	menu.orderAmountHelper(sellid, buyid, cargoamount - value)
	local newsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local newbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0

	local change = oldsellvalue - newsellvalue + oldbuyvalue - newbuyvalue
	if change > 0 then
		change = AddCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), ware, change, true)
		if menu.contextMenuData.wareexchange then
			RemoveCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), ware, change, true)
		end
	elseif change < 0 then
		if menu.contextMenuData.wareexchange then
			change = -AddCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), ware, -change, true)
		end
		RemoveCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), ware, -change, true)
	end

	-- fix order amounts in case adding cargo failed
	value = cargoamount - oldsellvalue - oldbuyvalue + change
	menu.orderAmountHelper(sellid, buyid, cargoamount - value)

	menu.tradeContextCostAndStorageUpdateHelper("cargo", ware)
end

function menu.slidercellShipAmmo(sellid, buyid, ware, ammoamount, value)
	menu.tradeAmountChanged = ware

	local oldsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local oldbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0
	menu.orderAmountHelper(sellid, buyid, ammoamount - value)
	local newsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local newbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0

	local waremacro = GetWareData(ware, "component")
	local change = oldsellvalue - newsellvalue + oldbuyvalue - newbuyvalue
	if change > 0 then
		change = AddAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), waremacro, change, false, true)
		if menu.contextMenuData.wareexchange then
			RemoveAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), waremacro, change, false, true)
		end
	elseif change < 0 then
		if menu.contextMenuData.wareexchange then
			change = -AddAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), waremacro, -change, false, true)
		end
		RemoveAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), waremacro, -change, false, true)
	end

	-- fix order amounts in case adding cargo failed
	value = ammoamount - oldsellvalue - oldbuyvalue + change
	menu.orderAmountHelper(sellid, buyid, ammoamount - value)

	menu.tradeContextCostAndStorageUpdateHelper("ammo", ware)
end

function menu.onSliderCellDown()
	if menu.contextMenuMode == "trade" then
		menu.tradeSliderLock = true
	end
end

function menu.slidercellTradeConfirmed(ware)
	if menu.tradeAmountChanged then
		menu.tradeAmountChanged = nil
		menu.showOptionalWarningWare = nil
	else
		menu.showOptionalWarningWare = ware
	end

	--menu.topRows.contextoffertable = GetTopRow(menu.contextoffertable)
	--menu.selectedRows.contextoffertable = Helper.currentTableRow[menu.contextoffertable]
	menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
	menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
	menu.tradeSliderLock = nil
	menu.createContextFrame()
end

function menu.slidercellStorageWarePriceOverride(container, ware, buysellswitch, value)
	if value then
		SetContainerWarePriceOverride(container, ware, buysellswitch, value)
	end
end

function menu.dropdownBoardingSetAction(ship, newaction)
	menu.boardingData.shipdata[ship].action = newaction
	menu.boardingData.changed = true
end

function menu.dropdownBoardingSetRisk(newrisklevel, phaseindex)
	--print("newrisklevel: " .. tostring(newrisklevel))
	local stage = ("risk" .. phaseindex)
	menu.boardingData[stage] = newrisklevel
	menu.boardingData.changed = true
end

function menu.dropdownShip(_, shipid)
	local shipid64 = ConvertStringTo64Bit(shipid)
	if shipid64 ~= menu.contextMenuData.currentShip then
		if C.IsComponentOperational(menu.contextMenuData.currentShip) then
			SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
		end

		menu.contextMenuData.currentShip = shipid64
		SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)

		menu.contextMenuData.orders = {}

		menu.initTradeContextData()

		--menu.topRows.contextoffertable = GetTopRow(menu.contextoffertable)
		--menu.selectedRows.contextoffertable = Helper.currentTableRow[menu.contextoffertable]
		menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
		menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
		menu.createContextFrame()
	end
end

function menu.dropdownNewSyncPoint(orderidx, idstring)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local id = tonumber(idstring)

		if id == 0 then
			C.RemoveOrderSyncPointID(menu.infoSubmenuObject, orderidx)
		else
			C.SetOrderSyncPointID(menu.infoSubmenuObject, orderidx, id, false)
		end

		menu.refreshInfoFrame()
	else
		DebugError("menu.dropdownNewSyncPoint: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.dropdownChangeOverrideOrder(idstring, attacker, instance)
	-- remove all override orders
	for i = #menu.infoTableData[instance].orders, 1, -1 do
		local entry = menu.infoTableData[instance].orders[i]
		if entry.isoverride then
			menu.removeOrder(i, instance)
		end
	end

	local orderidx
	if idstring == "Flee" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Flee", false, true, true)
		if orderidx > 0 then
			SetOrderParam(menu.infoSubmenuObject, orderidx, 1, nil, 'boost')
			SetOrderParam(menu.infoSubmenuObject, orderidx, 3, nil, true)
			SetOrderParam(menu.infoSubmenuObject, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Attack" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Attack", false, true, true)
		if orderidx > 0 then
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 1, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Wait" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Wait", false, true, true)
		if orderidx > 0 then
			SetOrderParam(menu.infoSubmenuObject, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 5, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	end

	if orderidx > 0 then
		C.EnableOrder(menu.infoSubmenuObject, orderidx)
		local newidx = 1
		if not C.AdjustOrder(menu.infoSubmenuObject, orderidx, newidx, true, false, true) then
			newidx = 2
		end
		C.AdjustOrder(menu.infoSubmenuObject, orderidx, newidx, true, false, false)
	end

	menu.noupdate = false
end

function menu.buttonReleaseSyncPoint(syncpointinfo)
	if syncpointinfo.id > 0 then
		C.ReleaseOrderSyncPoint(syncpointinfo.id)
	else
		C.ReleaseOrderSyncPointFromOrder(syncpointinfo.owningcontrollable, syncpointinfo.owningorderidx)
	end
	menu.refreshInfoFrame()
end

function menu.buttonContextSetLogo(logo)
	menu.contextMenuData.currentlogo = logo
	C.SetFleetLogo(menu.contextMenuData.component, logo)
end

function menu.buttonChangeLogoCancel()
	C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.origlogo)
	menu.closeContextMenu("back")
end

function menu.dropdownModuleSet(_, idstring)
	menu.plotData.set = idstring
	menu.noupdate = false
end

-- mode: "factionresponses", "controllableresponses"
function menu.dropdownOrdersSetResponse(_, newresponseid, factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.dropdownOrdersSetResponse called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.dropdownOrdersSetResponse called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.dropdownOrdersSetResponse called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if newresponseid == "reset" then
		if mode == "controllableresponses" then
			if not C.ResetResponseToSignalForControllable(signalid, factionorcontrollable) then
				DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(factionorcontrollable)) .. " " .. tostring(factionorcontrollable))
			end
		else
			local factionobjects = GetContainedObjectsByOwner(factionorcontrollable)
			for _, object in ipairs(factionobjects) do
				local object64 = ConvertIDTo64Bit(object)
				if C.IsComponentClass(object64, "controllable") then
					if not C.ResetResponseToSignalForControllable(signalid, object64) then
						DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(object64)) .. " " .. tostring(object64))
					end
				end
			end
		end
	else
		local ask
		if mode == "controllableresponses" then
			ask = C.GetAskToSignalForControllable(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForControllable(newresponseid, ask, signalid, factionorcontrollable)
		else
			ask = C.GetAskToSignalForFaction(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForFaction(newresponseid, ask, signalid, factionorcontrollable)
		end
	end
	menu.refreshInfoFrame()
end

function menu.dropdownOrdersResupply(controllable, id)
	C.SetDefensibleLoadoutLevel(controllable, tonumber(id))
	menu.refreshInfoFrame()
end

function menu.dropdownOrdersCargoReservations(ship, id)
	C.SetShipTradeLoopCargoReservationOverride(ship, id == "on")
	menu.refreshInfoFrame()
end

function  menu.dropdownOrdersBlacklist(controllable, type, id)
	C.SetControllableBlacklist(controllable, tonumber(id), type, true)
	menu.refreshInfoFrame()
end

function  menu.dropdownOrdersFightRule(controllable, type, id)
	C.SetControllableFightRule(controllable, tonumber(id), type, true)
	menu.refreshInfoFrame()
end

function menu.dropdownHireRole(_, idstring)
	menu.noupdate = false
	if idstring ~= nil then
		local type, id = string.match(idstring, "(.+):(.+)")
		if type == "mission" then
			menu.contextMenuData.hireIsMission = true
			menu.contextMenuData.hireIsPost = nil
		else
			menu.contextMenuData.hireIsMission = nil
			menu.contextMenuData.hireIsPost = type == "post"
		end
		menu.contextMenuData.hireRole = id

		menu.refreshContextFrame()
	end
end

function menu.dropdownBehaviourFormation(_, shape)
	if shape ~= nil then
		local info = C.SetFormationShape(menu.infoSubmenuObject, shape)
		shape = ffi.string(info.shape)

		if (shape ~= "") then
			local subordinates = GetSubordinates(menu.infoSubmenuObject)
			for i = #subordinates, 1, -1 do
				local subordinate = ConvertIDTo64Bit(subordinates[i])

				local numorders = C.GetNumOrders(subordinate)
				local currentorders = ffi.new("Order[?]", numorders)
				numorders = C.GetOrders(currentorders, numorders, subordinate)
				local paramoffset = 0
				for j = 1, numorders do
					if (ffi.string(currentorders[0].orderdef) == "Escort") then
						paramoffset = 0
					elseif (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
						paramoffset = 1
					end
					if (ffi.string(currentorders[0].orderdef) == "Escort") or (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
						SetOrderParam(subordinate, j, paramoffset + 2, nil, shape) -- shape
						SetOrderParam(subordinate, j, paramoffset + 3, nil, info.radius) -- radius
						SetOrderParam(subordinate, j, paramoffset + 4, nil, info.rollMembers) -- rollmembers
						SetOrderParam(subordinate, j, paramoffset + 5, nil, info.rollFormation) -- rollformation
						SetOrderParam(subordinate, j, paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
					end
				end

				local currentdefaultorder = ffi.new("Order")
				if C.GetDefaultOrder(currentdefaultorder, subordinate) then
					if (ffi.string(currentdefaultorder.orderdef) == "Escort") then
						paramoffset = 0
					elseif (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
						paramoffset = 1
					end
					if (ffi.string(currentdefaultorder.orderdef) == "Escort") or (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
						SetOrderParam(subordinate, "default", paramoffset + 2, nil, shape) -- shape
						SetOrderParam(subordinate, "default", paramoffset + 3, nil, info.radius) -- radius
						SetOrderParam(subordinate, "default", paramoffset + 4, nil, info.rollMembers) -- rollmembers
						SetOrderParam(subordinate, "default", paramoffset + 5, nil, info.rollFormation) -- rollformation
						SetOrderParam(subordinate, "default", paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
					end
				end
			end
		end
		menu.refreshInfoFrame()
	end
end

function  menu.dropdownTradeRule(container, type, id, ware, refresh)
	if type == "trade" then
		C.SetContainerTradeRule(container, tonumber(id), "buy",  ware or "", true)
		C.SetContainerTradeRule(container, tonumber(id), "sell", ware or "", true)
	else
		C.SetContainerTradeRule(container, tonumber(id), type, ware or "", true)
	end

	if refresh then
		menu.refreshInfoFrame()
	end
end

function  menu.dropdownBuildRule(container, id)
	C.SetContainerBuildMethod(container, id)
end

function menu.checkboxSetWeaponConfig(system, value)
	if system == "default" then
		menu.contextMenuData.default = value
	end
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		if entry.id == system then
			menu.contextMenuData.weaponsystems[i].active = value
		end
	end
	menu.createContextFrame()
end

-- mode: "factionresponses", "controllableresponses"
function menu.checkboxOrdersSetAsk(factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetAsk called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.checkboxOrdersSetAsk called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetAsk called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	local ask
	local response
	if mode == "controllableresponses" then
		ask = not C.GetAskToSignalForControllable(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForControllable(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForControllable(response, ask, signalid, factionorcontrollable)
	else
		ask = not C.GetAskToSignalForFaction(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForFaction(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForFaction(response, ask, signalid, factionorcontrollable)
	end
	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetOverride(controllable, signalid, mode, checked)
	if mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetOverride called with invalid mode set. only 'controllableresponses' is supported at this time. mode: " .. tostring(mode))
		return
	elseif not controllable then
		DebugError("menu.checkboxOrdersSetOverride called with invalid faction or controllable set. controllable: " .. tostring(controllable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetOverride called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if checked then
		if not C.ResetResponseToSignalForControllable(signalid, controllable) then
			DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(controllable)) .. " " .. tostring(controllable))
		end
	else
		local faction = GetComponentData(controllable, "owner")
		local deffactresponse = ffi.string(C.GetDefaultResponseToSignalForFaction(signalid, faction))
		local ask = C.GetAskToSignalForControllable(signalid, controllable)
		C.SetDefaultResponseToSignalForControllable(deffactresponse, ask, signalid, controllable)
	end 

	menu.refreshInfoFrame() 
end

function menu.checkboxOrdersSetResupplyOverride(controllable, checked)
	if checked then 
		C.SetDefensibleLoadoutLevel(controllable, -1)
	else 
		C.SetDefensibleLoadoutLevel(controllable, 0)
	end

	menu.refreshInfoFrame()
end
	 
function menu.checkboxOrdersSetCargoReservations(ship, checked)
	if checked then 
		C.RemoveShipTradeLoopCargoReservationOverride(ship)
	else 
		C.SetShipTradeLoopCargoReservationOverride(ship, C.GetPlayerGlobalTradeLoopCargoReservationSetting())
	end

	menu.refreshInfoFrame()
end

function menu.checkboxStorageWarePriceOverride(container, ware, buysellswitch, price, checked)
	if checked then
		ClearContainerWarePriceOverride(container, ware, buysellswitch)
	else
		SetContainerWarePriceOverride(container, ware, buysellswitch, price)
	end

	menu.refreshInfoFrame()
end
	 
function menu.checkboxOrdersSetBlacklistOverride(controllable, type, checked)
	if checked then 
		C.SetControllableBlacklist(controllable, -1, type, false)
	else 
		C.SetControllableBlacklist(controllable, -1, type, true)
	end

	menu.refreshInfoFrame()
end
	 
function menu.checkboxOrdersSetFightRuleOverride(controllable, type, checked)
	if checked then 
		C.SetControllableFightRule(controllable, -1, type, false)
	else 
		C.SetControllableFightRule(controllable, -1, type, true)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxSetWareList(ware, checked)
	menu.contextMenuData.selectedWares[ware] = checked or nil
end

function menu.checkboxSetSectorList(sector, checked)
	menu.contextMenuData.selectedSectors[tostring(sector)] = checked or nil
end

function menu.checkboxToggleWareList(checked)
	for _, ware in ipairs(menu.contextMenuData.wares) do
		menu.contextMenuData.selectedWares[ware] = checked or nil
	end
end

function menu.checkboxToggleSectorList(checked)
	for _, sector in ipairs(menu.contextMenuData.sectors) do
		menu.contextMenuData.selectedSectors[tostring(sector)] = checked or nil
	end
end
	 
function menu.checkboxSetTradeRuleOverride(container, type, checked, ware)
	if type == "trade" then
		if checked then 
			C.SetContainerTradeRule(container, -1, "buy",  ware or "", false)
			C.SetContainerTradeRule(container, -1, "sell", ware or "", false)
		else 
			local currentid = C.GetContainerTradeRuleID(container, "buy", ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "buy",  ware or "", true)
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "sell", ware or "", true)
		end
	else
		if checked then 
			C.SetContainerTradeRule(container, -1, type, ware or "", false)
		else 
			local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware or "", true)
		end
	end

	menu.refreshInfoFrame()
end
	 
function menu.checkboxSetBuildRuleOverride(container, checked, curglobal)
	if checked then 
		C.SetContainerBuildMethod(container, "")
	else 
		C.SetContainerBuildMethod(container, curglobal or "default")
	end

	menu.refreshInfoFrame()
end

function menu.storeCurrentPlots()
	menu.currentPlots = {}
	local playerobjects = GetContainedStationsByOwner("player", nil, true)
	for _, station in ipairs(playerobjects) do
		local station64 = ConvertStringTo64Bit(tostring(station))
		local rawsize = C.GetBuildPlotSize(station64)
		local plotcenter = C.GetBuildPlotCenterOffset(station64)
		menu.currentPlots[tostring(station64)] = {
			posX = math.ceil((rawsize.x / 2 + plotcenter.x) / 1000),
			negX = math.floor((rawsize.x / 2 - plotcenter.x) / 1000),
			posY = math.ceil((rawsize.y / 2 + plotcenter.y) / 1000),
			negY = math.floor((rawsize.y / 2 - plotcenter.y) / 1000),
			posZ = math.ceil((rawsize.z / 2 + plotcenter.z) / 1000),
			negZ = math.floor((rawsize.z / 2 - plotcenter.z) / 1000),
		}
	end
end

function menu.updatePlotData(station, donotrefresh)
	if not station then
		if not menu.plotData.component then
			DebugError("menu.updatePlotData(): no station passed in. station: " .. tostring(station) .. ", menu.plotData.component: " .. tostring(menu.plotData.component) .. ".")
			return
		end
		station = menu.plotData.component
	end

	if station ~= "plots_new" then
		local station64 = ConvertStringTo64Bit(tostring(station))
		local rawsize = C.GetBuildPlotSize(station)
		local plotcenter = C.GetBuildPlotCenterOffset(station)
		local sets = GetComponentData(station64, "modulesets")
		local sector = GetComponentData(station64, "sectorid")
		local owner = GetComponentData(station64, "owner")
		local boughtrawsize = C.GetPaidBuildPlotSize(station)
		local playermoney = GetPlayerMoney()
		local minimumrawsize = C.GetMinimumBuildPlotSize(station)
		local minimumcenter = C.GetMinimumBuildPlotCenterOffset(station)
		local pos = C.GetObjectPositionInSector(station)

		menu.plotData.name = ffi.string(C.GetComponentName(station))
		menu.plotData.component = station
		menu.plotData.position = pos
		menu.plotData.set = sets[1] or ""
		menu.plotData.placed = true
		menu.plotData.sector = ConvertIDTo64Bit(sector)
		menu.plotData.permanent = (C.GetNumStationModules(station, true, true) > 0) and true or false
		menu.plotData.isinownedspace = (GetComponentData(sector, "owner") ~= "ownerless") and (GetComponentData(sector, "owner") ~= "xenon")
		menu.plotData.paid = (not menu.plotData.isinownedspace or boughtrawsize.x > 0 or boughtrawsize.y > 0 or boughtrawsize.z > 0) and true or false
		local fullprice = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, rawsize.x, rawsize.y, rawsize.z, owner))
		local buf = ffi.new("bool[1]", 0)
		local plotpayment = tonumber(C.GetBuildPlotPayment(station, buf))
		local haspositionchanged = buf[0]
		menu.plotData.fullypaid = ((not menu.plotData.isinownedspace) or ((boughtrawsize.x >= rawsize.x) and (boughtrawsize.y >= rawsize.y) and (boughtrawsize.z >= rawsize.z))) and ((not haspositionchanged) or (plotpayment >= fullprice))
		menu.plotData.size = { x = rawsize.x / 1000, y = rawsize.y / 1000, z = rawsize.z / 1000 }
		menu.plotData.dimensions = {
			posX = math.ceil((rawsize.x / 2 + plotcenter.x) / 1000),
			negX = math.floor((rawsize.x / 2 - plotcenter.x) / 1000),
			posY = math.ceil((rawsize.y / 2 + plotcenter.y) / 1000),
			negY = math.floor((rawsize.y / 2 - plotcenter.y) / 1000),
			posZ = math.ceil((rawsize.z / 2 + plotcenter.z) / 1000),
			negZ = math.floor((rawsize.z / 2 - plotcenter.z) / 1000),
		}
		menu.plotData.minimumdimensions = {
			posX = math.ceil((minimumrawsize.x / 2 + minimumcenter.x) / 1000),
			negX = math.floor((minimumrawsize.x / 2 - minimumcenter.x) / 1000),
			posY = math.ceil((minimumrawsize.y / 2 + minimumcenter.y) / 1000),
			negY = math.floor((minimumrawsize.y / 2 - minimumcenter.y) / 1000),
			posZ = math.ceil((minimumrawsize.z / 2 + minimumcenter.z) / 1000),
			negZ = math.floor((minimumrawsize.z / 2 - minimumcenter.z) / 1000),
		}

		if ((not menu.plotData.isinownedspace) and (rawsize.x > boughtrawsize.x or rawsize.y > boughtrawsize.y or rawsize.z > boughtrawsize.z)) or GetComponentData(sector, "isplayerowned") then
			C.PayBuildPlotSize(station, rawsize, plotcenter)
			boughtrawsize = C.GetPaidBuildPlotSize(station)
			local found
			for _, plot in ipairs(menu.plots) do
				if plot.station == station then
					plot.boughtrawcenteroffset = plotcenter
					found = true
					break
				end
			end
			if not found then
				table.insert(menu.plots, { station = station, paid = true, fullypaid = true, permanent = (C.GetNumStationModules(station, true, true) > 0) and true or false, boughtrawcenteroffset = plotcenter, removed = nil })
			end
		end
		menu.plotData.boughtrawsize = { x = boughtrawsize.x, y = boughtrawsize.y, z = boughtrawsize.z }
		--print("fullypaid: " .. tostring(menu.plotData.fullypaid) .. ", boughtsize: " .. tostring(boughtrawsize.x) .. " x " .. tostring(boughtrawsize.y) .. " x " .. tostring(boughtrawsize.z) .. ", size: " .. tostring(rawsize.x) .. " x " .. tostring(rawsize.y) .. " x " .. tostring(rawsize.z))

		for _, plot in ipairs(menu.plots) do
			if station == plot.station then
				menu.plotData.boughtrawcenteroffset = plot.boughtrawcenteroffset
				break
			end
		end
		menu.plotData.price = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, rawsize.x, rawsize.y, rawsize.z, owner)) - plotpayment
		menu.plotData.affordable = playermoney >= menu.plotData.price
	else
		menu.plotData = {
			name = ReadText(1001, 9200),	-- New Plot
			set = "factory",
			active = false,
			placed = false,
			sector = menu.currentsector,
			permanent = false,
			isinownedspace = (GetComponentData(ConvertStringTo64Bit(tostring(menu.currentsector)), "owner") ~= "ownerless") and (GetComponentData(ConvertStringTo64Bit(tostring(menu.currentsector)), "owner") ~= "xenon"),
			paid = false,
			fullypaid = false,
			boughtrawsize = { x = 0, y = 0, z = 0 },
			size = { x = 4, y = 4, z = 4 },
			dimensions = { posX = 2, negX = 2, posY = 2, negY = 2, posZ = 2, negZ = 2 },
			minimumdimensions = { posX = 0, negX = 0, posY = 0, negY = 0, posZ = 0, negZ = 0 },
			affordable = false,
			removed = nil
		}
	end

	if menu.currentsector ~= menu.plotData.sector then
		menu.currentsector = menu.plotData.sector
		C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
		menu.applyFilterSettings()
	end

	if not donotrefresh and menu.plotsliders then
		-- if slider setup (3-slider or 6-slider) and plotData don't match, refresh the menu at the next opportunity.
		if (menu.plotsliders[1].dimension == "x" and menu.plotData.placed) or (menu.plotsliders[1].dimension ~= "x" and not menu.plotData.placed) then
			menu.over = true
		else
			menu.updatePlotWidgets()
		end
	end
end

function menu.updatePlotWidgets()
	for _, slider in ipairs(menu.plotsliders) do
		local sliderproperties = { min = 0, minselect = 2, max = config.maxPlotSize, start = menu.plotData.size[slider.dimension], step = 2, suffix = ReadText(1001, 108) }
		local boughtdimensions = {}
		if menu.plotData.paid then
			boughtdimensions = {
				posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + menu.plotData.boughtrawcenteroffset.x) / 1000),
				negX = math.floor((menu.plotData.boughtrawsize.x / 2 - menu.plotData.boughtrawcenteroffset.x) / 1000),
				posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + menu.plotData.boughtrawcenteroffset.y) / 1000),
				negY = math.floor((menu.plotData.boughtrawsize.y / 2 - menu.plotData.boughtrawcenteroffset.y) / 1000),
				posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + menu.plotData.boughtrawcenteroffset.z) / 1000),
				negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - menu.plotData.boughtrawcenteroffset.z) / 1000),
			}
		end
		if menu.plotData.placed then
			local locdimension = menu.plotData.dimensions[slider.dimension]
			local minimumdimension = menu.plotData.minimumdimensions[slider.dimension] or 0
			local boughtdimension = menu.plotData.paid and boughtdimensions[slider.dimension] or 0
			local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[slider.dimension]]

			local minselect = math.max(menu.plotData.permanent and math.max(boughtdimension, minimumdimension) or boughtdimension, (locpaireddimension == 0 and 1 or 0))
			sliderproperties = { 
				min = 0,
				minselect = minselect,
				max = (locpaireddimension > config.maxPlotSize) and locpaireddimension or config.maxPlotSize,
				maxselect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension),
				start = locdimension,
				step = 1,
				suffix = ReadText(1001, 108) 
			}
			if sliderproperties.minselect > sliderproperties.maxselect then
				print("menu.updatePlotWidgets(): minselect > maxselect [Florian]")
				sliderproperties.minselect = sliderproperties.maxselect
			end
			if sliderproperties.start < sliderproperties.minselect then
				print("menu.updatePlotWidgets(): start < minselect [Florian]")
				sliderproperties.start = sliderproperties.minselect
			end
		end
		--print("dimension: " .. tostring(slider.dimension) .. ", paired: " .. tostring(config.plotPairedDimension[slider.dimension]) .. ", row: " .. tostring(slider.row) .. ", value: " .. tostring(menu.plotData.dimensions[slider.dimension]) )
		--Helper.setSliderCellValue(slider.table.id, slider.row, slider.col, menu.plotData.dimensions[slider.dimension])

		-- NB: necessary at the moment to set max in addition to changing slider value.
		Helper.removeSliderCellScripts(menu, slider.table.id, slider.row, slider.col)
		SetCellContent(
					slider.table.id,
					Helper.createSliderCell(
						Helper.createTextInfo(
							slider.cell.properties.text.text,
							"left",
							Helper.standardFont,
							slider.cell.properties.text.fontsize,
							Helper.standardColor.r, 
							Helper.standardColor.g, 
							Helper.standardColor.b, 
							Helper.standardColor.a, 
							0,
							0), 
						nil,
						nil,
						nil,
						nil,
						config.mapRowHeight,
						slider.cell.properties.bgColor,
						nil,
						sliderproperties),
					slider.row,
					slider.col)
		Helper.setSliderCellScript(menu, nil, slider.table.id, slider.row, slider.col, function(_, val) return menu.slidercellPlotValue(_, val, slider.dimension, not menu.plotData.placed) end, nil, nil, nil, function() return menu.refreshInfoFrame() end)
	end

	-- NB: this is simply to reset the button's active attribute.
	for _, button in ipairs(menu.plotbuttons) do
		if button.rowdata == "createplot" then
			local activate
			if button.col == 2 then
				activate = (menu.plotData.placed and menu.plotData.paid and (menu.plotData.size.x * 1000 > menu.plotData.boughtrawsize.x or menu.plotData.size.y * 1000 > menu.plotData.boughtrawsize.y or menu.plotData.size.z * 1000 > menu.plotData.boughtrawsize.z) and not menu.plotData.permanent) and true or false
			elseif button.col == 3 then
				activate = not menu.plotData.placed
			end
			Helper.removeButtonScripts(menu, button.table.id, button.row, button.col)
			SetCellContent(
						button.table.id,
						Helper.createButton(
							Helper.createTextInfo(
								button.cell.properties.text.text,
								"center",
								Helper.standardFont,
								button.cell.properties.text.fontsize,
								Helper.standardColor.r, 
								Helper.standardColor.g, 
								Helper.standardColor.b, 
								Helper.standardColor.a, 
								0,
								0), 
							nil,
							false,
							activate),
						button.row,
						button.col)
			Helper.setButtonScript(menu, nil, button.table.id, button.row, button.col, button.script)
		elseif button.rowdata == "buyplot" then
			local activate
			if button.col == 2 then
				activate = false
			elseif button.col == 3 then
				activate = (menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and menu.plotData.affordable) and true or false
			end
			local mouseovertext = ""
			if menu.plotData.placed and (not menu.plotData.fullypaid) and menu.plotData.isinownedspace and (not menu.plotData.affordable) then
				mouseovertext = ReadText(1026, 3222)
			end
			Helper.removeButtonScripts(menu, button.table.id, button.row, button.col)
			SetCellContent(
						button.table.id,
						Helper.createButton(
							Helper.createTextInfo(
								button.cell.properties.text.text,
								"center",
								Helper.standardFont,
								button.cell.properties.text.fontsize,
								Helper.standardColor.r, 
								Helper.standardColor.g, 
								Helper.standardColor.b, 
								Helper.standardColor.a, 
								0,
								0), 
							nil,
							false,
							activate,
							nil,
							nil,
							nil,
							nil,
							nil,
							nil,
							nil,
							mouseovertext
						),
						button.row,
						button.col)
			Helper.setButtonScript(menu, nil, button.table.id, button.row, button.col, button.script)
		elseif button.rowdata == "initiateconstruction" then
			--local danger = menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace
			--local buttoncolor = danger and Helper.color.red or nil
			--local textcolor = danger and Helper.color.black or Helper.standardColor
			--local textfont = danger and Helper.standardFontBold or Helper.standardFont
			Helper.removeButtonScripts(menu, button.table.id, button.row, button.col)
			SetCellContent(
						button.table.id,
						Helper.createButton(
							Helper.createTextInfo(
								button.cell.properties.text.text,
								"center",
								Helper.standardFont,
								button.cell.properties.text.fontsize,
								Helper.standardColor.r, 
								Helper.standardColor.g, 
								Helper.standardColor.b, 
								Helper.standardColor.a, 
								0,
								0), 
							nil,
							false,
							menu.plotData.placed),
						button.row,
						button.col)
			Helper.setButtonScript(menu, nil, button.table.id, button.row, button.col, button.script)
		end
	end
end

function menu.resetPlotSize(cleanup)
	if not menu.plotData.placed then
		DebugError("menu.resetPlotSize: tried to resize a plot that has not yet been placed.")
		return
	end
	if menu.plotData.paid then
		local wantedcenteroffset = menu.plotData.boughtrawcenteroffset
		--print("wantedcenteroffset.x: " .. tostring(wantedcenteroffset.x) .. ", wantedcenteroffset.y: " .. tostring(wantedcenteroffset.y) .. ", wantedcenteroffset.z: " .. tostring(wantedcenteroffset.z))
		local boughtdimensions = {
			posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + wantedcenteroffset.x) / 1000),
			negX = math.floor((menu.plotData.boughtrawsize.x / 2 - wantedcenteroffset.x) / 1000),
			posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + wantedcenteroffset.y) / 1000),
			negY = math.floor((menu.plotData.boughtrawsize.y / 2 - wantedcenteroffset.y) / 1000),
			posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + wantedcenteroffset.z) / 1000),
			negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - wantedcenteroffset.z) / 1000),
		}
		local posSizeChange = { x = (boughtdimensions.posX - menu.plotData.dimensions.posX) * 1000, y = (boughtdimensions.posY - menu.plotData.dimensions.posY) * 1000, z = (boughtdimensions.posZ - menu.plotData.dimensions.posZ) * 1000 }
		local negSizeChange = { x = (boughtdimensions.negX - menu.plotData.dimensions.negX) * 1000, y = (boughtdimensions.negY - menu.plotData.dimensions.negY) * 1000, z = (boughtdimensions.negZ - menu.plotData.dimensions.negZ) * 1000 }
		--print("poschangeX: " .. tostring(posSizeChange.x) .. ", possizechangeY: " .. tostring(posSizeChange.y) .. ", possizechangeZ: " .. tostring(posSizeChange.z) .. "\nnegchangeX: " .. tostring(negSizeChange.x) .. ", negsizechangeY: " .. tostring(negSizeChange.y) .. ", negsizechangeZ: " .. tostring(negSizeChange.z))
		if C.ExtendBuildPlot(menu.plotData.component, posSizeChange, negSizeChange, true) then
			local plotcenteroffset = C.GetBuildPlotCenterOffset(menu.plotData.component)
			menu.plotData.size = { x = menu.plotData.boughtrawsize.x / 1000, y = menu.plotData.boughtrawsize.y / 1000, z = menu.plotData.boughtrawsize.z / 1000 }
			menu.plotData.dimensions = {
				posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + plotcenteroffset.x) / 1000),
				negX = math.floor((menu.plotData.boughtrawsize.x / 2 - plotcenteroffset.x) / 1000),
				posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + plotcenteroffset.y) / 1000),
				negY = math.floor((menu.plotData.boughtrawsize.y / 2 - plotcenteroffset.y) / 1000),
				posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + plotcenteroffset.z) / 1000),
				negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - plotcenteroffset.z) / 1000),
			}
			--print("menu.resetPlotSize: successfully reset build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
			if not cleanup then
				C.UpdateMapBuildPlot(menu.holomap)
			end
		else
			DebugError("menu.resetPlotSize: failed to reset build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. "\nposSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. "\nnegSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z))
		end
		if not menu.plotData.fullypaid and menu.plotData.price <= 0 then
			menu.plotData.fullypaid = true
		end
		menu.updatePlotData(menu.plotData.component, cleanup)
		if not cleanup then
			menu.refreshInfoFrame()
		end
	end
end

function menu.updatePlotSize(dimension, axis, valchange)
	if menu.plotData.active then
		C.ChangeMapBuildPlot(menu.holomap, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
	elseif menu.plotData.placed then
		local posSizeChange = { x = 0, y = 0, z = 0 }
		local negSizeChange = { x = 0, y = 0, z = 0 }
		if dimension == "posX" or dimension == "posY" or dimension == "posZ" then
			posSizeChange[axis] = valchange * 1000
		elseif dimension == "negX" or dimension == "negY" or dimension == "negZ" then
			negSizeChange[axis] = valchange * 1000
		else
			DebugError("menu.updatePlotSize: dimension passed in: " .. tostring(dimension) .. " indicates neither positive nor negative.")
			return
		end
		if C.ExtendBuildPlot(menu.plotData.component, posSizeChange, negSizeChange, true) then
			--print("menu.updatePlotSize: successfully extended build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
			C.UpdateMapBuildPlot(menu.holomap)
			if (not menu.plotData.isinownedspace) or GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "isplayerowned") then
				local rawsize = C.GetBuildPlotSize(menu.plotData.component)
				local plotcenter = C.GetBuildPlotCenterOffset(menu.plotData.component)
				for _, plot in ipairs(menu.plots) do
					if plot.station == menu.plotData.component then
						plot.boughtrawcenteroffset = plotcenter
						break
					end
				end
				C.PayBuildPlotSize(menu.plotData.component, rawsize, plotcenter)
			end
		else
			DebugError("menu.updatePlotSize: failed to extend build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
		end
	end
end

function menu.plotInitiateConstruction(station)
	if not station then
		DebugError("menu.plotInitiateConstruction(): no station passed in. station: " .. tostring(station))
		return
	end
	menu.setplotrow = Helper.currentTableRow[menu.infoTable]
	menu.setplottoprow = GetTopRow(menu.infoTable)
	for _, plot in ipairs(menu.plots) do
		if plot.station == station then
			plot.permanent = true
			break
		end
	end

	AddUITriggeredEvent(menu.name, "initiateconstruction_station", ConvertStringTo64Bit(tostring(station)))
	AddUITriggeredEvent(menu.name, "initiateconstruction_license", menu.plotData.fullypaid)

	Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, station })
	menu.cleanup()
end

-- shortcuts
function menu.hotkey(action)
	local rowdata = Helper.getCurrentRowData(menu, menu.infoTable)
	local selectedcomponent
	if next(menu.selectedcomponents) then
		for id, _ in pairs(menu.selectedcomponents) do
			selectedcomponent = ConvertStringTo64Bit(id)
			if IsValidComponent(selectedcomponent) then
				break
			end
			selectedcomponent = nil
		end
	end

	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_CLOSE_MAP" then
		if menu.showMultiverse then
			menu.buttonToggleMultiverseMap()
		else
			menu.onCloseElement("close")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_MISSIONS" then
		if menu.infoTableMode ~= "mission" then
			if menu.mode ~= "hire" then
				menu.infoTableMode = "mission"
				menu.refreshMainFrame = true
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_ZONE_VIEW" then
		if menu.holomap and (menu.holomap ~= 0) then
			C.SetMapTargetDistance(menu.holomap, 20000)
			C.ResetMapPlayerRotation(menu.holomap)
			C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
			if menu.infoTableMode == "objectlist" then
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_SECTOR_VIEW" then
		if menu.holomap and (menu.holomap ~= 0) then
			C.SetMapTargetDistance(menu.holomap, 2000000)
			C.ResetMapPlayerRotation(menu.holomap)
			C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
			if menu.infoTableMode == "objectlist" then
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_F1" then
		C.SetPlayerCameraCockpitView(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_T" then
		menu.target(nil, C.IsExternalTargetMode() or C.IsExternalViewActive(), selectedcomponent)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_A_SHIFT" then
		C.ToggleAutoPilot(false)

		menu.settoprow = GetTopRow(menu.infoTable)
		menu.setrow = Helper.currentTableRow[menu.infoTable]
		if not menu.createInfoFrameRunning then
			menu.createInfoFrame()
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE" then
		if GetPlayerActivity() == "travel" then
			C.StopPlayerActivity("travel")
		else
			C.StartPlayerActivity("travel")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_SETA" then
		if GetPlayerActivity() == "seta" then
			C.StopPlayerActivity("seta")
		else
			C.StartPlayerActivity("seta")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_MULTIVERSE" then
		if (menu.mode ~= "selectCV") and (menu.mode ~= "hire") and (menu.mode ~= "orderparam_object") and (menu.mode ~= "selectComponent") then
			if menu.showMultiverse then
				Helper.closeMenu(menu, dueToClose)
				menu.cleanup()
			else
				menu.buttonToggleMultiverseMap()
			end
		end
	elseif selectedcomponent then
		if action == "INPUT_ACTION_ADDON_DETAILMONITOR_C" then
			if (not menu.mode) and IsComponentOperational(selectedcomponent) and GetComponentData(selectedcomponent, "caninitiatecomm") then
				menu.openComm(selectedcomponent)
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_I" then
			if (not menu.mode) and IsInfoUnlockedForPlayer(selectedcomponent, "name") and CanViewLiveData(selectedcomponent) then
				menu.openDetails(selectedcomponent)
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_TELEPORT" then
			local isplayerowned, isally, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isally", "isdeployable")
			if (isplayerowned or (C.IsComponentClass(selectedcomponent, "station") and isally)) and (not isdeployable) and not C.IsUnit(selectedcomponent) then
				if selectedcomponent ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) then
					if ffi.string(C.CanTeleportPlayerTo(selectedcomponent, false, false)) == "granted" then
						C.TeleportPlayerTo(selectedcomponent, false, false, false)
						return
					end
				end
			end
			PlaySound("ui_target_set_fail")
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_P" then
			menu.plotCourse(selectedcomponent)
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_F3" then
			if C.IsPlayerCameraTargetViewPossible(selectedcomponent, true) then
				if menu.target(selectedcomponent, true) then
					C.SetPlayerCameraTargetView(selectedcomponent, true)
				else
					PlaySound("ui_target_set_fail")
				end
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REMOVE_ORDER" then
			local lastorderidx = C.GetNumOrders(selectedcomponent)
			if lastorderidx > 0 then
				if GetComponentData(selectedcomponent, "isplayerowned") and C.RemoveOrder(selectedcomponent, lastorderidx, false, true) then
					if C.RemoveOrder(selectedcomponent, lastorderidx, false, false) then
						if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
							menu.removeExtendedOrder(selectedcomponent, lastorderidx, "left")
							if lastorderidx == #menu.infoTableData.left.orders then
								menu.infoTablePersistentData.left.selectedorder = (lastorderidx > 1) and { (lastorderidx - 1) } or nil
							end
							if menu.infoTablePersistentData.left.selectedorder and (type(menu.infoTablePersistentData.left.selectedorder[1]) == "number") then
								menu.infoTablePersistentData.left.selectedorder = { math.min(menu.infoTablePersistentData.left.selectedorder[1], #menu.infoTableData.left.orders - 1) }
							end
						end
						if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
							menu.removeExtendedOrder(selectedcomponent, lastorderidx, "right")
							if lastorderidx == #menu.infoTableData.right.orders then
								menu.infoTablePersistentData.right.selectedorder = (lastorderidx > 1) and { (lastorderidx - 1) } or nil
							end
							if menu.infoTablePersistentData.right.selectedorder and (type(menu.infoTablePersistentData.right.selectedorder[1]) == "number") then
								menu.infoTablePersistentData.right.selectedorder = { math.min(menu.infoTablePersistentData.right.selectedorder[1], #menu.infoTableData.right.orders - 1) }
							end
						end
					else
						PlaySound("ui_target_set_fail")
					end
				else
					PlaySound("ui_target_set_fail")
				end
			else
				PlaySound("ui_target_set_fail")
			end
		end
	else
		PlaySound("ui_target_set_fail")
	end
end

function menu.target(component, allowfirstperson, fallbackcomponent)
	local refresh = false
	if component == nil then
		component = C.GetPickedMapComponent(menu.holomap)
		if not C.IsComponentClass(component, "sector") then
			if C.IsComponentClass(component, "object") or C.IsComponentClass(component, "highway") then
				menu.addSelectedComponent(component, true, true)
				refresh = true
			end
		else
			component = fallbackcomponent
		end
	end
	if component == nil then
		PlaySound("ui_target_set_fail")
		return
	end
	local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
	local targetsector = C.GetContextByClass(component, "sector", true)
	if C.IsComponentClass(component, "highway") then
		targetsector = C.ConvertStringTo64Bit(GetComponentData(ConvertStringToLuaID(tostring(component)), "sourcesector"))
	end
	if (not menu.mode) and (component ~= C.GetPlayerControlledShipID()) and (allowfirstperson or (not IsFirstPerson())) and ((targetsector == 0) or (playersector == targetsector)) then
		local success = C.SetSofttarget(component, "")
		if success then
			PlaySound("ui_target_set")
			if not menu.createInfoFrameRunning then
				menu.createInfoFrame()
			end
			return true
		else
			PlaySound("ui_target_set_fail")
		end
	else
		PlaySound("ui_target_set_fail")
	end
	if refresh then
		menu.refreshInfoFrame()
	end
	return false
end

function menu.openComm(component)
	menu.closeContextMenu()
	local entities = Helper.getSuitableControlEntities(component, true, true)
	if #entities == 1 then
		if menu.conversationMenu then
			Helper.closeMenuForSubConversation(menu, "default", entities[1], component)
		else
			Helper.closeMenuForNewConversation(menu, "default", entities[1], component)
		end
	else
		Helper.closeMenuForNewConversation(menu, "gMain_propertyResult", ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), component)
	end
	menu.cleanup()
end

function menu.openCommWithActor(actor)
	menu.closeContextMenu()
	if menu.conversationMenu then
		Helper.closeMenuForSubConversation(menu, "default", actor)
	else
		Helper.closeMenuForNewConversation(menu, "default", actor)
	end
	menu.cleanup()
end

function menu.openDetails(component)
	menu.infoTableMode = "info"
	menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(component))
	if not menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode.left) then
		menu.infoMode.left = "objectinfo"
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.filterTradeStorage(setting)
	local count = 0
	for i, option in ipairs(setting) do
		if menu.getFilterOption(option.id) then
			count = count + 1
		end
	end
	local transport = ffi.new("const char*[?]", count)
	local i = 0
	for _, option in ipairs(setting) do
		if menu.getFilterOption(option.id) then
			transport[i] = Helper.ffiNewString(option.param)
			i = i + 1
		end
	end

	C.SetMapTradeFilterByWareTransport(menu.holomap, transport, count)
end

function menu.filterTradeRelation(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "enemy" then
			if value then
				C.ClearMapTradeFilterByWillingToTradeWithPlayer(menu.holomap)
			else
				C.SetMapTradeFilterByWillingToTradeWithPlayer(menu.holomap)
			end
		end
	end
end

function menu.filterTradeWares(setting)
	local rawwarelist = menu.getFilterOption(setting.id) or {}
	local warelist = ffi.new("const char*[?]", #rawwarelist)
	for i, ware in ipairs(rawwarelist) do
		warelist[i - 1] = Helper.ffiNewString(ware)
	end
	if #rawwarelist > 0 then
		C.SetMapTradeFilterByWare(menu.holomap, warelist, #rawwarelist)
	else
		C.ClearMapTradeFilterByWare(menu.holomap)
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.filterTradePrice(setting)
	for _, option in ipairs(setting) do
		local value = menu.getFilterOption(option.id) or false
		if option.param == "maxprice" then
			C.SetMapTradeFilterByMaxPrice(menu.holomap, value)
		end
	end
end

function menu.filterTradeOffer(setting)
	for _, option in ipairs(setting) do
		local value = menu.getFilterOption(option.id) or false
		if option.param == "number" then
			C.SetMapTopTradesCount(menu.holomap, value)
		end
	end
end

function menu.filterTradeVolume(setting, override)
	for _, option in ipairs(setting) do
		if option.param == "volume" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id) or false
			end
			if value == 0 then
				C.ClearMapTradeFilterByMinTotalVolume(menu.holomap)
			else
				C.SetMapTradeFilterByMinTotalVolume(menu.holomap, value)
			end
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterTradePlayerOffer(setting, override)
	for _, option in ipairs(setting) do
		if option.param == "playeroffer_buy" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id) or 0
			end
			if value == 0 then
				C.ClearMapTradeFilterByPlayerOffer(menu.holomap, true)
			elseif value == 1 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, true, true)
			elseif value == 2 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, true, false)
			end
		elseif option.param == "playeroffer_sell" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id) or 0
			end
			if value == 0 then
				C.ClearMapTradeFilterByPlayerOffer(menu.holomap, false)
			elseif value == 1 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, false, true)
			elseif value == 2 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, false, false)
			end
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterThinkAlert(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "alert" then
			C.SetMapAlertFilter(menu.holomap, value)
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterThinkDiplomacy(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "factioncolor" then
			C.SetMapFactionRelationColorOption(menu.holomap, not value)
		elseif option.param == "highlightvisitors" then
			C.SetConfigSetting(option.param, value)
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterMining(value)
	for _, setting in ipairs(config.layersettings["layer_mining"]) do
		if value then
			setting.callback(setting)
		else
			setting.callback(setting, false)
		end
	end
end

function menu.filterMiningResources(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "display" then
			C.SetMapRenderResourceInfo(menu.holomap, value)
		end
	end
end

function menu.filterOther(value)
	for _, setting in ipairs(config.layersettings["layer_other"]) do
		if value then
			setting.callback(setting)
		else
			setting.callback(setting, false)
		end
	end
end

function menu.filterOtherStation(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "missions" then
			C.SetMapRenderMissionOffers(menu.holomap, value)
		elseif option.param == "civilian" then
			C.SetMapRenderCivilianShips(menu.holomap, value)
		end
	end
end

function menu.filterOtherShip(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "orderqueue" then
			C.SetMapRenderAllOrderQueues(menu.holomap, value)
		elseif option.param == "allyorderqueue" then
			C.SetMapRenderAllAllyOrderQueues(menu.holomap, value)
		end
	end
end

function menu.filterOtherMisc(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id) or false
		end
		if option.param == "ecliptic" then
			C.SetMapRenderEclipticLines(menu.holomap, value)
		elseif option.param == "wrecks" then
			C.SetMapRenderWrecks(menu.holomap, value)
		elseif option.param == "selectionlines" then
			C.SetMapRenderSelectionLines(menu.holomap, value)
		elseif option.param == "gateconnections" then
			C.SetMapRenderAllGateConnections(menu.holomap, value)
		elseif option.param == "opacity" then
			menu.refreshMainFrame = true
		elseif option.param == "coveroverride" then
			C.SetUICoverOverride(value)
			menu.refreshIF = getElapsedTime()
		elseif option.param == "rendersatelliteradarrange" then
			C.SetMapRenderSatelliteRadarRange(menu.holomap, value)
		end
	end
end

-- menu display
function menu.onShowMenu(state)
	-- Restore settings
	C.SetUICoverOverride(false)
	__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false

	-- Init variables
	menu.selectedcomponents = {}
	menu.borderOffset = Helper.frameBorder
	menu.sellShipsWidth = Helper.scaleX(300)
	menu.selectWidth = Helper.scaleX(260)
	menu.searchtext = {}
	menu.syncMapFilterWithConfig()
	menu.createLegend()
	menu.orderloopskill = C.GetOrderLoopSkillLimit() * 3
	menu.showMultiverse = false
	menu.onlineModeHintWidth = Helper.scaleX(600)

	-- Handle menu parameters
	menu.importMenuParameters()
	if menu.mode == nil then
		if state or menu.state then
			menu.onRestoreState(state or menu.state, state ~= nil)
			menu.state = nil
		end
	end
	if menu.initMultiverse then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "getVentures")
		end
		Helper.updateVenturePlatforms()

		menu.showMultiverse = true
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
		end
	else
		menu.showMultiverse = false
	end
	menu.initMultiverse = nil

	if (menu.infoTableMode ~= "plots") and (menu.mode ~= "selectCV") then
		menu.plotData = {}
	end

	-- main frame
	menu.editboxHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))

	menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	menu.sideBarOffsetX = menu.borderOffset
	menu.sideBarOffsetY = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + menu.borderOffset / 2 + menu.sideBarWidth + 2 * Helper.borderSize

	-- infoTable
	menu.infoTableWidth = Helper.playerInfoConfig.width - menu.sideBarWidth - 2 * Helper.borderSize
	menu.infoTableWidth = math.max(menu.infoTableWidth, 400)
	menu.infoTableOffsetX = menu.sideBarOffsetX + menu.sideBarWidth + 2 * Helper.borderSize
	menu.infoTableOffsetY = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + menu.borderOffset / 2

	-- searchfield
	menu.searchFieldData = {
		width = Helper.playerInfoConfig.width - menu.sideBarWidth - 2 * Helper.borderSize,
		offsetX = Helper.viewWidth - Helper.playerInfoConfig.width - menu.borderOffset,
		offsetY = menu.borderOffset,
	}

	-- map
	menu.rendertargetWidth = Helper.viewWidth
	menu.rendertargetHeight = Helper.viewHeight

	-- selected ships
	menu.selectedShipsTableData = {
		height = Helper.scaleY(20),
		width = Helper.scaleX(50),
		singleObjectWidth = Helper.scaleX(600),
		maxCols = 6,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		textHeight = Helper.scaleY(Helper.standardTextHeight),
	}

	-- trade rules
	Helper.updateTradeRules()

	-- Possible orders
	menu.orderdefs = {}
	menu.orderdefbyid = {}
	local orderdefs_skillsorted = {}
	local orderdefcategories_skillsorted = { mining = true }
	local orderdefs_forcedorderatfront = { "TradeRoutine_Basic", "TradeRoutine_Advanced" }
	
	local n = C.GetNumOrderDefinitions()
	local buf = ffi.new("OrderDefinition[?]", n)
	n = C.GetOrderDefinitions(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.id = ffi.string(buf[i].id)
		entry.name = ffi.string(buf[i].name)
		entry.description = ffi.string(buf[i].description)
		entry.category = ffi.string(buf[i].category)
		entry.categoryname = ffi.string(buf[i].categoryname)
		entry.infinite = buf[i].infinite
		entry.requiredSkill = buf[i].requiredSkill
		entry.loopable = C.IsOrderLoopable(entry.id)
		table.insert(menu.orderdefs, entry)
		menu.orderdefbyid[entry.id] = entry
		if (orderdefcategories_skillsorted[entry.category]) then
			table.insert(orderdefs_skillsorted, entry)
			--orderdefcategories_skillsorted[entry.category] = entry.categoryname
		end
	end
	table.sort(menu.orderdefs, Helper.sortName)
	table.sort(orderdefs_skillsorted, function (a, b) return a.requiredSkill < b.requiredSkill end)
	for i, orderid in ipairs(orderdefs_forcedorderatfront) do
		for j, entry in ipairs(menu.orderdefs) do
			if entry.id == orderid then
				table.insert(menu.orderdefs, i, entry)
				table.remove(menu.orderdefs, j + 1)
				break
			end
		end
	end

	menu.orderdefsbycategory = {}
	for _, orderdef in ipairs(menu.orderdefs) do
		if (not orderdefcategories_skillsorted[orderdef.category]) then
			if menu.orderdefsbycategory[orderdef.category] then
				table.insert(menu.orderdefsbycategory[orderdef.category], orderdef)
			else
				menu.orderdefsbycategory[orderdef.category] = { orderdef }
			end
		end
	end
	for _, orderdef in ipairs(orderdefs_skillsorted) do
		if menu.orderdefsbycategory[orderdef.category] then
			table.insert(menu.orderdefsbycategory[orderdef.category], orderdef)
		else
			menu.orderdefsbycategory[orderdef.category] = { orderdef }
		end
	end

	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	menu.sound_ambient = StartPlayingSound("ui_map_ambient")
	menu.displayMenu(true)

	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onMinimizeMenu()
	UnregisterAddonBindings("ego_detailmonitor")
	UnregisterEvent("updateHolomap", menu.updateHolomap)
	UnregisterEvent("info_updatePeople", menu.infoUpdatePeople)
	UnregisterEvent("mapfilter", menu.filterUpdate)
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.state = menu.onSaveState()
end

function menu.onRestoreMenu()
	if not menu.sound_ambient then
		menu.sound_ambient = StartPlayingSound("ui_map_ambient")
	end
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.selectedcomponents = {}
	menu.displayMenu()

	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		if not menu.showMultiverse then
			local mapstate = ffi.new("HoloMapState")
			C.GetMapState(menu.holomap, mapstate)
			state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
		else
			state.map = menu.normalMapCameraState
		end
	end

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
		if (key[1] == "focuscomponent") then
			if menu.holomap ~= 0 then
				local currentfocus = C.GetMapFocusComponent(menu.holomap)
				state[key[1]] = (currentfocus ~= 0) and currentfocus or nil
			end
		end
	end
	return state
end

function menu.onRestoreState(state, restorefromsubmenu)
	if (not menu.showMultiverse) and (not menu.initMultiverse) then
		if state.map then
			local offset = ffi.new("UIPosRot", {
				x = state.map.offset.x, 
				y = state.map.offset.y, 
				z = state.map.offset.z, 
				yaw = state.map.offset.yaw, 
				pitch = state.map.offset.pitch, 
				roll = state.map.offset.roll
			})
			menu.mapstate = ffi.new("HoloMapState", {
				offset = offset, 
				cameradistance = state.map.cameradistance
			})
		end
	else
		menu.normalMapCameraState = state.map
	end

	local focuscomponent = menu.focuscomponent
	local focusoffset = menu.focusoffset
	menu.focusoffset = nil

	for _, key in ipairs(config.stateKeys) do
		if key[2] == "UniverseID" then
			menu[key[1]] = ConvertStringTo64Bit(tostring(state[key[1]]))
			if menu[key[1]] == 0 then
				menu[key[1]] = nil
			end
		elseif key[2] == "bool" then
			if type(state[key[1]]) == "number" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		else
			menu[key[1]] = state[key[1]]
		end
	end

	-- check if stored focuscomponent still makes sense
	if menu.focuscomponent then
		if not IsValidComponent(menu.focuscomponent) then
			-- component is not valid anymore, keep default value
			menu.focuscomponent = focuscomponent
		elseif not CanViewLiveData(menu.focuscomponent) then
			-- component is not in view anymore, keep default value
			menu.focuscomponent = focuscomponent
		end
	end
	if (not restorefromsubmenu) and menu.param[4] then
		-- we are not restoring from a submenu but opened the map with this explizit parameter, keep the parameter
		menu.focuscomponent = focuscomponent
		menu.focusoffset = focusoffset
		menu.mapstate = nil
	end
	-- check if stored infoSubmenuObject still makes sense
	if menu.infoSubmenuObject then
		if not IsValidComponent(menu.infoSubmenuObject) then
			-- component is not valid anymore, keep default value
			menu.infoSubmenuObject = nil
		end
	end
	-- check selectedcomponents
	local remove = {}
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if not (IsValidComponent(selectedcomponent) and CanViewLiveData(selectedcomponent)) then
			table.insert(remove, id)
		end
	end
	for _, id in ipairs(remove) do
		menu.selectedcomponents[id] = nil
	end
	-- update venture platforms
	Helper.updateVenturePlatforms()
	-- set plot mode if necessary (only if we are restoring from a submenu now, see mail "#Observations# March 18th 2023 X4KE")
	if menu.infoTableMode == "plots" then
		if not restorefromsubmenu then
			menu.infoTableMode = "objectlist"
		else
			menu.updatePlotData("plots_new", true)
			menu.storeCurrentPlots()
			menu.mode = "selectbuildlocation"
		end
	end
	if menu.mode == "selectbuildlocation" then
		if not restorefromsubmenu then
			menu.mode = nil
		end
	end
end

function menu.displayMenu(firsttime)
	-- register lua events
	RegisterEvent("updateHolomap", menu.updateHolomap)
	RegisterEvent("info_updatePeople", menu.infoUpdatePeople)
	RegisterEvent("mapfilter", menu.filterUpdate)

	-- Register bindings
	RegisterAddonBindings("ego_detailmonitor", "map")
	RegisterAddonBindings("ego_detailmonitor", "comm")
	RegisterAddonBindings("ego_detailmonitor", "autopilot")
	RegisterAddonBindings("ego_detailmonitor", "undo")
	RegisterAddonBindings("ego_detailmonitor", "modes")

	menu.renderedComponents = {}

	menu.holomapcolor = Helper.getHoloMapColors()
	menu.prepareEconomyWares()

	-- create frames
	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	menu.activatemap = nil
	local curtime = getElapsedTime()
	menu.lastrefresh = curtime
	menu.lastHighlightCheck = curtime

	if menu.mode == "infomode" then
		menu.infoTableMode = menu.modeparam[1]

		if menu.infoTableMode == "info" then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(menu.modeparam[2]))
			menu.focuscomponent = menu.infoSubmenuObject
			if not menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode.left) then
				menu.infoMode.left = "objectinfo"
			end
			if menu.modeparam[3] then
				menu.extendedinfo = {}
				for _, loccategory in ipairs(menu.modeparam[3]) do
					menu.extendedinfo[loccategory .. "left"] = true
				end
			end
		elseif menu.infoTableMode == "mission" then
			if menu.modeparam[2] then
				menu.missionMode = menu.modeparam[2]
			end
			if menu.modeparam[3] then
				menu.missionModeCurrent = menu.modeparam[3]
			end
			if menu.modeparam[4] and (menu.modeparam[4] ~= 0) then
				menu.expandedMissionGroups[menu.modeparam[3]] = true
			end
		end

		menu.mode = nil
		menu.modeparam = {}

		if menu.infoTableMode == "plots" then
			menu.initPlotList()
			local station = "plots_new"
			if C.IsRealComponentClass(menu.focuscomponent, "station") then
				station = menu.focuscomponent
			end
			menu.updatePlotData(station, true)
			menu.storeCurrentPlots()
			menu.mode = "selectbuildlocation"
		end
	elseif menu.mode == "hire" then
		menu.infoTableMode = "propertyowned"
		menu.searchTableMode = "hire"
	elseif menu.mode == "sellships" then
		C.SetTrackedMenuFullscreen(menu.name, false)
		local ships = {}
		for _, ship in ipairs(menu.modeparam[2]) do
			table.insert(ships, ConvertIDTo64Bit(ship))
		end
		menu.contextMenuData = { shipyard = ConvertIDTo64Bit(menu.modeparam[1]), ships = ships, xoffset = menu.modeparam[3], yoffset = menu.modeparam[4] }
		menu.contextMenuMode = "sellships"
		menu.createContextFrame(menu.sellShipsWidth)
	elseif menu.mode == "selectCV" then
		menu.infoTableMode = "objectlist"
		menu.objectMode = "objectall"
		menu.propertyMode = "propertyall"
		table.insert(menu.searchtext, { text = ReadText(1014, 803), blockRemove = true })
		menu.focuscomponent = ConvertIDTo64Bit(menu.modeparam[1])
		menu.focusoffset = nil
		menu.layerBackup = {}
		for _, entry in ipairs(config.layers) do
			local oldvalue = __CORE_DETAILMONITOR_MAPFILTER[entry.mode]
			__CORE_DETAILMONITOR_MAPFILTER[entry.mode] = false
			menu.layerBackup[entry.mode] = oldvalue
		end
		menu.layerBackup["think_diplomacy_highlightvisitor"] = __CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"]
	elseif menu.mode == "selectComponent" then
		menu.infoTableMode = "objectlist"

		if menu.modeparam[3] == "deployables" then
			menu.objectMode = "deployables"
			menu.propertyMode = "deployables"
		end
	elseif menu.mode == "ventureconsole" then
		if C.AreVenturesCompatible() and (C.IsVentureSeasonSupported() or C.WasSessionOnline()) then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "getVentures")
			end
			Helper.updateVenturePlatforms()

			menu.showMultiverse = true
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
			end

			menu.mode = nil
			menu.modeparam = {}

			local isonline = Helper.isOnlineGame()
			if isonline then
				local operation = OnlineGetCurrentOperation()
				local currentteam = OnlineGetCurrentTeam()
				if operation.isvalid and currentteam.isvalid then
					menu.ventureMode = "ventureoperation"
				else
					menu.ventureMode = "ventureseason"
					menu.seasonMode.left = "currentseason"
				end
			end
		else
			menu.mode = nil
			menu.modeparam = {}
		end
	end
	
	if menu.mode == "tradecontext" then
		local shadyOnly = false
		if menu.modeparam[4] then
			shadyOnly = menu.modeparam[4] ~= 0
		end

		local loop = false
		if menu.modeparam[5] then
			loop = menu.modeparam[5]
		end

		local width, height
		if loop then
			menu.contextMenuMode = "tradeloop"
			menu.contextMenuData = { component = ConvertIDTo64Bit(menu.modeparam[1]), currentShip = ConvertIDTo64Bit(menu.modeparam[6]), orders = {}, xoffset = Helper.viewWidth / 2 - config.tradeLoopWidth / 2, yoffset = Helper.frameBorder, tradeModeHeight = config.tradeLoopWidth, loop = loop, reservecargo = true }
		
			width = config.tradeLoopWidth
		else
			menu.contextMenuMode = "trade"
			menu.contextMenuData = { component = ConvertIDTo64Bit(menu.modeparam[1]), currentShip = ConvertIDTo64Bit(menu.modeparam[2]), shadyOnly = shadyOnly, orders = {}, xoffset = Helper.viewWidth / 2 - config.tradeContextMenuWidth / 2, yoffset = Helper.frameBorder, wareexchange = menu.modeparam[3] ~= 0 }

			local numwarerows, numinforows = menu.initTradeContextData()
			menu.updateTradeContextDimensions(numwarerows, numinforows)

			if menu.contextMenuData.xoffset + menu.tradeContext.width > Helper.viewWidth - Helper.frameBorder then
				menu.contextMenuData.xoffset = Helper.viewWidth - menu.tradeContext.width - Helper.frameBorder
			end
			menu.contextMenuData.tradeModeHeight = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize
			if menu.contextMenuData.yoffset + menu.contextMenuData.tradeModeHeight > Helper.viewHeight - Helper.frameBorder then
				menu.contextMenuData.yoffset = Helper.viewHeight - menu.contextMenuData.tradeModeHeight - Helper.frameBorder
			end
			width = menu.tradeContext.width
			height = menu.contextMenuData.tradeModeHeight
		end

		menu.createMainFrame(nil, menu.contextMenuData.tradeModeHeight)

		menu.contextMenuData.yoffset = menu.contextMenuData.yoffset + menu.topLevelHeight
		menu.createContextFrame(width, height, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "boardingcontext" then
		-- accessing boarding menu from outside the map
		local width = Helper.viewWidth * 0.6
		local height = Helper.viewHeight * 0.7
		local xoffset = Helper.viewWidth * 0.2
		local yoffset = Helper.viewHeight * 0.15
		menu.closemapwithmenu = true
		menu.contextMenuMode = "boardingcontext"
		menu.contextMenuData = { target = menu.modeparam[1], boarders = menu.modeparam[2] }
		menu.createContextFrame(width, height, xoffset, yoffset)
	elseif menu.mode == "crewtransfercontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "crewtransfer"
		menu.contextMenuData = { leftShip = menu.modeparam[1], rightShip = menu.modeparam[2], extendedTier = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.crewTransferWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "dropwarescontext" then
		C.SetTrackedMenuFullscreen(menu.name, false)
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "dropwares"
		menu.contextMenuData = { mode = menu.modeparam[1], entity = ConvertStringTo64Bit(tostring(menu.modeparam[2])), xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y, wares = {} }

		if menu.contextMenuData.mode == "inventory" then
			local inventory = GetInventory(menu.contextMenuData.entity)
			local onlineitems = OnlineGetUserItems()

			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(menu.contextMenuData.wares, { ware = ware, name = entry.name, amount = entry.amount })
				end
			end
			table.sort(menu.contextMenuData.wares, Helper.sortName)
		end

		local height = (#menu.contextMenuData.wares + 5) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		if menu.contextMenuData.yoffset + height > Helper.viewHeight then
			menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
		end
		if menu.contextMenuData.xoffset + config.dropInventoryWidth > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - config.dropInventoryWidth - Helper.frameBorder
		end

		menu.createContextFrame(config.dropInventoryWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "renamecontext" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "rename"
		menu.contextMenuData = { component = menu.modeparam[1], fleetrename = menu.modeparam[2] ~= 0, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.renameWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "changelogocontext" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "changelogo"
		menu.contextMenuData = { component = menu.modeparam[1], origlogo = {}, currentlogo = {}, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local buf = C.GetCurrentFleetLogo(menu.contextMenuData.component)
		menu.contextMenuData.origlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }
		menu.contextMenuData.currentlogo = menu.contextMenuData.origlogo

		local width = Helper.scaleX(config.changeLogoWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "venturepatroninfo" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "venturepatron"
		menu.contextMenuData = { component = menu.modeparam[1], xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "venturereport" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "venturereport"
		menu.contextMenuData = { mode = "venturereport", submode = menu.modeparam[1], reason = menu.modeparam[2], timestamp = menu.modeparam[3], author = menu.modeparam[4], transactionid = menu.modeparam[5], userid = menu.modeparam[6], xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset, nil, false)
	else
		menu.createMainFrame(firsttime)

		if firsttime then
			if menu.infoTableMode then
				AddUITriggeredEvent(menu.name, menu.infoTableMode)
			end
		end
		menu.createInfoFrame()

		if menu.showMultiverse then
			local isonline = Helper.isOnlineGame()
			local operationRewardPending = Helper.hasVentureRewards()
			if C.IsVentureSeasonSupported() and (not isonline) then
				menu.contextMenuMode = "onlinemode"
				menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight }
				menu.createContextFrame(nil, nil, nil, nil, 0)
			elseif operationRewardPending then
				menu.contextMenuMode = "onlinereward"
				menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, rewardentries = OnlineGetLogbookRewards() }
				menu.createContextFrame(nil, nil, nil, nil, 0)
			end
		end
	end
end

-- create main frame (sideBar, navBar, map)
function menu.createMainFrame(firsttime, height, refresh)
	menu.createMainFrameRunning = true
	-- remove old data
	Helper.removeAllWidgetScripts(menu, config.mainFrameLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainFrameLayer,
		standardButtons = { back = true, close = true, minimize = (not menu.conversationMenu), help = true },
		standardButtonHelpOverlays = { help = "map_standardbutton_help" },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- player info
	menu.createPlayerInfo(menu.mainFrame, Helper.playerInfoConfig.width, Helper.playerInfoConfig.height, Helper.playerInfoConfig.offsetX, Helper.playerInfoConfig.offsetY)
	if menu.mode ~= "tradecontext" then
		if not menu.showMultiverse then
			-- search field
			menu.createSearchField(menu.mainFrame, menu.searchFieldData.width, 0, menu.searchFieldData.offsetX, menu.searchFieldData.offsetY, refresh)
		else
			Helper.clearTableConnectionColumn(menu, 3)
		end
		-- sideBar
		menu.createSideBar(firsttime, menu.mainFrame, menu.sideBarWidth, 0, menu.sideBarOffsetX, menu.sideBarOffsetY)
		if not menu.showMultiverse then
			-- rightBar
			menu.createRightBar(menu.mainFrame, menu.sideBarWidth, 0, Helper.viewWidth - menu.sideBarWidth - menu.borderOffset, menu.searchFieldData.offsetY)
			-- selected ships
			menu.createSelectedShips(menu.mainFrame)
		else
			Helper.clearTableConnectionColumn(menu, 4)
		end
	end
	-- top level
	menu.createTopLevel(menu.mainFrame)
	if menu.mode ~= "tradecontext" then
		-- map
		local alpha = 98
		if __CORE_DETAILMONITOR_MAPFILTER["other_misc_opacity"] then
			alpha = 100
		end
		menu.mainFrame:addRenderTarget({width = menu.rendertargetWidth, height = menu.rendertargetHeight, x = 0, y = 0, scaling = false, alpha = alpha, clear = false })
	end

	if menu.mode == "tradecontext" then
		menu.mainFrame.properties.backgroundID = "solid"
		menu.mainFrame.properties.backgroundColor = Helper.color.semitransparent
		if height then
			menu.mainFrame.properties.height = height + menu.topLevelHeight + 2 * Helper.frameBorder
		end
	end

	menu.mainFrame:display()
end

-- (re)create info frame (infoTable)
function menu.createInfoFrame()
	menu.createInfoFrameRunning = true
	menu.refreshed = true
	menu.noupdate = false

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoFrameLayer)

	-- infoTable
	local infoTableHeight = Helper.viewHeight - menu.infoTableOffsetY - menu.borderOffset

	menu.infoFrame = Helper.createFrameHandle(menu, {
		x = menu.infoTableOffsetX,
		y = menu.infoTableOffsetY,
		width = menu.infoTableWidth,
		height = infoTableHeight,
		layer = config.infoFrameLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = {},
		autoFrameHeight = true,
		helpOverlayID = "map_infoframe",
	})

	menu.autopilottarget = GetAutoPilotTarget()
	menu.softtarget = C.GetSofttarget().softtargetID
	menu.populateUpkeepMissionData()

	if (menu.infoTableMode ~= "info") and (menu.mode ~= "orderparam_object") then
		menu.infoTablePersistentData.left.cashtransferdetails = {}
		menu.infoTablePersistentData.left.drops = {}
		menu.infoTablePersistentData.left.crew.object = nil
		menu.infoTablePersistentData.left.macrostolaunch = {}
	end

	if menu.holomap ~= 0 then
		if menu.infoTableMode then
			C.SetMapStationInfoBoxMargin(menu.holomap, "left", menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder)
		else
			C.SetMapStationInfoBoxMargin(menu.holomap, "left", 0)
		end
	end

	Helper.clearTableConnectionColumn(menu, 2)

	local helpOverlayText = ""

	local infotabledesc, infotabledesc2
	menu.infoTableData = menu.infoTableData or {}
	menu.infoTableData.left = {}
	if menu.showMultiverse then
		if menu.ventureMode == "ventureseason" then
			if menu.seasonMode.left == "currentseason" then
				menu.createVentureSeason(menu.infoFrame, "left")
			elseif menu.seasonMode.left == "coalition" then
				Helper.callExtensionFunction("multiverse", "createVentureCoalition", menu, menu.infoFrame, "left")
			elseif menu.seasonMode.left == "ventureteam" then
				Helper.callExtensionFunction("multiverse", "createVentureTeam", menu, menu.infoFrame, "left")
			elseif menu.seasonMode.left == "pastseasons" then
				Helper.callExtensionFunction("multiverse", "createVenturePastSeasons", menu, menu.infoFrame, "left")
			end
		elseif menu.ventureMode == "ventureoperation" then
			Helper.callExtensionFunction("multiverse", "createVentureOperation", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "venturelogbook" then
			Helper.callExtensionFunction("multiverse", "createVentureLogbook", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "ventureinventory" then
			Helper.callExtensionFunction("multiverse", "createVentureInventory", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "venturecontacts" then
			Helper.callExtensionFunction("multiverse", "createVentureContacts", menu, menu.infoFrame, "left")
		else
			-- empty
			menu.infoFrame.properties.backgroundID = ""
			menu.infoFrame.properties.autoFrameHeight = false
			menu.infoFrame:addTable(0)
		end
	else
		if menu.infoTableMode == "objectlist" then
			infotabledesc, infotabledesc2 = menu.createObjectList(menu.infoFrame, "left")
		elseif menu.infoTableMode == "propertyowned" then
			infotabledesc = menu.createPropertyOwned(menu.infoFrame, "left")
		elseif menu.infoTableMode == "plots" then
			menu.createPlotMode(menu.infoFrame)
		elseif menu.infoTableMode == "info" then
			if menu.infoMode.left == "objectinfo" then
				menu.infoFrame.properties.autoFrameHeight = false
				menu.createInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectcrew" then
				menu.createCrewInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectloadout" then
				menu.createLoadoutInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectlogbook" then
				menu.createLogbookInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "orderqueue" then
				menu.createOrderQueue(menu.infoFrame, menu.infoMode.left, "left")
			elseif menu.infoMode.left == "orderqueue_advanced" then
				menu.createOrderQueue(menu.infoFrame, menu.infoMode.left, "left")
			elseif menu.infoMode.left == "standingorders" then
				menu.createStandingOrdersMenu(menu.infoFrame, "left")
			end
		elseif menu.infoTableMode == "missionoffer" then
			menu.createMissionMode(menu.infoFrame)
		elseif menu.infoTableMode == "mission" then
			menu.createMissionMode(menu.infoFrame)
		elseif menu.infoTableMode == "cheats" then
			menu.createCheats(menu.infoFrame)
		else
			-- empty

			-- kuertee start: callback
			-- menu.infoFrame.properties.backgroundID = ""
			-- menu.infoFrame.properties.autoFrameHeight = false
			-- menu.infoFrame:addTable(0)
			local isCreated = false
			if callbacks ["createInfoFrame_on_menu_infoTableMode"] then
				for _, callback in ipairs (callbacks ["createInfoFrame_on_menu_infoTableMode"]) do
					if callback (menu.infoFrame) then
						isCreated = true
					end
				end
			end
			if isCreated ~= true then
				menu.infoFrame.properties.backgroundID = ""
				menu.infoFrame.properties.autoFrameHeight = false
				menu.infoFrame:addTable(0)
			end
			-- kuertee end: callback

			-- start Forleyor_infoCenter callback:
			local isCreated = false
			if callbacks ["ic_createInfoFrame"] then
				for _, callback in ipairs (callbacks ["ic_createInfoFrame"]) do
					if callback (menu.infoFrame) then
						isCreated = true
					end
				end
			end
			if isCreated ~= true then
				menu.infoFrame:addTable(0)
			end
			-- end Forleyor_infoCenter callback:

		end

	end

	if menu.infoFrame then
		menu.infoFrame.properties.helpOverlayText = helpOverlayText
		menu.infoFrame:display()
	else
		-- create legacy info frame
		-- NOTE: descriptor table is {infotabledesc} if infotabledesc2 == nil
		Helper.displayFrame(menu, {infotabledesc, infotabledesc2}, false, "solid", "", {}, nil, config.infoFrameLayer, Helper.color.semitransparent, nil, false, true, nil, nil, menu.infoTableWidth, infoTableHeight, menu.infoTableOffsetX, menu.infoTableOffsetY)
	end

	if menu.holomap and (menu.holomap ~= 0) then
		menu.setSelectedMapComponents()
	end
end

-- create context frame
function menu.createContextFrame(width, height, xoffset, yoffset, noborder, startanimation)
	PlaySound("ui_positive_click")
	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)

	menu.contextMenuData = menu.contextMenuData or {}
	if width then
		menu.contextMenuData.width = width
	end
	if height then
		menu.contextMenuData.height = height
	end
	if xoffset then
		menu.contextMenuData.xoffset = xoffset
	end
	if yoffset then
		menu.contextMenuData.yoffset = yoffset
	end

	if menu.contextMenuData.xoffset + menu.contextMenuData.width + Helper.borderSize > Helper.viewWidth then
		menu.contextMenuData.width = Helper.viewWidth - menu.contextMenuData.xoffset - Helper.borderSize
	end

	local closeOnUnhandledClick = true
	if menu.contextMenuMode == "boardingcontext" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinemode" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinereward" then
		closeOnUnhandledClick = false
	end
	if menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		closeOnUnhandledClick = false
	end
	if menu.mode == "tradecontext" then
		closeOnUnhandledClick = false
	end

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - (noborder and 0 or 2 * Helper.borderSize),
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + (noborder and 0 or 2 * Helper.borderSize),
		layer = config.contextFrameLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		closeOnUnhandledClick = closeOnUnhandledClick,
		startAnimation = startanimation,
	})

	local adjustFrameHeight = true
	if menu.contextMenuMode == "neworder" then
		menu.createNewOrderContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "set_orderparam_ware" then
		menu.createOrderparamWareContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "set_orderparam_sector" then
		menu.createOrderparamSectorContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "filter_multiselectlist" then
		menu.createFilterparamWareContext(menu.contextFrame)
	elseif menu.contextMenuMode == "set_orderparam_formationshape" then
		menu.createOrderparamFormationShapeContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "trade" then
		menu.createTradeContext(menu.contextFrame)
	elseif menu.contextMenuMode == "tradeloop" then
		menu.createTradeLoopContext(menu.contextFrame)
	elseif menu.contextMenuMode == "mission" then
		menu.createMissionContext(menu.contextFrame)
	elseif menu.contextMenuMode == "boardingcontext" then
		menu.oldmode = menu.mode
		menu.mode = "boardingcontext"
		menu.oldInfoTableMode = menu.infoTableMode
		menu.infoTableMode = nil
		menu.refreshInfoFrame()
		menu.createBoardingContext(menu.contextFrame, menu.contextMenuData.target, menu.contextMenuData.boarders)
	elseif menu.contextMenuMode == "weaponconfig" then
		menu.createWeaponConfigContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "sellships" then
		menu.createSellShipsContext(menu.contextFrame)
	elseif menu.contextMenuMode == "select" then
		menu.createSelectContext(menu.contextFrame)
	elseif menu.contextMenuMode == "info_context" then
		menu.createInfoContext(menu.contextFrame)
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "crewtransfer" then
		menu.initCrewTransferData()
		menu.createCrewTransferContext(menu.contextFrame)
	elseif menu.contextMenuMode == "rename" then
		menu.createRenameContext(menu.contextFrame)
	elseif menu.contextMenuMode == "changelogo" then
		menu.createChangeLogoContext(menu.contextFrame)
	elseif menu.contextMenuMode == "userquestion" then
		menu.createUserQuestionContext(menu.contextFrame)
	elseif menu.contextMenuMode == "userquestion_multiverse" then
		Helper.callExtensionFunction("multiverse", "createUserQuestionContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "onlinemode" then
		local contexttable = menu.createOnlineModeContext(menu.contextFrame)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Helper.color.blue, width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
		menu.contextFrame.properties.standardButtons = {}
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "ventureconfig" then
		Helper.callExtensionFunction("multiverse", "showVentureConfigurationContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturecreateparty" then
		Helper.callExtensionFunction("multiverse", "createVentureCreatePartyContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturepatron" then
		Helper.callExtensionFunction("multiverse", "createVenturePatronContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturereport" then
		Helper.callExtensionFunction("multiverse", "createUserQuestionContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "ventureteammembercontext" then
		Helper.callExtensionFunction("multiverse", "createVentureTeamMemberContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturecontactcontext" then
		Helper.callExtensionFunction("multiverse", "createVentureContactContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturefriendlist" then
		Helper.callExtensionFunction("multiverse", "showVentureFriendListContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "hire" then
		menu.createHireContext(menu.contextFrame)
	elseif menu.contextMenuMode == "ventureoutcome" then
		Helper.callExtensionFunction("multiverse", "createVentureOutcomeContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "onlinereward" then
		local contexttable
		contexttable, menu.contextMenuData.allowClose = Helper.callExtensionFunction("multiverse", "createVentureRewardContext", menu, menu.contextFrame, menu.contextMenuData.instance)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		if not menu.contextMenuData.allowClose then
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Helper.color.orange, width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationRate = 360, rotationStart = 135, rotationDuration = 4, rotationInterval = 10 })
			menu.contextFrame.properties.standardButtons = {}
		else
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Helper.color.blue, width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
			menu.contextFrame.properties.standardButtonX = Helper.viewWidth - contexttable.properties.x - menu.onlineModeHintWidth - Helper.borderSize
			menu.contextFrame.properties.standardButtonY = contexttable.properties.y
		end
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	end
	
	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	if adjustFrameHeight then
		menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	end
	menu.contextFrame:display()
end

-- handle created frames
function menu.viewCreated(layer, ...)
	if layer == config.mainFrameLayer then
		if menu.mode ~= "tradecontext" then
			if menu.showMultiverse then
				menu.playerInfoTable, menu.sideBar, menu.topLevel, menu.map = ...
			else
				menu.playerInfoTable, menu.searchField, menu.sideBar, menu.rightBar, menu.selectedShipsTable, menu.topLevel, menu.map = ...
			end

			if menu.activatemap == nil then
				menu.activatemap = true
			end
		else
			menu.playerInfoTable, menu.topLevel = ...
		end
		menu.createMainFrameRunning = false
	elseif layer == config.infoFrameLayer then
		menu.infoTable, menu.infoTable2, menu.infoTable3 = ...
		
		menu.createInfoFrameRunning = false
	elseif layer == config.infoFrameLayer2 then
		menu.infoTableRight, menu.infoTableRight2, menu.infoTableRight3 = ...
		
		menu.createInfoFrame2Running = false
	elseif layer == config.contextFrameLayer then
		if menu.contextMenuMode == "neworder" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_ware" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_sector" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_formationshape" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "trade" then
			menu.contextshiptable, menu.contextbuttontable = ...
		elseif menu.contextMenuMode == "tradeloop" then
			menu.contextshiptable, menu.contextbuttontable = ...
		elseif menu.contextMenuMode == "mission" then
			menu.contextdesctable, menu.contextobjectivetable, menu.contextbottomtable = ...

			if menu.contextMenuData.isoffer then
				RegisterEvent("missionofferremoved", menu.onMissionOfferRemoved)
			else
				RegisterEvent("missionremoved", menu.onMissionRemoved)
			end
		elseif menu.contextMenuMode == "weaponconfig" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "sellships" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "select" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "crewtransfer" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "ventureconfig" then
			menu.contexttitletable, menu.contextmissiontable, menu.contextinfotable, menu.contextbuttontable, menu.contextrewardtable, menu.contextdescriptiontable = ...
		elseif menu.contextMenuMode == "hire" then
			menu.contexttable = ...
		end
	end

	-- clear descriptors again
	Helper.releaseDescriptors()
end

function menu.refreshContextFrame(setrow, setcol, noborder)
	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)

	local closeOnUnhandledClick = true
	if menu.contextMenuMode == "boardingcontext" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinemode" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinereward" then
		closeOnUnhandledClick = false
	end
	if menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		closeOnUnhandledClick = false
	end
	if menu.mode == "tradecontext" then
		closeOnUnhandledClick = false
	end

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - (noborder and 0 or 2 * Helper.borderSize),
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + (noborder and 0 or 2 * Helper.borderSize),
		layer = config.contextFrameLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		closeOnUnhandledClick = closeOnUnhandledClick,
	})
	
	local adjustFrameHeight = true
	if menu.contextMenuMode == "boardingcontext" then
		menu.contexttoprow = GetTopRow(menu.boardingtable_shipselection.id)
		menu.contextselectedrow = Helper.currentTableRow[menu.boardingtable_shipselection.id]

		menu.createBoardingContext(menu.contextFrame, menu.contextMenuData.target, menu.contextMenuData.boarders)
	elseif menu.contextMenuMode == "crewtransfer" then
		menu.contexttoprow = GetTopRow(menu.contexttable)
		menu.contextselectedrow = Helper.currentTableRow[menu.contexttable]

		menu.createCrewTransferContext(menu.contextFrame)
	elseif menu.contextMenuMode == "tradeloop" then
		menu.contextselectedrow = Helper.currentTableRow[menu.contextbuttontable]

		menu.createTradeLoopContext(menu.contextFrame)
	elseif menu.contextMenuMode == "ventureconfig" then
		menu.topRows.contextdescriptiontable = GetTopRow(menu.contextdescriptiontable)
		menu.selectedRows.contextdescriptiontable = setrow or Helper.currentTableRow[menu.contextdescriptiontable]
		menu.selectedCols.contextdescriptiontable = setcol or Helper.currentTableCol[menu.contextdescriptiontable]

		menu.topRows.contextinfotable = GetTopRow(menu.contextinfotable)
		menu.selectedRows.contextinfotable = setrow or Helper.currentTableRow[menu.contextinfotable]
		menu.selectedCols.contextinfotable = setcol or Helper.currentTableCol[menu.contextinfotable]

		menu.topRows.contextbuttontable = GetTopRow(menu.contextbuttontable)
		menu.selectedRows.contextbuttontable = Helper.currentTableRow[menu.contextbuttontable]
		menu.selectedCols.contextbuttontable = Helper.currentTableCol[menu.contextbuttontable]

		Helper.callExtensionFunction("multiverse", "showVentureConfigurationContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturecreateparty" then
		Helper.callExtensionFunction("multiverse", "createVentureCreatePartyContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "hire" then
		menu.createHireContext(menu.contextFrame)
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "ventureoutcome" then
		Helper.callExtensionFunction("multiverse", "createVentureOutcomeContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "onlinereward" then
		local contexttable
		contexttable, menu.contextMenuData.allowClose = Helper.callExtensionFunction("multiverse", "createVentureRewardContext", menu, menu.contextFrame, menu.contextMenuData.instance)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		if not menu.contextMenuData.allowClose then
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Helper.color.orange, width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationRate = 360, rotationStart = 135, rotationDuration = 4, rotationInterval = 10 })
			menu.contextFrame.properties.standardButtons = {}
		else
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Helper.color.blue, width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
			menu.contextFrame.properties.standardButtonX = Helper.viewWidth - contexttable.properties.x - menu.onlineModeHintWidth - Helper.borderSize
			menu.contextFrame.properties.standardButtonY = contexttable.properties.y
		end
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	end

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	if adjustFrameHeight then
		menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	end
	menu.contextFrame:display()
end

function menu.refreshInfoFrame(setrow, setcol, setrow2, setcol2)
	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	end
	if not menu.createInfoFrameRunning then
		menu.settoprow = menu.settoprow or GetTopRow(menu.infoTable)
		menu.topRows.infotableleft = menu.settoprow
		if menu.setplottoprow then
			menu.settoprow = menu.setplottoprow
			menu.setplottoprow = nil
		end
		local storerowinfo = true
		if not menu.showMultiverse then

			-- if (menu.infoTableMode ~= "objectlist") and (menu.infoTableMode ~= "propertyowned") and ((menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation")) then
			-- kuertee start: callback
			if (not string.find ("" .. tostring (menu.infoTableMode), "objectlist")) and (not string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) and ((menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation")) then
				-- kuertee end: callback

				storerowinfo = false
			end
		end
		if storerowinfo then
			menu.setrow = setrow or Helper.currentTableRow[menu.infoTable]
			menu.selectedRows.infotableleft = menu.setrow
			if menu.setplotrow then
				menu.setrow = menu.setplotrow
				menu.setplotrow = nil
			end
			menu.setcol = setcol or Helper.currentTableCol[menu.infoTable]
			menu.selectedCols.infotableleft = menu.setcol
		end

		menu.selectedRows.infotable2 = nil
		menu.selectedCols.infotable2 = nil
		if menu.infoTable2 then
			menu.selectedRows.infotable2 = setrow2 or Helper.currentTableRow[menu.infoTable2]
			menu.selectedCols.infotable2 = setcol2 or Helper.currentTableCol[menu.infoTable2]
		end
		if menu.infoTable3 then
			menu.topRows.infotable3left = GetTopRow(menu.infoTable3)
			menu.selectedRows.infotable3left = Helper.currentTableRow[menu.infoTable3]
		end
		if menu.orderHeaderTable and menu.lastactivetable == menu.orderHeaderTable.id then
			menu.selectedRows.orderHeaderTableleft = menu.selectedRows.orderHeaderTableleft or Helper.currentTableRow[menu.orderHeaderTable.id] or 1
			menu.selectedCols.orderHeaderTableleft = menu.selectedCols.orderHeaderTableleft or Helper.currentTableCol[menu.orderHeaderTable.id]
		end
		if menu.ventureSeasonHeaderTableLeft and menu.lastactivetable == menu.ventureSeasonHeaderTableLeft.id then
			menu.selectedRows.ventureSeasonHeaderTableleft = menu.selectedRows.ventureSeasonHeaderTableleft or Helper.currentTableRow[menu.ventureSeasonHeaderTableLeft.id] or 1
			menu.selectedCols.ventureSeasonHeaderTableleft = menu.selectedCols.ventureSeasonHeaderTableleft or Helper.currentTableCol[menu.ventureSeasonHeaderTableLeft.id]
		end
		if menu.ventureInventoryHeaderTableLeft and menu.lastactivetable == menu.ventureInventoryHeaderTableLeft.id then
			menu.selectedRows.ventureInventoryHeaderTableleft = menu.selectedRows.ventureInventoryHeaderTableleft or Helper.currentTableRow[menu.ventureInventoryHeaderTableLeft.id] or 1
			menu.selectedCols.ventureInventoryHeaderTableleft = menu.selectedCols.ventureInventoryHeaderTableleft or Helper.currentTableCol[menu.ventureInventoryHeaderTableLeft.id]
		end
		if menu.ventureContactsHeaderTableLeft and menu.lastactivetable == menu.ventureContactsHeaderTableLeft.id then
			menu.selectedRows.ventureContactsHeaderTableleft = menu.selectedRows.ventureContactsHeaderTableleft or Helper.currentTableRow[menu.ventureContactsHeaderTableLeft.id] or 1
			menu.selectedCols.ventureContactsHeaderTableleft = menu.selectedCols.ventureContactsHeaderTableleft or Helper.currentTableCol[menu.ventureContactsHeaderTableLeft.id]
		end
		if menu.missionModeHeaderTableLeft and menu.lastactivetable == menu.missionModeHeaderTableLeft.id then
			menu.selectedRows.missionModeHeaderTableleft = menu.selectedRows.missionModeHeaderTableleft or Helper.currentTableRow[menu.missionModeHeaderTableLeft.id] or 1
			menu.selectedCols.missionModeHeaderTableleft = menu.selectedCols.missionModeHeaderTableleft or Helper.currentTableCol[menu.missionModeHeaderTableLeft.id]
		end
		menu.createInfoFrame()
	end
	menu.refreshInfoFrame2()
end

function menu.refreshInfoFrame2(setrow, setcol)
	-- kuertee start: callback
	local isCreated = false
	if callbacks ["refreshInfoFrame2_on_start"] then
		for _, callback in ipairs (callbacks ["refreshInfoFrame2_on_start"]) do
			if callback () then
				isCreated = true
			end
		end
	end
	-- kuertee end: callback

	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	end
	if not menu.createInfoFrame2Running then
		menu.topRows.infotableright = menu.topRows.infotableright or GetTopRow(menu.infoTableRight)
		menu.selectedRows.infotableright = setrow or Helper.currentTableRow[menu.infoTableRight]
		menu.selectedCols.infotableright = setcol or Helper.currentTableCol[menu.infoTableRight]
		
		if menu.infoTableRight3 then
			menu.topRows.infotable3right = GetTopRow(menu.infoTableRight3)
			menu.selectedRows.infotable3right = Helper.currentTableRow[menu.infoTableRight3]
		end
		if menu.orderHeaderTableRight and menu.lastactivetable == menu.orderHeaderTableRight.id then
			menu.selectedRows.orderHeaderTableright = menu.selectedRows.orderHeaderTableright or Helper.currentTableRow[menu.orderHeaderTableRight.id] or 1
			menu.selectedCols.orderHeaderTableright = menu.selectedCols.orderHeaderTableright or Helper.currentTableCol[menu.orderHeaderTableRight.id]
		end
		if menu.ventureSeasonHeaderTableRight and menu.lastactivetable == menu.ventureSeasonHeaderTableRight.id then
			menu.selectedRows.ventureSeasonHeaderTableright = menu.selectedRows.ventureSeasonHeaderTableright or Helper.currentTableRow[menu.ventureSeasonHeaderTableRight.id] or 1
			menu.selectedCols.ventureSeasonHeaderTableright = menu.selectedCols.ventureSeasonHeaderTableright or Helper.currentTableCol[menu.ventureSeasonHeaderTableRight.id]
		end
		if menu.ventureInventoryHeaderTableRight and menu.lastactivetable == menu.ventureInventoryHeaderTableRight.id then
			menu.selectedRows.ventureInventoryHeaderTableright = menu.selectedRows.ventureInventoryHeaderTableright or Helper.currentTableRow[menu.ventureInventoryHeaderTableRight.id] or 1
			menu.selectedCols.ventureInventoryHeaderTableright = menu.selectedCols.ventureInventoryHeaderTableright or Helper.currentTableCol[menu.ventureInventoryHeaderTableRight.id]
		end
		if menu.ventureContactsHeaderTableRight and menu.lastactivetable == menu.ventureContactsHeaderTableRight.id then
			menu.selectedRows.ventureContactsHeaderTableright = menu.selectedRows.ventureContactsHeaderTableright or Helper.currentTableRow[menu.ventureContactsHeaderTableRight.id] or 1
			menu.selectedCols.ventureContactsHeaderTableright = menu.selectedCols.ventureContactsHeaderTableright or Helper.currentTableCol[menu.ventureContactsHeaderTableRight.id]
		end
		if menu.missionModeHeaderTableRight and menu.lastactivetable == menu.missionModeHeaderTableRight.id then
			menu.selectedRows.missionModeHeaderTableright = menu.selectedRows.missionModeHeaderTableright or Helper.currentTableRow[menu.missionModeHeaderTableRight.id] or 1
			menu.selectedCols.missionModeHeaderTableright = menu.selectedCols.missionModeHeaderTableright or Helper.currentTableCol[menu.missionModeHeaderTableRight.id]
		end
		menu.createInfoFrame2()
	end
end

function menu.extendSectionAndRefresh(rowdata)
	menu.extendModuleType(rowdata[2], rowdata[3])
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.updateMapAndInfoFrame()
end

function menu.getContainerNameAndColors(container, iteration, issquadleader, showScanLevel)
	local convertedContainer = ConvertIDTo64Bit(container)
	local isplayer, revealpercent, name, faction, icon, ismissiontarget, isonlineobject, isenemy, ishostile = GetComponentData(container, "isplayerowned", "revealpercent", "name", "owner", "icon", "ismissiontarget", "isonlineobject", "isenemy", "ishostile")
	local unlocked = IsInfoUnlockedForPlayer(container, "name")
	local usefactioncolor = false
	local highlightvisitors = false
	if menu.getFilterOption("layer_other") then
		usefactioncolor = menu.getFilterOption("think_diplomacy_factioncolor")
		highlightvisitors = menu.getFilterOption("think_diplomacy_highlightvisitor")
	end

	local name = Helper.unlockInfo(unlocked, name .. " (" .. ffi.string(C.GetObjectIDCode(convertedContainer)) .. ")") .. (((not showScanLevel) or isplayer) and "" or " (" .. revealpercent .. " %)")
	local font = Helper.standardFont
	local color = Helper.standardColor

	if faction == nil then
		if C.IsComponentClass(convertedContainer, "controllable") then
			DebugError("Found a controllable without a faction: " .. name)
		end
		usefactioncolor = false
	end

	local bgcolor = issquadleader and Helper.defaultSimpleBackgroundColor or Helper.color.transparent
	if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(convertedContainer)) then
		bgcolor = menu.darkgrey
	elseif (menu.mode == "selectCV") and C.IsBuilderBusy(convertedContainer) then
		name = "\27R" .. ReadText(1001, 7943) .. "\27X - " .. name
		color = menu.grey
	elseif (menu.mode == "selectComponent") and (not menu.checkForSelectComponent(convertedContainer)) then
		bgcolor = menu.darkgrey
	end

	if not menu.mode then 
		if convertedContainer == menu.softtarget then
			name = config.softtargetmarker_l .. name
			font = Helper.standardFontBold
		end
		if IsSameComponent(menu.autopilottarget, container) then
			name = config.autopilotmarker .. name
		end
	end

	if ismissiontarget then
		color = menu.holomapcolor.missioncolor
	elseif isonlineobject and highlightvisitors then
		color = menu.holomapcolor.visitorcolor
	elseif not unlocked then
		color = menu.grey
	elseif isplayer then
		if convertedContainer == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		else
			color = menu.holomapcolor.playercolor
		end
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	local factioncolor = ""
	if usefactioncolor then
		factioncolor = Helper.convertColorToText(GetFactionData(faction, "color"))
	end

	if IsComponentClass(container, "ship") or IsComponentClass(container, "station") then
		local iconid = icon
		if iconid and iconid ~= "" then
			if usefactioncolor then
				name = string.format("%s\027[%s]%s %s", factioncolor, iconid, Helper.convertColorToText(color), name)
			else
				name = string.format("\027[%s] %s", iconid, name)
			end
		end
	end
	local mouseover = "" --name
	for i = 1, iteration do
		name = "    " .. name
	end

	return name, color, bgcolor, font, mouseover, factioncolor
end

function menu.getFleetName(object64)
	if C.IsComponentClass(object64, "controllable") then
		local fleetname = ffi.string(C.GetFleetName(object64))
		if fleetname ~= "" then
			return fleetname
		end
	end
end

function menu.updateRenderedComponents()
	menu.renderedComponents = {}
	menu.renderedComponentsRef = {}
	if menu.holomap and (menu.holomap ~= 0) then
		Helper.ffiVLA(menu.renderedComponents, "UniverseID", C.GetNumMapRenderedComponents, C.GetMapRenderedComponents, menu.holomap)
		for i = #menu.renderedComponents, 1, -1 do
			local id = ConvertStringTo64Bit(tostring(menu.renderedComponents[i]))
			if IsValidComponent(id) then
				local ismasstraffic, isenemy, hull, purpose, ismodule, uirelation = GetComponentData(id, "ismasstraffic", "isenemy", "hullpercent", "primarypurpose", "ismodule", "uirelation")
				if ismasstraffic and (not isenemy) then
					table.remove(menu.renderedComponents, i)
				else
					menu.renderedComponents[i] = { id = id, name = ffi.string(C.GetComponentName(id)), fleetname = menu.getFleetName(id), objectid = ismodule and "" or ffi.string(C.GetObjectIDCode(id)), class = ffi.string(C.GetComponentClass(id)), hull = hull, purpose = purpose, relation = uirelation }
					menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(id))] = true
				end
			else
				table.remove(menu.renderedComponents, i)
			end
		end

		-- make sure the holomap is up before using the focuscomponent to init selectedcomponents
		if #menu.renderedComponents > 0 then
			if menu.focuscomponent then
				menu.infoTable = nil
				menu.highlightedbordercomponent = nil
				menu.highlightedbordermoduletype = nil
				menu.highlightedplannedmodule = nil
				menu.highlightedbordersection = nil
				menu.highlightedborderstationcategory = nil
				menu.selectedstationcategory = nil
				menu.highlightedconstruction = nil
				menu.selectedconstruction = nil
				menu.selectedfleetcommander = nil
				if menu.selectfocuscomponent then
					menu.addSelectedComponent(menu.focuscomponent)
					menu.selectfocuscomponent = nil
				end
				menu.focuscomponent = nil
			end
		end
	end

	-- Always show target component
	local softtarget = ConvertStringTo64Bit(tostring(C.GetSofttarget().softtargetID))
	if softtarget ~= 0 then
		if not menu.renderedComponentsRef[softtarget] then
			local hull, purpose, uirelation, sector = GetComponentData(softtarget, "hullpercent", "primarypurpose", "uirelation", "sector")
			table.insert(menu.renderedComponents, { id = softtarget, name = ffi.string(C.GetComponentName(softtarget)), fleetname = menu.getFleetName(softtarget), objectid = C.IsComponentClass(softtarget, "object") and ffi.string(C.GetObjectIDCode(softtarget)) or "", class = ffi.string(C.GetComponentClass(softtarget)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
			menu.renderedComponentsRef[softtarget] = true
		end
	end

	-- Always show selected components
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsValidComponent(selectedcomponent) then
			if not menu.renderedComponentsRef[selectedcomponent] then
				local hull, purpose, uirelation, sector = GetComponentData(selectedcomponent, "hullpercent", "primarypurpose", "uirelation", "sector")
				table.insert(menu.renderedComponents, { id = selectedcomponent, name = ffi.string(C.GetComponentName(selectedcomponent)), fleetname = menu.getFleetName(selectedcomponent), objectid = C.IsComponentClass(selectedcomponent, "object") and ffi.string(C.GetObjectIDCode(selectedcomponent)) or "", class = ffi.string(C.GetComponentClass(selectedcomponent)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
				menu.renderedComponentsRef[selectedcomponent] = true
			end
		end
	end

	table.sort(menu.renderedComponents, menu.componentSorter(menu.objectSorterType))
end

function menu.componentSorter(sorttype)
	local sorter = Helper.sortNameAndObjectID
	if sorttype == "nameinverse" then
		sorter = function (a, b) return Helper.sortNameAndObjectID(a, b, true) end
	elseif sorttype == "class" then
		sorter = Helper.sortShipsByClassAndPurpose
	elseif sorttype == "classinverse" then
		sorter = function (a, b) return Helper.sortShipsByClassAndPurpose(a, b, true) end
	elseif sorttype == "hull" then
		sorter = Helper.sortHullAndName
	elseif sorttype == "hullinverse" then
		sorter = function (a, b) return Helper.sortHullAndName(a, b, true) end
	elseif sorttype == "relation" then
		sorter = Helper.sortRelationAndName
	elseif sorttype == "relationinverse" then
		sorter = function (a, b) return Helper.sortRelationAndName(a, b, true) end
	elseif sorttype == "sector" then
		sorter = Helper.sortNameSectorAndObjectID
	elseif sorttype == "sectorinverse" then
		sorter = function (a, b) return Helper.sortNameSectorAndObjectID(a, b, true) end

	-- kuertee start: add sort by distance
	elseif sorttype == "distance_from_player" then
		sorter = menu.sortDistanceFromPlayer
	elseif sorttype == "distance_from_playerinverse" then
		sorter = function (a, b) return menu.sortDistanceFromPlayer (a, b, true) end
	elseif sorttype == "distance_from_object" then
		sorter = menu.sortDistanceFromObject
	elseif sorttype == "distance_from_objectinverse" then
		sorter = function (a, b) return menu.sortDistanceFromObject (a, b, true) end
	-- kuertee end: add sort by distance

	end
	return sorter
end

function menu.sortComponentListHelper(components, sorter)
	local sortedComponents = {}
	for _, component in ipairs(components) do
		local component64 = ConvertStringTo64Bit(tostring(component))
		local hull, purpose, uirelation, sector = GetComponentData(component64, "hullpercent", "primarypurpose", "uirelation", "sector")
		table.insert(sortedComponents, { id = component64, name = ffi.string(C.GetComponentName(component64)), fleetname = menu.getFleetName(component64), objectid = C.IsComponentClass(component64, "object") and ffi.string(C.GetObjectIDCode(component64)) or "", class = ffi.string(C.GetComponentClass(component64)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
	end
	table.sort(sortedComponents, menu.componentSorter(sorter))
	local returnvalue = {}
	for _, entry in ipairs(sortedComponents) do
		table.insert(returnvalue, ConvertStringToLuaID(tostring(entry.id)))
	end
	return returnvalue
end

function menu.isObjectValid(object)
	if not C.IsComponentClass(object, "ship") and not (C.IsRealComponentClass(object, "station") and (not C.IsComponentWrecked(object))) and not GetComponentData(object, "isdeployable") and not C.IsComponentClass(object, "lockbox") then
		return false
	elseif C.IsComponentClass(object, "controllable") and C.IsUnit(object) then
		return false
	elseif (not C.IsObjectKnown(object)) or (not GetComponentData(ConvertStringTo64Bit(tostring(object)), "isradarvisible")) then
		return false
	end
	return true
end

function menu.getShipIconWidth()
	local numbertext = "99"
	local minWidthPercent = 0.028

	local textheight = math.ceil(C.GetTextHeight("99", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), Helper.viewWidth))
	local textwidth = math.ceil(C.GetTextWidth("99", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize)))

	return math.max(minWidthPercent * menu.infoTableWidth, math.max(textheight, textwidth))
end

-- Object List

function menu.createObjectList(frame, instance)
	local infoTableData = menu.infoTableData[instance]

	-- TODO: Move to config table?
	infoTableData.maxIcons = 5
	infoTableData.shipIconWidth = menu.getShipIconWidth()
	local maxicons = infoTableData.maxIcons

	local objecttable = frame:addTable(5 + maxicons, { tabOrder = 1, multiSelect = true })
	objecttable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	objecttable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	objecttable:setDefaultCellProperties("icon",   { height = config.mapRowHeight })
	objecttable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })
	--  [+/-] [Object Name] [Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N] [Shield/Hull Bar]
	objecttable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	objecttable:setColWidthMinPercent(2, 20)
	objecttable:setColWidthMinPercent(4, 10)
	for i = 1, maxicons do
		objecttable:setColWidth(5 + i - 1, infoTableData.shipIconWidth, false)
	end
	objecttable:setColWidth(5 + maxicons, infoTableData.shipIconWidth, false)
	objecttable:setDefaultBackgroundColSpan(2, 4 + maxicons)

	-- title section
	local onlysectorallowed
	if menu.currentsector and (menu.currentsector ~= 0) then	
		-- title
		menu.title = ReadText(20001, 201) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(menu.currentsector))
		infoTableData.ownerDetails = C.GetOwnerDetails(menu.currentsector)

		if menu.mode == "orderparam_object" then
			local sectorallowed = false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = menu.checkForOrderParamObject(menu.currentsector)
							onlysectorallowed = #menu.modeparam[2].inputparams.class == 1
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end
			
			local row = objecttable:addRow(sectorallowed, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(4):createText(menu.title, Helper.headerRowCenteredProperties)
			row[5]:setColSpan(1 + maxicons):createButton({ active = sectorallowed, height = Helper.headerRow1Height, mouseOverText = ReadText(1001, 3228) }):setText(ReadText(1001, 3102), { halign = "center" })
			row[5].handlers.onClick = menu.buttonSelectSector
		else
			local row = objecttable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5 + maxicons):createText(menu.title, Helper.headerRowCenteredProperties)
		end

		-- owner
		if ffi.string(infoTableData.ownerDetails.factionIcon) ~= "" then
			local locsectorname = ffi.string(infoTableData.ownerDetails.factionName)
			if C.IsContestedSector(menu.currentsector) then
				locsectorname = locsectorname .. " " .. ReadText(1001, 3247)
			end
			
			local row = objecttable:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
			local sector64 = ConvertStringTo64Bit(tostring(menu.currentsector))
			row[1]:createIcon(function () return GetComponentData(sector64, "ownericon") end)
			row[2]:setColSpan(4 + maxicons):createText(locsectorname)
		end
	end

	-- object section
	infoTableData.playerStations = { }
	infoTableData.npcStations = { }
	infoTableData.moduledata = { }
	infoTableData.playerShips = { }
	infoTableData.npcShips = { }
	infoTableData.deployables = { }
	infoTableData.subordinates = { }
	infoTableData.dockedships = { }
	infoTableData.constructions = { }

	menu.updateRenderedComponents()
	local numdisplayed = 0
	local maxvisibleheight

	if not onlysectorallowed then
		for _, entry in ipairs(menu.renderedComponents) do
			local id = entry.id
			local convertedID = ConvertStringToLuaID(tostring(id))
			if menu.isObjectValid(id) then
				if menu.mode == "selectCV" then
					if C.IsComponentClass(id, "ship") and GetComponentData(convertedID, "primarypurpose") == "build" then
						if GetComponentData(convertedID, "isplayerowned") then
							table.insert(infoTableData.playerShips, convertedID)
						else
							table.insert(infoTableData.npcShips, convertedID)
						end
					end
				else
					if GetComponentData(convertedID, "isdeployable") or C.IsComponentClass(id, "lockbox") then
						table.insert(infoTableData.deployables, convertedID)
					elseif C.IsComponentClass(id, "ship") or C.IsRealComponentClass(id, "station") then
						-- Determine subordinates that may appear in the menu
						local subordinates = {}
						if C.IsComponentClass(id, "controllable") then
							subordinates = GetSubordinates(convertedID)
						end
						for i = #subordinates, 1, -1 do
							local subordinate = ConvertIDTo64Bit(subordinates[i])
							if not menu.isObjectValid(subordinate) then
								table.remove(subordinates, i)
							elseif menu.renderedComponentsRef[subordinate] then
								subordinates.hasRendered = true
							end
						end
						infoTableData.subordinates[tostring(convertedID)] = subordinates

						local dockedships = {}
						if C.IsComponentClass(id, "container") then
							Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, id, nil)
						end
						for i = #dockedships, 1, -1 do
							local convertedID = ConvertStringToLuaID(tostring(dockedships[i]))
							local commander = GetCommander(convertedID)
							if (not commander) or (not menu.renderedComponentsRef[ConvertIDTo64Bit(commander)]) then
								dockedships[i] = convertedID
							else
								table.remove(dockedships, i)
							end
						end
						infoTableData.dockedships[tostring(convertedID)] = dockedships

						if C.IsComponentClass(id, "ship") then
							local commander = GetCommander(convertedID)
							local isdocked = GetComponentData(convertedID, "isdocked")
							local dockcontainer = C.GetContextByClass(id, "container", false)
							if (not commander) or (not menu.renderedComponentsRef[ConvertIDTo64Bit(commander)]) then
								if (not isdocked) or (not menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(dockcontainer))]) then
									if GetComponentData(convertedID, "isplayerowned") then
										table.insert(infoTableData.playerShips, convertedID)
									else
										table.insert(infoTableData.npcShips, convertedID)
									end
								end
							end
						elseif C.IsRealComponentClass(id, "station") then
							local isplayerowned = GetComponentData(convertedID, "isplayerowned")
							if isplayerowned then
								table.insert(infoTableData.playerStations, convertedID)
							else
								table.insert(infoTableData.npcStations, convertedID)
							end

							local constructions = {}
							local constructionshipsbymacro = {}
							-- builds in progress
							local n = C.GetNumBuildTasks(id, 0, true, false)
							local buf = ffi.new("BuildTaskInfo[?]", n)
							n = C.GetBuildTasks(buf, n, id, 0, true, false)
							for i = 0, n - 1 do
								table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
							end
							if #constructions > 0 then
								table.insert(constructions, { empty = true })
							end
							-- other builds
							local n = C.GetNumBuildTasks(id, 0, false, false)
							local buf = ffi.new("BuildTaskInfo[?]", n)
							n = C.GetBuildTasks(buf, n, id, 0, false, false)
							for i = 0, n - 1 do
								local component = buf[i].component
								local macro = ffi.string(buf[i].macro)
								if (component == 0) and (macro ~= "") then
									if constructionshipsbymacro[macro] then
										constructions[constructionshipsbymacro[macro]].amount = constructions[constructionshipsbymacro[macro]].amount + 1
										table.insert(constructions[constructionshipsbymacro[macro]].ids, buf[i].id)
									else
										table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
										constructionshipsbymacro[macro] = #constructions
									end
								else
									table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
								end
							end
							infoTableData.constructions[tostring(convertedID)] = constructions
						end
					end
				end
			end
		end
	
		maxvisibleheight = objecttable:getFullHeight()
		if menu.mode ~= "selectCV" then
			if (menu.objectMode == "stations") or (menu.objectMode == "objectall") then
				numdisplayed = menu.createPropertySection(instance, "ownedstations", objecttable, ReadText(1001, 3276), infoTableData.playerStations, "-- " .. ReadText(1001, 33) .. " --", true, numdisplayed, nil, menu.objectSorterType)
			end
		end
		if (menu.objectMode == "ships") or (menu.objectMode == "objectall") then
			numdisplayed = menu.createPropertySection(instance, "ownedships", objecttable, ReadText(1001, 8301), infoTableData.playerShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
		end
		if menu.mode ~= "selectCV" then
			if (menu.objectMode == "stations") or (menu.objectMode == "objectall") then
				numdisplayed = menu.createPropertySection(instance, "npcstations", objecttable, ReadText(1001,8302), infoTableData.npcStations, "-- " .. ReadText(1001, 33) .. " --", true, numdisplayed, nil, menu.objectSorterType)
			end
		end
		if (menu.objectMode == "ships") or (menu.objectMode == "objectall") then
			numdisplayed = menu.createPropertySection(instance, "npcships", objecttable, ReadText(1001,8303), infoTableData.npcShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
		end
		if menu.mode ~= "selectCV" then
			if menu.objectMode == "deployables" then
				numdisplayed = menu.createPropertySection(instance, "deployables", objecttable, ReadText(1001, 1332), infoTableData.deployables, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
			end
		end
	end

	if numdisplayed > 50 then
		objecttable.properties.maxVisibleHeight = maxvisibleheight + 50 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	end

	menu.numFixedRows = objecttable.numfixedrows

	menu.settoprow = ((not menu.settoprow) or (menu.settoprow == 0)) and ((menu.setrow and menu.setrow > 31) and (menu.setrow - 27) or 3) or menu.settoprow
	objecttable:setTopRow(menu.settoprow)
	if menu.infoTable then
		local result = GetShiftStartEndRow(menu.infoTable)
		if result then
			objecttable:setShiftStartEnd(table.unpack(result))
		end
	end
	objecttable:setSelectedRow(menu.sethighlightborderrow or menu.setrow)
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.sethighlightborderrow = nil

	local tabtable
	local maxNumCategoryColumns =  math.floor(menu.infoTableWidth / (menu.sideBarWidth + Helper.borderSize))
	if maxNumCategoryColumns > Helper.maxTableCols then
		maxNumCategoryColumns = Helper.maxTableCols
	end
	local numOfSorterColumns = 4 -- "sort by", "size", "name", "hull"
	local colSpanPerSorterColumn = math.floor(maxNumCategoryColumns / numOfSorterColumns)
	tabtable = frame:addTable(maxNumCategoryColumns, { tabOrder = 2, reserveScrollBar = false })
	if maxNumCategoryColumns > 0 then
		for i = 1, maxNumCategoryColumns do
			tabtable:setColWidth(i, menu.sideBarWidth, false)
		end
		local diff = menu.infoTableWidth - maxNumCategoryColumns * (menu.sideBarWidth + Helper.borderSize)
		tabtable:setColWidth(maxNumCategoryColumns, menu.sideBarWidth + diff, false)
		-- object list categories row
		local row = tabtable:addRow("property_tabs", { fixed = true, bgColor = Helper.color.transparent })
		local rowCount = 1
		if #config.objectCategories > 0 then
			for i, entry in ipairs(config.objectCategories) do
				if i / maxNumCategoryColumns > rowCount then
					row = tabtable:addRow("property_tabs", { fixed = true, bgColor = Helper.color.transparent })
					rowCount = rowCount + 1
				end
				local bgcolor = Helper.defaultTitleBackgroundColor
				local color = Helper.color.white
				if entry.category == menu.objectMode then
					bgcolor = Helper.defaultArrowRowBackgroundColor
				end
				local active = true
				if menu.mode == "selectCV" then
					active = entry.category == "objectall"
				elseif (menu.mode == "selectComponent") and (menu.modeparam[3] == "deployables") then
					active = entry.category == "deployables"
					if active and (menu.selectedCols.propertytabs == nil) then
						menu.selectedCols.propertytabs = i
					end
				end
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns]:createButton({ height = menu.sideBarWidth, width = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText, active = active }):setIcon(entry.icon, { color = color})
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns].handlers.onClick = function () return menu.buttonObjectSubMode(entry.category, i) end
			end
		end
		local row = tabtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		-- sorter row
		-- "sort by"
		row[1]:setColSpan(colSpanPerSorterColumn):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		local buttonheight = Helper.scaleY(config.mapRowHeight)
		-- "size"
		local sorterColumn = 2
		local tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 8026), { halign = "center", scaling = true })
		if menu.objectSorterType == "class" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "classinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("class") end
		-- "name"
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 2809), { halign = "center", scaling = true })
		if menu.objectSorterType == "name" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "nameinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("name") end
		-- "hull"
		sorterColumn = 4
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 1), { halign = "center", scaling = true })
		if menu.objectSorterType == "hull" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "hullinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("hull") end
		-- "relation"
		local row = tabtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		sorterColumn = 2
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 7749), { halign = "center", scaling = true })
		if menu.objectSorterType == "relation" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "relationinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("relation") end
	end

	tabtable:setSelectedRow(menu.selectedRows.propertytabs or menu.selectedRows.infotable2 or 0)
	tabtable:setSelectedCol(menu.selectedCols.propertytabs or Helper.currentTableCol[menu.infoTable2] or 0)
	menu.selectedRows.propertytabs = nil
	menu.selectedCols.propertytabs = nil

	objecttable.properties.y = tabtable.properties.y + tabtable:getFullHeight() + Helper.borderSize

	tabtable:addConnection(1, 2, true)
	objecttable:addConnection(2, 2)
end

-- Property Owned

function menu.createPropertyOwned(frame, instance)
	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_start"] then
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	local infoTableData = menu.infoTableData[instance]

	-- TODO: Move to config table?
	infoTableData.maxIcons = 5
	infoTableData.shipIconWidth = menu.getShipIconWidth()
	local maxicons = infoTableData.maxIcons

	local ftable = frame:addTable(5 + maxicons, { tabOrder = 1, multiSelect = true })
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	--  [+/-] [Object Name][Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N] [Shield/Hull Bar]
	ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setDefaultBackgroundColSpan(2, 4 + maxicons)
	ftable:setColWidthMinPercent(2, 14)
	ftable:setColWidthMinPercent(4, 5)
	for i = 1, maxicons do
		ftable:setColWidth(5 + i - 1, infoTableData.shipIconWidth, false)
	end
	ftable:setColWidth(5 + maxicons, infoTableData.shipIconWidth, false)

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(5 + maxicons):createText(ReadText(1001, 1000), Helper.headerRowCenteredProperties)

	infoTableData.stations = { }
	infoTableData.fleetLeaderShips = { }
	infoTableData.unassignedShips = { }
	infoTableData.constructionShips = { }
	infoTableData.inventoryShips = { }
	infoTableData.deployables = { }
	infoTableData.subordinates = { }
	infoTableData.dockedships = { }
	infoTableData.constructions = { }
	infoTableData.moduledata = { }

	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_init_infoTableData"] then
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_init_infoTableData"]) do
			callback (infoTableData)
		end
	end
	-- kuertee end: callback

	local onlineitems = {}
	if menu.propertyMode == "inventoryships" then
		onlineitems = OnlineGetUserItems()
	end

	local playerobjects = {}
	if Helper.isPlayerCovered() and (not C.IsUICoverOverridden()) then
		playerobjects[1] = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	else
		playerobjects = GetContainedObjectsByOwner("player")
	end
	for i = #playerobjects, 1, -1 do
		local object = playerobjects[i]
		local object64 = ConvertIDTo64Bit(object)
		if menu.isObjectValid(object64) then
			local hull, purpose, uirelation, sector = GetComponentData(object, "hullpercent", "primarypurpose", "uirelation", "sector")
			playerobjects[i] = { id = object, name = ffi.string(C.GetComponentName(object64)), fleetname = menu.getFleetName(object64), objectid = ffi.string(C.GetObjectIDCode(object64)), class = ffi.string(C.GetComponentClass(object64)), hull = hull, purpose = purpose, relation = uirelation, sector = sector }
		else
			table.remove(playerobjects, i)
		end
	end

	table.sort(playerobjects, menu.componentSorter(menu.propertySorterType))

	for _, entry in ipairs(playerobjects) do
		local object = entry.id
		local object64 = ConvertIDTo64Bit(object)
		-- Determine subordinates that may appear in the menu
		local subordinates = {}
		if C.IsComponentClass(object64, "controllable") then
			subordinates = GetSubordinates(object)
		end
		for i = #subordinates, 1, -1 do
			local subordinate = subordinates[i]
			if not menu.isObjectValid(ConvertIDTo64Bit(subordinate)) then
				table.remove(subordinates, i)
			end
		end
		subordinates.hasRendered = #subordinates > 0
		infoTableData.subordinates[tostring(object)] = subordinates
		-- Find docked ships
		local dockedships = {}
		if C.IsComponentClass(object64, "container") then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, object64, nil)
		end
		for i = #dockedships, 1, -1 do
			local convertedID = ConvertStringToLuaID(tostring(dockedships[i]))
			local loccommander = GetCommander(convertedID)
			if not loccommander then
				dockedships[i] = convertedID
			else
				table.remove(dockedships, i)
			end
		end
		infoTableData.dockedships[tostring(object)] = dockedships
		-- Check if object is station, fleet leader or unassigned
		local commander
		if C.IsComponentClass(object64, "controllable") then
			commander = GetCommander(object)
		end
		if not commander then
			if C.IsRealComponentClass(object64, "station") then
				table.insert(infoTableData.stations, object)
			elseif GetComponentData(object, "isdeployable") or C.IsComponentClass(object64, "lockbox") then
				table.insert(infoTableData.deployables, object)
			elseif #subordinates > 0 then
				table.insert(infoTableData.fleetLeaderShips, object)
			else
				table.insert(infoTableData.unassignedShips, object)
			end
		end

		if C.IsRealComponentClass(object64, "station") then
			local constructions = {}
			local constructionshipsbymacro = {}
			-- builds in progress
			local n = C.GetNumBuildTasks(object64, 0, true, false)
			local buf = ffi.new("BuildTaskInfo[?]", n)
			n = C.GetBuildTasks(buf, n, object64, 0, true, false)
			for i = 0, n - 1 do
				table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
			end
			if #constructions > 0 then
				table.insert(constructions, { empty = true })
			end
			-- other builds
			local n = C.GetNumBuildTasks(object64, 0, false, false)
			local buf = ffi.new("BuildTaskInfo[?]", n)
			n = C.GetBuildTasks(buf, n, object64, 0, false, false)
			for i = 0, n - 1 do
				local component = buf[i].component
				local macro = ffi.string(buf[i].macro)
				if (component == 0) and (macro ~= "") then
					if constructionshipsbymacro[macro] then
						constructions[constructionshipsbymacro[macro]].amount = constructions[constructionshipsbymacro[macro]].amount + 1
						table.insert(constructions[constructionshipsbymacro[macro]].ids, buf[i].id)
					else
						table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
						constructionshipsbymacro[macro] = #constructions
					end
				else
					table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
				end
			end
			infoTableData.constructions[tostring(object)] = constructions
		elseif C.IsComponentClass(object64, "ship") then
			if menu.propertyMode == "inventoryships" then
				local pilot = ConvertIDTo64Bit(GetComponentData(object, "assignedpilot"))
				if pilot and (pilot ~= C.GetPlayerID()) then
					local inventory = GetInventory(pilot)
					if next(inventory) then
						local sortedWares = {}
						for ware, entry in pairs(inventory) do
							local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
							if (not ispersonalupgrade) and (not onlineitems[ware]) then
								table.insert(infoTableData.inventoryShips, object)
								break
							end
						end
					end
				end
			end

			-- kuertee start: callback
			if callbacks ["createPropertyOwned_on_add_ship_infoTableData"] then
				for _, callback in ipairs (callbacks ["createPropertyOwned_on_add_ship_infoTableData"]) do
					callback (infoTableData, object)
				end
			end
			-- kuertee end: callback

		end
	end

	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_add_other_objects_infoTableData"] then
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_add_other_objects_infoTableData"]) do
			result = callback (infoTableData)
			if result then
				infoTableData = result.infoTableData
			end
		end
	end
	-- kuertee end: callback

	local constructionshipsbymacro = {}
	local n = C.GetNumPlayerShipBuildTasks(true, false)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetPlayerShipBuildTasks(buf, n, true, false)
	for i = 0, n - 1 do
		local factionid = ffi.string(buf[i].factionid)
		if factionid == "player" then
			table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
		end
	end
	if #infoTableData.constructionShips > 0 then
		table.insert(infoTableData.constructionShips, { empty = true })
	end
	local n = C.GetNumPlayerShipBuildTasks(false, false)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetPlayerShipBuildTasks(buf, n, false, false)
	for i = 0, n - 1 do
		local factionid = ffi.string(buf[i].factionid)
		if factionid == "player" then
			local component = buf[i].component
			local macro = ffi.string(buf[i].macro)
			if (component == 0) and (macro ~= "") then
				if constructionshipsbymacro[macro] then
					infoTableData.constructionShips[constructionshipsbymacro[macro]].amount = infoTableData.constructionShips[constructionshipsbymacro[macro]].amount + 1
					table.insert(infoTableData.constructionShips[constructionshipsbymacro[macro]].ids, buf[i].id)
				else
					table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
					constructionshipsbymacro[macro] = #infoTableData.constructionShips
				end
			else
				table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
			end
		end
	end

	local numdisplayed = 0
	local maxvisibleheight = ftable:getFullHeight()
	if menu.mode ~= "selectCV" then
		if (menu.propertyMode == "stations") or (menu.propertyMode == "propertyall") then
			numdisplayed = menu.createPropertySection(instance, "ownedstations", ftable, ReadText(1001, 8379), infoTableData.stations, "-- " .. ReadText(1001, 33) .. " --", menu.mode ~= "hire", numdisplayed, nil, menu.propertySorterType)
		end
	end
	if (menu.propertyMode == "fleets") or (menu.propertyMode == "propertyall") then
		numdisplayed = menu.createPropertySection(instance, "ownedfleets", ftable, ReadText(1001, 8326), infoTableData.fleetLeaderShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)			-- {1001,8326} = Fleets
	end
	if (menu.propertyMode == "unassignedships") or (menu.propertyMode == "propertyall") then
		numdisplayed = menu.createPropertySection(instance, "ownedships", ftable, ReadText(1001, 8327), infoTableData.unassignedShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)	-- {1001,8327} = Unassigned Ships
	end
	if menu.propertyMode == "inventoryships" then
		numdisplayed = menu.createPropertySection(instance, "inventoryships", ftable, ReadText(1001, 8381), infoTableData.inventoryShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, true, menu.propertySorterType)	-- {1001,8327} = Ships with Inventory
	end
	if (menu.propertyMode == "unassignedships") or (menu.propertyMode == "propertyall") then
		-- construction rows do not use the shield/hull bar widget
		menu.createConstructionSection(instance, "constructionships", ftable, ReadText(1001, 8328), infoTableData.constructionShips)
	end
	if menu.mode ~= "selectCV" then
		if menu.propertyMode == "deployables" then
			numdisplayed = menu.createPropertySection(instance, "owneddeployables", ftable, ReadText(1001, 1332), infoTableData.deployables, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)
		end
	end

	-- kuertee start: callback
	if callbacks ["createPropertyOwned_on_createPropertySection_unassignedships"] then
		local result
		for _, callback in ipairs (callbacks ["createPropertyOwned_on_createPropertySection_unassignedships"]) do
			result = callback (numdisplayed, instance, ftable, infoTableData)
			if result and result.numdisplayed > numdisplayed then
				numdisplayed = result.numdisplayed
			end
		end
	end
	-- kuertee end: callback

	if numdisplayed > 50 then
		ftable.properties.maxVisibleHeight = maxvisibleheight + 50 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	end

	menu.numFixedRows = ftable.numfixedrows

	menu.settoprow = ((not menu.settoprow) or (menu.settoprow == 0)) and ((menu.setrow and menu.setrow > 31) and (menu.setrow - 27) or 3) or menu.settoprow
	ftable:setTopRow(menu.settoprow)
	if menu.infoTable then
		local result = GetShiftStartEndRow(menu.infoTable)
		if result then
			ftable:setShiftStartEnd(table.unpack(result))
		end
	end
	ftable:setSelectedRow(menu.sethighlightborderrow or menu.setrow)
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.sethighlightborderrow = nil

	local tabtable
	local maxNumCategoryColumns =  math.floor(menu.infoTableWidth / (menu.sideBarWidth + Helper.borderSize))
	if maxNumCategoryColumns > Helper.maxTableCols then
		maxNumCategoryColumns = Helper.maxTableCols
	end
	local numOfSorterColumns = 4 -- "sort by", "size", "name", "hull"
	local colSpanPerSorterColumn = math.floor(maxNumCategoryColumns / numOfSorterColumns)
	tabtable = frame:addTable(maxNumCategoryColumns, { tabOrder = 2, reserveScrollBar = false })
	if maxNumCategoryColumns > 0 then
		for i = 1, maxNumCategoryColumns do
			tabtable:setColWidth(i, menu.sideBarWidth, false)
		end
		local diff = menu.infoTableWidth - maxNumCategoryColumns * (menu.sideBarWidth + Helper.borderSize)
		tabtable:setColWidth(maxNumCategoryColumns, menu.sideBarWidth + diff, false)
		-- product categories row
		local row = tabtable:addRow("property_tabs", { fixed = true, bgColor = Helper.color.transparent })
		local rowCount = 1
		if #config.propertyCategories > 0 then
			for i, entry in ipairs(config.propertyCategories) do
				if i / maxNumCategoryColumns > rowCount then
					row = tabtable:addRow("property_tabs", { fixed = true, bgColor = Helper.color.transparent })
					rowCount = rowCount + 1
				end
				local bgcolor = Helper.defaultTitleBackgroundColor
				local color = Helper.color.white
				if entry.category == menu.propertyMode then
					bgcolor = Helper.defaultArrowRowBackgroundColor
				end
				local active = true
				if menu.mode == "hire" then
					active = entry.category ~= "deployables"
				elseif menu.mode == "selectCV" then
					active = entry.category == "propertyall"
				elseif (menu.mode == "selectComponent") and (menu.modeparam[3] == "deployables") then
					active = entry.category == "deployables"
					if active and (menu.selectedCols.propertytabs == nil) then
						menu.selectedCols.propertytabs = i
					end
				end
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns]:createButton({ height = menu.sideBarWidth, width = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText, active = active }):setIcon(entry.icon, { color = color})
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns].handlers.onClick = function () return menu.buttonPropertySubMode(entry.category, i) end
			end
		end
		local row = tabtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		-- sorter row
		-- "sort by"
		row[1]:setColSpan(colSpanPerSorterColumn):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		local buttonheight = Helper.scaleY(config.mapRowHeight)
		-- "size"
		local sorterColumn = 2
		local tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 8026), { halign = "center", scaling = true })
		if menu.propertySorterType == "class" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "classinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("class") end
		-- "name"
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 2809), { halign = "center", scaling = true })
		if menu.propertySorterType == "name" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "nameinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("name") end
		-- "hull"
		sorterColumn = 4
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 1), { halign = "center", scaling = true })
		if menu.propertySorterType == "hull" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "hullinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("hull") end
		-- "sector"
		local row = tabtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		sorterColumn = 2
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 11284), { halign = "center", scaling = true })
		if menu.propertySorterType == "sector" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "sectorinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("sector") end

		--kuertee start: add distance sorters
		-- "distance from player"
		local buttonLabel = ffi.string (C.GetPlayerName ())
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(buttonLabel, { halign = "center", scaling = true })
		if menu.propertySorterType == "distance_from_player" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "distance_from_playerinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("distance_from_player") end
		-- "distance from object"
		if menu.infoSubmenuObject then
			buttonLabel = ffi.string (C.GetObjectIDCode (menu.infoSubmenuObject))
			if buttonLabel == "" then
				buttonLabel = ffi.string (C.GetComponentName (menu.infoSubmenuObject))
			end
			sorterColumn = 4
			tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
			local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(buttonLabel, { halign = "center", scaling = true })
			if menu.propertySorterType == "distance_from_object" then
				button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
			elseif menu.propertySorterType == "distance_from_objectinverse" then
				button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
			end
			row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("distance_from_object") end
		end
		--kuertee end: add distance sorters
	end

	tabtable:setSelectedRow(menu.selectedRows.propertytabs or menu.selectedRows.infotable2 or 0)
	tabtable:setSelectedCol(menu.selectedCols.propertytabs or Helper.currentTableCol[menu.infoTable2] or 0)
	menu.selectedRows.propertytabs = nil
	menu.selectedCols.propertytabs = nil

	ftable.properties.y = tabtable.properties.y + tabtable:getFullHeight() + Helper.borderSize

	tabtable:addConnection(1, 2, true)
	ftable:addConnection(2, 2)
end

function menu.createPropertySection(instance, id, ftable, name, array, nonetext, showmodules, numdisplayed, hidesubordinates, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local row = ftable:addRow(false)
	row[1]:setColSpan(5 + maxicons):createText(name, Helper.headerRowCenteredProperties)

	if id == menu.highlightedbordersection then
		menu.sethighlightborderrow = row.index + 1
	end

	local prevnumdisplayed = numdisplayed
	if #array > 0 then
		for _, component in ipairs(array) do
			numdisplayed = menu.createPropertyRow(instance, ftable, component, 0, nil, showmodules, hidesubordinates, numdisplayed, sorter)
		end
	end
	if numdisplayed == prevnumdisplayed then
		row = ftable:addRow(id, { bgColor = Helper.color.transparent, interactive = false })
		row[2]:setColSpan(4 + maxicons):createText(nonetext)
	end

	return numdisplayed
end

function menu.getOrderInfo(ship, gettargetname)
	local isplayerowned, assignment, assignedpilot = GetComponentData(ship, "isplayerowned", "assignment", "assignedpilot")
	if not isplayerowned then
		return "", "", nil, "", false, nil, "", "", ""
	end

	local waiticon = ""
	local orderdefinition = ffi.new("OrderDefinition")
	if C.GetOrderDefinition(orderdefinition, "Wait") then
		waiticon = ffi.string(orderdefinition.icon)
	end

	local orders, defaultorder = {}, {}
	local n = C.GetNumOrders(ship)
	local buf = ffi.new("Order2[?]", n)
	n = C.GetOrders2(buf, n, ship)
	for i = 0, n - 1 do
		local order = {}
		order.state = ffi.string(buf[i].state)
		order.statename = ffi.string(buf[i].statename)
		order.orderdef = ffi.string(buf[i].orderdef)
		order.actualparams = tonumber(buf[i].actualparams)
		order.enabled = buf[i].enabled
		order.isinfinite = buf[i].isinfinite
		order.issyncpointreached = buf[i].issyncpointreached
		order.istemporder = buf[i].istemporder
		order.isoverride = buf[i].isoverride

		local orderdefinition = ffi.new("OrderDefinition")
		if order.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, order.orderdef) then
			order.orderdef = {}
			order.orderdef.id = ffi.string(orderdefinition.id)
			order.orderdef.icon = ffi.string(orderdefinition.icon)
			order.orderdef.name = ffi.string(orderdefinition.name)
			order.orderdef.description = ffi.string(orderdefinition.description)
		else
			order.orderdef = { id = "", icon = "", name = "", description = "" }
		end

		table.insert(orders, order)
	end

	local hasrealorders = false
	for _, order in ipairs(orders) do
		if order.enabled and (not order.istemporder) then
			hasrealorders = true
			break
		end
	end
	
	local buf = ffi.new("Order")
	if C.GetDefaultOrder(buf, ship) then
		defaultorder.state = ffi.string(buf.state)
		defaultorder.statename = ffi.string(buf.statename)
		defaultorder.orderdef = ffi.string(buf.orderdef)
		defaultorder.actualparams = tonumber(buf.actualparams)
		defaultorder.enabled = buf.enabled
		defaultorder.issyncpointreached = buf.issyncpointreached
		defaultorder.istemporder = buf.istemporder

		local orderdefinition = ffi.new("OrderDefinition")
		if defaultorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, defaultorder.orderdef) then
			defaultorder.orderdef = {}
			defaultorder.orderdef.id = ffi.string(orderdefinition.id)
			defaultorder.orderdef.icon = ffi.string(orderdefinition.icon)
			defaultorder.orderdef.name = ffi.string(orderdefinition.name)
			defaultorder.orderdef.description = ffi.string(orderdefinition.description)
		else
			defaultorder.orderdef = { id = "", icon = "", name = "", description = "" }
		end
	end

	local icon, name, description, color, isoverride, mouseovertext, targetname, behaviouricon, behaviourname, behaviourdescription = "", "", "", nil, false, nil, "", "", "", ""
	if #orders > 0 then
		-- there is an order
		local curindex = tonumber(C.GetOrderQueueCurrentIdx(ship))
		local order = orders[curindex]
		name = order.orderdef.name
		description = order.orderdef.description
		icon = order.orderdef.icon
		isoverride = order.isoverride
		-- change icon to wait if the order is in the wait part
		if (order.orderdef.id == "MoveWait") or (order.orderdef.id == "MoveToObject") or (order.orderdef.id == "DockAndWait") then
			if order.issyncpointreached then
				icon = waiticon
			end
		end
		-- if all orders are temp they were spawned by a defaultorder
		if not hasrealorders then
			color = Helper.color.blue
		end
		if gettargetname then
			local targets = {}
			Helper.ffiVLA(targets, "UniverseID", C.GetNumOrderLocationData, C.GetOrderLocationData, ship, curindex, false)
			if #targets == 1 then
				local target = targets[1]
				targetname = ffi.string(C.GetComponentName(target))
				if C.IsComponentClass(target, "ship") then
					targetname = targetname .. " (" .. ffi.string(C.GetObjectIDCode(target)) .. ")"
				end
			elseif #targets > 0 then
				targetname = ReadText(1001, 3424)
			end
		end
		-- if there are normal orders also return information about the default order
		if next(defaultorder) then
			-- there is a defaultorder
			behaviourname = defaultorder.orderdef.name
			behaviourdescription = defaultorder.orderdef.description
			behaviouricon = defaultorder.orderdef.icon
			if (defaultorder.orderdef.id == "Wait") then
				-- do not show Wait default order
				behaviouricon = ""
			elseif (defaultorder.orderdef.id == "MoveWait") or (defaultorder.orderdef.id == "MoveToObject") or (defaultorder.orderdef.id == "DockAndWait") then
				if defaultorder.issyncpointreached then
					-- do not show these default orders if they reached the wait part
					behaviouricon = ""
				end
			end
		end
	elseif next(defaultorder) then
		-- there is a defaultorder
		name = defaultorder.orderdef.name
		description = defaultorder.orderdef.description
		icon = defaultorder.orderdef.icon
		-- change icon to wait if the order is in the wait part
		if (defaultorder.orderdef.id == "MoveWait") or (defaultorder.orderdef.id == "MoveToObject") or (defaultorder.orderdef.id == "DockAndWait") then
			if defaultorder.issyncpointreached then
				icon = waiticon
			end
		end
		color = Helper.color.blue
		if gettargetname then
			local targets = {}
			Helper.ffiVLA(targets, "UniverseID", C.GetNumOrderLocationData, C.GetOrderLocationData, ship, 0, true)
			if #targets == 1 then
				local target = targets[1]
				targetname = ffi.string(C.GetComponentName(target))
				if C.IsComponentClass(target, "ship") then
					targetname = targetname .. " (" .. ffi.string(C.GetObjectIDCode(target)) .. ")"
				end
			elseif #targets > 0 then
				targetname = ReadText(1001, 3424)
			end
		end
	end

	if assignedpilot and (assignment == "assist") then
		-- if the ship is trying to mimic, but failed, mark the icon red
		local aicommandactionraw = GetComponentData(assignedpilot, "aicommandactionraw")
		if aicommandactionraw == "orderfailed" then
			color = Helper.color.red
			mouseovertext = ReadText(1026, 3268)
		end
	elseif C.HasControllableAnyOrderFailures(ship) then
		-- if the ship had any order failure, mark the icon orange
		color = Helper.color.warningorange
	end

	local texticon = ""
	if icon ~= "" then
		texticon = (color and Helper.convertColorToText(color) or "") .. "\27[" .. icon .. "]\27X"
	end
	local behaviourtexticon = ""
	if behaviouricon ~= "" then
		behaviourtexticon = Helper.convertColorToText(Helper.color.blue) .. "\27[" .. behaviouricon .. "]\27X"
	end
	return texticon, icon, color, name, description, isoverride, mouseovertext, targetname, behaviourtexticon, behaviouricon, behaviourname, behaviourdescription
end

function menu.overrideOrderIcon(normalcolor, usetext, icon, prefix, postfix)
	-- number between 0 and 1, duration 1s
	local x = getElapsedTime() % 1

	normalcolor = normalcolor or Helper.color.white
	overridecolor = Helper.color.red
	local color = {
		r = (1 - x) * overridecolor.r + x * normalcolor.r,
		g = (1 - x) * overridecolor.g + x * normalcolor.g,
		b = (1 - x) * overridecolor.b + x * normalcolor.b,
		a = (1 - x) * overridecolor.a + x * normalcolor.a,
	}
	if usetext then
		local colortext = Helper.convertColorToText(color) .. "\27[" .. icon .. "]\27X"
		return prefix .. colortext .. postfix
	else
		return color
	end
end

function menu.getModuleData(object64)
	local modules = {}
	local modulesByID = {}
	local n = C.GetNumStationModules(object64, false, false)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, object64, false, false)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		local type = GetModuleType(module)
		modulesByID[tostring(module)] = true
		if modules[type] then
			table.insert(modules[type], module)
		else
			modules[type] = { module }
		end
	end
	local n = C.GetNumPlannedStationModules(object64, false)
	local buf = ffi.new("UIConstructionPlanEntry[?]", n)
	n = C.GetPlannedStationModules(buf, n, object64, false)
	for i = 0, tonumber(n) - 1 do
		local module, type
		if buf[i].componentid ~= 0 then
			module = ConvertStringTo64Bit(tostring(buf[i].componentid))
			type = GetModuleType(module)
			if modulesByID[tostring(module)] then
				module = nil
				type = nil
			end
		else
			module = ffi.string(buf[i].macroid)
			type = GetModuleType(nil, module)
		end
		if module then
			if modules[type] then
				table.insert(modules[type], module)
			else
				modules[type] = { module }
			end
		end
	end
	return modules
end

function menu.createPropertyRow(instance, ftable, component, iteration, commanderlocation, showmodules, hidesubordinates, numdisplayed, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)] or {}
	local dockedships = menu.infoTableData[instance].dockedships[tostring(component)] or {}
	local constructions = menu.infoTableData[instance].constructions[tostring(component)] or {}
	local convertedComponent = ConvertStringTo64Bit(tostring(component))

	-- kuertee start: callback
	if callbacks ["createPropertyRow_on_init_vars"] then
		local result
		for _, callback in ipairs (callbacks ["createPropertyRow_on_init_vars"]) do
			result = callback (maxicons, subordinates, dockedships, constructions, convertedComponent, iteration)
			if result then
				maxicons = result.maxicons
				subordinates = result.subordinates
				dockedships = result.dockedships
				constructions = result.constructions
				convertedComponent = result.convertedComponent
				iteration = result.iteration
			end
		end
	end
	-- kuertee end: callback

	if (#menu.searchtext == 0) or Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(convertedComponent, numtexts, texts, true) end, "text") then
		if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(convertedComponent)) then
			return numdisplayed
		elseif (menu.mode == "selectComponent") and (not menu.checkForSelectComponent(convertedComponent)) then
			return numdisplayed
		end

		numdisplayed = numdisplayed + 1

		if (not menu.isPropertyExtended(tostring(component))) and (menu.isCommander(component) or menu.isConstructionContext(convertedComponent)) then
			menu.extendedproperty[tostring(component)] = true
		end
		if (not menu.isPropertyExtended(tostring(component))) and menu.isDockContext(convertedComponent) then

			-- if menu.infoTableMode ~= "propertyowned" then
			-- kuertee start: callback
			if not string.find (menu.infoTableMode, "propertyowned") then
				-- kuertee end: callback

				menu.extendedproperty[tostring(component)] = true
			end
		end

		local isstation = IsComponentClass(component, "station")
		local isdoublerow = (iteration == 0 and (isstation or #subordinates > 0))
		local name, color, bgcolor, font, mouseover, factioncolor = menu.getContainerNameAndColors(component, iteration, isdoublerow, false)
		local alertString = ""
		local alertMouseOver = ""
		if menu.getFilterOption("layer_other") then
			local alertStatus, missionlist = menu.getContainerAlertLevel(component)
			local minAlertLevel = menu.getFilterOption("think_alert")
			if (minAlertLevel ~= 0) and alertStatus >= minAlertLevel then
				local color = Helper.color.white
				if alertStatus == 1 then
					color = menu.holomapcolor.lowalertcolor
				elseif alertStatus == 2 then
					color = menu.holomapcolor.mediumalertcolor
				else
					color = menu.holomapcolor.highalertcolor
				end
				alertString = Helper.convertColorToText(color) .. "\027[workshop_error]\027X"
				alertMouseOver = ReadText(1001, 3305) .. ReadText(1001, 120) .. "\n" .. missionlist
			end
		end
		local location, locationtext, isdocked, aipilot, isplayerowned, isonlineobject, iscovered, isenemy, macro, isally = GetComponentData(component, "sectorid", "sector", "isdocked", "assignedaipilot", "isplayerowned", "isonlineobject", "iscovered", "isenemy", "macro", "isally")
		if isplayerowned and iscovered then
			alertString = alertString .. factioncolor .. "\27[menu_hidden]\27X"
		end

		if menu.mode == "selectCV" then
			if isenemy then
				mouseover = "\027R" .. ReadText(1026, 8014) .. "\027X"
			elseif C.IsBuilderBusy(convertedComponent) then
				mouseover = "\027R" .. ReadText(1001, 7939) .. "\027X"
			elseif not isplayerowned then
				local fee = tonumber(C.GetBuilderHiringFee())
				mouseover = ((fee > GetPlayerMoney()) and "\027R" or "\027G") .. ReadText(1001, 7940) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101) .. "\027X"
			end
		end

		local row = ftable:addRow({"property", component, nil, iteration}, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(component) })
		if (menu.getNumSelectedComponents() == 1) and menu.isSelectedComponent(component) then
			menu.setrow = row.index
		end
		if IsSameComponent(component, menu.highlightedbordercomponent) then
			menu.sethighlightborderrow = row.index
		end

		-- Set up columns
		--  [+/-] [Object Name] [Top Level Shield/Hull Bar] [Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N or Shield/Hull Bar]
		if showmodules or (subordinates.hasRendered and (not hidesubordinates)) or (#dockedships > 0) or (isstation and (#constructions > 0)) then
			row[1]:createButton({ scaling = false }):setText(menu.isPropertyExtended(tostring(component)) and "-" or "+", { scaling = true, halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendProperty(tostring(component)) end
		end

		local displaylocation = location and not (commanderlocation and IsSameComponent(location, commanderlocation))
		local currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext, behaviouricon, behaviourrawicon, behaviourname, behaviourdescription = "", "", nil, "", "", false, nil, "", "", "", ""
		if IsComponentClass(component, "ship") then
			currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext, _, behaviouricon, behaviourrawicon, behaviourname, behaviourdescription = menu.getOrderInfo(convertedComponent)
		end
		local fleettypes = IsComponentClass(component, "controllable") and menu.getPropertyOwnedFleetData(instance, component, maxicons) or {}

		if isplayerowned and isonlineobject then
			locationtext = Helper.convertColorToText(menu.holomapcolor.visitorcolor) .. ReadText(1001, 11231) .. "\27X"
			currentordericon = Helper.convertColorToText(menu.holomapcolor.visitorcolor) .. "\27[order_venture]\27X"
			currentorderrawicon = "order_waitforventure"
			currentordercolor = menu.holomapcolor.visitorcolor
			currentordername = ReadText(1001, 7868)
			currentordermouseovertext = nil
			isdocked = false
		end

		-- kuertee start: callback
		if callbacks ["createPropertyRow_on_set_locationtext"] then
			local result
			for i, callback in ipairs (callbacks ["createPropertyRow_on_set_locationtext"]) do
				result = callback (locationtext, component)
				if result.locationtext then
					locationtext = result.locationtext
				end
			end
		end
		-- kuertee end: callback

		local namecolspan = 1
		if menu.infoTableMode == "objectlist" then
			displaylocation = false
		end
		if not displaylocation then
			if (currentordericon ~= "") or isdocked then
				namecolspan = namecolspan + maxicons - 3
			else
				namecolspan = namecolspan + maxicons
			end
		end

		if isdoublerow then
			if isstation then
				-- station case
				local secondline = ""
				if displaylocation then
					secondline = locationtext
				end
				row[2]:setColSpan(4 + maxicons - #fleettypes - 1)
				local stationname = alertString .. Helper.convertColorToText(color) .. name .. "\27X"
				if alertMouseOver ~= "" then
					if mouseover ~= "" then
						mouseover = mouseover .. "\n\n"
					end
					mouseover = mouseover .. alertMouseOver
				end
				row[2]:createText(stationname .. "\n" .. secondline, { font = font, mouseOverText = mouseover })
			else
				-- fleet case
				local textheight = C.GetTextHeight(" \n ", font, Helper.scaleFont(font, config.mapFontSize), Helper.viewWidth)
				local icon = row[2]:setColSpan(4 + maxicons - #fleettypes - 1):createIcon("solid", { scaling = false, color = { r = 0, g = 0, b = 0, a = 1 }, height = textheight })
				
				local secondtext1 = ""
				local secondtext2 = ""
				if displaylocation or (currentordericon ~= "") or isdocked then
					if displaylocation then
						secondtext1 = locationtext
					end
					secondtext2 = (currentordericon ~= "") and currentordericon or ""
					if isdocked then
						secondtext2 = secondtext2 .. " \27[order_dockat]"
					end
					if behaviouricon ~= "" then
						secondtext2 = Helper.convertColorToText(Helper.color.blue) .. behaviouricon .. "\27X" .. secondtext2
					end
				end
				local secondtext1truncated = TruncateText(secondtext1, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx))
				local secondtext1width = C.GetTextWidth(secondtext1truncated, font, Helper.scaleFont(font, config.mapFontSize))
				local secondtext2width = C.GetTextWidth(secondtext2, font, Helper.scaleFont(font, config.mapFontSize))

				local fleetname = ffi.string(C.GetFleetName(convertedComponent))
				local shipname = alertString .. name
				local fleetnametruncated = TruncateText(fleetname, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx) - secondtext1width - Helper.scaleX(10))
				local shipnametruncated = TruncateText(shipname, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx) - secondtext2width - Helper.scaleX(10))

				local mouseovertext = ""
				if fleetnametruncated ~= fleetname then
					mouseovertext = mouseovertext .. fleetname
				end
				if shipnametruncated ~= shipname then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. alertString .. Helper.convertColorToText(color) .. name .. "\27X"
				end
				if secondtext1truncated ~= secondtext1 then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. secondtext1
				end
				-- skip adding when behaviouricon was ignored (case: behaviour == HoldPosition AND order ~= null)
				if behaviouricon ~= "" and behaviourname and behaviourname ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. behaviourname
				end
				-- skip adding when behaviouricon was ignored (case: behaviour == HoldPosition AND order ~= null)
				if behaviouricon ~= "" and behaviourdescription and behaviourdescription ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. Helper.indentText(behaviourdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont())
				end
				if currentordername ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. currentordername .. (currentordermouseovertext and ("\n\27R" .. currentordermouseovertext .. "\27X") or "")
				end
				if currentorderdescription and currentorderdescription ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. Helper.indentText(currentorderdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont())
				end
				if isdocked then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ReadText(1001, 3249)
				end
				if alertMouseOver ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n\n"
					end
					mouseovertext = mouseovertext .. alertMouseOver
				end
				icon.properties.mouseOverText = mouseovertext

				icon:setText(string.format("%s\n%s%s", fleetnametruncated, Helper.convertColorToText(color), shipnametruncated), { scaling = true, font = font, x = Helper.standardTextOffsetx })
				icon:setText2(currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, true, currentorderrawicon, secondtext1truncated .. "\n", isdocked and "\27[order_dockat]" or "") end or (secondtext1truncated .. "\n" .. secondtext2), { scaling = true, font = font, halign = "right", x = Helper.standardTextOffsetx })
			end
			-- fleet info
			for i, fleetdata in ipairs(fleettypes) do
				local colidx = 5 + maxicons - #fleettypes + i - 1
				if fleetdata.icon then
					row[colidx]:createText(string.format("\027[%s]\n%d", fleetdata.icon, fleetdata.count), { halign = "center", x = 0, color = fleetdata.color })
				else
					row[colidx]:createText(string.format("...\n%d", fleetdata.count), { halign = "center", x = 0 })
				end
			end
			-- shieldhullbar
			row[5 + maxicons]:createObjectShieldHullBar(component, { y = isstation and Helper.standardTextHeight / 2 or 1.5 * Helper.standardTextHeight })
		else
			-- unassigned ship case
			row[2]:setColSpan(namecolspan + 1)
			local indentation, actualname = string.match(name, "([ ]*)(.*)")
			local shipname = indentation .. alertString .. actualname
			if alertMouseOver ~= "" then
				if mouseover ~= "" then
					mouseover = mouseover .. "\n\n"
				end
				mouseover = mouseover .. alertMouseOver
			end

			-- kuertee start: callback
			-- row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
			if not callbacks ["createPropertyRow_override_row_shipname_createText"] then
				row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
			else
				local result
				for _, callback in ipairs (callbacks ["createPropertyRow_override_row_shipname_createText"]) do
					result = callback (shipname, { font = font, color = color, mouseOverText = mouseover }, component)
					if result then
						row[2]:createText(result.shipname, result.properties)
					end
				end
				if not result then
					row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
				end
			end
			-- kuertee end: callback

			-- location / order
			if displaylocation then
				local colspan = 5 + maxicons - 3 - namecolspan
				if currentordericon ~= "" then
					colspan = colspan - 1
				end
				if isdocked then
					colspan = colspan - 1
				end
				if behaviouricon ~= "" then
					colspan = colspan - 1
				end
				row[3 + namecolspan]:setColSpan(colspan)
				local locationtexttruncated = TruncateText(locationtext, font, Helper.scaleFont(font, config.mapFontSize), row[3 + namecolspan]:getColSpanWidth())
				local mouseovertext = ""
				if locationtexttruncated ~= locationtext then
					mouseovertext = locationtext
				end

				-- kuertee start: callback
				-- row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
				if not callbacks ["createPropertyRow_override_row_location_createText"] then
					row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
				else
					local result
					for _, callback in ipairs (callbacks ["createPropertyRow_override_row_location_createText"]) do
						result = callback (locationtext, {halign = "right", font = font, mouseOverText = mouseovertext, x = 0}, component)
						if result then
							row[3 + namecolspan]:createText(result.locationtext, result.properties)
						end
					end
					if not result then
						row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
					end
				end
				-- kuertee end: callback

			end
			if (currentordericon ~= "") or isdocked then
				local col = 4 + maxicons
				if isdocked then
					row[col]:createIcon("order_dockat", { width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = ReadText(1001, 3249) })
					col = col - 1
				end
				if currentordericon ~= "" then
					row[col]:createIcon(currentorderrawicon, { color = currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, false) end or currentordercolor, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = currentordername .. "\n" .. currentorderdescription .. (currentordermouseovertext and ("\n\27R" .. currentordermouseovertext .. "\27X") or "") })
					col = col - 1
				end
				if behaviouricon ~= "" then
					row[col]:createIcon(behaviourrawicon, { color = Helper.color.blue, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = behaviourname .. "\n" .. behaviourdescription })
					col = col - 1
				end
			end
			-- shieldhullbar
			row[5 + maxicons]:createObjectShieldHullBar(component)
		end

		if row[1].type == "button" then
			if isdoublerow and (not isstation) then
				row[1].properties.height = row[2]:getHeight()
			else
				row[1].properties.height = row[2]:getMinTextHeight(true)
			end
		end

		if IsComponentClass(component, "station") then
			AddKnownItem("stationtypes", macro)
		elseif IsComponentClass(component, "ship_xl") then
			AddKnownItem("shiptypes_xl", macro)
		elseif IsComponentClass(component, "ship_l") then
			AddKnownItem("shiptypes_l", macro)
		elseif IsComponentClass(component, "ship_m") then
			AddKnownItem("shiptypes_m", macro)
		elseif GetMacroData(macro, "islasertower") then
			AddKnownItem("lasertowers", macro)
		elseif IsComponentClass(component, "ship_s") then
			AddKnownItem("shiptypes_s", macro)
		elseif IsComponentClass(component, "ship_xs") then
			AddKnownItem("shiptypes_xs", macro)
		end

		if menu.isPropertyExtended(tostring(component)) then
			-- modules
			if showmodules then
				menu.createModuleSection(instance, ftable, component, iteration)
			end
			-- subordinates
			if subordinates.hasRendered and (not hidesubordinates) then
				numdisplayed = menu.createSubordinateSection(instance, ftable, component, isstation, iteration, location or commanderlocation, numdisplayed, sorter, isplayerowned, isally)
			end
			-- dockedships
			if #dockedships > 0 then
				local isdockedshipsextended = menu.isDockedShipsExtended(tostring(component), isstation)
				if (not isdockedshipsextended) and menu.isDockContext(convertedComponent) then

					-- kuertee start: callback
					-- if menu.infoTableMode ~= "propertyowned" then
					if not string.find (menu.infoTableMode, "propertyowned") then
						-- kuertee end: callback

						menu.extendeddockedships[tostring(component)] = true
						isdockedshipsextended = true
					end
				end

				local row = ftable:addRow({"dockedships", component}, { bgColor = Helper.color.transparent })
				row[1]:createButton():setText(isdockedshipsextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendDockedShips(tostring(component), isstation) end
				local text = ReadText(1001, 3265)
				for i = 1, iteration + 1 do
					text = "    " .. text
				end
				row[2]:setColSpan(3):createText(text)
				local numdockedplayerships = 0
				for _, dockedship in ipairs(dockedships) do
					local isplayerowned = GetComponentData(dockedship, "isplayerowned")
					if isplayerowned then
						numdockedplayerships = numdockedplayerships + 1
					end
				end
				if numdockedplayerships > 0 then
					row[5]:setColSpan(1 + maxicons):createText("\27[order_dockat] " .. numdockedplayerships, { halign = "right", color = menu.holomapcolor.playercolor })
				end
				if IsSameComponent(component, menu.highlightedbordercomponent) and (menu.highlightedborderstationcategory == "dockedships") then
					menu.sethighlightborderrow = row.index
				end
				if isdockedshipsextended then
					dockedships = menu.sortComponentListHelper(dockedships, sorter)
					for _, dockedship in ipairs(dockedships) do
						numdisplayed = menu.createPropertyRow(instance, ftable, dockedship, iteration + 2, location or commanderlocation, nil, true, numdisplayed, sorter)
					end
				end
			end
			if isstation then
				-- construction
				if #constructions > 0 then
					menu.createConstructionSubSection(ftable, component, constructions)
				end
			end
		end
	end

	return numdisplayed
end

function menu.createSubordinateSection(instance, ftable, component, isstation, iteration, location, numdisplayed, sorter, isplayerowned, isally)
	local maxicons = menu.infoTableData[instance].maxIcons
	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)] or {}
	subordinates = menu.sortComponentListHelper(subordinates, sorter)
	-- setup groups
	local groups = {}
	for _, subordinate in ipairs(subordinates) do
		local group = GetComponentData(subordinate, "subordinategroup")
		if group and group > 0 then
			if groups[group] then
				if (not groups[group].hasrendered) and (menu.infoTableMode == "objectlist") then
					groups[group].hasrendered = menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate)]
				end
				table.insert(groups[group].subordinates, subordinate)
			else
				local isrendered = true
				if menu.infoTableMode == "objectlist" then
					isrendered = menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate)]
				end
				groups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(ConvertIDTo64Bit(component), group)), subordinates = { subordinate }, hasrendered = isrendered }
			end
		end
	end

	for group = 1, 10 do
		if groups[group] and groups[group].hasrendered then
			local issubordinateextended = menu.isSubordinateExtended(tostring(component), group)
			if (not issubordinateextended) and menu.isCommander(component, group) then
				menu.extendedsubordinates[tostring(component) .. group] = true
				issubordinateextended = true
			end

			local row = ftable:addRow({"subordinates" .. tostring(component) .. group, component, group}, { bgColor = Helper.color.transparent })
			row[1]:createButton():setText(issubordinateextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendSubordinate(tostring(component), group) end
			local text = string.format(ReadText(1001, 8398), ReadText(20401, group))
			for i = 1, iteration + 1 do
				text = "    " .. text
			end
			row[2]:setColSpan(2):createText(text)

			local assignmenttext = config.assignments[groups[group].assignment] and config.assignments[groups[group].assignment].name or ""
			local groupiconstext = ""
			local groupmouseovertext = ""

			if isplayerowned or isally then
				groupmouseovertext = ReadText(1001, 5903) .. ReadText(1001, 120) .. " " .. assignmenttext -- Assignment: X
				local idlingshipstext = ReadText(1026, 3271) -- "%d ships waiting for orders."
				local idlingshipstext_singular = ReadText(1026, 3272) -- "1 ship waiting for orders."
				local awayshipstext = ReadText(1026, 3273) -- "%d ships in a different sector."
				local awayshipstext_singular = ReadText(1026, 3274) -- "1 ship in a different sector."

				-- group icons
				local shipstates = menu.getPropertyOwnedGroupIcons(instance, component, groups[group].subordinates)
				for i, shipstatedata in ipairs(shipstates) do
					if shipstatedata.icon and shipstatedata.count > 0 then
						groupiconstext = groupiconstext .. string.format("\027[%s]%d  ", shipstatedata.icon, shipstatedata.count)
						if (shipstatedata.name == "shipstate_idling") then
							if shipstatedata.count == 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. idlingshipstext_singular
							elseif shipstatedata.count > 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. string.format(idlingshipstext, shipstatedata.count)
							end
						elseif (shipstatedata.name == "shipstate_away") then
							if shipstatedata.count == 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. awayshipstext_singular
							elseif shipstatedata.count > 1 then
								groupmouseovertext = groupmouseovertext .. "\n" .. string.format(awayshipstext, shipstatedata.count)
							end
						end
					end
				end
				groupiconstext = groupiconstext .. assignmenttext
			else
				groupiconstext = assignmenttext
			end

			row[4]:setColSpan(maxicons + 2):createText(groupiconstext, { halign = "right", mouseOverText = groupmouseovertext })
			if menu.highlightedborderstationcategory == "subordinates" .. tostring(component) .. group then
				menu.sethighlightborderrow = row.index
			end
			if issubordinateextended then
				for _, subordinate in ipairs(groups[group].subordinates) do
					local isdocked, subordinategroup = GetComponentData(subordinate, "isdocked", "subordinategroup")
					local isexternaldock, parent
					if isdocked then
						isexternaldock = C.IsShipAtExternalDock(ConvertIDTo64Bit(subordinate))
						parent = C.GetContextByClass(ConvertIDTo64Bit(subordinate), "container", false)
					end

					if (menu.infoTableMode ~= "objectlist") or menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate)] or (isdocked and (not isexternaldock) and menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(parent))]) then
						numdisplayed = menu.createPropertyRow(instance, ftable, subordinate, iteration + 2, location, nil, nil, numdisplayed, sorter)
					end
				end
			end
		end
	end

	return numdisplayed
end

function menu.createModuleSection(instance, ftable, component, iteration)
	local moduledata = menu.getModuleData(ConvertStringTo64Bit(tostring(component)))
	local maxicons = menu.infoTableData[instance].maxIcons

	for _, moduletype in ipairs(config.moduletypes) do
		local modules = moduledata[moduletype.type] or {}
		if next(modules) then
			if (not menu.isModuleTypeExtended(component, moduletype.type)) then
				for _, module in ipairs(modules) do
					if menu.isSelectedComponent(module) then
						menu.extendModuleType(component, moduletype.type, true)
						break
					end
				end
			end

			local istypeextended = menu.isModuleTypeExtended(component, moduletype.type)

			local bgcolor = Helper.color.transparent
			if (menu.mode == "orderparam_object") then
				bgcolor = menu.darkgrey
			end

			local row = ftable:addRow({"moduletype", component, moduletype.type, iteration}, { bgColor = bgcolor })
			if IsSameComponent(component, menu.highlightedbordercomponent) and (moduletype.type == menu.highlightedbordermoduletype) then
				menu.sethighlightborderrow = row.index
			end

			row[1]:createButton():setText(istypeextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendModuleType(component, moduletype.type) end
			local moduleUnderConstruction
			for _, module in ipairs(modules) do
				if type(module) ~= "string" then
					if IsComponentConstruction(module) then
						moduleUnderConstruction = module
						break
					end
				end
			end

			if moduleUnderConstruction then
				row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "    " .. moduletype.name, moduleUnderConstruction) end)
				local buildingprocessor = GetComponentData(component, "buildingprocessor")
				local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
				row[5]:setColSpan(1 + maxicons):createText(function () return menu.getBuildTime(ConvertIDTo64Bit(buildingprocessor), moduleUnderConstruction, ismissingresources) end, { halign = "right", mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
			else
				row[2]:setColSpan(3):createText("    " .. moduletype.name)
			end

			if istypeextended then
				for _, module in ipairs(modules) do
					if type(module) == "string" then
						local name = GetMacroData(module, "name")
						local bgcolor = Helper.color.transparent
						if menu.mode == "orderparam_object" then
							bgcolor = menu.darkgrey
						end
						local row = ftable:addRow({"module", nil, moduletype.type, iteration, component, module}, { bgColor = bgcolor })

						if IsSameComponent(component, menu.highlightedbordercomponent) and (moduletype.type == menu.highlightedbordermoduletype) and (module == menu.highlightedplannedmodule) then
							menu.sethighlightborderrow = row.index
						end

						row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "        " .. name, 0) end, { color = color })
					else
						local moduleunlocked = isplayer or IsInfoUnlockedForPlayer(module, "name")

						local color = (not moduleunlocked) and menu.grey or nil
						local bgcolor = Helper.color.transparent
						if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(module)) then
							bgcolor = menu.darkgrey
						end

						local row = ftable:addRow({"module", ConvertStringToLuaID(tostring(module)), moduletype.type, iteration, component}, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(module) })
						if IsSameComponent(module, menu.highlightedbordercomponent) then
							menu.sethighlightborderrow = row.index
						end
						local name = moduleunlocked and ffi.string(C.GetComponentName(module)) or ReadText(1001, 3210)
						row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "        " .. name, module) end, { color = color })

						local isfunctional, ishacked = GetComponentData(module, "isfunctional", "ishacked")
						if IsComponentConstruction(module) then
							local buildingprocessor = GetComponentData(component, "buildingprocessor")
							local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
							row[5]:setColSpan(1 + maxicons):createText(function () return menu.getBuildTime(ConvertIDTo64Bit(buildingprocessor), module, ismissingresources) end, { halign = "right", color = color, mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
						else
							if not isfunctional then
								row[5]:setColSpan(maxicons):createText(ishacked and ("[" .. ReadText(1001, 4770) .. "]") or ("[" .. ReadText(1001, 11606) .. "]"), { halign = "right", color = Helper.color.warningorange })
							end
							row[5 + maxicons]:createObjectShieldHullBar(module)
						end
					end
				end
			end
		end
	end
end

function menu.createConstructionSubSection(ftable, component, constructions)
	for i, construction in ipairs(constructions) do
		if menu.isSelectedComponent(construction.component) then
			menu.extendedconstruction[tostring(component)] = true
		end
	end
	local isconstructionextended = menu.isConstructionExtended(tostring(component))
	local row = ftable:addRow({"constructions", component}, { bgColor = Helper.color.transparent })
	row[1]:createButton():setText(isconstructionextended and "-" or "+", { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonExtendConstruction(tostring(component)) end
	row[2]:setColSpan(3):createText("    " .. ReadText(1001, 3266))
	if IsSameComponent(component, menu.highlightedbordercomponent) and (menu.highlightedborderstationcategory == "constructions") then
		menu.sethighlightborderrow = row.index
	end
	if isconstructionextended then
		for i, construction in ipairs(constructions) do
			if construction.empty then
				ftable:addEmptyRow(config.mapRowHeight / 2)
			else
				menu.createConstructionRow(ftable, component, construction, 2)
			end
		end
	end
end

function menu.createConstructionSection(instance, id, ftable, name, constructions)
	if #constructions > 0 then
		local maxicons = menu.infoTableData[instance].maxIcons

		local row = ftable:addRow(false)
		row[1]:setColSpan(5 + maxicons):createText(name, Helper.headerRowCenteredProperties)

		if id == menu.highlightedbordersection then
			menu.sethighlightborderrow = row.index + 1
		end

		for i, construction in ipairs(constructions) do
			if construction.empty then
				ftable:addEmptyRow(config.mapRowHeight / 2)
			else
				local component = ConvertStringTo64Bit(tostring(construction.buildingcontainer))
				menu.createConstructionRow(ftable, component, construction, 1)
			end
		end
	end
end

function menu.createConstructionRow(ftable, component, construction, iteration)
	local name = ReadText(20109, 5101)
	if construction.component ~= 0 then
		name = ffi.string(C.GetComponentName(construction.component))
	elseif construction.macro ~= "" then
		name = GetMacroData(construction.macro, "name")
		if construction.amount then
			name = construction.amount .. ReadText(1001, 42) .. " " .. name
		end
	end
	for i = 1, iteration do
		name = "    " .. name
	end
	local color = (construction.factionid == "player") and menu.holomapcolor.playercolor or Helper.color.white
	local bgcolor = Helper.color.transparent
	if menu.mode == "orderparam_object" then
		bgcolor = menu.darkgrey
	end

	local row = ftable:addRow({ "construction", component, construction }, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(construction.component) })
	if menu.highlightedconstruction and (construction.id == menu.highlightedconstruction.id) then
		menu.sethighlightborderrow = row.index
	end
	if (construction.component ~= 0) and IsSameComponent(ConvertStringTo64Bit(tostring(construction.component)), menu.highlightedbordercomponent) then
		menu.sethighlightborderrow = row.index
	end

	if construction.inprogress then
		row[2]:setColSpan(4):createText(function () return menu.getShipBuildProgress(construction.component, name .. " (" .. ffi.string(C.GetObjectIDCode(construction.component)) .. ")") end, { color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
		row[6]:setColSpan(5):createText(function () return (construction.ismissingresources and "\27Y\27[warning] " or "") .. Helper.formatTimeLeft(C.GetBuildProcessorEstimatedTimeLeft(construction.buildercomponent)) end, { halign = "right", color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
	else
		local duration = C.GetBuildTaskDuration(construction.buildingcontainer, construction.id)
		row[2]:setColSpan(3):createText(name, { color = color })
		if construction.amount then
			row[5]:setColSpan(6):createText(string.format(ReadText(1001, 11608), Helper.formatTimeLeft(duration)), { halign = "right", color = color })
		else
			row[5]:setColSpan(6):createText("#" .. construction.queueposition .. " - " .. Helper.formatTimeLeft(duration), { halign = "right", color = color })
		end
	end
end

function menu.getPropertyOwnedFleetData(instance, component, maxentries)
	local shiptyperanks = { }
	local shiptypedata = { }
	menu.getPropertyOwnedFleetDataInternal(instance, component, shiptyperanks, shiptypedata)
	table.sort(shiptyperanks)
	local result = { }

	-- kuertee start: show idlers - do not show if 0 or component is a ship
	-- for _, shiptyperank in ipairs(shiptyperanks) do
	-- 	-- insert at front
	-- 	table.insert(result, 1, shiptypedata[shiptyperank])
	-- end
	for _, shiptyperank in ipairs(shiptyperanks) do
		if shiptypedata [shiptyperank].count > 0 then
			table.insert(result, 1, shiptypedata [shiptyperank])
		end
	end
	-- kuertee end: show idlers - do not show if 0 or component is a ship

	local dockedships = menu.infoTableData[instance].dockedships[tostring(component)] or {}
	local numdockedplayerships = 0
	for _, dockedship in ipairs(dockedships) do
		local isplayerowned = GetComponentData(dockedship, "isplayerowned")
		if isplayerowned then
			local iscommander = false
			local commanderlist = GetAllCommanders(dockedship)
			for i, entry in ipairs(commanderlist) do
				if IsSameComponent(entry, component) then
					iscommander = true
					break
				end
			end
			if not iscommander then
				numdockedplayerships = numdockedplayerships + 1
			end
		end
	end
	if numdockedplayerships > 0 then
		table.insert(result, 1, { icon = "order_dockat", count = numdockedplayerships, color = menu.holomapcolor.playercolor })
	end

	-- If there are too many entries, accumulate counts in last entry and invalidate icon
	while maxentries and #result > maxentries do
		local removed = table.remove(result)
		result[maxentries].count = result[maxentries].count + removed.count
		result[maxentries].icon = nil
	end
	return result
end

function menu.getPropertyOwnedFleetDataInternal(instance, component, shiptyperanks, shiptypedata)
	local shiptyperank
	local shipclass = "xs"
	if IsComponentClass(component, "ship_xl") then
		shiptyperank = 50
		shipclass = "xl"
	elseif IsComponentClass(component, "ship_l") then
		shiptyperank = 40
		shipclass = "l"
	elseif IsComponentClass(component, "ship_m") then
		shiptyperank = 30
		shipclass = "m"
	elseif IsComponentClass(component, "ship_s") then
		shiptyperank = 20
		shipclass = "s"
	elseif IsComponentClass(component, "ship_xs") then
		shiptyperank = 10
		shipclass = "xs"
	end
	if shiptyperank then
		local purpose, icon = GetComponentData(component, "primarypurpose", "icon")
		if purpose == "fight" then
			shiptyperank = shiptyperank + 5
		elseif purpose == "auxiliary" then
			shiptyperank = shiptyperank + 4
		elseif purpose == "trade" then
			shiptyperank = shiptyperank + 3
		elseif purpose == "mine" then
			shiptyperank = shiptyperank + 2
		elseif purpose == "build" then
			shiptyperank = shiptyperank + 1
		else
			purpose = "neutral"
		end
		if not shiptypedata[shiptyperank] then
			table.insert(shiptyperanks, shiptyperank)
			shiptypedata[shiptyperank] = { icon = icon, count = 0 }
		end
		shiptypedata[shiptyperank].count = shiptypedata[shiptyperank].count + 1
	end

	-- kuertee start: callback
	if callbacks ["getPropertyOwnedFleetDataInternal_addToFleetIcons"] then
		for _, callback in ipairs (callbacks ["getPropertyOwnedFleetDataInternal_addToFleetIcons"]) do
			callback (component, shiptyperanks, shiptypedata)
		end
	end
	-- kuertee end: callback

	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)]
	if subordinates == nil then
		-- component is not rendered but we still need the subordinates for accurate fleet counts
		subordinates = GetSubordinates(component)
		for i = #subordinates, 1, -1 do
			local subordinate = subordinates[i]
			if not menu.isObjectValid(ConvertIDTo64Bit(subordinate)) then
				table.remove(subordinates, i)
			end
		end
	end
	menu.infoTableData[instance].subordinates[tostring(component)] = subordinates
	for _, subordinate in ipairs(subordinates) do
		menu.getPropertyOwnedFleetDataInternal(instance, subordinate, shiptyperanks, shiptypedata)
	end
end

function menu.getPropertyOwnedGroupIcons(instance, component, subordinates)
	local shipstates = {}
	local shipstatesdata = {}
	local sectorbase = GetComponentData(ConvertStringTo64Bit(tostring(component)), "sector")
	for _, subordinate in ipairs(subordinates) do
		if menu.isObjectValid(ConvertIDTo64Bit(subordinate)) then
			menu.getPropertyOwnedGroupIcons_getData(instance, subordinate, shipstates, shipstatesdata, sectorbase)
		end
	end
	table.sort(shipstates)
	local result = {}
	for _, shipstate in ipairs(shipstates) do
		table.insert(result, 1, shipstatesdata[shipstate])
	end
	return result
end

function menu.getPropertyOwnedGroupIcons_getData(instance, component, shipstates, shipstatesdata, sectorbase)
	local shipstate_idling = 10
	local shipstate_name = "shipstate_idling"
	local shipstate_idling_icon = "ships_idling_01"
	local purpose = GetComponentData(component, "primarypurpose")
	if not shipstatesdata[shipstate_idling] then
		table.insert(shipstates, shipstate_idling)
		shipstatesdata[shipstate_idling] = {name = shipstate_name, icon = shipstate_idling_icon, count = 0 }
	end
	local numOrders = C.GetNumOrders(ConvertStringTo64Bit(tostring(component)))
	if numOrders == 0 then
		shipstatesdata[shipstate_idling].count = shipstatesdata[shipstate_idling].count + 1
	end
	local shipstate_away = 20
	local shipstate_name = "shipstate_away"
	local shipstate_away_icon = "ships_away_01"
	local sector = GetComponentData(ConvertStringTo64Bit(tostring(component)), "sector")
	if not shipstatesdata[shipstate_away] then
		table.insert(shipstates, shipstate_away)
		shipstatesdata[shipstate_away] = {name = shipstate_name, icon = shipstate_away_icon, count = 0}
	end
	if sector ~= sectorbase then
		shipstatesdata[shipstate_away].count = shipstatesdata[shipstate_away].count + 1
	end
end

function menu.populateUpkeepMissionData()
	menu.upkeepMissionData = {}

	local numMissions = GetNumMissions()
	for i = 1, numMissions do
		local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, alertLevel = GetMissionDetails(i)
				
		if maintype == "upkeep" then
			if associatedcomponent then
				local rawcontainer = C.GetContextByRealClass(ConvertIDTo64Bit(associatedcomponent), "container", true)
				if rawcontainer ~= 0 then
					local container = ConvertStringTo64Bit(tostring(rawcontainer))

					if menu.upkeepMissionData[tostring(container)] then
						table.insert(menu.upkeepMissionData[tostring(container)], { missionID = missionID, alertLevel = alertLevel, name = name })
					else
						menu.upkeepMissionData[tostring(container)] = { { missionID = missionID, alertLevel = alertLevel, name = name } }
					end
				end
			end
		end
	end
end

function menu.getContainerAlertLevel(component)
	component = ConvertStringTo64Bit(tostring(component))
	local highestAlertLevel = 0
	local upkeepMissions = {}
	if menu.upkeepMissionData[tostring(component)] then
		for _, entry in ipairs(menu.upkeepMissionData[tostring(component)]) do
			highestAlertLevel = math.max(highestAlertLevel, entry.alertLevel)
			table.insert(upkeepMissions, { alertLevel = entry.alertLevel, name = entry.name })
		end
	end

	table.sort(upkeepMissions, function (a, b) return a.alertLevel > b.alertLevel end)
	local missionlist = ""
	for i, entry in ipairs(upkeepMissions) do
		if i ~= 1 then
			missionlist = missionlist .. "\n"
		end
		local color = Helper.color.white
		if entry.alertLevel == 1 then
			color = menu.holomapcolor.lowalertcolor
		elseif entry.alertLevel == 2 then
			color = menu.holomapcolor.mediumalertcolor
		else
			color = menu.holomapcolor.highalertcolor
		end
		missionlist = missionlist .. Helper.convertColorToText(color) .. entry.name
	end

	return highestAlertLevel, missionlist
end

function menu.getBuildProgress(station, name, component)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ConvertIDTo64Bit(station)))
	elseif component == 0 then
		buildprogress = "-"
	end

	if buildprogress == 100 then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

function menu.getBuildTime(buildingprocessor, component, ismissingresources)
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		return (ismissingresources and "\27Y\27[warning] " or "") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(buildingprocessor), "%h:%M:%S")
	else
		return ""
	end
end

function menu.getShipBuildProgress(ship, name)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(ship))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ship))
	elseif ship == 0 then
		buildprogress = "-"
	end

	if buildprogress == 100 then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

-- Order Queue

function menu.displayOrderParam(ftable, orderidx, order, paramidx, param, listidx, instance)
	local value = param.value
	local ismissing = value == nil
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64
	local paramactive = true
	if orderidx == "default" then
		paramactive = (menu.infoTableData[instance].commander == nil) and (not isplayeroccupiedship)
	end
	if paramactive and ((param.inputparams and param.inputparams.playerreadonly) or param.playerreadonly) then
		if param.inputparams and param.inputparams.playerreadonly then
			paramactive = (param.inputparams.playerreadonly ~= 1)
		elseif param.playerreadonly then
			paramactive = (param.playerreadonly ~= 1)
		end
	end
	if instance == nil then
		print(TraceBack())
	end
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local numValues = 0
	if not ismissing then
		if listidx then
			numValues = #order.params[paramidx].value
		end
		value = menu.getParamValue(param.type, value, param.inputparams)
	end

	local paramcolor = menu.white
	if ismissing then
		paramcolor = menu.red
	elseif order.state == "setup" then
		paramcolor = menu.green
	end

	if listidx then
		local row = ftable:addRow({ orderidx, paramidx, listidx }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText("  " .. param.text .. ReadText(1001, 120))
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		row[5]:setColSpan(5):createButton({ active = active }):setText(value and tostring(value) or "", { halign = "center", color = paramcolor })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
		row[10]:createButton({ active = active and ((not order.params[paramidx].required) or (numValues > 1)) }):setText("x", { halign = "center", color = paramcolor })
		row[10].handlers.onClick = function () return menu.buttonRemoveListParam(orderidx, paramidx, listidx, instance) end
	elseif config.complexOrderParams[param.type] then
		local data = config.complexOrderParams[param.type].data(param.value)
		local playerreadonly = param.inputparams and param.inputparams.playerreadonly
		if next(data) then
			for _, subparam in ipairs(config.complexOrderParams[param.type]) do
				if subparam.value(data) then
					local subparam2 = { text = subparam.name, value = subparam.value(data), type = subparam.type, editable = param.editable, playerreadonly = playerreadonly }
					menu.displayOrderParam(ftable, orderidx, order, paramidx, subparam2, nil, instance)
				end
			end
		end
	elseif param.inputparams and (param.type == "number" or param.type == "length" or param.type == "time" or param.type == "money") then
		local defaultmax = 50000
		local minselect = math.max(0, param.inputparams.min or 0)
		local maxselect = math.max(0, param.inputparams.max or defaultmax)
		local curvalue = tonumber(param.value)
		local startvalue = param.inputparams.startvalue
		local step = (param.inputparams.step and (param.inputparams.step >= 1)) and param.inputparams.step or 1
		local usetimeformat = false

		local suffix = ""
		if param.type == "length" then
			if param.inputparams.step >= 1000 then
				suffix = ReadText(1001, 108)
				minselect = math.floor(minselect / 1000)
				maxselect = math.floor(maxselect / 1000)
				curvalue = curvalue and math.floor(curvalue / 1000)
				startvalue = startvalue and math.floor(startvalue / 1000)
				step = math.ceil(step / 1000)
			else
				suffix = ReadText(1001, 107)
			end
		elseif param.type == "time" then
			suffix = ReadText(1001, 103)
			usetimeformat = true
			minselect = math.floor(minselect / 60)
			maxselect = math.floor(maxselect / 60)
			curvalue = curvalue and math.floor(curvalue / 60)
			startvalue = startvalue and math.floor(startvalue / 60)
			step = math.ceil(step / 60)
		elseif param.type == "money" then
			suffix = ReadText(1001, 101)
		end

		local useinfinite = false
		if param.hasinfinitevalue then
			useinfinite = true
			infinitevalue = param.infinitevalue
		end

		local slidercellProperties = { 
			height = config.mapRowHeight,
			bgColor = Helper.color.transparent,
			min       = minselect,
			max       = maxselect,
			start     = math.max(minselect, math.min(maxselect, curvalue or startvalue or minselect)),
			step      = step,
			suffix    = suffix,
			exceedMaxValue = false,
			readOnly = (not paramactive) or isplayeroccupiedship or (((order.state ~= "setup") or (paramidx > (order.actualparams + 1))) and ((order.state == "setup") and (not param.editable))),
			hideMaxValue = param.hasinfinitevalue,
			useInfiniteValue = useinfinite,
			infiniteValue = infinitevalue,
			useTimeFormat = usetimeformat,
		}

		local row = ftable:addRow({ orderidx, paramidx, listidx }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3)
		row[menu.infoTableData[instance].hasloop and 4 or 2]:createText("  " .. param.text .. ReadText(1001, 120))
		row[5]:setColSpan(6):createSliderCell(slidercellProperties):setText("", { fontsize = config.mapFontSize, color = paramcolor })
		row[5].handlers.onSliderCellConfirm = function (_, value) return menu.slidercellSetOrderParam(orderidx, paramidx, listidx, value, instance) end
		row[5].handlers.onSliderCellActivated = function() menu.noupdate = true end
		row[5].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
	elseif param.type == "bool" then
		local row = ftable:addRow({ orderidx, paramidx, listidx }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText("  " .. param.text .. ReadText(1001, 120))
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		local rawvalue = param.value ~= 0
		if ismissing then
			rawvalue = false
		end
		row[5]:createCheckBox(rawvalue, { active = active, width = config.mapRowHeight })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
	else
		local row = ftable:addRow({ orderidx, paramidx, listidx }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText("  " .. param.text .. ReadText(1001, 120))
		row[5]:setColSpan(6)
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		local text = value and tostring(value) or ""
		local height = math.max(config.mapRowHeight, math.ceil(C.GetTextHeight(text, Helper.standardFont, Helper.standardFontSize, row[5]:getWidth())) + Helper.borderSize)
		row[5]:createButton({ active = active, height = height }):setText(text, { halign = "center", color = paramcolor, y = (height - config.mapRowHeight) / 2 })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
	end
end

function menu.displayFailureParam(ftable, failureidx, paramidx, param, listidx, instance)
	if instance == nil then
		print(TraceBack())
	end
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local value = menu.getParamValue(param.type, param.value, param.inputparams)

	if listidx then
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { bgColor = Helper.color.transparent, interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText("  " .. param.text .. ReadText(1001, 120))
		row[5]:setColSpan(6):createButton({ active = false }):setText(value and tostring(value) or "", { halign = "center" })
	elseif config.complexOrderParams[param.type] then
		local data = config.complexOrderParams[param.type].data(param.value)
		if next(data) then
			for _, subparam in ipairs(config.complexOrderParams[param.type]) do
				if subparam.value(data) then
					local subparam2 = { text = subparam.name, value = subparam.value(data), type = subparam.type, editable = param.editable }
					menu.displayFailureParam(ftable, failureidx, paramidx, subparam2, nil, instance)
				end
			end
		end
	elseif param.inputparams and (param.type == "number" or param.type == "length" or param.type == "time" or param.type == "money") then
		local defaultmax = 50000
		local minselect = math.max(0, param.inputparams.min or 0)
		local maxselect = math.max(0, param.inputparams.max or defaultmax)
		local curvalue = tonumber(param.value)
		local startvalue = param.inputparams.startvalue
		local step = (param.inputparams.step and (param.inputparams.step >= 1)) and param.inputparams.step or 1
		local usetimeformat = false

		local suffix = ""
		if param.type == "length" then
			if param.inputparams.step and (param.inputparams.step >= 1000) then
				suffix = ReadText(1001, 108)
				minselect = math.floor(minselect / 1000)
				maxselect = math.floor(maxselect / 1000)
				curvalue = curvalue and math.floor(curvalue / 1000)
				startvalue = startvalue and math.floor(startvalue / 1000)
				step = math.ceil(step / 1000)
			else
				suffix = ReadText(1001, 107)
			end
		elseif param.type == "time" then
			suffix = ReadText(1001, 103)
			usetimeformat = true
			minselect = math.floor(minselect / 60)
			maxselect = math.floor(maxselect / 60)
			curvalue = curvalue and math.floor(curvalue / 60)
			startvalue = startvalue and math.floor(startvalue / 60)
			step = math.ceil(step / 60)
		elseif param.type == "money" then
			suffix = ReadText(1001, 101)
		end

		local useinfinite = false
		if param.hasinfinitevalue then
			useinfinite = true
			infinitevalue = param.infinitevalue
		end

		local slidercellProperties = { 
			height = config.mapRowHeight,
			bgColor = Helper.color.transparent,
			readOnly = true,
			min       = minselect,
			max       = maxselect,
			start     = math.max(minselect, math.min(maxselect, curvalue or startvalue or minselect)),
			step      = step,
			suffix    = suffix,
			exceedMaxValue = false,
			hideMaxValue = param.hasinfinitevalue,
			useInfiniteValue = useinfinite,
			infiniteValue = infinitevalue,
			useTimeFormat = usetimeformat,
		}

		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { bgColor = Helper.color.transparent, interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3)
		row[menu.infoTableData[instance].hasloop and 4 or 2]:createText("  " .. param.text .. ReadText(1001, 120))
		row[5]:setColSpan(6):createSliderCell(slidercellProperties):setText("", { fontsize = config.mapFontSize })
	elseif param.type == "bool" then
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { bgColor = Helper.color.transparent, interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText("  " .. param.text .. ReadText(1001, 120))
		local rawvalue = param.value ~= 0
		if ismissing then
			rawvalue = false
		end
		row[5]:createCheckBox(rawvalue, { active = false, width = config.mapRowHeight })
	else
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { bgColor = Helper.color.transparent, interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText("  " .. param.text .. ReadText(1001, 120))
		row[5]:setColSpan(6)
		local text = value and tostring(value) or ""
		local height = math.max(config.mapRowHeight, math.ceil(C.GetTextHeight(text, Helper.standardFont, Helper.standardFontSize, row[5]:getWidth())) + Helper.borderSize)
		row[5]:createButton({ active = false, height = height }):setText(text, { halign = "center", y = (height - config.mapRowHeight) / 2 })
	end
end

function menu.copyDefaultOrderForPlanning(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		C.CreateOrder(menu.infoSubmenuObject, menu.infoTableData[instance].defaultorder.orderdef, true)
		local buf = ffi.new("Order")
		if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
			menu.infoTableData[instance].planneddefaultorder.state = ffi.string(buf.state)
			menu.infoTableData[instance].planneddefaultorder.statename = ffi.string(buf.statename)
			menu.infoTableData[instance].planneddefaultorder.orderdef = ffi.string(buf.orderdef)
			menu.infoTableData[instance].planneddefaultorder.actualparams = tonumber(buf.actualparams)
			menu.infoTableData[instance].planneddefaultorder.enabled = buf.enabled
			menu.infoTablePersistentData[instance].planneddefaultorderiscopy = true

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == menu.infoTableData[instance].planneddefaultorder.orderdef) then
					menu.infoTableData[instance].planneddefaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		end

		menu.closeContextMenu()
		menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
	else
		DebugError("menu.copyDefaultOrderForPlanning: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	CopyDefaultOrderParamsForPlanning(menu.infoSubmenuObject)
	menu.refreshInfoFrame()
end

function menu.createOrdersMenuHeader(frame, instance)
	-- sync with tab table in menu.createOrderQueue()
	local orderHeaderTable
	if instance == "left" then
		menu.orderHeaderTable = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		orderHeaderTable = menu.orderHeaderTable
	elseif instance == "right" then
		menu.orderHeaderTableRight = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		orderHeaderTable = menu.orderHeaderTableRight
	end

	for i, entry in ipairs(config.infoCategories) do
		if entry.empty then
			orderHeaderTable:setColWidth(i, menu.sideBarWidth / 2, false)
		else
			orderHeaderTable:setColWidth(i, menu.sideBarWidth, false)
		end
	end

	local row = orderHeaderTable:addRow("orders_tabs", { fixed = true, bgColor = Helper.color.transparent })
	local count = 1
	for _, entry in ipairs(config.infoCategories) do
		if not entry.empty then
			local bgcolor = Helper.defaultTitleBackgroundColor
			local color = Helper.color.white
			if entry.category == menu.infoMode[instance] then
				bgcolor = Helper.defaultArrowRowBackgroundColor
			end

			local shown = true
			if entry.category == "orderqueue_advanced" then
				if C.IsMasterVersion() and (C.GetConfigSetting("advancedorderqueue") <= 0) then
					shown = false
				end
			end

			if shown then
				local loccount = count
				row[loccount]:createButton({ active = menu.isInfoModeValidFor(menu.infoSubmenuObject, entry.category), height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
				row[loccount].handlers.onClick = function () return menu.buttonInfoSubMode(entry.category, loccount, instance) end
				count = count + 1
			end
		else
			count = count + 1
		end
	end

	if menu.selectedRows["orderHeaderTable" .. instance] then
		orderHeaderTable.properties.defaultInteractiveObject = true
		orderHeaderTable:setSelectedRow(menu.selectedRows["orderHeaderTable" .. instance])
		if menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode[instance]) then
			orderHeaderTable:setSelectedCol(menu.selectedCols["orderHeaderTable" .. instance] or 0)
		end
		menu.selectedRows["orderHeaderTable" .. instance] = nil
		menu.selectedCols["orderHeaderTable" .. instance] = nil
	end

	return orderHeaderTable
end

function menu.createResponsesForFaction(ftable, faction, textproperties, mode, yoffset)
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(8):createText(ReadText(1001, 9301), Helper.headerRowCenteredProperties)	-- Global Standing Orders

	for _, signalentry in ipairs(menu.signals) do
		local signalid = signalentry.id
		local defask = C.GetAskToSignalForFaction(signalid, faction)
		local defresponse = ffi.string(C.GetDefaultResponseToSignalForFaction(signalid, faction))
		local locresponses = {}
		for _, responseentry in ipairs(signalentry.responses) do
			table.insert(locresponses, { id = responseentry.id, text = responseentry.name, icon = "", displayremoveoption = false })
		end
		table.insert(locresponses, { id = "reset", text = ReadText(1001, 9310), icon = "", displayremoveoption = false })	-- Reset standing orders of all ships for this scenario

		row = ftable:addRow(false, {bgColor = Helper.color.transparent})
		row[1]:setColSpan(8):createText(ReadText(1001, 9320) .. " " .. tostring(signalentry.name) .. ReadText(1001, 120), textproperties)	-- Default global response to, :

		row = ftable:addRow("orders_" .. (tostring(signalid) .. "_response"), {bgColor = Helper.color.transparent})
		row[1]:setColSpan(8):createDropDown(locresponses, {height = config.mapRowHeight, startOption = defresponse}):setTextProperties({fontsize = config.mapFontSize})
		row[1].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(_, newresponseid, faction, signalid, mode) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		row = ftable:addRow("orders_" .. tostring(signalid) .. "_ask", {bgColor = Helper.color.transparent})
		row[1]:createCheckBox(defask, { width = config.mapRowHeight, height = config.mapRowHeight })
		row[1].handlers.onClick = function() return menu.checkboxOrdersSetAsk(faction, signalid, mode) end
		row[2]:createText(ReadText(1001, 9330), textproperties)	-- Notify me if incident occurs
	end
end

function menu.createResponsesForControllable(ftable, controllable, textproperties, mode, yoffset, instance)
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local isvalid = menu.isInfoModeValidFor(controllable, "standingorders")
	local faction = GetComponentData(controllable, "owner")
	if C.IsComponentClass(controllable, "ship") then
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 8362), Helper.headerRowCenteredProperties)

		for _, signalentry in ipairs(menu.signals) do
			local signalid = signalentry.id
			local defask = false
			local defresponse = ""
			local deffactresponse = ""
			local hasownresponse = false
			if isvalid then
				defask = C.GetAskToSignalForControllable(signalid, controllable)
				defresponse = ffi.string(C.GetDefaultResponseToSignalForControllable(signalid, controllable))
				deffactresponse = ffi.string(C.GetDefaultResponseToSignalForFaction(signalid, faction))
				hasownresponse = C.HasControllableOwnResponse(controllable, signalid)
			end
			local deffactresponsename = ""

			local locresponses = {}
			for _, responseentry in ipairs(signalentry.responses) do
				if responseentry.id == deffactresponse then
					deffactresponsename = responseentry.name
					break
				end
			end
			for _, responseentry in ipairs(signalentry.responses) do
				table.insert(locresponses, { id = responseentry.id, text = responseentry.name, text2 = (deffactresponse ~= responseentry.id) and ("[" .. ReadText(1001, 8366) .. ReadText(1001, 120) .. " " .. deffactresponsename .. "]") or "", icon = "", displayremoveoption = false })
			end
			--table.insert(locresponses, { id = "reset", text = ReadText(1001, 9311), icon = "", displayremoveoption = false })	-- Reset standing orders of this ship for this scenario

			row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(8):createText(ReadText(1001, 9321) .. " " .. tostring(signalentry.name) .. ReadText(1001, 120), textproperties)	-- Default response to, :
		
			local rowdata = "orders_" .. tostring(signalid) .. "_global"
			row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetOverride(controllable, signalid, mode, checked) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367), textproperties)

			local rowdata = "orders_" .. tostring(signalid) .. "_response"
			row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:setColSpan(8):createDropDown(locresponses, { height = config.mapRowHeight, startOption = defresponse, active = isvalid and hasownresponse }):setTextProperties({fontsize = config.mapFontSize}):setText2Properties({ fontsize = config.mapFontSize, halign = "right" })
			row[1].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(_, newresponseid, controllable, signalid, mode) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
		
			local rowdata = "orders_" .. tostring(signalid) .. "_ask"
			row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(defask, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid and hasownresponse })
			row[1].handlers.onClick = function() return menu.checkboxOrdersSetAsk(controllable, signalid, mode) end
			row[2]:setColSpan(7):createText(ReadText(1001, 9330), textproperties)	-- Notify me if incident occurs
			row[2].properties.color = hasownresponse and Helper.color.white or Helper.color.grey

			ftable:addEmptyRow()
		end
	end
	
	if C.IsComponentClass(controllable, "ship") or C.IsComponentClass(controllable, "station") then
		-- resupply
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(C.IsComponentClass(controllable, "ship") and ReadText(1001, 7722) or ReadText(1001, 7724), Helper.headerRowCenteredProperties)

		local curOption = Helper.round(C.GetDefensibleLoadoutLevel(controllable), 1)
		local hasownresponse = isvalid and (curOption ~= -1)
		local component = controllable
		while curOption == -1 do
			component = GetCommander(component)
			if component then
				curOption = Helper.round(C.GetDefensibleLoadoutLevel(ConvertIDTo64Bit(component)), 1)
			else
				curOption = Helper.round(C.GetPlayerGlobalLoadoutLevel(), 1)
				break
			end
		end

		local rowdata = "orders_resupply_global"
		local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetResupplyOverride(controllable, checked) end
		row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = 0,   text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
			{ id = 0.1, text = ReadText(1001, 7736), icon = "", displayremoveoption = false },
			{ id = 0.5, text = ReadText(1001, 7737), icon = "", displayremoveoption = false },
			{ id = 1.0, text = ReadText(1001, 7738), icon = "", displayremoveoption = false },
		}
		local row = ftable:addRow("orders_resupply", {bgColor = Helper.color.transparent})
		row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = curOption, active = isvalid and hasownresponse }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersResupply(controllable, id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		ftable:addEmptyRow()

		-- blacklists
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(C.IsComponentClass(controllable, "ship") and ReadText(1001, 9143) or ReadText(1001, 9178), Helper.headerRowCenteredProperties)

		local blacklists = Helper.getBlackLists()

		local purpose = GetComponentData(controllable, "primarypurpose")
		local group = ((purpose == "fight") or (purpose == "auxiliary")) and "military" or "civilian"
		local types = {
			{ type = "sectortravel",	name = ReadText(1001, 9165) },
			{ type = "sectoractivity",	name = ReadText(1001, 9166) },
			{ type = "objectactivity",	name = ReadText(1001, 9167) },
		}
		for i, entry in ipairs(types) do
			row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(8):createText(entry.name .. ReadText(1001, 120), textproperties)

			local hasownlist = isvalid and C.HasControllableOwnBlacklist(controllable, entry.type)
			local blacklistid = C.GetControllableBlacklistID(controllable, entry.type, group)

			local rowdata = "orders_blacklist_" .. entry.type .. "_global"
			local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(not hasownlist, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetBlacklistOverride(controllable, entry.type, checked) end
			row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

			local locresponses = {
				{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
			}
			for _, blacklist in ipairs(blacklists) do
				if blacklist.type == entry.type then
					table.insert(locresponses, { id = blacklist.id, text = blacklist.name, icon = "", displayremoveoption = false })
				end
			end
			local row = ftable:addRow("orders_resupply", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(7):createDropDown(locresponses, { startOption = (blacklistid ~= 0) and blacklistid or -1, active = isvalid and hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersBlacklist(controllable, entry.type, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			row[8]:createButton({ mouseOverText = ReadText(1026, 8413) }):setIcon("menu_edit")
			row[8].handlers.onClick = menu.buttonEditBlacklist

			ftable:addEmptyRow()
		end

		-- fight rules
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 7753), Helper.headerRowCenteredProperties)

		local fightrules = Helper.getFightRules()

		local hasownrule = isvalid and C.HasControllableOwnFightRule(controllable, "attack")
		local fightruleid = C.GetControllableFightRuleID(controllable, "attack")

		local rowdata = "orders_fightrule_attack_global"
		local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:createCheckBox(not hasownrule, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetFightRuleOverride(controllable, "attack", checked) end
		row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
		}
		for _, fightrule in ipairs(fightrules) do
			table.insert(locresponses, { id = fightrule.id, text = fightrule.name, icon = "", displayremoveoption = false })
		end
		local row = ftable:addRow("orders_resupply", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(7):createDropDown(locresponses, { startOption = (fightruleid ~= 0) and fightruleid or -1, active = isvalid and hasownrule }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersFightRule(controllable, "attack", id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
		row[8]:createButton({ mouseOverText = ReadText(1026, 8414) }):setIcon("menu_edit")
		row[8].handlers.onClick = menu.buttonEditFightRule
	end

	-- ship trade prices & restrictions
	if C.IsComponentClass(controllable, "ship") then
		ftable:addEmptyRow()

		-- trade loop cargo reservations
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 11642), Helper.headerRowCenteredProperties)

		local rowdata = "orders_cargoreservations_global"
		local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local hasownresponse = C.HasShipTradeLoopCargoReservationOverride(controllable)
		local curOption = C.GetShipTradeLoopCargoReservationSetting(controllable) and "on" or "off"
		row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetCargoReservations(controllable, checked) end
		row[2]:setColSpan(7):createText(ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = "off",   text = ReadText(1001, 7726),  icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3276) },
			{ id = "on",    text = ReadText(1001, 11643), icon = "", displayremoveoption = false },
		}
		local row = ftable:addRow("orders_cargoreservations", {bgColor = Helper.color.transparent})
		row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = curOption, active = isvalid and hasownresponse }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersCargoReservations(controllable, id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		if GetComponentData(controllable, "issupplyship") then
			ftable:addEmptyRow()

			-- preferred build method
			local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(ReadText(1001, 11298), Helper.headerRowCenteredProperties)

			local cursetting = ffi.string(C.GetContainerBuildMethod(controllable))
			local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
					if id == curglobalsetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				curglobalsetting = "default"
			end
			local hasownsetting = cursetting ~= ""

			local rowdata = "info_buildrule_global"
			local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(controllable, checked, curglobalsetting) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367))

			local row = ftable:addRow("info_buildrule", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(controllable, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			ftable:addEmptyRow()

			local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(ReadText(1001, 7725), Helper.headerRowCenteredProperties)

			-- trade rule
			local hasownlist = C.HasContainerOwnTradeRule(controllable, "buy", "") or C.HasContainerOwnTradeRule(controllable, "sell", "")
			local traderuleid = C.GetContainerTradeRuleID(controllable, "buy", "")
			if traderuleid ~= C.GetContainerTradeRuleID(controllable, "sell", "") then
				DebugError("menu.createResponsesForControllable(): Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(controllable, "sell", "")))
			end
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(8):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
			-- global
			local row = ftable:addRow("order_wares_global", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(7):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
			row[8]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
			row[8].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(controllable, "trade", checked) end
			-- current
			local row = ftable:addRow("order_wares_current", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(7):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(controllable, "trade", id, "", true) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
			row[8].handlers.onClick = menu.buttonEditTradeRule

			local row = ftable:addRow(false, {bgColor = Helper.color.transparent})
			row[1]:setColSpan(8):createText("")

			local wares = {}
			local n = C.GetNumMaxProductionStorage(controllable)
			local buf = ffi.new("UIWareAmount[?]", n)
			n = C.GetMaxProductionStorage(buf, n, controllable)
			for i = 0, n - 1 do
				table.insert(wares, ffi.string(buf[i].wareid))
			end
			table.sort(wares, Helper.sortWareName)
	
			local reservations = {}
			local n = C.GetNumContainerWareReservations2(controllable, false, false, true)
			local buf = ffi.new("WareReservationInfo2[?]", n)
			n = C.GetContainerWareReservations2(buf, n, controllable, false, false, true)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i].ware)
				local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
				local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
				if reservations[ware] then
					table.insert(reservations[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta })
				else
					reservations[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta } }, [invbuyflag] = {} }
				end
			end
			for _, data in pairs(reservations) do
				table.sort(data.buyoffer, menu.etaSorter)
				table.sort(data.selloffer, menu.etaSorter)
			end

			for _, ware in ipairs(wares) do
				local name, minprice, maxprice = GetWareData(ware, "name", "minprice", "maxprice")
				local isextended = menu.isOrderExtended(controllable, ware, instance)

				-- ware
				local rowdata = "orders_wares_" .. ware .. "_header"
				local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
				if selectedorder and (selectedorder[1] == rowdata) then
					menu.setrow = row.index
					menu.setcol = nil
				end
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendOrder(controllable, ware, instance, row.index, 1) end
				row[2]:setColSpan(5):createText(name)
				if (C.GetContainerTradeRuleID(controllable, "buy", ware) > 0) or (C.GetContainerTradeRuleID(controllable, "sell", ware) > 0) then
					row[7]:setColSpan(2):createText("\27[lso_error]", { halign = "right", color = Helper.color.warningorange })
				end

				if isextended then
					-- trade rule
					local hasownlist = C.HasContainerOwnTradeRule(controllable, "buy", ware) or C.HasContainerOwnTradeRule(controllable, "sell", ware)
					local traderuleid = C.GetContainerTradeRuleID(controllable, "buy", ware)
					if traderuleid ~= C.GetContainerTradeRuleID(controllable, "sell", ware) then
						DebugError("menu.createResponsesForControllable(): Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(controllable, "sell", ware)))
					end
					local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(7):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
					-- global
					local row = ftable:addRow("orders_wares_" .. ware .. "_tradeglobal", { bgColor = Helper.color.transparent })
					row[2]:setColSpan(6):createText(ReadText(1001, 11031) .. ReadText(1001, 120), textproperties)
					row[8]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
					row[8].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(controllable, "trade", checked, ware) end
					-- current
					local row = ftable:addRow("orders_wares_" .. ware .. "_tradecurrent", { bgColor = Helper.color.transparent })
					row[2]:setColSpan(6):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
					row[2].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(controllable, "trade", id, ware, true) end
					row[2].handlers.onDropDownActivated = function () menu.noupdate = true end
					row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
					row[8].handlers.onClick = menu.buttonEditTradeRule

					ftable:addEmptyRow(config.mapRowHeight / 2)

					local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(controllable, ware, true))))
					local haspriceoverride = HasContainerWarePriceOverride(controllable, ware, true)
					-- automatic pricing
					local rowdata = "orders_wares_" .. ware .. "_autoprice"
					local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
					if selectedorder and (selectedorder[1] == rowdata) then
						menu.setrow = row.index
						menu.setcol = nil
					end
					row[2]:setColSpan(6):createText(ReadText(1001, 8402) .. ReadText(1001, 120))
					row[8]:createCheckBox(not haspriceoverride, { height = config.mapRowHeight })
					row[8].handlers.onClick = function (_, checked) return menu.checkboxStorageWarePriceOverride(controllable, ware, true, currentprice, checked) end
					-- price
					local rowdata = "orders_wares_" .. ware .. "_price"
					local row = ftable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
					if selectedorder and (selectedorder[1] == rowdata) then
						menu.setrow = row.index
						menu.setcol = nil
					end
					row[2]:setColSpan(7):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haspriceoverride and Helper.defaultSliderCellValueColor or Helper.color.grey,
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
					})
					row[2].handlers.onSliderCellChanged = function(_, value) return menu.slidercellStorageWarePriceOverride(controllable, ware, true, value) end
					-- reservations
					if reservations[ware] and (#reservations[ware].buyoffer > 0) then
						-- title
						local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(7):createText(ReadText(1001, 7946) .. ReadText(1001, 120))
						for _, reservation in ipairs(reservations[ware].buyoffer) do
							local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
							local name = ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")"
							row[2]:setColSpan(5):createText(function () return "   " .. Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
							row[7]:setColSpan(2):createText(ConvertIntegerString(reservation.amount, true, 0, false), { halign = "right" })
						end
					end
				end
			end
		end
	end
end

function menu.createOrderQueue(frame, mode, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	infoTableData.ships = menu.getShipList(true, true)
	if not menu.infoSubmenuObject then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if GetComponentData(selectedcomponent, "isplayerowned") and C.IsComponentClass(selectedcomponent, "ship") then
				menu.infoSubmenuObject = selectedcomponent
				break
			end
		end
		if not menu.infoSubmenuObject then
			if #infoTableData.ships > 0 then
				menu.infoSubmenuObject = ConvertIDTo64Bit(infoTableData.ships[1].shipid)
			else
				menu.infoSubmenuObject = 0
			end
		end
	end

	if menu.infoTablePersistentData[instance].planneddefaultorderloop and (menu.infoTablePersistentData[instance].planneddefaultorderloop.curobject ~= menu.infoSubmenuObject) then
		menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	end
	if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.curobject ~= menu.infoSubmenuObject) then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData[instance].orderqueuemode.curobject)
		menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
		menu.infoTablePersistentData[instance].orderqueuemode = nil
	end

	-- Current orders
	infoTableData.orders = {}
	infoTableData.defaultorder = {}
	infoTableData.planneddefaultorder = {}

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, mode) then
		local n = C.GetNumOrders(menu.infoSubmenuObject)
		local buf = ffi.new("Order2[?]", n)
		n = C.GetOrders2(buf, n, menu.infoSubmenuObject)
		for i = 0, n - 1 do
			local entry = {}
			entry.state = ffi.string(buf[i].state)
			entry.statename = ffi.string(buf[i].statename)
			entry.orderdef = ffi.string(buf[i].orderdef)
			entry.actualparams = tonumber(buf[i].actualparams)
			entry.enabled = buf[i].enabled
			entry.isinfinite = buf[i].isinfinite
			entry.isoverride = buf[i].isoverride
			entry.istemporder = buf[i].istemporder
			table.insert(infoTableData.orders, entry)
		end
	
		local buf = ffi.new("Order")
		if C.GetDefaultOrder(buf, menu.infoSubmenuObject) then
			infoTableData.defaultorder.state = ffi.string(buf.state)
			infoTableData.defaultorder.statename = ffi.string(buf.statename)
			infoTableData.defaultorder.orderdef = ffi.string(buf.orderdef)
			infoTableData.defaultorder.actualparams = tonumber(buf.actualparams)
			infoTableData.defaultorder.enabled = buf.enabled

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == infoTableData.defaultorder.orderdef) then
					infoTableData.defaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		end
	
		local buf = ffi.new("Order")
		if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
			infoTableData.planneddefaultorder.state = ffi.string(buf.state)
			infoTableData.planneddefaultorder.statename = ffi.string(buf.statename)
			infoTableData.planneddefaultorder.orderdef = ffi.string(buf.orderdef)
			infoTableData.planneddefaultorder.actualparams = tonumber(buf.actualparams)
			infoTableData.planneddefaultorder.enabled = buf.enabled

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == infoTableData.planneddefaultorder.orderdef) then
					infoTableData.planneddefaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		elseif (not menu.infoTablePersistentData[instance].planneddefaultorderloop) and menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
			menu.infoTablePersistentData[instance].orderqueuemode = nil
		end

		infoTableData.commander = GetCommander(menu.infoSubmenuObject)

		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.infoSubmenuObject, hasloop)
		infoTableData.hasloop = hasloop[0]
		infoTableData.currentIdx = tonumber(C.GetOrderQueueCurrentIdx(menu.infoSubmenuObject))
	end

	if not selectedorder then
		menu.setcol = nil
	else
		if selectedorder.object ~= menu.infoSubmenuObject then
			selectedorder = nil
			menu.setrow = nil
			menu.setcol = nil
			menu.topRows["infotable" .. instance] = nil
			menu.selectedRows["infotable" .. instance] = nil
			menu.selectedCols["infotable" .. instance] = nil
		end
	end

	local ftable = frame:addTable(10, { tabOrder = 1 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidth(2, Helper.standardTextHeight)
	ftable:setColWidth(3, 2 * Helper.standardTextHeight)
	ftable:setColWidth(4, frame.properties.width / 3 - 4 * Helper.scaleY(Helper.standardTextHeight) - 3 * Helper.borderSize, false)
	ftable:setColWidthPercent(5, 33)
	ftable:setColWidth(7, Helper.standardTextHeight)
	ftable:setColWidth(8, Helper.standardTextHeight)
	ftable:setColWidth(9, Helper.standardTextHeight)
	ftable:setColWidth(10, Helper.standardTextHeight)

	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultBackgroundColSpan(1, 10)

	-- isvalid == controllable.isclass.ship and controllable.isplayerowned
	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local color = Helper.color.white
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	if isplayerowned then
		color = menu.holomapcolor.playercolor
		if menu.infoSubmenuObject == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other") and menu.getFilterOption("think_diplomacy_highlightvisitor") then
		color = menu.holomapcolor.visitorcolor
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	--- title ---
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(10):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(10):createText((mode == "orderqueue") and ReadText(1001, 8360) or ReadText(1001, 8361), Helper.headerRowCenteredProperties)
	--- name ---
	local row = ftable:addRow({ "info_focus" }, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[10]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
	row[10].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if C.IsComponentClass(menu.infoSubmenuObject, "object") then
		row[1]:setBackgroundColSpan(9):setColSpan(5):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
		row[6]:setColSpan(4):createText(ffi.string(C.GetObjectIDCode(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[6].properties.color = color
		row[6].properties.halign = "right"
	else
		row[1]:setBackgroundColSpan(9):setColSpan(9):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
	end

	local maxvisibleheight

	if C.IsComponentClass(menu.infoSubmenuObject, "ship") then
		---- pilot info ----
		local pilot, formation, isplayerowned = GetComponentData(menu.infoSubmenuObject, "assignedpilot", "formation", "isplayerowned")
		local pilot64 = ConvertIDTo64Bit(pilot)
		local isplayer = pilot64 == C.GetPlayerID()
		local commandername, commandercolor = "-", Helper.color.white
		if infoTableData.commander then
			commandername, commandercolor = menu.getContainerNameAndColors(infoTableData.commander, 0, false, false)
		end
		if isvalid and isplayerowned then
			local name, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", ReadText(1001, 4847), {}
			if pilot and IsValidComponent(pilot) then
				name, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
			end
			--- name ---
			local row = ftable:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(4):createText(postname .. ReadText(1001, 120))
			row[5]:setColSpan(6):createText(name)
			--- skills ---
			local adjustedskill = pilot and math.floor(C.GetEntityCombinedSkill(pilot64, nil, isplayer and "playerpilot" or "aipilot") * 15 / 100) or 0
			local row = ftable:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(4):createText(ReadText(1001, 9124) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
			row[5]:setColSpan(6):createText(pilot and Helper.displaySkill(adjustedskill) or "-", { color = pilot and Helper.color.brightyellow or nil, mouseOverText = ReadText(1026, 2) })
			--- commander ---
			local row = ftable:addRow({ infoTableData.commander }, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
			if infoTableData.commander then
				row[5]:setColSpan(5):createText(commandername, { color = commandercolor })
				row[10]:createButton():setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[10].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(infoTableData.commander), true) end
			else
				row[5]:setColSpan(6):createText(commandername, { color = commandercolor })
			end
			--- current ai command ---
			if pilot and IsValidComponent(pilot) then
				local row = ftable:addRow(false, { bgColor = Helper.color.unselectable })
				row[1]:setColSpan(4):createText(ReadText(1001, 78) .. ReadText(1001, 120))
				local unlocked_operator_commands = IsInfoUnlockedForPlayer(menu.infoSubmenuObject, "operator_commands")
				if #aicommandstack > 0 then
					aicommand = aicommandstack[1].command
					aicommandparam = aicommandstack[1].param
				end
				row[5]:setColSpan(6):createText(Helper.unlockInfo(unlocked_operator_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)))
				local row = ftable:addRow(false, { bgColor = Helper.color.unselectable })
				local numaicommands = #aicommandstack
				if numaicommands > 1 then
					aicommandaction = aicommandstack[numaicommands].command
					aicommandactionparam = aicommandstack[numaicommands].param
				end
				row[3]:setColSpan(6):createText(Helper.unlockInfo(unlocked_operator_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)))
			end
			--- subordinates ---
			local subordinates = GetSubordinates(menu.infoSubmenuObject, nil, true)
			local row = ftable:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120))
			row[5]:setColSpan(6):createText(#subordinates)
			--- formation ---
			local n = C.GetNumFormationShapes()
			local buf = ffi.new("UIFormationInfo[?]", n)
			n = C.GetFormationShapes(buf, n)
			local formationshapes = {}
			for i = 0, n - 1 do
				-- skill range from 0-5 -> 0-15
				table.insert(formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape), requiredSkill = buf[i].requiredSkill * 3 })
			end
			table.sort(formationshapes, Helper.sortName)
			local formationOptions = {}
			for _, data in ipairs(formationshapes) do
				table.insert(formationOptions, { id = data.shape, text = data.name, text2 = Helper.displaySkill(data.requiredSkill), icon = "", displayremoveoption = false, active = data.requiredSkill <= adjustedskill })
			end
			local row = ftable:addRow({ "formation" }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == "formation") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(4):createText(ReadText(1001, 8307) .. ReadText(1001, 120))
			row[5]:setColSpan(6):createDropDown(formationOptions, { height = config.mapRowHeight, startOption = formation, active = isvalid and (#subordinates > 0), textOverride = (#subordinates == 0) and ReadText(20223, 11) or nil }):setTextProperties({ fontsize = config.mapFontSize }):setText2Properties({ fontsize = config.mapFontSize, color = Helper.color.brightyellow, halign = "right" })
			row[5].handlers.onDropDownConfirmed = menu.dropdownBehaviourFormation
			row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
		end

		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(10):createText(" ")

		---- actual order queue ----
		--- title ---
		local titlerow = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		titlerow[1]:setColSpan(10):createText((infoTableData.hasloop and (utf8.char(8734) .. " ") or "") .. ((mode == "orderqueue") and ReadText(1001, 3225) or ReadText(1001, 8318)) .. (infoTableData.hasloop and (" [" .. ReadText(1001, 11270) .. "]") or ""), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "map_orderqueue"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false

		menu.displayOrderFailureSection(ftable, instance)

		if infoTableData.hasloop then
			local row = ftable:addRow(false, { bgColor = Helper.color.darkgrey })
			if #infoTableData.orders > 0 then
				local nontempcounter = 0
				for _, order in ipairs(infoTableData.orders) do
					if not order.istemporder then
						nontempcounter = nontempcounter + 1
					end
				end
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11271), nontempcounter) .. ReadText(1001, 120), { font = Helper.standardFontBold })
			else
				row[1]:setColSpan(10):createText(ReadText(1001, 11272), { font = Helper.standardFontBold })
			end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end

		local row = ftable:addEmptyRow(1)
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		if #infoTableData.orders > 15 then
			maxvisibleheight = ftable:getFullHeight() + 15 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		end

		--- orders ---
		infoTableData.disabledmarker = nil
		local firstoverride = true
		local nontempcounter = 0
		for i, order in ipairs(infoTableData.orders) do
			local nextorder = infoTableData.orders[i + 1]
			if i == 1 and ((order.state == "setup") or (order.state == "disabled")) then
				infoTableData.disabledmarker = 1
			elseif (not infoTableData.disabledmarker) and ((nextorder and ((nextorder.state == "setup") or (nextorder.state == "disabled"))) or (i == #infoTableData.orders)) then
				infoTableData.disabledmarker = i + 1
			end
			-- red line
			if infoTableData.disabledmarker == i then
				if next(infoTableData.defaultorder) and (not infoTableData.hasloop) then
					local row = ftable:addRow(false, { bgColor = Helper.color.darkgrey })
					row[2]:setColSpan(9):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " " .. infoTableData.defaultorder.orderdefref.name, { font = Helper.standardFontBold })
				end

				local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(10):createText(ReadText(1001, 8319), { halign = "center", titleColor = Helper.color.red })
			end

			-- orderdef
			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == order.orderdef) then
					order.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				break
			end

			-- params
			order.params = GetOrderParams(menu.infoSubmenuObject, i)

			-- hasrequiredparams
			order.hasrequiredparams = false
			for _, param in ipairs(order.params) do
				if param.type ~= "internal" then
					order.hasrequiredparams = true
					break
				end
			end

			-- sync point
			order.syncPointInfo = ffi.new("SyncPointInfo2")
			order.hasSyncPoint = C.GetSyncPointInfo2(menu.infoSubmenuObject, i, order.syncPointInfo)

			local color = menu.white
			if order.state == "started" or order.state == "critical" or order.state == "finish" then
				color = menu.green
			end

			local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i, instance)

			-- sort out parameters for AdjustOrder()
			local oldidx, newupidx, newdownidx, enableup, enabledown
			oldidx = i
			if infoTableData.disabledmarker == i + 1 then
				newupidx = i - 1
				newdownidx = i
				enableup = true
				enabledown = false
			elseif infoTableData.disabledmarker == i then
				newupidx = i
				newdownidx = i + 1
				enableup = true
				enabledown = false
			else
				newupidx = i - 1
				newdownidx = i + 1
				enableup = order.enabled
				enabledown = order.enabled
			end

			-- state color
			local statecolor = "\27X"
			if order.state == "setup" then
				statecolor = "\27R"
			elseif order.state == "disabled" then
				statecolor = "\27O"
			end

			local row = ftable:addRow({ i }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == i) then
				menu.selectedRows["infotable" .. instance] = row.index
			end
			-- loop indicator
			if infoTableData.hasloop then
				if i == infoTableData.currentIdx then
					row[1]:createIcon("widget_arrow_right_01", { height = config.mapRowHeight, width = config.mapRowHeight })
				end
			end
			-- extend
			row[infoTableData.hasloop and 2 or 1]:createButton({ active = order.hasrequiredparams }):setText(isextended and "-" or "+", { halign = "center" })
			row[infoTableData.hasloop and 2 or 1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i, instance, row.index, infoTableData.hasloop and 2 or 1) end
			-- loop counter
			if infoTableData.hasloop then
				if not order.istemporder then
					nontempcounter = nontempcounter + 1
					row[3]:createText(nontempcounter, { halign = "right" })
				end
			end
			-- name
			local colspan = (firstoverride and order.isoverride) and 1 or 2
			if not infoTableData.hasloop then
				colspan = colspan + 2
			end
			local name = order.orderdefref.name
			local mouseovertext
			if order.isoverride then
				name = name .. " \27R[" .. ReadText(1001, 11219) .. "]"
			elseif order.istemporder then
				name = name .. " " .. Helper.convertColorToText(Helper.color.grey) .. "[" .. ReadText(1001, 11283) .. "]"
				mouseovertext = ReadText(1026, 3261)
			end
			local id = C.GetOrderID(menu.infoSubmenuObject, i)
			local failure = infoTableData.looporderfailures[tostring(id)]
			if failure then
				menu.cachedOrderFailures[tostring(id)] = failure
			elseif (order.state ~= "started") and (order.state ~= "critical") then
				menu.cachedOrderFailures[tostring(id)] = nil
			end
			row[infoTableData.hasloop and 4 or 2]:setColSpan(colspan):createText((failure and (Helper.convertColorToText(Helper.color.warningorange) .. "\27[warning]\27X ") or "") .. name, { x = infoTableData.hasloop and 0 or nil, mouseOverText = failure and (Helper.convertColorToText(Helper.color.warningorange) .. failure.message) or mouseovertext })
			-- override
			if firstoverride and order.isoverride then
				local attacker
				if order.orderdefref.id == "Flee" then
					if order.params[6] and order.params[6].value then
						local value = ConvertIDTo64Bit(order.params[6].value)
						if value ~= 0 then
							attacker = value
						end
					end
				elseif order.orderdefref.id == "Attack" then
					if order.params[1] and order.params[1].value and (order.params[1].type == "object") and (order.params[1].value ~= 0) then
						attacker = order.params[1].value
					end
				elseif order.orderdefref.id == "Wait" then
					if order.params[5] and order.params[5].value then
						local value = ConvertIDTo64Bit(order.params[5].value)
						if value ~= 0 then
							attacker = value
						end
					end
				end

				local overrideOrderOptions = {}
				if order.orderdefref.id ~= "Attack" then
					table.insert(overrideOrderOptions, { id = "Attack", text = ReadText(1001, 11228), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3234), active = attacker ~= nil })
				end
				if order.orderdefref.id ~= "Flee" then
					table.insert(overrideOrderOptions, { id = "Flee", text = ReadText(1001, 11220), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3232), active = attacker ~= nil })
				end
				if order.orderdefref.id ~= "Wait" then
					table.insert(overrideOrderOptions, { id = "Wait", text = ReadText(1001, 11247), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3245), active = attacker ~= nil })
				end

				row[5]:createDropDown(overrideOrderOptions, { height = config.mapRowHeight, startOption = "", active = isvalid and (not isplayeroccupiedship), textOverride = ReadText(1001, 11248) }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
				row[5].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownChangeOverrideOrder(id, attacker, instance) end
				row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

				firstoverride = false
			end
			-- state
			row[6]:createText(statecolor .. " [" .. order.statename .. "]", { halign = "right" })
			-- weapon config
			row[7]:createButton({ active = isvalid and not isplayeroccupiedship, mouseOverText = ReadText(1001, 1105) }):setText("*", { halign = "center" })
			row[7].handlers.onClick = function () return menu.buttonWeaponConfig(menu.infoSubmenuObject, i, false, instance) end
			-- up
			row[8]:createButton({ active = isvalid and (not isplayeroccupiedship) and C.AdjustOrder(menu.infoSubmenuObject, oldidx, newupidx, enableup, false, true), mouseOverText = ReadText(1026, 3264) }):setIcon("table_arrow_inv_up")
			row[8].handlers.onClick = function () return menu.buttonOrderUp(i, instance) end
			-- down
			row[9]:createButton({ active = isvalid and (not isplayeroccupiedship) and C.AdjustOrder(menu.infoSubmenuObject, oldidx, newdownidx, enabledown, false, true), mouseOverText = ReadText(1026, 3265) }):setIcon("table_arrow_inv_down")
			row[9].handlers.onClick = function () return menu.buttonOrderDown(i, instance) end
			-- remove
			row[10]:createButton({ active = C.RemoveOrder(menu.infoSubmenuObject, i, false, true), helpOverlayID = "map_ordercancel", helpOverlayText = " ", helpOverlayHighlightOnly = true, mouseOverText = ReadText(1026, 3263) }):setText("x", { halign = "center" })
			row[10].handlers.onClick = function () return menu.buttonRemoveOrder(i, instance) end
			row[10].properties.uiTriggerID = "deleteorder"
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

			if isextended then
				if failure then
					local row = ftable:addRow(nil, { bgColor = Helper.color.unselectable })
					row[infoTableData.hasloop and 4 or 2]:setColSpan(infoTableData.hasloop and 7 or 9):createText("  " .. Helper.getPassedTime(failure.timestamp) .. " - " .. failure.message, { color = Helper.color.warningorange })
				elseif menu.cachedOrderFailures[tostring(id)] then
					local row = ftable:addRow(nil, { bgColor = Helper.color.unselectable })
					row[infoTableData.hasloop and 4 or 2]:setColSpan(infoTableData.hasloop and 7 or 9):createText("  " .. Helper.getPassedTime(menu.cachedOrderFailures[tostring(id)].timestamp) .. " - " .. menu.cachedOrderFailures[tostring(id)].message, { color = Helper.color.transparent })
				end
				for j, param in ipairs(order.params) do
					if (not param.advanced) or (mode == "orderqueue_advanced") then
						if param.type == "list" then
							local playerreadonly = param.inputparams and param.inputparams.playerreadonly
							if param.value then
								for k, entry in ipairs(param.value) do
									local param2 = { text = param.text .. " #" .. k, value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
									menu.displayOrderParam(ftable, i, order, j, param2, k, instance)
								end
							end

							if playerreadonly ~= 1 then
								local row = ftable:addRow({ i, j, "new" }, { bgColor = Helper.color.transparent })
								if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
									menu.selectedRows["infotable" .. instance] = row.index
									menu.selectedCols["infotable" .. instance] = nil
								end
								local active = isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
								row[2]:setColSpan(9):createButton({ active = active }):setText("  " .. string.format(ReadText(1001, 3235), param.text), { halign = "center" })
								row[2].handlers.onClick = function () return menu.buttonSetOrderParam(i, j, nil, nil, instance) end
							end
						elseif (param.type ~= "internal") then
							menu.displayOrderParam(ftable, i, order, j, param, nil, instance)
						end
					end
				end
				-- sync point option
				if (not order.hasSyncPoint) or (order.syncPointInfo.owningcontrollable == 0) then
					if (order.orderdefref.id == "MoveWait") or (order.orderdefref.id == "Wait") or (order.orderdefref.id == "DockAndWait") then
						local syncPointOptions = { [1] = { id = 0, text = ReadText(1001, 3236), icon = "", displayremoveoption = false } }
						for i = 1, 10 do
							table.insert(syncPointOptions, { id = i, text = Helper.getSyncPointName(i), icon = "", displayremoveoption = false })
						end

						local row = ftable:addRow({ i, nil, "syncoption" }, { bgColor = Helper.color.transparent })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncoption") then
							menu.selectedRows["infotable" .. instance] = row.index
							menu.selectedCols["infotable" .. instance] = nil
						end
						row[2]:setColSpan(3):createText("  " .. ReadText(1001, 3237))
						row[5]:setColSpan(6):createDropDown(syncPointOptions, { height = config.mapRowHeight, startOption = order.syncPointInfo.id, active = isvalid and (not isplayeroccupiedship) and order.isinfinite }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
						row[5].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownNewSyncPoint(i, id) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
					end
				end
			end

			-- sync point info
			if order.hasSyncPoint then
				local color = Helper.color.red
				if order.syncPointInfo.reached then
					color = Helper.color.green
				end

				local row = ftable:addRow({ i, nil, "syncinfo" }, { bgColor = Helper.color.transparent })
				if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncinfo") then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end

				local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i .. "syncpoint", instance)
				row[infoTableData.hasloop and 2 or 1]:createButton({ active = order.hasrequiredparams }):setText(isextended and "-" or "+", { halign = "center" })
				row[infoTableData.hasloop and 2 or 1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i .. "syncpoint", instance, row.index, infoTableData.hasloop and 2 or 1) end

				if order.syncPointInfo.id > 0 then
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 7 or 8):createText(ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. Helper.getSyncPointName(order.syncPointInfo.id), { titleColor = color })
					row[10]:createButton({ active = isvalid and not isplayeroccupiedship }):setText("x", { halign = "center" })
					row[10].handlers.onClick = function () return menu.buttonRemoveOrderSyncPoint(i, instance) end
				else
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 8 or 9):createText(ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(order.syncPointInfo.owningcontrollable)) .. " (" .. ffi.string(C.GetObjectIDCode(order.syncPointInfo.owningcontrollable)) .. ")", { titleColor = color })
				end

				if isextended then
					local row = ftable:addRow({ i, nil, "syncpointreleasesetting" }, { bgColor = Helper.color.transparent })
					if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncpointreleasesetting") then
						menu.selectedRows["infotable" .. instance] = row.index
						menu.selectedCols["infotable" .. instance] = nil
					end
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 7 or 8):createText("  " .. ReadText(1001, 11297) .. ReadText(1001, 120))
					if order.syncPointInfo.id > 0 then
						row[10]:createCheckBox(function () return C.GetSyncPointAutoRelease(order.syncPointInfo.id, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[10].handlers.onClick = function(_, checked) return C.SetSyncPointAutoRelease(order.syncPointInfo.id, checked, false) end
					else
						row[10]:createCheckBox(function () return C.GetSyncPointAutoReleaseFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[10].handlers.onClick = function(_, checked) return C.SetSyncPointAutoReleaseFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, checked, false) end
					end

					local totalobjects, reachedobjects
					if order.syncPointInfo.id > 0 then
						totalobjects = C.GetNumObjectsWithSyncPoint(order.syncPointInfo.id, false)
						reachedobjects = C.GetNumObjectsWithSyncPoint(order.syncPointInfo.id, true)
					else
						totalobjects = C.GetNumObjectsWithSyncPointFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, false)
						reachedobjects = C.GetNumObjectsWithSyncPointFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, true)
					end

					local row = ftable:addRow({ i, nil, "syncpointtrigger" }, { bgColor = Helper.color.transparent })
					if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncpointtrigger") then
						menu.selectedRows["infotable" .. instance] = row.index
						menu.selectedCols["infotable" .. instance] = nil
					end
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 2 or 3):createText("  " .. string.format(ReadText(1001, 3229), reachedobjects, totalobjects))
					row[5]:setColSpan(6):createButton({ active = (reachedobjects > 0) }):setText(ReadText(1001, 8324), { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonReleaseSyncPoint(order.syncPointInfo) end
				end
			end
		end

		-- red line
		if (infoTableData.disabledmarker == nil) or (infoTableData.disabledmarker == (#infoTableData.orders + 1)) then
			if next(infoTableData.defaultorder) and (not infoTableData.hasloop) then
				local row = ftable:addRow(false, { bgColor = Helper.color.darkgrey })
				row[2]:setColSpan(9):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " " .. infoTableData.defaultorder.orderdefref.name, { font = Helper.standardFontBold })
			end

			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText(ReadText(1001, 8319), { halign = "center", titleColor = Helper.color.red })
		end

		local hasstartableorders = false
		local hasremoveableorders = false
		for i, order in ipairs(infoTableData.orders) do
			if C.RemoveOrder(menu.infoSubmenuObject, i, false, true) then
				hasremoveableorders = true
			end
			if order.state == "disabled" then
				hasstartableorders = true
				break;
			end
			if order.state == "setup" then
				break;
			end
		end

		if mode == "orderqueue_advanced" then
			local row = ftable:addRow({ "neworder" }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == "neworder") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(10):createButton({ active = isvalid and (not isplayeroccupiedship) and ((pilot64 ~= nil) and (pilot64 ~= 0)), mouseOverText = isplayeroccupiedship and ReadText(1026, 3224) or (((pilot64 == nil) or (pilot64 == 0)) and ReadText(1026, 3225) or "") }):setText(ReadText(1001, 3238), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonNewOrder(nil, false, instance) end
		end

		local row = ftable:addRow({ "buttons" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "buttons") then
			menu.selectedRows["infotable" .. instance] = row.index
		end
		row[1]:setColSpan(4):createButton({ active = isvalid and hasremoveableorders }):setText(ReadText(1001, 3239), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonDeleteAllOrders(instance) end
		row[1].properties.uiTriggerID = "deleteallorders"
		row[6]:setColSpan(5):createButton({ active = isvalid and (not isplayeroccupiedship) and hasstartableorders }):setText(ReadText(1001, 3240), { halign = "center" })
		row[6].handlers.onClick = function () return menu.buttonStartOrders(instance) end
		row[6].properties.uiTriggerID = "startorderqueue"

		-- syncpoint overview
		local first = true
		for i = 1, 10 do
			local totalobjects = C.GetNumObjectsWithSyncPoint(i, false)
			local reachedobjects = C.GetNumObjectsWithSyncPoint(i, true)

			if totalobjects > 0 then
				if first then
					ftable:addEmptyRow(1)
					--- title ---
					local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
					row[1]:setColSpan(10):createText(ReadText(1001, 8323), Helper.headerRowCenteredProperties)
					first = false
				end
				local row = ftable:addRow({"sync", i}, { bgColor = Helper.color.transparent })
				if selectedorder and (selectedorder[1] == "sync") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[1]:setColSpan(4):createText(Helper.getSyncPointName(i) .. " (" .. string.format(ReadText(1001, 3229), reachedobjects, totalobjects) .. ")")
				row[5]:setColSpan(6):createButton({ active = (reachedobjects > 0) }):setText(ReadText(1001, 8324), { halign = "center" })
				local syncpointinfo = { id = i }
				row[5].handlers.onClick = function () return menu.buttonReleaseSyncPoint(syncpointinfo) end

				local row = ftable:addRow({"syncrelease", i}, { bgColor = Helper.color.transparent })
				if selectedorder and (selectedorder[1] == "syncrelease") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[3]:setColSpan(7):createText(ReadText(1001, 11297) .. ReadText(1001, 120))
				row[10]:createCheckBox(function () return C.GetSyncPointAutoRelease(i, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[10].handlers.onClick = function(_, checked) return C.SetSyncPointAutoRelease(i, checked, false) end
			end
		end

		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(10):createText(" ")

		---- assignment ----
		if infoTableData.commander and isvalid and (not isplayeroccupiedship) then
			--- title ---
			local row = ftable:addRow({ infoTableData.commander }, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(string.format(ReadText(1001, 7803), Helper.convertColorToText(commandercolor) .. commandername), Helper.headerRowCenteredProperties)
			row[10]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
			row[10].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(infoTableData.commander), true) end

			local row = ftable:addRow({ "assignment" }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == "assignment") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(4):createText(ReadText(1001, 8373) .. ReadText(1001, 120))
		
			local isstation = IsComponentClass(infoTableData.commander, "station")
			local isship = IsComponentClass(infoTableData.commander, "ship")
			local shiptype = GetComponentData(infoTableData.commander, "shiptype")
			local currentassignment, primarypurpose = GetComponentData(menu.infoSubmenuObject, "assignment", "primarypurpose")
			local asssignmentOptions = {}
			-- defence
			table.insert(asssignmentOptions, { id = "defence", text = ReadText(20208, 40301), icon = "", displayremoveoption = false })
			-- supplyfleet
			if isship and (primarypurpose == "auxiliary") and GetComponentData(menu.infoSubmenuObject, "cansupplyships") then
				table.insert(asssignmentOptions, { id = "supplyfleet", text = ReadText(20208, 40701), icon = "", displayremoveoption = false })
			end
			if isstation then
				-- trade
				table.insert(asssignmentOptions, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, mouseovertext = (primarypurpose == "mine") and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8608)) or "" })
				if primarypurpose == "mine" then
					-- mining
					table.insert(asssignmentOptions, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false })
				else
					-- trade for build storage
					table.insert(asssignmentOptions, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false })
				end
				if primarypurpose == "salvage" then
					table.insert(asssignmentOptions, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false })
				end
			elseif isship then
				-- position defence
				local parentcommander = ConvertIDTo64Bit(GetCommander(infoTableData.commander))
				local subordinates = GetSubordinates(infoTableData.commander)
				local isfleetcommander = (not parentcommander) and (#subordinates > 0)
				if (shiptype == "carrier") and isfleetcommander then
					local hasintersectorgroup = C.HasSubordinateAssignment(ConvertIDTo64Bit(infoTableData.commander), "positiondefence")
					table.insert(asssignmentOptions, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false, active = hasintersectorgroup, mouseovertext = hasintersectorgroup and "" or ReadText(1026, 3270) })
				end
				-- attack and intercept
				table.insert(asssignmentOptions, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
				local active = true
				local mouseovertext = ""
				local buf = ffi.new("Order")
				if not C.GetDefaultOrder(buf, ConvertIDTo64Bit(infoTableData.commander)) then
					active = false
					mouseovertext = ReadText(1026, 8606)
				end
				table.insert(asssignmentOptions, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
				-- trade
				if shiptype == "resupplier" then
					table.insert(asssignmentOptions, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false })
				end
			end

			row[5]:setColSpan(6):createDropDown(asssignmentOptions, { height = config.mapRowHeight, startOption = currentassignment }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
			row[5].handlers.onDropDownConfirmed = function(_, newassignment) Helper.dropdownAssignment(_, menu.infoSubmenuObject, nil, nil, newassignment) end
			row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

			local row = ftable:addRow({ "removeassignment" }, { bgColor = Helper.color.transparent })
			if selectedorder and (selectedorder[1] == "removeassignment") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(10):createButton({ active = true }):setText(ReadText(1001, 7810), { halign = "center" })
			row[1].handlers.onClick = menu.buttonRemoveAssignment

			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText(" ")
		end

		---- default order ----
		local hasloop = infoTableData.hasloop or menu.infoTablePersistentData[instance].planneddefaultorderloop
		
		--- title ---
		local titlerow = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		titlerow[1]:setColSpan(10):createText((hasloop and (utf8.char(8734) .. " ") or "") .. ReadText(1001, 8320), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "map_defaultorder"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false

		if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			menu.displayPlannedDefaultBehaviour(ftable, mode, titlerow, instance)
		else
			menu.displayDefaultBehaviour(ftable, mode, titlerow, instance)
		end
	else
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(10):createText(ReadText(1001, 11226), { wordwrap = true })
	end

	if maxvisibleheight then
		ftable.properties.maxVisibleHeight = maxvisibleheight
	end

	if menu.selectedRows["infotable" .. instance] then
		ftable:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.selectedCols["infotable" .. instance] then
			ftable:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	if menu.topRows["infotable" .. instance] then
		ftable:setTopRow(menu.topRows["infotable" .. instance])
		menu.topRows["infotable" .. instance] = nil
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	--- tabs ---
	local tabtable = menu.createOrdersMenuHeader(frame, instance)

	ftable.properties.y = tabtable.properties.y + tabtable:getVisibleHeight() + Helper.borderSize

	tabtable:addConnection(1, (instance == "left") and 2 or 3, true)
	ftable:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.displayOrderFailureSection(ftable, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder
	infoTableData.looporderfailures = {}

	local found = false
	local n = C.GetNumOrderFailures(menu.infoSubmenuObject, infoTableData.hasloop == true)
	if n > 0 then
		local buf = ffi.new("OrderFailure[?]", n)
		n = C.GetOrderFailures(buf, n, menu.infoSubmenuObject, infoTableData.hasloop == true)
		for i = 0, n - 1 do
			local failure = buf[i]

			if failure.wasinloop then
				local entry = {}
				entry.message = ffi.string(failure.message)
				entry.timestamp = failure.timestamp
				infoTableData.looporderfailures[tostring(buf[i].orderid)] = entry
			else
				if not found then
					found = true
					-- failed behaviour
					local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
					row[1]:setColSpan(10):createText(ReadText(1001, 11621), Helper.subHeaderTextProperties)
				end

				local orderdefid = ffi.string(failure.orderdef)
				local orderfailuredef
				local found = false
				for _, orderdef in ipairs(menu.orderdefs) do
					if orderdef.id == orderdefid then
						orderfailuredef = orderdef
						found = true
						break
					end
				end
				if not found then
					DebugError("Order failure of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
				end

				local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i .. "failure", instance, true)
				local message = ffi.string(failure.message)
				-- name
				local row = ftable:addRow({ "failure", i }, { bgColor = Helper.color.transparent })
				if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i .. "failure", instance, row.index, 1) end
				row[2]:setColSpan(3):createText(orderfailuredef and orderfailuredef.name or "", { mouseOverText = Helper.convertColorToText(Helper.color.warningorange) .. message })
				row[5]:setColSpan(5):createText("[" .. ReadText(1001, 8837) .. "]", { halign = "right", color = Helper.color.warningorange, mouseOverText = Helper.convertColorToText(Helper.color.warningorange) .. message })
				row[10]:createButton({  }):setText("X", { halign = "center" })
				row[10].handlers.onClick = function () C.RemoveOrderFailure(menu.infoSubmenuObject, buf[i].id); menu.refreshInfoFrame(nil, 0) end
				if isextended then
					-- message
					local row = ftable:addRow(nil, { bgColor = Helper.color.unselectable })
					row[2]:setColSpan(9):createText("  " .. Helper.getPassedTime(failure.timestamp) .. " - " .. message, { color = Helper.color.warningorange })
					-- params
					local params = GetOrderFailureParams(menu.infoSubmenuObject, tonumber(failure.id))
					for j, param in ipairs(params) do
						if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
							if param.type == "list" then
								if param.value then
									for k, entry in ipairs(param.value) do
										local param2 = { text = param.text .. " #" .. k, value = entry, type = param.inputparams.type, editable = param.editable }
										menu.displayFailureParam(ftable, i, j, param2, k, instance)
									end
								end
							elseif (param.type ~= "internal") then
								menu.displayFailureParam(ftable, i, j, param, nil, instance)
							end
						end
					end
				end
			end
		end
		if found then
			-- empty line
			local row = ftable:addEmptyRow()
			-- current behaviour
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(10):createText(ReadText(1001, 11622), Helper.subHeaderTextProperties)
		end
	end
end

function menu.createStandingOrdersMenu(frame, instance)
	local infoTableData = menu.infoTableData[instance]

	infoTableData.ships = menu.getShipList(true, true)
	if not menu.infoSubmenuObject then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if GetComponentData(selectedcomponent, "isplayerowned") and C.IsComponentClass(selectedcomponent, "ship") then
				menu.infoSubmenuObject = selectedcomponent
				break
			end
		end
		if not menu.infoSubmenuObject then
			if #infoTableData.ships > 0 then
				menu.infoSubmenuObject = ConvertIDTo64Bit(infoTableData.ships[1].shipid)
			else
				menu.infoSubmenuObject = 0
			end
		end
	end

	if not menu.infoTablePersistentData[instance].selectedorder then
		menu.setcol = nil
	else
		if menu.infoTablePersistentData[instance].selectedorder.object ~= menu.infoSubmenuObject then
			menu.infoTablePersistentData[instance].selectedorder = nil
			menu.setrow = nil
			menu.setcol = nil
		end
	end

	local ftable = frame:addTable(8, { tabOrder = 1 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidth(2, frame.properties.width / 3 - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidthPercent(3, 33)
	ftable:setColWidth(5, Helper.standardTextHeight)
	ftable:setColWidth(6, Helper.standardTextHeight)
	ftable:setColWidth(7, Helper.standardTextHeight)
	ftable:setColWidth(8, Helper.standardTextHeight)

	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultBackgroundColSpan(1, 8)

	local color = Helper.color.white
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	if isplayerowned then
		color = menu.holomapcolor.playercolor
		if menu.infoSubmenuObject == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other") and menu.getFilterOption("think_diplomacy_highlightvisitor") then
		color = menu.holomapcolor.visitorcolor
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	--- title ---
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(8):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(8):createText(ReadText(1001, 8396), Helper.headerRowCenteredProperties)
	--- name ---
	local row = ftable:addRow({ "info_focus" }, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[8]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
	row[8].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if C.IsComponentClass(menu.infoSubmenuObject, "object") then
		row[1]:setBackgroundColSpan(7):setColSpan(3):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
		row[4]:setColSpan(4):createText(ffi.string(C.GetObjectIDCode(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[4].properties.color = color
		row[4].properties.halign = "right"
	else
		row[1]:setBackgroundColSpan(7):setColSpan(7):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
	end

	---- current override order ----
	infoTableData.orders = {}
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "standingorders") then
		local n = C.GetNumOrders(menu.infoSubmenuObject)
		local buf = ffi.new("Order2[?]", n)
		n = C.GetOrders2(buf, n, menu.infoSubmenuObject)
		for i = 0, n - 1 do
			local entry = {}
			entry.state = ffi.string(buf[i].state)
			entry.statename = ffi.string(buf[i].statename)
			entry.orderdef = ffi.string(buf[i].orderdef)
			entry.actualparams = tonumber(buf[i].actualparams)
			entry.enabled = buf[i].enabled
			entry.isinfinite = buf[i].isinfinite
			entry.isoverride = buf[i].isoverride
			table.insert(infoTableData.orders, entry)
		end
	end

	if (#infoTableData.orders > 0) and infoTableData.orders[1].isoverride then
		local order = infoTableData.orders[1]
		local orderdefinition = ffi.new("OrderDefinition")
		local ordername = ""
		local orderrefid
		if order.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, order.orderdef) then
			ordername = ffi.string(orderdefinition.name)
			orderrefid = ffi.string(orderdefinition.id)
		end
		order.params = GetOrderParams(menu.infoSubmenuObject, 1)

		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 11221), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(8):createText(ordername .. " \27R[" .. ReadText(1001, 11219) .. "]")

		local row = ftable:addRow({ "current_override_order" }, { bgColor = Helper.color.transparent })

		local attacker
		if orderrefid == "Flee" then
			if order.params[6] and order.params[6].value then
				local value = ConvertIDTo64Bit(order.params[6].value)
				if value ~= 0 then
					attacker = value
				end
			end
		elseif orderrefid == "Attack" then
			if order.params[1] and order.params[1].value and (order.params[1].type == "object") and (order.params[1].value ~= 0) then
				attacker = order.params[1].value
			end
		elseif orderrefid == "Wait" then
			if order.params[5] and order.params[5].value then
				local value = ConvertIDTo64Bit(order.params[5].value)
				if value ~= 0 then
					attacker = value
				end
			end
		end

		local overrideOrderOptions = {}
		if orderrefid ~= "Attack" then
			table.insert(overrideOrderOptions, { id = "Attack", text = ReadText(1001, 11228), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3234), active = attacker ~= nil })
		end
		if orderrefid ~= "Flee" then
			table.insert(overrideOrderOptions, { id = "Flee", text = ReadText(1001, 11220), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3232), active = attacker ~= nil })
		end
		if orderrefid ~= "Wait" then
			table.insert(overrideOrderOptions, { id = "Wait", text = ReadText(1001, 11247), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3245), active = attacker ~= nil })
		end

		row[3]:createDropDown(overrideOrderOptions, { height = config.mapRowHeight, startOption = "", active = isvalid and (not isplayeroccupiedship), textOverride = ReadText(1001, 11248) }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownChangeOverrideOrder(id, attacker, instance) end
		row[3].handlers.onDropDownActivated = function () menu.noupdate = true end

		row[4]:setColSpan(5):createButton({ active = C.RemoveOrder(menu.infoSubmenuObject, 1, false, true), mouseOverText = ReadText(1026, 3233) }):setText(ReadText(1001, 11222), { halign = "center" })
		row[4].handlers.onClick = function () return menu.buttonRemoveOrder(1, instance) end

		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:createText(" ")
	end

	---- standing orders ----
	menu.signals = {}
	local numsignals = C.GetNumAllSignals()
	local allsignals = ffi.new("SignalInfo[?]", numsignals)
	numsignals = C.GetAllSignals(allsignals, numsignals)
	for i = 0, numsignals - 1 do
		local signalid = ffi.string(allsignals[i].id)
		table.insert(menu.signals, {id = signalid, name = ffi.string(allsignals[i].name), description = ffi.string(allsignals[i].description), responses = {}})

		local numresponses = C.GetNumAllResponsesToSignal(signalid)
		local allresponses = ffi.new("ResponseInfo[?]", numresponses)
		numresponses = C.GetAllResponsesToSignal(allresponses, numresponses, signalid)
		for j = 0, numresponses - 1 do
			table.insert(menu.signals[#menu.signals].responses, {id = ffi.string(allresponses[j].id), name = ffi.string(allresponses[j].name), description = ffi.string(allresponses[j].description)})
		end
	end

	if C.IsComponentClass(menu.infoSubmenuObject, "ship") or C.IsComponentClass(menu.infoSubmenuObject, "station") then
		menu.createResponsesForControllable(ftable, menu.infoSubmenuObject, { height = config.mapRowHeight, fontsize = config.mapFontSize }, "controllableresponses", nil, instance)
	else
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(8):createText(ReadText(1001, 11227), { wordwrap = true })
	end

	if menu.selectedRows["infotable" .. instance] then
		ftable:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.selectedCols["infotable" .. instance] then
			ftable:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	if menu.topRows["infotable" .. instance] then
		ftable:setTopRow(menu.topRows["infotable" .. instance])
		menu.topRows["infotable" .. instance] = nil
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	--- tabs ---
	local tabtable = menu.createOrdersMenuHeader(frame, instance)

	ftable.properties.y = tabtable.properties.y + tabtable:getVisibleHeight() + Helper.borderSize

	tabtable:addConnection(1, (instance == "left") and 2 or 3, true)
	ftable:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance, planned)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder
	if not infoTableData.hasloop then
		local failure = ffi.new("OrderFailure")
		if C.GetDefaultOrderFailure(failure, menu.infoSubmenuObject) then
			-- failed behaviour
			local row = ftable:addRow({ "defaultorderfailure" }, { bgColor = Helper.defaultTitleBackgroundColor })
			if selectedorder and (selectedorder[1] == "defaultorderfailure") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(9):setBackgroundColSpan(9):createText(ReadText(1001, 11618), Helper.subHeaderTextProperties)
			row[10]:createButton({ height = Helper.subHeaderHeight }):setText("X", { halign = "center" })
			row[10].handlers.onClick = function () C.RemoveDefaultOrderFailure(menu.infoSubmenuObject); menu.refreshInfoFrame() end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

			local orderdefid = ffi.string(failure.orderdef)
			local orderfailuredef
			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if orderdef.id == orderdefid then
					orderfailuredef = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Default order failure of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
			end

			-- name
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
			row[5]:setColSpan(6):createButton({ active = false }):setText(orderfailuredef and orderfailuredef.name or ""):setText2(orderfailuredef and Helper.displaySkill(math.floor(orderfailuredef.requiredSkill * 15 / 100)) or "", { halign = "right", color = Helper.color.brightyellow })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			-- params
			local params = GetOrderFailureParams(menu.infoSubmenuObject, tonumber(failure.id))
			for j, param in ipairs(params) do
				if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
					if param.type == "list" then
						if param.value then
							for k, entry in ipairs(param.value) do
								local param2 = { text = param.text .. " #" .. k, value = entry, type = param.inputparams.type, editable = param.editable }
								menu.displayFailureParam(ftable, "defaultorderfailure", j, param2, k, instance)
							end
						end
					elseif (param.type ~= "internal") then
						menu.displayFailureParam(ftable, "defaultorderfailure", j, param, nil, instance)
					end
				end
			end
			-- message
			local row = ftable:addRow(nil, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(10):createText(Helper.getPassedTime(failure.timestamp) .. " - " .. ffi.string(failure.message), { color = Helper.color.warningorange })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			if orderdefid ~= infoTableData.defaultorder.orderdefref.id then
				-- changed default
				local row = ftable:addRow(nil, { bgColor = Helper.color.unselectable })
				row[1]:setColSpan(10):createText(ReadText(1001, 11619), { color = Helper.color.warningorange })
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			end
			-- empty line
			local row = ftable:addEmptyRow()
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			-- current behaviour
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(10):createText(planned and ReadText(1001, 11620) or ReadText(1001, 11617), Helper.subHeaderTextProperties)
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
	end
end

function menu.displayDefaultBehaviour(ftable, mode, titlerow, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64
	
	local haspilot = GetComponentData(menu.infoSubmenuObject, "assignedpilot") ~= nil
	local behaviouractive = (infoTableData.commander == nil) and isvalid and (not isplayeroccupiedship) and haspilot
	local mouseovertext = isplayeroccupiedship and ReadText(1026, 3226) or ((not haspilot) and ReadText(1026, 3227) or "")

	menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance)

	local order = infoTableData.defaultorder
	if infoTableData.hasloop then
		-- name
		local row = ftable:addRow({ "default2" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(6):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and ReadText(1026, 3269) or mouseovertext }):setText(ReadText(1001, 11267)):setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Helper.color.brightyellow })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	elseif next(order) then
		order.params = GetOrderParams(menu.infoSubmenuObject, "default")
		-- commander
		if infoTableData.commander then
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText(ReadText(1001, 11230), { wordwrap = true })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
		-- note
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(10):createText(ReadText(1001, 8363) .. ReadText(1001, 120))
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- name
		local row = ftable:addRow({ "default2" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local printedSkillReq = math.floor(order.orderdefref.requiredSkill * 15 / 100)
		row[1]:setColSpan(4):createText(ReadText(1001, 8364) .. ReadText(1001, 120))
		row[5]:setColSpan(6):createButton({helpOverlayID = "map_behaviourassignement", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = behaviouractive, mouseOverText = (mouseovertext == "") and order.orderdefref.description or mouseovertext }):setText(order.orderdefref.name):setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Helper.color.brightyellow })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		row[5].properties.uiTriggerID = "DefaultBehaviour"
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- weapon config - TODO
		--row[7]:createButton({ active = isvalid and not isplayeroccupiedship }):setText("*", { halign = "center" })
		--row[7].handlers.onClick = function () return menu.buttonWeaponConfig(menu.infoSubmenuObject, nil, true) end

		for j, param in ipairs(order.params) do
			if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
				if param.type == "list" then
					local playerreadonly = param.inputparams and param.inputparams.playerreadonly
					if param.value then
						for k, entry in ipairs(param.value) do
							local param2 = { text = param.text .. " #" .. k, value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
							menu.displayOrderParam(ftable, "default", order, j, param2, k, instance)
						end
					end

					if playerreadonly ~= 1 then
						local row = ftable:addRow({ i, j, "new" }, { bgColor = Helper.color.transparent })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
							menu.setrow = row.index
							menu.setcol = nil
						end

						-- kuertee start: callback
						if callbacks ["displayDefaultBehaviour_change_param_behaviouractive"] then
							for _, callback in ipairs (callbacks ["displayDefaultBehaviour_change_param_behaviouractive"]) do
								result = callback (behaviouractive)
								if result then
									behaviouractive = result.behaviouractive
								end
							end
						end
						-- kuertee end: callback

						local active = behaviouractive and isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
						row[2]:setColSpan(9):createButton({ active = active }):setText("  " .. string.format((param.inputparams.type == "ware") and ReadText(1001, 8377) or ReadText(1001, 3235), param.text), { halign = "center" })
						row[2].handlers.onClick = function () return menu.buttonSetOrderParam("default", j, nil, nil, instance) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				elseif (param.type ~= "internal") then
					menu.displayOrderParam(ftable, "default", order, j, param, nil, instance)
				end
			end
		end
	else
		local row = ftable:addRow({ "default" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "default") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[2]:setColSpan(8):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " ---")
		row[10]:createButton({ active = behaviouractive, mouseOverText = mouseovertext }):setIcon("menu_edit")
		row[10].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	local row = ftable:addRow({ "defaultbuttons" }, { bgColor = Helper.color.transparent })
	if selectedorder and (selectedorder[1] == "defaultbuttons") then
		menu.setrow = row.index
	end
	row[1]:setColSpan(4):createButton({ active = false }):setText(ReadText(1001, 2821), { halign = "center" })
	row[6]:setColSpan(5):createButton({ active = false }):setText(ReadText(1001, 64), { halign = "center" })
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
end

function menu.displayPlannedDefaultBehaviour(ftable, mode, titlerow, instance)
	local infoTableData = menu.infoTableData[instance]
	local persistentData = menu.infoTablePersistentData[instance]
	local selectedorder = persistentData.selectedorder

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64
	
	local haspilot = GetComponentData(menu.infoSubmenuObject, "assignedpilot") ~= nil
	local behaviouractive = (infoTableData.commander == nil) and isvalid and (not isplayeroccupiedship) and haspilot
	local mouseovertext = isplayeroccupiedship and ReadText(1026, 3226) or ((not haspilot) and ReadText(1026, 3227) or "")

	menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance, true)

	menu.setcol = nil

	local order = infoTableData.planneddefaultorder

	local row = ftable:addEmptyRow(1)
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

	if persistentData.planneddefaultorderloop then
		-- note
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(10):createText(ReadText(1001, 8365) .. ReadText(1001, 120), { font = Helper.standardFontBold })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		-- name
		local row = ftable:addRow({ "default2" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(6):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and ReadText(1026, 3269) or mouseovertext }):setText(ReadText(1001, 11267)):setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Helper.color.brightyellow })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		-- delete existing orders note
		if #infoTableData.orders > 0 then
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText(function () return persistentData.planneddefaultorderloop.hasunremoveableorders and ReadText(1001, 11269) or ReadText(1001, 11268) end, { color = Helper.color.red })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
	elseif next(order) then
		order.params = GetOrderParams(menu.infoSubmenuObject, "planneddefault")

		-- note
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(10):createText((persistentData.planneddefaultorderiscopy and ReadText(1001, 11610) or ReadText(1001, 8365)) .. ReadText(1001, 120), { font = Helper.standardFontBold })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- name
		local row = ftable:addRow({ "default2" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local printedSkillReq = math.floor(order.orderdefref.requiredSkill * 15 / 100)
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(6):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and order.orderdefref.description or mouseovertext }):setText(order.orderdefref.name):setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Helper.color.brightyellow })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		for j, param in ipairs(order.params) do
			if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
				if param.type == "list" then
					local playerreadonly = param.inputparams and param.inputparams.playerreadonly
					if param.value then
						for k, entry in ipairs(param.value) do
							local param2 = { text = param.text .. " #" .. k, value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
							menu.displayOrderParam(ftable, "planneddefault", order, j, param2, k, instance)
						end
					end

					if playerreadonly ~= 1 then
						local row = ftable:addRow({ i, j, "new" }, { bgColor = Helper.color.transparent })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
							menu.setrow = row.index
							menu.setcol = nil
						end
						local active = isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
						row[2]:setColSpan(9):createButton({ active = active }):setText("  " .. (param.inputparams and string.format((param.inputparams.type == "ware") and ReadText(1001, 8377) or ReadText(1001, 3235), param.text) or "---"), { halign = "center" })
						row[2].handlers.onClick = function () return menu.buttonSetOrderParam("planneddefault", j, nil, nil, instance) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				elseif (param.type ~= "internal") then
					menu.displayOrderParam(ftable, "planneddefault", order, j, param, nil, instance)
				end
			end
		end
	else
		local row = ftable:addRow({ "planneddefault" }, { bgColor = Helper.color.transparent })
		if selectedorder and (selectedorder[1] == "planneddefault") then
			menu.setrow = row.index
		end
		row[2]:setColSpan(8):createText(ReadText(1001, 8322) .. ReadText(1001, 120) .. " ---")
		row[10]:createButton({ active = behaviouractive, mouseOverText = mouseovertext }):setIcon("menu_edit")
		row[10].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	local row = ftable:addRow({ "defaultbuttons" }, { bgColor = Helper.color.transparent })
	if selectedorder and (selectedorder[1] == "defaultbuttons") then
		menu.setrow = row.index
	end
	row[1]:setColSpan(4):createButton({ active = function () return menu.buttonConfirmPlannedDefaultOrderActive(instance, isvalid) end }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonDefaultOrderConfirm(instance) end
	row[6]:setColSpan(5):createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[6].handlers.onClick = function () return menu.buttonDefaultOrderDiscard(instance) end
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
end

function menu.buttonConfirmPlannedDefaultOrderActive(instance, isvalid)
	if not isvalid then
		return false
	end
	if next(menu.infoTableData[instance].planneddefaultorder) then
		return C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, true)
	else
		menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders = nil
		local numorders = C.GetNumOrders(menu.infoSubmenuObject)
		local currentorders = ffi.new("Order[?]", numorders)
		numorders = C.GetOrders(currentorders, numorders, menu.infoSubmenuObject)
		for i = 0, numorders - 1 do
			if ffi.string(currentorders[i].state) == "critical" then
				menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders = true
				break
			end
		end
		return not menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders
	end
end

function menu.createPlotMode(inputframe)
	local textproperties = { height = config.mapRowHeight, fontsize = config.mapFontSize }

	menu.initPlotList()

	menu.table_plotlist = inputframe:addTable(4, {tabOrder = 1})
	menu.table_plotlist:setColWidth(4, Helper.scaleY(textproperties.height), false)
	menu.table_plotlist:setColWidthPercent(2, 30)
	menu.table_plotlist:setColWidthPercent(3, 5)

	local row = menu.table_plotlist:addRow(false, {fixed = true, bgColor = Helper.defaultTitleBackgroundColor})
	row[1]:setColSpan(4):createText(ReadText(1001, 9201), Helper.headerRowCenteredProperties)	-- Your Plots

	local numrows = config.plots.maxPlotRows
	local maxVisibleHeight
	local numplotentries = #menu.plots + 1
	for i, plot in ipairs(menu.plots) do
		local station64 = plot.station
		local stationname = ffi.string(C.GetComponentName(station64))
		row = menu.table_plotlist:addRow(station64)
		row[1]:setBackgroundColSpan(3):createText((stationname), textproperties)
		row[1].properties.color = function() return plot.fullypaid and Helper.standardColor or Helper.color.red end

		row[2]:createText((ReadText(1001, 9210) .. " " .. i), textproperties)	-- Plot
		row[2].properties.halign = "right"
		row[2].properties.x = 0
		row[2].properties.color = function() return plot.fullypaid and Helper.standardColor or Helper.color.red end

		row[3]:createText(function() return (plot.fullypaid and "" or "!") end, textproperties)
		row[3].properties.halign = "left"
		row[3].properties.font = Helper.standardFontBold
		row[3].properties.color = Helper.color.red

		row[4]:createButton({ active = not plot.permanent, helpOverlayID = "menu_cancel_plot", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText("x", {halign = "center"})
		row[4].handlers.onClick = function() return menu.buttonRemovePlot(station64) end

		if i == numrows then
			maxVisibleHeight = menu.table_plotlist:getFullHeight()
		end
		if station64 == menu.plotData.component then
			menu.setrow = row.index
		end
	end
	row = menu.table_plotlist:addRow("plots_new")
	row[1]:setBackgroundColSpan(4):createText(ReadText(1001, 9200), textproperties)	-- New Plot
	row[2]:createText((ReadText(1001, 9210) .. " " .. tostring(numplotentries)), textproperties)	-- Plot
	row[2].properties.halign = "right"
	row[2].properties.x = 0

	if maxVisibleHeight then
		menu.table_plotlist.properties.maxVisibleHeight = maxVisibleHeight
	end

	if not menu.plotData.component and not menu.plots_initialized then
		for id, _ in pairs(menu.selectedcomponents) do
			local station = ConvertStringTo64Bit(id)
			if GetComponentData(station, "isplayerowned") and C.IsRealComponentClass(station, "station") then
				menu.updatePlotData(station, true)

				for _, row in ipairs(menu.table_plotlist.rows) do
					if row.rowdata == station then
						menu.setplotrow = row.index
						menu.setplottoprow = (row.index - numrows + 1) > 1 and (row.index - numrows + 1) or 1
						break
					end
				end

				break
			end
		end
	elseif menu.plotData.component then
		menu.updatePlotData(menu.plotData.component, true)
	end
	menu.plots_initialized = true

	if menu.setplotrow then
		menu.setrow = menu.setplotrow
		menu.setplotrow = nil
		if menu.setplottoprow then
			menu.settoprow = menu.setplottoprow
			menu.setplottoprow = nil
		end
	end

	if menu.setrow then
		menu.table_plotlist:setSelectedRow(menu.setrow)
		menu.plotDoNotUpdate = true
		menu.setrow = nil
	else
		menu.table_plotlist:setSelectedRow(row.index)
	end
	if menu.settoprow then
		menu.table_plotlist:setTopRow(menu.settoprow)
		menu.settoprow = nil
	else
		menu.table_plotlist:setTopRow((row.index - numrows + 1) > 1 and (row.index - numrows + 1) or 1)
	end

	local table_plotdetails = inputframe:addTable(3, { tabOrder = 2 })
	table_plotdetails:setColWidthPercent(1, 40)
	table_plotdetails:setDefaultBackgroundColSpan(1, 3)

	row = table_plotdetails:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(3):createText(function () return menu.plotData.name or "" end, Helper.headerRowCenteredProperties)

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:createText(ReadText(1001, 11284) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return ffi.string(C.GetComponentName(menu.plotData.sector)) end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:createText(ReadText(1001, 2412) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "sunlight") * 100 .. "%" end, { halign = "right" })
	
	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:createText(ReadText(1001, 11296) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return string.format("%+.0f%%", GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "populationworkforcefactor") * 100) end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(3):createText(ReadText(1001, 11285), Helper.headerRowCenteredProperties)

	if IsCheatVersion() then
		local setOptions = {}
		local n = C.GetNumAllModuleSets()
		local buf = ffi.new("UIModuleSet[?]", n)
		n = C.GetAllModuleSets(buf, n)
		for i = 0, n - 1 do
			table.insert(setOptions, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
		end
		table.sort(setOptions, function (a, b) return a.text < b.text end)

		row = table_plotdetails:addRow(true)
		row[1]:setColSpan(3):createDropDown(setOptions, { height = config.mapRowHeight, startOption = menu.plotData.set, active = not menu.plotData.placed and not menu.plotData.active }):setTextProperties({fontsize = config.mapFontSize})
		row[1].handlers.onDropDownConfirmed = function(_, idstring) return menu.dropdownModuleSet(_, idstring) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
	end

	menu.plotsliders = {}
	menu.plotbuttons = {}
	local dimensions = { [1] = { dimension = "posX", text = ReadText(1001, 9220) },
						 [2] = { dimension = "negX", text = ReadText(1001, 9221) },
						 [3] = { dimension = "posY", text = ReadText(1001, 9222) },
						 [4] = { dimension = "negY", text = ReadText(1001, 9223) },
						 [5] = { dimension = "posZ", text = ReadText(1001, 9224) },
						 [6] = { dimension = "negZ", text = ReadText(1001, 9225) },
					}
	local boughtdimensions = {}
	if menu.plotData.paid then
		boughtdimensions = {
			posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + menu.plotData.boughtrawcenteroffset.x) / 1000),
			negX = math.floor((menu.plotData.boughtrawsize.x / 2 - menu.plotData.boughtrawcenteroffset.x) / 1000),
			posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + menu.plotData.boughtrawcenteroffset.y) / 1000),
			negY = math.floor((menu.plotData.boughtrawsize.y / 2 - menu.plotData.boughtrawcenteroffset.y) / 1000),
			posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + menu.plotData.boughtrawcenteroffset.z) / 1000),
			negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - menu.plotData.boughtrawcenteroffset.z) / 1000),
		}
	end

	for i, dimension in ipairs(dimensions) do
		row = table_plotdetails:addRow(true, {bgColor = Helper.color.transparent})
		local locdimension = menu.plotData.dimensions[dimension.dimension]
		local minimumdimension = menu.plotData.minimumdimensions[dimension.dimension] or 0
		local boughtdimension = menu.plotData.paid and boughtdimensions[dimension.dimension] or 0
		local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]]

		local minselect = math.max(menu.plotData.permanent and math.max(boughtdimension, minimumdimension) or boughtdimension, (locpaireddimension == 0 and 1 or 0))
		local maxselect = (menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] > config.maxPlotSize) and menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] or (config.maxPlotSize - menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]])
		local max = (menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] > config.maxPlotSize) and menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] or config.maxPlotSize
		if maxselect > max then
			print("maxselect > max. axis: " .. tostring(dimension.dimension) .. " maxselect: " .. tostring(maxselect) .. ", max: " .. tostring(max) .. ", paired value: " .. tostring(menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]]))
		end
		if minselect > maxselect then
			print("menu.createPlotMode(): minselect > maxselect [Florian]")
			minselect = maxselect
		end
		if locdimension < minselect then
			print("menu.createPlotMode(): start < minselect [Florian]")
			locdimension = minselect
		end

		-- increased minSelect to 1 because it looks like slider text is rounding to the nearest integer (and shows 0.5 as 0). so smallest possible plot size is 2x2x2.
		row[1]:setColSpan(3):createSliderCell({ 
			height = config.mapRowHeight,
			bgColor = Helper.color.transparent,
			min = 0,
			minSelect = minselect,
			max = (locpaireddimension > config.maxPlotSize) and locpaireddimension or config.maxPlotSize,
			maxSelect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension),
			start = locdimension,
			step = 1,
			suffix = ReadText(1001, 108) 
		}):setText(dimension.text, {fontsize = config.mapFontSize})
		--row[1]:setColSpan(3):createSliderCell({ height = config.mapRowHeight, min = 0, minSelect = (menu.plotData.paid or menu.plotData.permanent) and menu.plotData.dimensions[dimension.dimension] or 1, max = 9, maxSelect = config.maxPlotSize - menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]], start = menu.plotData.dimensions[dimension.dimension], step = 1, suffix = ReadText(1001, 108) }):setText(dimension.text, {fontsize = config.mapFontSize})
		row[1].handlers.onSliderCellChanged = function(_, val) return menu.slidercellPlotValue(_, val, dimension.dimension) end
		row[1].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
		table.insert(menu.plotsliders, { table = table_plotdetails, cell = row[1], row = row.index, col = 1, dimension = dimension.dimension })
	end

	table_plotdetails:addEmptyRow(config.mapRowHeight / 2)

	row = table_plotdetails:addRow(nil, { bgColor = Helper.color.unselectable })
	row[1]:createText(ReadText(1001, 8026) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return (menu.plotData.dimensions.posX + menu.plotData.dimensions.negX) .. " " .. ReadText(1001, 42) .. " " .. (menu.plotData.dimensions.posY + menu.plotData.dimensions.negY) .. " " .. ReadText(1001, 42) .. " " .. (menu.plotData.dimensions.posZ + menu.plotData.dimensions.negZ) .. " " .. ReadText(1001, 108) end, { halign = "right" })

	row = table_plotdetails:addRow("createplot", {bgColor = Helper.color.transparent})
	row[2]:createButton({ height = config.mapRowHeight, active = (menu.plotData.isinownedspace and menu.plotData.placed and menu.plotData.paid and (menu.plotData.size.x * 1000 > menu.plotData.boughtrawsize.x or menu.plotData.size.y * 1000 > menu.plotData.boughtrawsize.y or menu.plotData.size.z * 1000 > menu.plotData.boughtrawsize.z) and not menu.plotData.permanent) and true or false }):setText(ReadText(1001, 9230), { halign = "center", fontsize = config.mapFontSize })	-- Reset size
	row[2].handlers.onClick = function() return menu.resetPlotSize() end
	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row[2], row = row.index, col = 2, rowdata = "createplot", script = function() return menu.resetPlotSize() end })

	row[3]:createButton({ height = config.mapRowHeight, active = not menu.plotData.placed, helpOverlayID = "create_plot_new", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9231), { halign = "center", fontsize = config.mapFontSize })	-- Create new plot
	row[3].handlers.onClick = function() return menu.buttonNewPlot() end
	row[3].properties.uiTriggerID = "createnewplot"

	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row[3], row = row.index, col = 3, rowdata = "createplot", script = function() return menu.buttonNewPlot() end })

	table_plotdetails:setSelectedRow(menu.selectedRows.infotable2)
	menu.selectedRows.infotable2 = nil

	row = table_plotdetails:addRow(false, {bgColor = Helper.defaultTitleBackgroundColor})
	row[1]:setColSpan(3):createText(ReadText(1001, 9202), Helper.headerRowCenteredProperties)	-- Real Estate Transfer Tax

	row = table_plotdetails:addRow(false, { bgColor = Helper.color.unselectable })
	row2 = table_plotdetails:addRow("buyplot", {bgColor = Helper.color.transparent})

	row[1]:setColSpan(2):createText(function() return (not menu.plotData.placed and ReadText(1001, 9240)) or ((menu.plotData.fullypaid or not menu.plotData.isinownedspace) and ReadText(1001, 9241)) or (ReadText(1001, 9242) .. ReadText(1001, 120)) end, textproperties)	-- Place or select plot to see required fees., You own this plot., Fee to acquire plot licence, :
	row[3]:createText(function() return (menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and (ConvertMoneyString(tostring(menu.plotData.price), false, true, 0, true) .. " " .. ReadText(1001, 101))) or "" end, textproperties)
	row[3].properties.halign = "right"

	-- TODO: activate after there is a distinction between a holomap-only plot and a real one.
	--row2[2]:createButton({active = false, height = config.mapRowHeight}):setText(ReadText(1001, 9232), {halign = "center", fontsize = config.mapFontSize})	-- Ignore licence
	--row2[2]:createButton({active = not menu.plotData.fullypaid and menu.plotData.isinownedspace, height = config.mapRowHeight}):setText(ReadText(1001, 9232), {halign = "center", fontsize = config.mapFontSize})	-- Ignore licence
	--row2[2].handlers.onClick = function() return menu.buttonIgnorePlotLicence() end
	--table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[2], row = row2.index, col = 2, rowdata = "buyplot", script = function() return menu.buttonIgnorePlotLicence() end })
	local mouseovertext = ""
	if menu.plotData.placed and (not menu.plotData.fullypaid) and menu.plotData.isinownedspace and (not menu.plotData.affordable) then
		mouseovertext = ReadText(1026, 3222)
	end
	row2[3]:createButton({ active = menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and menu.plotData.affordable, height = config.mapRowHeight, mouseOverText = mouseovertext, helpOverlayID = "create_plot_purchase", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9233), { halign = "center", fontsize = config.mapFontSize })	-- Buy licence
	row2[3].handlers.onClick = function() return menu.buttonBuyPlot() end
	row2[3].properties.uiTriggerID = "buyplot"
	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[3], row = row2.index, col = 3, rowdata = "buyplot", script = function() return menu.buttonBuyPlot() end })

	row = table_plotdetails:addRow(false, {bgColor = Helper.defaultTitleBackgroundColor})
	row[1]:setColSpan(3):createText(ReadText(1001, 9234), Helper.headerRowCenteredProperties)	-- Continue to Construction

	row = table_plotdetails:addRow(false, { bgColor = Helper.color.unselectable })
	textproperties.height = config.mapRowHeight * 2
	textproperties.wordwrap = true
	row2 = table_plotdetails:addRow("initiateconstruction", {bgColor = Helper.color.transparent})

	row[1]:setColSpan(3):createText(function() return (not menu.plotData.placed and ReadText(1001, 9243)) or ((menu.plotData.fullypaid or not menu.plotData.isinownedspace) and ReadText(1001, 9244)) or ReadText(1001, 9245) end, textproperties)	-- Place or select plot to initiate construction., Click continue to initiate construction., Building without a licence will be seen as a hostile act by the local government.
	row[1].properties.color = function() return menu.plotData.placed and menu.plotData.isinownedspace and not menu.plotData.fullypaid and Helper.color.red or Helper.standardColor end
	row2[3]:createButton({active = menu.plotData.placed, height = config.mapRowHeight, helpOverlayID = "create_plot_continue", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9235), {halign = "center", fontsize = config.mapFontSize})	-- Continue
	row2[3].handlers.onClick = function() return menu.plotInitiateConstruction(menu.plotData.component) end
	row2[3].properties.uiTriggerID = "initiateconstruction"

	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[3], row = row2.index, col = 3, rowdata = "initiateconstruction", script = function() return menu.plotInitiateConstruction(menu.plotData.component) end })

	table_plotdetails.properties.y = menu.table_plotlist:getVisibleHeight() + Helper.borderSize

	menu.table_plotlist:addConnection(1, 2, true)
	table_plotdetails:addConnection(2, 2)
end

function menu.createFilterMode(ftable, numCols)
	local title = ""
	local row = ftable:addRow("tabs", { fixed = true, bgColor = Helper.color.transparent })
	for i, entry in ipairs(config.layers) do
		local icon = entry.icon
		local bgcolor = Helper.defaultTitleBackgroundColor
		-- active filter groups get different colors
		if entry.mode == menu.displayedFilterLayer then
			title = entry.name
			bgcolor = Helper.defaultArrowRowBackgroundColor
		end
		if not menu.getFilterOption(entry.mode) then
			icon = icon .. "_disabled"
		end

		local colindex = i
		if i > 1 then
			colindex = colindex + 2
		end

		row[colindex]:setColSpan((i == 1) and 3 or 1):createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(icon, { })
		row[colindex].handlers.onClick = function () return menu.buttonFilterSwitch(entry.mode, row.index, colindex) end
	end

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	local color = Helper.color.white
	local onoffcolor = Helper.color.white
	local active = true
	if not __CORE_DETAILMONITOR_MAPFILTER[menu.displayedFilterLayer] then
		color = Helper.color.grey
		onoffcolor = Helper.color.red
		active = false
	end
	row[1]:setColSpan(2):createButton({ height = Helper.headerRow1Height, helpOverlayID = "toggle_trade_filter", helpOverlayText = " ", helpOverlayHighlightOnly = true}):setIcon("menu_on_off", { color = onoffcolor })
	row[1].handlers.onClick = function () return menu.buttonSetFilterLayer(menu.displayedFilterLayer, row.index, 1) end
	row[3]:setColSpan(numCols - 2):createText(title, Helper.headerRowCenteredProperties)

	local settings = config.layersettings[menu.displayedFilterLayer]
	for i, setting in ipairs(settings) do
		if i > 1 then
			ftable:addEmptyRow(config.mapRowHeight / 2)
		end

		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(numCols):createText(setting.caption, Helper.subHeaderTextProperties)
		row[1].properties.color = color

		if setting.type == "multiselectlist" then
			local list = menu.getFilterOption(setting.id) or {}
			for i, curOption in ipairs(list) do
				local index = i

				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(numCols - 1):createText(setting.displayOption(curOption), { fontsize = config.mapFontSize })
				row[1].properties.color = color
				row[numCols]:createButton({ active = active }):setText("x", { halign = "center" })
				row[numCols].handlers.onClick = function () return menu.removeFilterOption(setting, setting.id, index) end
			end
			local row = ftable:addRow(true, {  })
			row[1]:setColSpan(numCols):createButton({ mouseOverText = setting.info, active = active }):setText(setting.overrideText, { halign = "center", fontsize = config.mapFontSize })
			row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, setting, setting.id) end
		else
			for _, option in ipairs(setting) do
				local optionactive = true
				if option.active then
					optionactive = option.active()
				end
				if setting.type == "checkbox" then
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:createCheckBox(menu.getFilterOption(option.id) or false, { scaling = false, width = Helper.scaleY(config.mapRowHeight), height = Helper.scaleY(config.mapRowHeight), active = active and optionactive })
					row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id) end
					row[2]:setColSpan(numCols - 1):createText(option.name, { mouseOverText = option.info })
					row[2].properties.color = color
				elseif setting.type == "slidercell" then
					if option.scale.exceedmax then
						option.scale.start = math.max(option.scale.min, menu.getFilterOption(option.id)) or option.scale.max
					else
						option.scale.start = math.max(option.scale.min, math.min(option.scale.max, menu.getFilterOption(option.id))) or option.scale.max
					end
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(numCols):createSliderCell({ height = config.mapRowHeight, min = option.scale.min, minSelect = option.scale.minSelect, max = option.scale.max, maxSelect = option.scale.maxSelect, start = option.scale.start, step = option.scale.step, suffix = option.scale.suffix, exceedMaxValue = option.scale.exceedmax, mouseOverText = option.info, readOnly = not active, bgColor = (not active) and Helper.color.transparent or nil, valueColor = (not active) and color or nil }):setText(option.name, {fontsize = config.mapFontSize})
					row[1].handlers.onSliderCellChanged = function (_, value) menu.noupdate = true; return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id, value) end
					row[1].handlers.onSliderCellConfirm = function() menu.noupdate = false end
				elseif setting.type == "dropdown" then
					local listOptions = option.listOptions()
					local row = ftable:addRow(true, {  })
					row[1]:setColSpan(numCols):createDropDown(listOptions, { height = config.mapRowHeight, startOption = menu.getFilterOption(option.id), mouseOverText = option.info, active = active }):setTextProperties({ fontsize = config.mapFontSize }):setText2Properties({ fontsize = config.mapFontSize, halign = "right" })
					row[1].handlers.onDropDownConfirmed = function (_, id) return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id, id) end
					row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
				end
			end
		end
	end
end

function menu.createLegendMode(ftable, numCols)
	ftable.properties.highlightMode = "grey"

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 9801), Helper.headerRowCenteredProperties)

	for _, entry in ipairs(config.legend) do
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		if entry.icon then
			local iconheight = entry.height or 1.5 * config.mapRowHeight
			local iconwidth  = entry.width  or 1.5 * config.mapRowHeight
			local iconx = 0
			if iconwidth < (1.5 * config.mapRowHeight) then
				iconx = (1.5 * config.mapRowHeight - iconwidth) / 2
			end
			local color
			if entry.color then
				if type(entry.color) == "string" then
					color = menu.holomapcolor[entry.color]
				else
					color = entry.color
				end
			end
			row[1]:setColSpan(3):createIcon(entry.icon, { width = iconwidth, height = iconheight, x = iconx, color = color })
			local texty = 0
			local textheight = math.max(math.max(entry.minRowHeight or 0, Helper.standardTextHeight), iconheight)
			if textheight > Helper.standardTextHeight then
				texty = (textheight - Helper.standardTextHeight) / 2
			end
			row[4]:setColSpan(numCols - 3):createText(entry.text, { minRowHeight = entry.minRowHeight, y = texty })
		else
			row[1]:setColSpan(numCols):createText(entry.text, Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
		end
	end
end

function menu.createHireMode(ftable, numCols)
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(numCols):createText(ishiring and ReadText(1001, 3500) or ReadText(1001, 3264), Helper.headerRowCenteredProperties)

	AddUITriggeredEvent(menu.name, "menu_hiremode")

	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0
	local name
	if npc then
		name = GetComponentData(npc, "name")
	else
		name = ffi.string(C.GetPersonName(npcseed, object))
	end

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText(ReadText(1001, 2809))
	row[6]:setColSpan(numCols - 5):createText(name, { halign = "right" })
	-- Skills
	local possiblePostsAndRoles = {}
	local n = C.GetNumAllControlPosts()
	local buf = ffi.new("ControlPostInfo[?]", n)
	n = C.GetAllControlPosts(buf, n)
	for i = 0, n - 1 do
		table.insert(possiblePostsAndRoles, { name = ffi.string(buf[i].name), post = ffi.string(buf[i].id) })
	end
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20103), role = "service" })
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20203), role = "marine" })
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20503), role = "trainee_group" })
	table.sort(possiblePostsAndRoles, Helper.sortName)

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 3257))
	for _, entry in ipairs(possiblePostsAndRoles) do
		local adjustedskill
		if npc then
			adjustedskill = math.floor(C.GetEntityCombinedSkill(npc, entry.role, entry.post) * 15 / 100)
		else
			adjustedskill = math.floor(C.GetPersonCombinedSkill(object, npcseed, entry.role, entry.post) * 15 / 100)
		end
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText("   " .. entry.name)
		row[6]:setColSpan(numCols - 5):createText(Helper.displaySkill(adjustedskill), { halign = "right", color = Helper.color.brightyellow })
	end
end

function menu.hireReasonLookup(reason, isbulk)
	if reason == "" then
		return ""
	elseif reason == "invalid" then
		return ReadText(1026, 3236)
	elseif reason == "sameposition" then
		return ReadText(1026, 3237)
	elseif reason == "intransit" then
		return ReadText(1026, 3238)
	elseif reason == "nofreespace" then
		return isbulk and ReadText(1026, 3243) or ReadText(1026, 3239)
	elseif reason == "pilotbusy" then
		return ReadText(1026, 3240)
	elseif reason == "previouspilotbusy" then
		return ReadText(1026, 3241)
	elseif reason == "shiptraderbusy" then
		return ReadText(1026, 3244)
	elseif reason == "postoccupied" then
		return ReadText(1026, 3246)
	end
end

function menu.createInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if not menu.infoSubmenuObject or menu.infoSubmenuObject == 0 then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if not menu.infoSubmenuObject or menu.infoSubmenuObject == 0 then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "infomenu_open", menu.infoSubmenuObject)

	local isdatavault, islandmark = GetComponentData(menu.infoSubmenuObject, "isdatavault", "islandmark")
	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "sector"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "gate"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "deployable"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") then
		mode = "asteroid"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "object") and (isdatavault or islandmark) then
		mode = "none"
	else
		DebugError("menu.createInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	local table_info = inputframe:addTable(8, { tabOrder = 1 })
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidthMinPercent(2, 20)
	table_info:setColWidthMinPercent(3, 20)
	table_info:setColWidth(4, 4 * config.mapRowHeight)
	table_info:setColWidth(6, 4 * config.mapRowHeight)
	table_info:setColWidth(8, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 8)

	menu.setupInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local isplayerowned, isdeployable, description = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isdeployable", "description")

	local table_button_bottom = inputframe:addTable(2, { tabOrder = 2 })
	if isplayerowned and (mode == "ship" or mode == "station") and (not C.IsUnit(menu.infoSubmenuObject)) and (not isdeployable) then
		table_button_bottom:setColWidthPercent(2, 50)

		row = table_button_bottom:addRow("info_button_bottom", { fixed = true, bgColor = Helper.color.transparent })
		if mode == "ship" then
			row[2]:createButton({ active = true }):setText(ReadText(1001, 1137), { halign = "center" })	-- Ship Overview
			row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "upgrade", { tostring(menu.infoSubmenuObject) } }) menu.cleanup() end
		elseif mode == "station" then
			row[1]:createButton({ active = true }):setText(ReadText(1001, 1136), { halign = "center" })	-- Configure Station
			row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, menu.infoSubmenuObject }) menu.cleanup() end
			row[2]:createButton({ active = true }):setText(ReadText(1001, 1138), { halign = "center" })	-- Station Overview
			row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, menu.infoSubmenuObject }) menu.cleanup() end
		end
	end
	table_button_bottom.properties.y = frameheight - table_button_bottom:getFullHeight() - Helper.borderSize

	local table_description = inputframe:addTable(1, { tabOrder = 3, highlightMode = "off" })
	row = table_description:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:createText(ReadText(1001, 2404), Helper.headerRowCenteredProperties)

	local descriptiontext = GetTextLines(description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), inputframe.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx))
	if #descriptiontext > 12 then
		-- scrollbar case
		descriptiontext = GetTextLines(description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), inputframe.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
	end
	for linenum, descline in ipairs(descriptiontext) do
		local row = table_description:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:createText(descline)
		if linenum == 12 then
			visibleHeight = table_description:getFullHeight()
		end
	end

	if menu.selectedRows["infotable3" .. instance] then
		table_description:setSelectedRow(menu.selectedRows["infotable3" .. instance])
		menu.selectedRows["infotable3" .. instance] = nil
		if menu.topRows["infotable3" .. instance] then
			table_description:setTopRow(menu.topRows["infotable3" .. instance])
			menu.topRows["infotable3" .. instance] = nil
		end
	end

	if visibleHeight then
		table_description.properties.maxVisibleHeight = visibleHeight
	else
		table_description.properties.maxVisibleHeight = table_description:getFullHeight()
	end

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	table_description.properties.y = table_button_bottom.properties.y - table_description:getVisibleHeight() - Helper.borderSize
	table_info.properties.maxVisibleHeight = table_description.properties.y - table_info.properties.y - Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
	table_description:addConnection(3, (instance == "left") and 2 or 3)
	table_button_bottom:addConnection(4, (instance == "left") and 2 or 3)
end

function menu.createCrewInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "crewinfomenu_open", menu.infoSubmenuObject)

	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship_xs") then
		mode = "none"
	elseif GetMacroData(GetComponentData(menu.infoSubmenuObject, "macro"), "islasertower") then
		mode = "none"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") then
		mode = "none"
	else
		DebugError("menu.createCrewInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	if (C.IsComponentClass(menu.infoSubmenuObject, "ship") or C.IsComponentClass(menu.infoSubmenuObject, "station")) and (menu.infoTablePersistentData[instance].resetcrew or (menu.infoTablePersistentData[instance].crew.object ~= menu.infoSubmenuObject)) then
		menu.infoSubmenuPrepareCrewInfo(instance)
		menu.infoTablePersistentData[instance].resetcrew = nil
	end

	local table_info = inputframe:addTable(7, { tabOrder = 1 } )
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidth(2, config.mapRowHeight)
	table_info:setColWidthPercent(4, 25)
	table_info:setColWidth(5, 0.25 * inputframe.properties.width - Helper.borderSize, false)
	table_info:setColWidth(6, 0.25 * inputframe.properties.width - (Helper.scaleY(config.mapRowHeight) + Helper.borderSize) , false)
	table_info:setColWidth(7, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 7)

	menu.setupCrewInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.createLoadoutInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "loadoutinfomenu_open", menu.infoSubmenuObject)

	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship_xs") then
		mode = "none"
	elseif GetMacroData(GetComponentData(menu.infoSubmenuObject, "macro"), "islasertower") then
		mode = "none"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") then
		mode = "none"
	else
		DebugError("menu.createLoadoutInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	local table_info = inputframe:addTable(13, { tabOrder = 1 } )
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidth(3, config.mapRowHeight)
	table_info:setColWidth(4, config.mapRowHeight)
	table_info:setColWidth(5, config.mapRowHeight)
	table_info:setColWidth(6, config.mapRowHeight)
	table_info:setColWidth(7, 0.25 * inputframe.properties.width - 4 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize) , false)
	table_info:setColWidth(8, config.mapRowHeight)
	table_info:setColWidth(9, config.mapRowHeight)
	table_info:setColWidth(10, config.mapRowHeight)
	table_info:setColWidth(11, config.mapRowHeight)
	table_info:setColWidth(12, math.max(1, 0.25 * inputframe.properties.width - 5 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)) , false)
	table_info:setColWidth(13, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 13)

	menu.setupLoadoutInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	
	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
end

function menu.createLogbookInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, "objectlogbook")

	AddUITriggeredEvent(menu.name, "logbookinfomenu_open", menu.infoSubmenuObject)

	local useSeparatePageRow = true
	local buttonsize = Helper.scaleY(config.mapRowHeight)
	local table_info = inputframe:addTable(10, { tabOrder = 1 } )
	table_info:setColWidth(1, inputframe.properties.width / 3, false)
	table_info:setColWidth(4, config.mapRowHeight)
	table_info:setColWidth(5, config.mapRowHeight)
	table_info:setColWidth(6, config.mapRowHeight)
	table_info:setColWidth(7, config.mapRowHeight)
	table_info:setColWidth(8, inputframe.properties.width / 3 - 4 * (buttonsize + Helper.borderSize), false)
	table_info:setColWidth(9, config.mapRowHeight)
	table_info:setColWidth(10, config.mapRowHeight)

	menu.setupLogbookInfoSubmenuRows(table_info, menu.infoSubmenuObject, instance, isvalid)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	local table_button = inputframe:addTable(3, { tabOrder = 3 } )
	table_button:addEmptyRow()
	local row = table_button:addRow(true, { bgColor = Helper.color.transparent })
	row[3]:createButton({ active = isvalid }):setText(ReadText(1001, 5722), { halign = "center" })
	row[3].handlers.onClick = function () return menu.buttonInfoLogbookClearQuestion(instance) end

	local infotableheight = table_info:getFullHeight()
	local buttontableheight = table_button:getFullHeight()
	if table_info.properties.y + infotableheight + buttontableheight + Helper.borderSize + Helper.frameBorder < frameheight then
		table_button.properties.y = table_info.properties.y + infotableheight + Helper.borderSize
	else
		table_button.properties.y = frameheight - Helper.frameBorder - buttontableheight
		table_info.properties.maxVisibleHeight = table_button.properties.y - Helper.borderSize - table_info.properties.y
	end
	
	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_info:addConnection(2, (instance == "left") and 2 or 3)
	table_button:addConnection(3, (instance == "left") and 2 or 3)
end

function menu.setupInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local object64 = ConvertStringTo64Bit(tostring(inputobject))

	if (not menu.infoTablePersistentData[instance].cashtransferdetails) or (menu.infoTablePersistentData[instance].cashtransferdetails.curobject ~= inputobject) then
		menu.infoTablePersistentData[instance].cashtransferdetails = { curobject = inputobject, transfers = {} }
		menu.infoTablePersistentData[instance].drops = {}
	end

	local infocashtransferdetails = menu.infoTablePersistentData[instance].cashtransferdetails
	local infodrops = menu.infoTablePersistentData[instance].drops

	local indentsize = 0

	local loadout = {}
	if mode == "ship" or mode == "station" then
		loadout = { ["component"] = {}, ["macro"] = {}, ["ware"] = {} }
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				loadout.component[upgradetype.type] = {}
				local numslots = 0
				if C.IsComponentClass(inputobject, "defensible") then
					numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", upgradetype.type))
				end
				for j = 1, numslots do
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, upgradetype.type, j)
					if current ~= 0 then
						table.insert(loadout.component[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				loadout.macro[upgradetype.type] = {}
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(inputobject, "", upgradetype.type))
				for j = 1, numslots do
					local current = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(inputobject, upgradetype.type, j))
					if current ~= "" then
						table.insert(loadout.macro[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "software" then
				loadout.ware[upgradetype.type] = {}
				local numslots = C.GetNumSoftwareSlots(inputobject, "")
				local buf = ffi.new("SoftwareSlot[?]", numslots)
				numslots = C.GetSoftwareSlots(buf, numslots, inputobject, "")
				for j = 0, numslots - 1 do
					local current = ffi.string(buf[j].current)
					if current ~= "" then
						table.insert(loadout.ware[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "ammo" then
				loadout.macro[upgradetype.type] = {}
			end
		end
	end

	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Helper.color.white
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other") and menu.getFilterOption("think_diplomacy_highlightvisitor") then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end
	local unknowntext = ReadText(1001, 3210)
	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local ownerinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "owner")
	local defenceinfo_low =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_level")
	local defenceinfo_high =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_status")
	local operatorinfo =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_name")
	local operatorinfo_details =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_details")
	local operatorinfo_commands =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_commands")
	local productioninfo_products =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_products")
	local productioninfo_rate =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_rate")
	local productioninfo_resources =	cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_resources")
	local productioninfo_time =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_time")
	local storageinfo_capacity =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_capacity")
	local storageinfo_amounts =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_amounts")
	local storageinfo_warelist =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_warelist")
	local unitinfo_capacity =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_capacity")
	local unitinfo_amount =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_amount")
	local unitinfo_details =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_details")

	if not isplayerowned then
		menu.extendedinfo["info_weaponconfig" .. instance] = nil
	end

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(8):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)

	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(8):createText(ReadText(1001, 1111), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	--- object name ---
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[8]:createButton({ width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[8].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(7):setColSpan(5):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[6]:setColSpan(2):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[6].properties.halign = "right"
		row[6].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(7):setColSpan(7):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		locrowdata = { "info_name", ReadText(1001, 2809) .. ReadText(1001, 120), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], { bgColor = Helper.color.transparent })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + indentsize })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)
		end

		locrowdata = { false, ReadText(1001, 9040) .. ReadText(1001, 120), Helper.unlockInfo(ownerinfo, GetComponentData(object64, "ownername")) }	-- "Owner"
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local loccontainer = nil
		if isdocked then
			loccontainer = ConvertStringTo64Bit(tostring(C.GetTopLevelContainer(inputobject)))
		end
		local objectlocid64 = ConvertStringTo64Bit(tostring(GetComponentData(object64, "sectorid")))
		if objectlocid64 == 0 then
			objectlocid64 = ConvertStringTo64Bit(tostring(GetComponentData(object64, "clusterid")))		-- no sector; object is in superhighway
		end
		local objectloc = Helper.unlockInfo(C.IsInfoUnlockedForPlayer(objectlocid64, "name"), ffi.string(C.GetComponentName(objectlocid64)))
		if loccontainer then
			objectloc = ReadText(1001, 3248) .. " " .. ffi.string(C.GetComponentName(loccontainer)) .. ", " .. objectloc	-- Docked at
		end
		locrowdata = { false, ReadText(1001, 2943) .. ReadText(1001, 120), objectloc }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local macroname, ware, islasertower = GetMacroData(GetComponentData(object64, "macro"), "name", "ware", "islasertower")
		local objecttype = Helper.unlockInfo(nameinfo, macroname)
		locrowdata = { false, ReadText(1001, 94) .. ReadText(1001, 120), objecttype }	-- Model
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		if ware then
			local n = C.GetNumWareBlueprintOwners(ware)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWareBlueprintOwners(buf, n, ware)
			local first = true
			for i = 0, n - 1 do
				local faction = ffi.string(buf[i])
				local name = GetFactionData(faction, "name")
				local known = IsKnownItem("factions", faction)
				if known then
					locrowdata = { false, first and (ReadText(1001, 8391) .. ReadText(1001, 120)) or "", Helper.unlockInfo(nameinfo, name) }	-- Produced by
					row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
					first = false
				end
			end
		end

		locrowdata = { false, ReadText(1001, 9051) .. ReadText(1001, 120), Helper.unlockInfo(nameinfo, (function() return tostring(GetComponentData(object64, "shiptypename") or 0, true, 0, true) end)) }	-- Ship Type
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString(Helper.round(GetComponentData(object64, "hullmax")), true, 4, true, true, true))
		locrowdata = { false, ReadText(1001, 1) .. ReadText(1001, 120), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" ..  GetComponentData(object64, "hullpercent") .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local shield_max = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString(Helper.round(GetComponentData(object64, "shieldmax")), true, 4, true, true, true))
		locrowdata = { false, ReadText(1001, 2) .. ReadText(1001, 120), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "shield")), true, 4, true, true, true) .. " / " .. shield_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "shieldpercent") .. "%)") end) or (unknowntext .. " / " .. shield_max .. " " .. ReadText(1001, 118) .. " (" ..  GetComponentData(object64, "shieldpercent") .. "%)")) }	-- Shield, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { true, ReadText(1001, 9076) .. ReadText(1001, 120), defenceinfo_low and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "maxunboostedforwardspeed") or 0), true, 0, true) .. " " .. ReadText(1001, 113)) end) or (unknowntext .. " " .. ReadText(1001, 113)) }	-- Cruising Speed, m/s
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)

		local dpstable = ffi.new("DPSData[?]", 6)
		local hasturrets = (defenceinfo_low and #loadout.component.turret > 0)
		local numtotalquadrants = C.GetDefensibleDPS(dpstable, inputobject, true, true, true, true, hasturrets, false, false)
		if not hasturrets then
			locrowdata = { false, ReadText(1001, 9092) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(dpstable[0].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- Weapon Output, MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		else
			for i = 0, numtotalquadrants - 1 do
				locrowdata = { false, (ReadText(1001, 9092) .. " (" .. ReadText(20220, dpstable[i].quadranttextid) .. ")" .. ReadText(1001, 120)), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(dpstable[i].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- Weapon Output, MW
				row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
			end
		end

		local sustainedfwddps = ffi.new("DPSData[?]", 1)
		C.GetDefensibleDPS(sustainedfwddps, inputobject, true, true, true, true, false, true, false)
		if sustainedfwddps[0].dps > 0 then
			locrowdata = { false, ReadText(1001, 9093) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(sustainedfwddps[0].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
		-- crew skill
		if (not C.IsRealComponentClass(inputobject, "ship_xs")) and (not islasertower) then
			local shipcombinedskill = math.floor(C.GetShipCombinedSkill(inputobject) * 15 / 100)
			local printedshipcombinedskill = unknowntext
			local locfont = inputfont
			local locfontcolor = Helper.standardColor
			if operatorinfo_details then
				printedshipcombinedskill = Helper.displaySkill(shipcombinedskill)
				locfontcolor = Helper.color.brightyellow
			end
			locrowdata = { false, ReadText(1001, 9427) .. ReadText(1001, 120), printedshipcombinedskill }	-- Crew Skill
			row = inputtable:addRow(locrowdata[1], { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = Helper.standardTextOffsetx + indentsize, mouseOverText = ReadText(1026, 1) })
			row[4]:setColSpan(5):createText(locrowdata[3], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = locfont, color = locfontcolor, mouseOverText = ReadText(1026, 1) })
		end
		-- radar range
		local radarrange = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString((Helper.round(GetComponentData(object64, "maxradarrange")) / 1000), true, 0, true))
		locrowdata = { false, ReadText(1001, 2426) .. ReadText(1001, 120), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- boarding strength
		locrowdata = { false, ReadText(1001, 1325) .. ReadText(1001, 120), Helper.unlockInfo(defenceinfo_high, (function() return ConvertIntegerString(GetComponentData(object64, "boardingstrength") or 0, true, 0, true) end)) }	-- Boarding Attack Strength
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- docked ships
		local shipstoragecapacity, numdockingbays = GetComponentData(inputobject, "shipstoragecapacity", "numdockingbays")
		local maxdockedships = (shipstoragecapacity or 0) + (numdockingbays or 0)
		if maxdockedships > 0 then
			local numdockedships = 0
			if C.IsComponentClass(inputobject, "container") then
				numdockedships = C.GetNumDockedShips(inputobject, nil)
			end
			local row = inputtable:addRow("info_dockedships", { bgColor = Helper.color.transparent })
			row[1]:createButton({ height = config.mapRowHeight, active = numdockedships > 0 }):setText(function() return (numdockedships > 0 and menu.isInfoExtended("info_dockedships", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_dockedships", instance) end
			row[1].properties.uiTriggerID = "info_dockedships_toggle"
			row[2]:setColSpan(2):createText(ReadText(1001, 3265) .. ReadText(1001, 120)) -- Docked Ships
			row[4]:setColSpan(5):createText(numdockedships .. " / " .. maxdockedships, { halign = "right" })
			if menu.isInfoExtended("info_dockedships", instance) then
				local dockedships = ffi.new("UniverseID[?]", numdockedships)
				numdockedships = C.GetDockedShips(dockedships, numdockedships, inputobject, nil)
				local playerowneddockedships = {}
				local npcowneddockedships = {}
				for i = 0, numdockedships-1 do
					local locship = ConvertStringTo64Bit(tostring(dockedships[i]))
					if GetComponentData(locship, "isplayerowned") then
						table.insert(playerowneddockedships, locship)
					else
						table.insert(npcowneddockedships, locship)
					end
				end
				table.sort(playerowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				table.sort(npcowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

				for i, shipid in ipairs(playerowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. i, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(2):createText(shipname, { color = Helper.color.green, x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", color = Helper.color.green, x = Helper.standardTextOffsetx + indentsize })
				end
				for i, shipid in ipairs(npcowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. (#playerowneddockedships + i), { bgColor = Helper.color.transparent })
					row[2]:setColSpan(2):createText(shipname, { x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", x = Helper.standardTextOffsetx + indentsize })
				end
			end
		end
		-- pilot
		local pilot = GetComponentData(inputobject, "assignedpilot")
		pilot = ConvertIDTo64Bit(pilot)
		local pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, ReadText(1001, 4847), {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end
		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		if (not C.IsRealComponentClass(inputobject, "ship_xs")) and (not islasertower) then
			-- title
			local printedtitle = isbigship and ReadText(1001, 4848) or ReadText(1001, 4847)	-- Captain, Pilot
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(printedtitle, Helper.headerRowCenteredProperties)
			if pilot then
				local adjustedskill = math.floor(C.GetEntityCombinedSkill(pilot, nil, "aipilot") * 15 / 100)
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
				-- name
				local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
				local row = inputtable:addRow({ "info_pilot", pilot, inputobject }, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText(printedpilotname, { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Helper.standardColor
				if operatorinfo_details then
					locfontcolor = Helper.color.brightyellow
				end
				row[4]:setColSpan(5):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			else
				-- name
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText("-", { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Helper.standardColor
				row[4]:setColSpan(5):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			end
			-- commander
			local commander = nil
			if C.IsComponentClass(inputobject, "controllable") then
				commander = GetCommander(menu.infoSubmenuObject)
			end
			local commandername, commandercolor = "-", Helper.color.white
			if commander then
				commandername, commandercolor = menu.getContainerNameAndColors(commander, 0, false, false)
			end
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(2):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(commandername, { halign = "right", color = commandercolor })
			-- subordinates
			local subordinates = {}
			if C.IsComponentClass(inputobject, "controllable") then
				subordinates = GetSubordinates(inputobject)
			end
			local row = inputtable:addRow("info_subordinates", { bgColor = Helper.color.transparent, interactive = false })
			row[2]:setColSpan(2):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[4]:setColSpan(5):createText(#subordinates, { halign = "right" })
			-- current order
			local numorders = C.GetNumOrders(inputobject)
			local currentorders = ffi.new("Order[?]", numorders)
			local activeorder = ffi.new("Order")
			if numorders > 0 then
				numorders = C.GetOrders(currentorders, numorders, inputobject)
				activeorder = currentorders[0]
			else
				C.GetDefaultOrder(activeorder, inputobject)
			end
			local ordername = ReadText(1001, 31)
			local orderdefinition = ffi.new("OrderDefinition")
			if activeorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, activeorder.orderdef) then
				ordername = Helper.unlockInfo(operatorinfo_commands, ffi.string(orderdefinition.name))
			end
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(2):createText(ReadText(1001, 8392) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(ordername, { halign = "right" })
			-- command
			if pilot and IsValidComponent(pilot) then
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(2):createText(ReadText(1001, 78) .. ReadText(1001, 120), { x = Helper.standardIndentStep })
				if #aicommandstack > 0 then
					aicommand = aicommandstack[1].command
					aicommandparam = aicommandstack[1].param
				end
				row[4]:setColSpan(5):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)), { halign = "right" })
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				local numaicommands = #aicommandstack
				if numaicommands > 1 then
					aicommandaction = aicommandstack[numaicommands].command
					aicommandactionparam = aicommandstack[numaicommands].param
				end
				row[4]:setColSpan(5):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)), { halign = "right" })
			end
			if isplayerowned then
				-- transaction log
				local row = inputtable:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(2):createText(ReadText(1001, 11286) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createButton({  }):setText(ReadText(1001, 11287), { halign = "center" })
				row[4].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, inputobject }); menu.cleanup() end
			end
		end
		-- storage
		local storagemodules = GetStorageData(object64)
		local cargotable = {}
		local sortedwarelist = {}
		local simplewarelist = {}
		for _, storagemodule in ipairs(storagemodules) do
			for _, ware in ipairs(storagemodule) do
				table.insert(sortedwarelist, ware)
				simplewarelist[ware.ware] = true
			end
		end

		local isresupplyship = GetComponentData(object64, "cansupplyships")
		if isresupplyship then
			local n = C.GetNumMaxProductionStorage(object64)
			local buf = ffi.new("UIWareAmount[?]", n)
			n = C.GetMaxProductionStorage(buf, n, object64)
			for i = 0, n - 1 do
				local locwareid = ffi.string(buf[i].wareid)
				if not simplewarelist[locwareid] then
					local locware = {}
					locware["ware"] = locwareid
					locware["name"], locware["volume"] = GetWareData(locwareid, "name", "volume")
					locware["amount"] = 0
					locware["consumption"] = buf[i].amount
					table.insert(sortedwarelist, locware)
					--print("inserting " .. tostring(locware.name) .. ". id: " .. tostring(locware.ware) .. ", name: " .. tostring(locware.name) .. ", amount: " .. tostring(locware.amount) .. ", volume: " .. tostring(locware.volume) .. ", consumption: " .. tostring(locware.consumption))
				end
			end
		end

		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)
		for _, ware in ipairs(sortedwarelist) do
			table.insert(cargotable, { ware = ware.ware, amount = ware.amount })
		end
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 1400), Helper.headerRowCenteredProperties) -- Storage
		if storageinfo_warelist then
			-- slider showing total filled capacity
			local n = C.GetNumCargoTransportTypes(inputobject, true)
			local transporttype = ffi.new("StorageInfo[?]", n)
			n = C.GetCargoTransportTypes(transporttype, n, inputobject, true, false)
			for i = 0, n - 1 do
				-- slider showing total filled capacity
				row = inputtable:addRow("info_storage_used_" .. ffi.string(transporttype[i].transport), { bgColor = Helper.color.transparent, interactive = false })
				row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = transporttype[i].spaceused, max = transporttype[i].capacity, suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 1402) .. " (" .. ffi.string(transporttype[i].name) .. ")" .. ReadText(1001, 120)), { fontsize = config.mapFontSize, color = Helper.standardColor })
			end

			--local row = inputtable:addRow("info_storage_totalused", { bgColor = Helper.color.transparent })
			--row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = storagemodules.stored, max = math.max(storagemodules.capacity, storagemodules.stored), suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 1402) .. ReadText(1001, 120)), { fontsize = config.mapFontSize, color = Helper.standardColor })

			if isplayerowned then
				local numtrips = GetComponentData(object64, "numtrips") or 0
				if numtrips > 0 then
					local cargoaftertrades = GetCargoAfterTradeOrders(object64, true)
					local totalvolume = 0
					for ware, amount in pairs(cargoaftertrades) do
						totalvolume = totalvolume + amount * GetWareData(ware, "volume")
					end
					local row = inputtable:addRow("info_storage_future", { bgColor = Helper.color.transparent, interactive = false })
					row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = totalvolume, max = math.max(storagemodules.capacity, totalvolume), suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 8374) .. ReadText(1001, 120)), { fontsize = config.mapFontSize, color = Helper.standardColor })
				end
			end

			inputtable:addEmptyRow(config.mapRowHeight / 2)

			local candrop = isplayerowned and (not C.IsUnit(menu.infoSubmenuObject))
			local locpolicefaction = GetComponentData(GetComponentData(object64, "zoneid"), "policefaction")
			for _, wareentry in ipairs(cargotable) do
				local ware = wareentry.ware
				local amount = wareentry.amount
				local targetamount = GetWareProductionLimit(object64, ware)
				if not infodrops[ware] then
					infodrops[ware] = 0
				end
				local row = inputtable:addRow(ware, { bgColor = Helper.color.transparent, interactive = playerowned })
				if not isresupplyship then
					row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = math.max(math.floor(storagemodules.capacity / GetWareData(ware, "volume")), amount - infodrops[ware]), readOnly = not candrop, hideMaxValue = true }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Helper.color.illegal or Helper.standardColor })
				else
					-- applies even if targetamount == 0
					if targetamount then
						row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = math.max(targetamount, amount), readOnly = not candrop }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Helper.color.illegal or Helper.standardColor })
					else
						row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = amount, readOnly = not candrop, hideMaxValue = true }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Helper.color.illegal or Helper.standardColor })
					end
				end

				if candrop then
					--local oldamount = amount
					row[2].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateDrops(ware, amount, newamount, instance) end
					row[2].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
					row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
					row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

					local row = inputtable:addRow("Drops", { bgColor = Helper.color.transparent })
					row[4]:setColSpan(5):createText(function() return (infodrops[ware] ~= 0) and (ReadText(1001, 9406) .. ReadText(1001, 120) .. " (" .. tostring(infodrops[ware]) .. ")") or "" end, { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont })	-- Dropping, :
				end
			end

			if candrop then
				local stufftodrop = false
				for ware, numdrops in pairs(infodrops) do
					if numdrops > 0 then
						stufftodrop = true
						break
					end
				end
				local row = inputtable:addRow("ConfirmDrops", { bgColor = Helper.color.transparent })

				-- add a "Drop" button
				row[4]:setColSpan(2):createButton({ height = config.mapRowHeight, active = stufftodrop }):setText(ReadText(1001, 9405), { halign = "center", fontsize = config.mapFontSize })	-- Drop
				row[4].handlers.onClick = function() return menu.infoSubmenuConfirmDrops(inputobject, instance) end
				row[6]:setColSpan(3):createButton({ height = config.mapRowHeight, active = stufftodrop }):setText(ReadText(1001, 64), { halign = "center", fontsize = config.mapFontSize })	-- Cancel
				row[6].handlers.onClick = function() return menu.resetInfoSubmenu(nil, instance) end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(7):createText(ReadText(1001, 3210))
		end
	elseif mode == "station" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			local row = inputtable:addRow(locrowdata[1], { bgColor = Helper.color.transparent })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)
		end

		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, GetComponentData(object64, "ownername")) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2943), GetComponentData(object64, "sector") }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = defenceinfo_low and ConvertIntegerString(Helper.round(GetComponentData(object64, "hullmax")), true, 4, true, true, true) or unknowntext
		locrowdata = { false, ReadText(1001, 1), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local radarrange = defenceinfo_low and (Helper.round(GetComponentData(object64, "maxradarrange")) / 1000) or unknowntext
		locrowdata = { false, ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- docked ships
		local shipstoragecapacity, numdockingbays = GetComponentData(inputobject, "shipstoragecapacity", "numdockingbays")
		local maxdockedships = (shipstoragecapacity or 0) + (numdockingbays or 0)
		if maxdockedships > 0 then
			local numdockedships = 0
			if C.IsComponentClass(inputobject, "container") then
				numdockedships = C.GetNumDockedShips(inputobject, nil)
			end
			local row = inputtable:addRow("info_dockedships", { bgColor = Helper.color.transparent })
			row[1]:createButton({ height = config.mapRowHeight, active = numdockedships > 0 }):setText(function() return (numdockedships > 0 and menu.isInfoExtended("info_dockedships", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_dockedships", instance) end
			row[1].properties.uiTriggerID = "info_dockedships_toggle"
			row[2]:setColSpan(2):createText(ReadText(1001, 3265) .. ReadText(1001, 120)) -- Docked Ships
			row[4]:setColSpan(5):createText(numdockedships .. " / " .. maxdockedships, { halign = "right" })
			if menu.isInfoExtended("info_dockedships", instance) then
				local dockedships = ffi.new("UniverseID[?]", numdockedships)
				numdockedships = C.GetDockedShips(dockedships, numdockedships, inputobject, nil)
				local playerowneddockedships = {}
				local npcowneddockedships = {}
				for i = 0, numdockedships-1 do
					local locship = ConvertStringTo64Bit(tostring(dockedships[i]))
					if GetComponentData(locship, "isplayerowned") then
						table.insert(playerowneddockedships, locship)
					else
						table.insert(npcowneddockedships, locship)
					end
				end
				table.sort(playerowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				table.sort(npcowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

				for i, shipid in ipairs(playerowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. i, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(2):createText(shipname, { color = Helper.color.green, x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", color = Helper.color.green, x = Helper.standardTextOffsetx + indentsize })
				end
				for i, shipid in ipairs(npcowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. (#playerowneddockedships + i), { bgColor = Helper.color.transparent })
					row[2]:setColSpan(2):createText(shipname, { x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", x = Helper.standardTextOffsetx + indentsize })
				end
			end
		end
		-- trade subscription
		locrowdata = { false, ReadText(1001, 9414), (GetComponentData(object64, "tradesubscription") and ReadText(1001, 2617) or ReadText(1001, 2618)) }	-- Updating Trade Offers
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local buildstorage = ConvertIDTo64Bit(GetComponentData(inputobject, "buildstorage"))
		if isplayerowned then
			-- acccounts
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(ReadText(1001, 7708), Helper.headerRowCenteredProperties) -- Account Management
			local playercash = GetPlayerMoney()
			local cashcontainers = {}
			if C.IsComponentClass(inputobject, "container") then
				table.insert(cashcontainers, { container = inputobject, estimatetype = "productionmoney", supply = true, tradewares = true, text = ReadText(1001, 7710) }) -- Station Account
			end
			if buildstorage then
				table.insert(cashcontainers, { container = buildstorage, estimatetype = "wantedmoney", text = ReadText(1001, 9429) }) -- Funds for Station Construction
			end
			for i, entry in ipairs(cashcontainers) do
				if i ~= 1 then
					inputtable:addEmptyRow(config.mapRowHeight)
				end

				if not infocashtransferdetails.transfers[i] then
					infocashtransferdetails.transfers[i] = { object = entry.container, amount = 0, estimatetype = entry.estimatetype, supply = entry.supply, tradewares = entry.tradewares }
				end

				local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:createText("", { cellBGColor = Helper.color.transparent })
				row[2]:setColSpan(7):createText(entry.text, Helper.subHeaderTextProperties)

				local container = entry.container
				local containercash = GetAccountData(container, "money") or 0
				local sliderstart = infocashtransferdetails.transfers[i].amount + containercash
				local slidermax = math.max((containercash + playercash), sliderstart)

				local othertransfers = 0
				for j, transferentry in ipairs(infocashtransferdetails.transfers) do
					if j ~= i then
						othertransfers = othertransfers + transferentry.amount
					end
				end
				local slidermaxselect = math.min(math.max((containercash + playercash - othertransfers), sliderstart), slidermax)

				local row = inputtable:addRow("info_stationaccount" .. i, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(7):createSliderCell({
					height = config.mapRowHeight,
					start = sliderstart, 
					min = math.min(containercash, 0),
					max = slidermax,
					maxSelect = slidermaxselect,
					suffix = ReadText(1001, 101) })

				row[2].handlers.onSliderCellChanged = function(_, value) 
					local idx = i
					local loccash = containercash
					return menu.infoSubmenuUpdateTransferAmount(instance, value, idx, loccash) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				row[2].handlers.onSliderCellConfirm = function() menu.over = true end

				local row = inputtable:addRow(nil, { bgColor = Helper.color.unselectable })
				row[1]:createText("", { cellBGColor = Helper.color.transparent })
				
				local baseestimate = GetComponentData(container, entry.estimatetype)
				local supplymoney, tradewaremoney = 0, 0
				local estimate = baseestimate
				if entry.supply then
					supplymoney = tonumber(C.GetSupplyBudget(container)) / 100
					estimate = estimate + supplymoney
				end
				if entry.tradewares then
					tradewaremoney = tonumber(C.GetTradeWareBudget(container)) / 100
					estimate = estimate + tradewaremoney
				end

				local text = ReadText(1001, 9434)
				local mouseovertext = ""
				if container == buildstorage then
					text = ReadText(1001, 9436)
				else
					mouseovertext =	ReadText(1001, 8420) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(baseestimate, false, true, 0, true)	.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8423) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(supplymoney, false, true, 0, true)		.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8447) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tradewaremoney, false, true, 0, true)	.. " " .. ReadText(1001, 101)
				end
				row[2]:setColSpan(2):createText(text .. ReadText(1001, 120), { mouseOverText = mouseovertext })
				row[4]:setColSpan(5):createText(ConvertMoneyString(estimate, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })

				local row = inputtable:addRow("info_updateaccount", { bgColor = Helper.color.transparent })
				row[3]:createButton({ height = config.mapRowHeight, active = function () local money, estimate = GetComponentData(container, "money", entry.estimatetype); if entry.supply then estimate = estimate + tonumber(C.GetSupplyBudget(container)) / 100 end; if entry.tradewares then estimate = estimate + tonumber(C.GetTradeWareBudget(container)) / 100 end; return (money + GetPlayerMoney()) > estimate end }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })	-- Accept Estimate
				row[3].handlers.onClick = function () return menu.infoSubmenuSetManagerAccountToEstimate(i, instance) end
				row[4]:setColSpan(2):createButton({ height = config.mapRowHeight, active = function () return menu.checkTransferDetails(i, instance) end }):setText(ReadText(1001, 2821), { halign = "center", fontsize = config.mapFontSize })	-- Confirm
				row[4].handlers.onClick = function () return menu.infoSubmenuUpdateManagerAccount(i, instance) end
				row[6]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function () return menu.checkTransferDetails(i, instance) end }):setText(ReadText(1001, 64), { halign = "center", fontsize = config.mapFontSize })	-- Cancel
				row[6].handlers.onClick = function() return menu.resetInfoSubmenu(i, instance) end
			end
			-- trade rules
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(ReadText(1001, 11010), Helper.headerRowCenteredProperties)

			local types = {
				{ type = "trade",	name = ReadText(1001, 11017) },
				{ type = "supply",	name = ReadText(1001, 11018) },
				{ type = "build",	name = ReadText(1001, 11019), condition = GetComponentData(inputobject, "canequipships") },
			}
			if buildstorage then
				table.insert(types, { type = "trade",	name = ReadText(1001, 11032), object = buildstorage })
			end
			local displayed = false
			for i, entry in ipairs(types) do
				if (entry.condition == nil) or entry.condition then
					if displayed then
						row = inputtable:addRow(false, { bgColor = Helper.color.transparent })
						row[1]:setColSpan(8):createText("")
					end
					displayed = true

					row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
					row[1]:setColSpan(8):createText(entry.name .. ReadText(1001, 120))

					local object = entry.object or inputobject
					local hasownlist, traderuleid
					if entry.type == "trade" then
						hasownlist = C.HasContainerOwnTradeRule(object, "buy", "") or C.HasContainerOwnTradeRule(object, "sell", "")
						traderuleid = C.GetContainerTradeRuleID(object, "buy", "")
						if traderuleid ~= C.GetContainerTradeRuleID(object, "sell", "") then
							DebugError("menu.setupInfoSubmenuRows(): Mismatch between buy and sell trade rule on station level: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(inputobject, "sell", "")))
						end
					else
						hasownlist = C.HasContainerOwnTradeRule(object, entry.type, "")
						traderuleid = C.GetContainerTradeRuleID(object, entry.type, "")
					end

					local rowdata = "info_traderule_" .. entry.type .. "_global"
					local row = inputtable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
					row[1]:createCheckBox(not hasownlist, { width = config.mapRowHeight, height = config.mapRowHeight })
					row[1].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(object, entry.type, checked) end
					row[2]:setColSpan(7):createText(ReadText(1001, 8367))

					local row = inputtable:addRow("info_traderule_" .. entry.type .. "_current", { bgColor = Helper.color.transparent })
					row[1]:setColSpan(7):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
					row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(object, entry.type, id, nil, true) end
					row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
					row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
					row[8].handlers.onClick = menu.buttonEditTradeRule
				end
			end
			-- preferred build method
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(ReadText(1001, 11298), Helper.headerRowCenteredProperties)

			local cursetting = ffi.string(C.GetContainerBuildMethod(inputobject))
			local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
					if id == curglobalsetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				curglobalsetting = "default"
			end
			local hasownsetting = cursetting ~= ""

			local rowdata = "info_buildrule_global"
			local row = inputtable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(inputobject, checked, curglobalsetting) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367))

			local row = inputtable:addRow("info_buildrule", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(inputobject, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
		end
		-- manager
		local manager = GetComponentData(inputobject, "tradenpc")
		manager = ConvertIDTo64Bit(manager)
		local managername, skilltable, postname, isfemale = "-", {}, ReadText(1001, 4847)
		if manager then
			managername, skilltable, postname, isfemale = GetComponentData(manager, "name", "skills", "postname", "isfemale")
		end
		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- title
		local printedtitle = (manager and isfemale) and ReadText(20208, 30302) or ReadText(20208, 30301)
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(printedtitle, Helper.headerRowCenteredProperties)
		if manager then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(manager, nil, "manager") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow({ "info_pilot", manager, inputobject }, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(printedmanagername, { halign = "right" })
			-- combined skill
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
			local locfontcolor = Helper.standardColor
			if operatorinfo_details then
				locfontcolor = Helper.color.brightyellow
			end
			row[4]:setColSpan(5):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
		else
			-- name
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText("-", { halign = "right" })
			-- combined skill
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
			local locfontcolor = Helper.standardColor
			row[4]:setColSpan(5):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
		end
		-- subordinates
		local subordinates = C.IsComponentClass(inputobject, "controllable") and GetSubordinates(inputobject) or {}
		local row = inputtable:addRow("info_subordinates", { bgColor = Helper.color.transparent, interactive = false })
		row[2]:setColSpan(2):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
		row[4]:setColSpan(5):createText(#subordinates, { halign = "right" })
		if isplayerowned then
			-- transaction log
			local row = inputtable:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(2):createText(ReadText(1001, 11286) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createButton({  }):setText(ReadText(1001, 11287), { halign = "center" })
			row[4].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, inputobject }); menu.cleanup() end
		end
		--storage
		local productiontable = {}
		local products = {}
		local intermediatewares = {}
		local resources = {}
		local productionmodules = GetProductionModules(object64)
		for i, prodmod in ipairs(productionmodules) do
			local macro = GetComponentData(prodmod, "macro")
			local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
			for _, productdata in ipairs(macrodata.products) do
				if not products[productdata.ware] then
					products[productdata.ware] = { name = GetWareData(productdata.ware, "name"), amount = 0, ware = productdata.ware }
					products[productdata.ware].listed = false
				end
			end
		end
		list_allresources = GetComponentData(inputobject, "allresources")
		for _, resource in ipairs(list_allresources) do
			if products[resource] then
				intermediatewares[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				intermediatewares[resource].listed = false
				products[resource] = nil
			elseif not resources[resource] then
				resources[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				resources[resource].listed = false
			end
		end
		storagemodules = {capacity = 0, stored = 0}
		if C.IsComponentClass(inputobject, "container") then
			storagemodules = GetStorageData(inputobject)
		end
		cargotable = { products = {text = ReadText(1001, 1610), numcatwares = 0, wares = {}}, intermediatewares = {text = ReadText(1001, 6100), numcatwares = 0, wares = {}}, resources = {text = ReadText(1001, 41), numcatwares = 0, wares = {}}, storage = {text = ReadText(1001, 1400), numcatwares = 0, wares = {}} }	-- Products, Resources, Storage
		local cargocatindex = { "products", "intermediatewares", "resources", "storage" }
		numwares = 0
		local sortedwarelist = {}
		-- numbered: ware (see below); storagemodule.name, storagemodule.consumption, storagemodule.stored, storagemodule.capacity
		for _, storagemodule in ipairs(storagemodules) do
			--print("storage module: " .. tostring(storagemodule.name) .. ", consumption: " .. tostring(storagemodule.consumption) .. ", stored: " .. tostring(storagemodule.stored) .. ", capacity: " .. tostring(storagemodule.capacity))
			-- can query: ware.ware, ware.name, ware.amount, ware.consumption, ware.volume
			for _, ware in ipairs(storagemodule) do
				--print("sortedwarelist. inserting stored ware: " .. ware.name .. ", amount: " .. tostring(ware.amount))
				table.insert(sortedwarelist, ware)
				if resources[ware.ware] then
					--print("resource: " .. ware.name .. " is already listed.")
					resources[ware.ware].listed = true
				end
				if intermediatewares[ware.ware] then
					--print("resource: " .. ware.name .. " is already listed.")
					intermediatewares[ware.ware].listed = true
				end
				if products[ware.ware] then
					--print("product: " .. ware.name .. " is already listed.")
					products[ware.ware].listed = true
				end
			end
		end
		for _, resource in pairs(resources) do
			if not resource.listed then
				--print("sortedwarelist. inserting resource: " .. resource.name)
				table.insert(sortedwarelist, resource)
			end
		end
		for _, intermediateware in pairs(intermediatewares) do
			if not intermediateware.listed then
				--print("sortedwarelist. inserting intermediate ware: " .. intermediateware.name)
				table.insert(sortedwarelist, intermediateware)
			end
		end
		for _, product in pairs(products) do
			if not product.listed then
				--print("sortedwarelist. inserting product: " .. product.name)
				table.insert(sortedwarelist, product)
			end
		end
		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)

		for _, ware in ipairs(sortedwarelist) do
			local usage = "storage"
			if intermediatewares[ware.ware] then
				usage = "intermediatewares"
			elseif products[ware.ware] then
				usage = "products"
			elseif resources[ware.ware] then
				usage = "resources"
			end
			--print("usage: " .. tostring(usage) .. ", ware: " .. tostring(ware.ware) .. ", amount: " .. tostring(ware.amount) .. ", entry: " .. tostring(ware))
			table.insert(cargotable[usage].wares, { ware = ware.ware, amount = ware.amount })
			cargotable[usage].numcatwares = cargotable[usage].numcatwares + 1
			numwares = numwares + 1
		end
		--print("estimated: " .. tostring(storagemodules.estimated) .. ", productionestimated: " .. tostring(storagemodules.productionestimated))
		local loccapacity = (storagemodules.capacity > 0) and storagemodules.capacity or 0
		local locamount = storageinfo_amounts and storagemodules.stored or unknowntext
		local printednumwares = storageinfo_amounts and ConvertIntegerString(numwares, true, 0, true) or unknowntext

		-- ware reservations
		local reservationscapacity = menu.getReservationsVolumeByTransportType(inputobject)
		local reservationscargo = menu.getReservationsAmountByWareType(inputobject)

		-- title		
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 1400), Helper.headerRowCenteredProperties)
		if storageinfo_warelist then
			local n = C.GetNumCargoTransportTypes(inputobject, true)
			local transporttype = ffi.new("StorageInfo[?]", n)
			n = C.GetCargoTransportTypes(transporttype, n, inputobject, true, false)
			for i = 0, n - 1 do
				-- slider showing total filled capacity
				local rowdata = {
					inputtable = inputtable,
					textcolumn = 2,
					textcolspan = 7,
					barcolumn = 1,
					currentamount = transporttype[i].spaceused,
					futureamount = transporttype[i].spaceused,
					maxcapacity = transporttype[i].capacity,
					transporttypename = ffi.string(transporttype[i].name)
				}

				if reservationscapacity[ffi.string(transporttype[i].transport)] then
					rowdata.futureamount = rowdata.futureamount + reservationscapacity[ffi.string(transporttype[i].transport)]
				end

				menu.addCapacityRow(rowdata)
			end
			
			locrowdata = { "info_station_storage", (ReadText(1001, 1400) .. " (" .. printednumwares .. " " .. ((printednumwares == "1") and ReadText(1001, 45) or ReadText(1001, 46)) .. ")") }	-- Storage, Ware, Wares
			local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, true, (numwares > 0) and true or false, 1, indentsize)
			local setting, list = menu.getTradeWareFilter()
			if menu.isInfoExtended(locrowdata[1], instance) then
				for i, usagecat in ipairs(cargocatindex) do
					if (cargotable[usagecat].numcatwares > 0) then
						--print("adding category: " .. cargotable[usagecat].text)
						locrowdata = { false, (cargotable[usagecat].text .. ReadText(1001, 120)) }
						local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata)
						for _, wareentry in ipairs(cargotable[usagecat].wares) do
							local ware = wareentry.ware
							local currentamount = wareentry.amount
							--print("ware: " .. tostring(ware) .. ", amount: " .. tostring(currentamount))
							locrowdata = { GetWareData(ware, "name"), currentamount }
							local printedwarecapacity = GetWareProductionLimit(inputobject, ware)
							--print("printedwarecapacity: " .. tostring(printedwarecapacity) .. ", amount: " .. tostring(currentamount))
							if (printedwarecapacity < 1) or (printedwarecapacity < currentamount) then
								printedwarecapacity = currentamount
							end

							local buttondata = {
								inputtable = inputtable,
								buttoncolumn = 2,
								buttoncolspan = 7,
								barcolumn = 1,
								currentamount = currentamount,
								futureamount = currentamount,
								maxcapacity = printedwarecapacity,
								warename = GetWareData(ware, "name")
							}

							if reservationscargo[ware] then
								buttondata.futureamount = buttondata.futureamount + reservationscargo[ware]
							end

							buttondata.textcolor, buttondata.buttonscript = menu.getWareButtonColorAndScript(list, setting, ware)
							menu.addWareInfoButtonRow(buttondata)
						end
					end
				end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(7):createText(ReadText(1001, 3210))
		end

		-- build storage
		local storagemodules = {}
		local cargotable = {}
		local numwares = 0
		local sortedwarelist = {}
		local list_allresources = {}
		local resources = {}
		local reservationsbuildcapacity = 0
		local reservationsbuildcargo = 0
		if buildstorage then
			-- insert build storage details
			storagemodules = GetStorageData(buildstorage)
			list_allresources = GetComponentData(buildstorage, "allresources")
			-- build storage reservations
			reservationsbuildcapacity = menu.getReservationsAmountTotal(buildstorage)
			reservationsbuildcargo = menu.getReservationsAmountByWareType(buildstorage)
		end
		for _, resource in ipairs(list_allresources) do
			if not resources[resource] then
				resources[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				resources[resource].listed = false
				--print("registering resource: " .. tostring(resource))
			end
		end
		for _, storagemodule in ipairs(storagemodules) do
			for _, ware in ipairs(storagemodule) do
				table.insert(sortedwarelist, ware)
				--print("ware in storage. adding " .. tostring(ware.ware))
				if resources[ware.ware] then
					resources[ware.ware].listed = true
					--print(tostring(ware.ware) .. "is a resource.")
				end
			end
		end
		for _, resource in pairs(resources) do
			if not resource.listed then
				table.insert(sortedwarelist, resource)
				resource.listed = true
				--print("adding unlisted resource: " .. tostring(resource.ware))
			end
		end
		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)
		for _, ware in ipairs(sortedwarelist) do
			table.insert(cargotable, { ware = ware.ware, amount = ware.amount })
			numwares = numwares + 1
		end
		--print("storageinfo_warelist: " .. tostring(storageinfo_warelist) .. " numwares > 0: " .. tostring(numwares > 0))
		--print("buildstorage: " .. ffi.string(C.GetComponentName(buildstorage)) .. " " .. tostring(buildstorage) .. " numwares: " .. tostring(numwares))

		-- title
		if buildstorage then
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(8):createText(ReadText(20104, 80101), Helper.headerRowCenteredProperties)
			if storageinfo_warelist then
				local n = C.GetNumCargoTransportTypes(buildstorage, true)
				local transporttype = ffi.new("StorageInfo[?]", n)
				n = C.GetCargoTransportTypes(transporttype, n, buildstorage, true, false)
				for i = 0, n - 1 do
					-- slider showing total filled capacity
					local rowdata = {
						inputtable = inputtable,
						textcolumn = 2,
						textcolspan = 7,
						barcolumn = 1,
						currentamount = transporttype[i].spaceused,
						futureamount = transporttype[i].spaceused + reservationsbuildcapacity,
						maxcapacity = transporttype[i].capacity,
						transporttypename = ReadText(20104, 23003)
					}

					menu.addCapacityRow(rowdata)
				end
			
				local loccapacity = storageinfo_capacity and storagemodules.capacity or unknowntext
				local locamount = storageinfo_amounts and storagemodules.stored or unknowntext
				local printednumwares = storageinfo_amounts and ConvertIntegerString(numwares, true, 0, true) or unknowntext
				locrowdata = { "info_station_buildstorage_storage", (ReadText(1001, 1400) .. " (" .. printednumwares .. " " .. ((printednumwares == "1") and ReadText(1001, 45) or ReadText(1001, 46)) .. ")") }	-- Storage, Ware, Wares
				local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, true, (numwares > 0) and true or false, 1, indentsize)
				local setting, list = menu.getTradeWareFilter()
				if menu.isInfoExtended(locrowdata[1], instance) then
					for _, wareentry in ipairs(cargotable) do
						local ware = wareentry.ware
						local currentamount = wareentry.amount
						--print("ware: " .. tostring(ware) .. ", amount: " .. tostring(currentamount))
						local printedwarecapacity = GetWareProductionLimit(buildstorage, ware)
						--print("printedwarecapacity: " .. tostring(printedwarecapacity) .. ", amount: " .. tostring(currentamount))
						if (printedwarecapacity < 1) or (printedwarecapacity < currentamount) then
							printedwarecapacity = currentamount
						end
						locrowdata = { GetWareData(ware, "name"), currentamount }

						local buttondata = {
							inputtable = inputtable,
							buttoncolumn = 2,
							buttoncolspan = 7,
							barcolumn = 1,
							currentamount = currentamount,
							futureamount = currentamount,
							maxcapacity = printedwarecapacity,
							warename = GetWareData(ware, "name")
						}

						if reservationsbuildcargo[ware] then
							buttondata.futureamount = buttondata.futureamount + reservationsbuildcargo[ware]
						end

						buttondata.textcolor, buttondata.buttonscript = menu.getWareButtonColorAndScript(list, setting, ware)
						menu.addWareInfoButtonRow(buttondata)
					end
				end
			else
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(7):createText(ReadText(1001, 3210))
			end
		end

	elseif mode == "sector" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], { bgColor = Helper.color.transparent })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		local owner = GetComponentData(object64, "ownername")
		if C.IsContestedSector(object64) then
			owner = owner .. " " .. ReadText(1001, 3247)
		end
		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, owner) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local stationtable = GetContainedStations(object64, true)
		local numstations = #stationtable
		local productiontable = {}
		local products = {}
		local sectorpopulation = 0
		for _, station in ipairs(stationtable) do
			local workforceinfo = C.GetWorkForceInfo(ConvertStringTo64Bit(tostring(station)), "")
			sectorpopulation = sectorpopulation + workforceinfo.current
			table.insert(productiontable, GetComponentData(station, "products"))
		end
		for _, entry in ipairs(productiontable) do
			for _, product in ipairs(entry) do
				local notincremented = true
				for compproduct, count in pairs(products) do
					if compproduct == product then
						products[product] = count + 1
						notincremented = false
						break
					end
				end
				if notincremented then
					products[product] = 1
				end
			end
		end
		local maxproductgrp = ReadText(1001, 9002)	-- Unknown
		local maxcount = 0
		for product, count in pairs(products) do
			if not maxproductgrp or (count > maxcount) then
				maxproductgrp = GetWareData(product, "groupName")
				maxcount = count
			end
		end
		
		locrowdata = { false, ReadText(1001, 9041), ConvertIntegerString(tonumber(C.GetSectorPopulation(object64)), true, 3, true) }	-- Population
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		
		locrowdata = { false, ReadText(1001, 11296), string.format("%+.0f%%", GetComponentData(object64, "populationworkforcefactor") * 100) }	-- Workforce Availability Bonus
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2456), ConvertIntegerString(sectorpopulation, true, 3, true) }	-- Station Workforce
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9042), (numstations > 0 and numstations or 0) }	-- Known Stations
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9050), maxproductgrp }	-- Main Production
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		-- natural resources
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 9423), Helper.headerRowCenteredProperties) -- Natural Resources
		local sunlight = (GetComponentData(object64, "sunlight") * 100 .. "%")
		locrowdata = { false, ReadText(1001, 2412), sunlight }	-- Sunlight
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local resources = {}
		local n = C.GetNumDiscoveredSectorResources(object64)
		local buf = ffi.new("WareYield[?]", n)
		n = C.GetDiscoveredSectorResources(buf, n, object64)
		for i = 0, n - 1 do
			table.insert(resources, { name = GetWareData(ffi.string(buf[i].ware), "name"), current = buf[i].current, max = buf[i].max })
		end
		table.sort(resources, Helper.sortName)

		for _, entry in ipairs(resources) do
			locrowdata = { false, entry.name, ConvertIntegerString(entry.current, true, 3, true) }
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		-- TODO: Add Region info: NB: Matthias says that yield numbers for regions could be too big to be useful, and that retrieving that info is very inefficient. But we'll try when the function is up.

	elseif mode == "gate" then
		-- general info
		local isgateactive = GetComponentData(object64, "isactive")
		local gatedestinationsector, gatedestinationsector64
		local gatedestination = unknowntext
		if isgateactive then
			local destgate = GetComponentData(object64, "destination")
			if destgate then
				gatedestinationsector = GetContextByClass(destgate, "sector")
				gatedestinationsector64 = ConvertStringTo64Bit(tostring(gatedestinationsector))
				local destspace = Helper.getDisplayableGateDestinationSpace(object64)
				if destspace then
					gatedestination = GetComponentData(destspace, "name")
				end
			end
		end
		locrowdata = { false, ReadText(1001, 3215), tostring(gatedestination) }	-- (gate) Destination
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local destinationowner = unknowntext
		if C.IsInfoUnlockedForPlayer(gatedestinationsector64, "name") then
			destinationowner = GetComponentData(gatedestinationsector, "ownername") or ""
			if C.IsContestedSector(gatedestinationsector64) then
				destinationowner = destinationowner .. " " .. ReadText(1001, 3247)
			end
		end
		locrowdata = { false, ReadText(1001, 9424), tostring(destinationowner) }	-- Destination Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9425), (isgateactive and ReadText(1001, 2617) or ReadText(1001, 2618)) }	-- Active, Yes, No
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
	elseif mode == "deployable" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], { bgColor = Helper.color.transparent })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, GetComponentData(inputobject, "ownername")) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2943), GetComponentData(inputobject, "sector") }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = defenceinfo_low and ConvertIntegerString(Helper.round(GetComponentData(inputobject, "hullmax")), true, 4, true, true, true) or unknowntext
		locrowdata = { false, ReadText(1001, 1), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(inputobject, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(inputobject, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. unknowntext .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local radarrange = defenceinfo_low and GetComponentData(inputobject, "maxradarrange") or unknowntext

		if C.IsComponentClass(menu.infoSubmenuObject, "mine") then
			-- add if mines are made selectable in the map again:
			--	detonation output (s), tracking capability (s), friend/foe (s), proximity (s)
		elseif C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") then
			if radarrange and radarrange ~= unknowntext then
				radarrange = Helper.round(radarrange / 1000)
			end
			locrowdata = { "info_radarrange", ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 9082)) }	-- Scannning Range, km
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		elseif C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
			if radarrange and radarrange ~= unknowntext then
				radarrange = Helper.round(radarrange / 1000)
			end
			locrowdata = { false, ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
	elseif mode == "asteroid" then
		-- general info
		local rawlength = GetComponentData(inputobject, "length")
		local rawwidth = GetComponentData(inputobject, "width")
		local rawheight = GetComponentData(inputobject, "height")
		local loclength = ConvertIntegerString(rawlength, true, 0, true)
		local locwidth = ConvertIntegerString(rawwidth, true, 0, true)
		local locheight = ConvertIntegerString(rawheight, true, 0, true)
		locrowdata = { false, ReadText(1001, 9229), (loclength .. ReadText(1001, 107) .. " " .. ReadText(1001, 42) .. " " .. locwidth .. ReadText(1001, 107) .. " " .. ReadText(1001, 42) .. " " .. locheight .. ReadText(1001, 107)) }	-- m, x
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local rawvolume = rawlength * rawwidth * rawheight
		local locvolume = ConvertIntegerString(rawvolume, true, 0, true)
		locrowdata = { false, ReadText(1001, 1407), (locvolume .. " " .. ReadText(1001, 110)) }	-- Volume, m^3
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local wares = GetComponentData(inputobject, "wares")
		local hasyield = false
		if wares then
			for _, ware in ipairs(wares) do
				if ware.amount > 0 then
					hasyield = true
					break
				end
			end

			if hasyield then
				locrowdata = { false, ReadText(1001, 3214) .. ReadText(1001, 120) }	-- Yield, :
				row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

				for i, ware in ipairs(wares) do
					if ware.amount > 0 then
						local warename = GetWareData(ware.ware, "name")
						locrowdata = { false, warename, ware.amount }
						row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 2, indentsize)
					end
				end
			end
		end
	elseif mode == "none" then
		local locrowdata = { "info_none", ReadText(1001, 6526) }
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false)
	else
		DebugError("menu.setupInfoSubmenuRows(): called with unsupported mode: " .. tostring(mode) .. ".")
	end
end

function menu.setupCrewInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	local object64 = ConvertStringTo64Bit(tostring(inputobject))
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Helper.color.white
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other") and menu.getFilterOption("think_diplomacy_highlightvisitor") then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local operatorinfo =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_name")
	local operatorinfo_details =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_details")
	local operatorinfo_commands =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_commands")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(7):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(7):createText(ReadText(1001, 80), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))

	-- object name
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[7]:createButton({ width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(6):setColSpan(5):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[6]:createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[6].properties.halign = "right"
		row[6].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(6):setColSpan(6):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		local pilot = ConvertIDTo64Bit(GetComponentData(inputobject, "assignedpilot"))
		local pilotname, skilltable, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end

		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- pilot
		local printedtitle = isbigship and ReadText(1001, 4848) or ReadText(1001, 4847)	-- Captain, Pilot
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(7):createText(printedtitle, Helper.headerRowCenteredProperties)
		if pilot then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(pilot, nil, "aipilot") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
			local row = inputtable:addRow({ "info_pilot", pilot, inputobject }, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createText(printedpilotname)
			local locfontcolor = Helper.standardColor
			if operatorinfo_details then
				locfontcolor = Helper.color.brightyellow
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(skilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
				local locfontcolor = Helper.standardColor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
			-- replace pilot
			if isplayerowned then
				local line_replace = isbigship and ReadText(1001, 9430) or ReadText(1001, 9431)	-- Replace captain with best crewmember, Replace pilot with best crewmember
				-- button is clickable if:
				-- we have crew,
				-- we have a pilot,
				-- the pilot is not in a critical state (NPC_State_Machines),
				-- the controllable is not running an order in a critical state,
				-- and one of our crew members is better than the current pilot.
				-- NB: check to see if there is a pilot is necessary since there is a delay between pressing this button and the old pilot getting dismissed leading to errors in the later checks.
				local row = inputtable:addRow("ReplacePilot", { bgColor = Helper.color.transparent })
				row[2]:setColSpan(6):createButton({ height = config.mapRowHeight, active = function() local locpilot = GetComponentData(inputobject, "assignedpilot"); return (infocrew.current.total > 0) and locpilot and IsValidComponent(locpilot) and (not C.IsCurrentOrderCritical(inputobject)) and menu.infoSubmenuReplacePilot(inputobject, ConvertIDTo64Bit(locpilot), nil, true, nil, instance) end }):setText(line_replace, { halign = "center", fontsize = config.mapFontSize })
				row[2].handlers.onClick = function() return menu.infoSubmenuReplacePilot(inputobject, pilot, nil, nil, nil, instance) end
			end
		else
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(4):createText("-")
			local locfontcolor = Helper.standardColor
			row[6]:setColSpan(2):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			if isplayerowned then
				-- replace pilot
				local line_replace = ReadText(1001, 9432) .. " " .. printedtitle	-- Promote best crewmember to
				local row = inputtable:addRow("ReplacePilot", { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createButton({ height = config.mapRowHeight, active = function () return (infocrew.current.total > 0) and menu.infoSubmenuReplacePilot(inputobject, nil, nil, true, nil, instance) end }):setText(line_replace, { halign = "center", fontsize = config.mapFontSize })
				row[2].handlers.onClick = function() return menu.infoSubmenuReplacePilot(inputobject, nil, nil, nil, nil, instance) end
			end
		end
		-- commander
		local commander
		if C.IsComponentClass(inputobject, "controllable") then
			commander = GetCommander(menu.infoSubmenuObject)
		end
		local commandername, commandercolor = "-", Helper.color.white
		if commander then
			commandername, commandercolor = menu.getContainerNameAndColors(commander, 0, false, false)
		end
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(3):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
		row[5]:setColSpan(3):createText(commandername, { halign = "right", color = commandercolor })
		-- subordinates
		local subordinates = {}
		if C.IsComponentClass(inputobject, "controllable") then
			subordinates = GetSubordinates(inputobject)
		end
		local row = inputtable:addRow("info_subordinates", { bgColor = Helper.color.transparent })
		row[1]:createButton({ height = config.mapRowHeight, active = #subordinates > 0 }):setText(function() return (#subordinates > 0 and menu.isInfoExtended("info_subordinates", instance)) and "-" or "+" end, { halign = "center" })
		row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_subordinates", instance) end
		row[1].properties.uiTriggerID = "info_subordinates_toggle"
		row[2]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
		row[6]:setColSpan(2):createText(#subordinates, { halign = "right" })
		if (#subordinates > 0) and menu.isInfoExtended("info_subordinates", instance) then
			table.sort(subordinates, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
			for i, locship in ipairs(subordinates) do
				local shipid = ConvertIDTo64Bit(locship)
				local shipname, textcolor = menu.getContainerNameAndColors(shipid, 0, false, false)

				local row = inputtable:addRow("info_subordinate" .. i, { bgColor = Helper.color.transparent })
				row[3]:setColSpan(4):createText(shipname, { color = textcolor })
				row[7]:createButton({ height = config.mapRowHeight }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, shipid, true) end
			end
		end
		-- current order
		local numorders = C.GetNumOrders(inputobject)
		local currentorders = ffi.new("Order[?]", numorders)
		local activeorder = ffi.new("Order")
		if numorders > 0 then
			numorders = C.GetOrders(currentorders, numorders, inputobject)
			activeorder = currentorders[0]
		else
			C.GetDefaultOrder(activeorder, inputobject)
		end
		local ordername = ReadText(1001, 31)
		local orderdefinition = ffi.new("OrderDefinition")
		if activeorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, activeorder.orderdef) then
			ordername = Helper.unlockInfo(operatorinfo_commands, ffi.string(orderdefinition.name))
		end
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(3):createText(ReadText(1001, 8392) .. ReadText(1001, 120))
		row[5]:setColSpan(3):createText(ordername, { halign = "right" })
		-- command
		if pilot and IsValidComponent(pilot) then
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[3]:setColSpan(2):createText(ReadText(1001, 78) .. ReadText(1001, 120))
			if #aicommandstack > 0 then
				aicommand = aicommandstack[1].command
				aicommandparam = aicommandstack[1].param
			end
			row[5]:setColSpan(3):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)), { halign = "right" })
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			local numaicommands = #aicommandstack
			if numaicommands > 1 then
				aicommandaction = aicommandstack[numaicommands].command
				aicommandactionparam = aicommandstack[numaicommands].param
			end
			row[5]:setColSpan(3):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)), { halign = "right" })
		end
		-- # orders
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(4):createText(ReadText(1001, 9402) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo_commands, numorders), { halign = "right" })
		-- inventory
		if isplayerowned and pilot and IsValidComponent(pilot) then
			local inventory = GetInventory(pilot)
			local onlineitems = OnlineGetUserItems()

			local sortedWares = {}
			local totalamount = 0
			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(sortedWares, { ware = ware, name = entry.name, amount = entry.amount })
					totalamount = totalamount + entry.amount
				end
			end
			-- title
			local row = inputtable:addRow("info_pilot_inventory", { bgColor = Helper.color.transparent })
			row[1]:createButton({ height = config.mapRowHeight, active = totalamount > 0 }):setText(function() return ((totalamount > 0) and menu.isInfoExtended("info_pilot_inventory", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_pilot_inventory", instance) end
			row[2]:setColSpan(4):createText(ReadText(1001, 2202) .. ReadText(1001, 120))
			row[6]:setColSpan(2):createText(totalamount, { halign = "right" })
			if next(inventory) and menu.isInfoExtended("info_pilot_inventory", instance) then
				if #sortedWares > 0 then
					table.sort(sortedWares, Helper.sortName)
					-- wares
					for i, entry in ipairs(sortedWares) do
						local row = inputtable:addRow({ "info_inventory", entry.ware, inputobject }, { bgColor = Helper.color.transparent })
						row[3]:setColSpan(3):createText(entry.name)
						row[6]:setColSpan(2):createText(ConvertIntegerString(entry.amount, true, 0, true), { halign = "right" })
					end
					-- drop inventory
					local row = inputtable:addRow("DropPilotInventory", { bgColor = Helper.color.transparent })
					row[2]:setColSpan(3):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 7733), { halign = "center" })
					row[2].handlers.onClick = function() return menu.buttonDropPilotInventory(pilot, sortedWares) end
				end
			end
		end
		-- relief pilot
		local aipilot = ConvertIDTo64Bit(GetComponentData(inputobject, "assignedaipilot"))
		if aipilot and aipilot ~= pilot then
			local aipilotname, aipilotskilltable = GetComponentData(aipilot, "name", "skills")
			-- title
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(7):createText(ReadText(1001, 9403), Helper.headerRowCenteredProperties)
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(aipilot, nil, "aipilot") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, aipilotname)
			local row = inputtable:addRow({ "info_pilot", aipilot, inputobject }, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createText(printedpilotname)
			local locfontcolor = Helper.standardColor
			if operatorinfo_details then
				locfontcolor = Helper.color.brightyellow
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(aipilotskilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(aipilotskilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
				local locfontcolor = Helper.standardColor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
		end
		if C.IsComponentClass(inputobject, "controllable") then
			menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, aipilot, isplayerowned)
		end
	elseif mode == "station" then
		local manager, shiptrader, individualtrainee = GetComponentData(inputobject, "tradenpc", "shiptrader", "individualtrainee")
		manager = ConvertIDTo64Bit(manager)
		shiptrader = ConvertIDTo64Bit(shiptrader)
		local managername, skilltable, postname, isfemale = "-", {}, ReadText(1001, 4847)
		if manager then
			managername, skilltable, postname, isfemale = GetComponentData(manager, "name", "skills", "postname", "isfemale")
		end

		-- manager
		local printedtitle = (manager and isfemale) and ReadText(20208, 30302) or ReadText(20208, 30301)
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(7):createText(printedtitle, Helper.headerRowCenteredProperties)
		if manager then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(manager, nil, "manager") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow({ "info_manager", manager, inputobject }, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createText(printedmanagername)
			local locfontcolor = Helper.standardColor
			if operatorinfo_details then
				locfontcolor = Helper.color.brightyellow
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(skilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
				local locfontcolor = Helper.standardColor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
		else
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(4):createText("-")
			local locfontcolor = Helper.standardColor
			row[6]:setColSpan(2):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
		end
		if isplayerowned then
			-- budget
			local recommendedfunds = GetComponentData(inputobject, "productionmoney") or 0
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(4):createText(ReadText(1001, 9434) .. ReadText(1001, 120)) -- Expected operating budget
			row[6]:setColSpan(2):createText(ConvertMoneyString(recommendedfunds, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
		end
		-- subordinates
		if C.IsComponentClass(inputobject, "controllable") then
			local subordinates = GetSubordinates(inputobject)
			local row = inputtable:addRow("info_subordinates", { bgColor = Helper.color.transparent })
			row[1]:createButton({ height = config.mapRowHeight, active = #subordinates > 0 }):setText(function() return (#subordinates > 0 and menu.isInfoExtended("info_subordinates", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_subordinates", instance) end
			row[1].properties.uiTriggerID = "info_subordinates_toggle"
			row[2]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[6]:setColSpan(2):createText(#subordinates, { halign = "right" })
			if (#subordinates > 0) and menu.isInfoExtended("info_subordinates", instance) then
				table.sort(subordinates, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				for i, locship in ipairs(subordinates) do
					local shipid = ConvertIDTo64Bit(locship)
					local shipname, textcolor = menu.getContainerNameAndColors(shipid, 0, false, false)

					local row = inputtable:addRow("info_subordinate" .. i, { bgColor = Helper.color.transparent, interactive = false })
					row[3]:setColSpan(5):createText(shipname, { color = textcolor })
				end
			end
		end
		-- shiptrader
		if shiptrader then
			shiptrader = ConvertIDTo64Bit(shiptrader)
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(7):createText(GetComponentData(shiptrader, "isfemale") and ReadText(20208, 30502) or ReadText(20208, 30501), Helper.headerRowCenteredProperties) -- Ship Trader (female), Ship Trader (male)
			-- name
			local name = GetComponentData(shiptrader, "name")
			local row = inputtable:addRow({ "info_shiptrader", shiptrader, inputobject }, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(6):createText(Helper.unlockInfo(operatorinfo, tostring(name)))
		end
		-- individualtrainee
		if individualtrainee then
			individualtrainee = ConvertIDTo64Bit(individualtrainee)
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(7):createText(GetComponentData(individualtrainee, "isfemale") and ReadText(20208, 20602) or ReadText(20208, 20601), Helper.headerRowCenteredProperties)
			-- name
			local name, skilltable = GetComponentData(individualtrainee, "name", "skills")
			local row = inputtable:addRow({ "info_individualtrainee", individualtrainee, inputobject }, { bgColor = Helper.color.transparent })
			row[1]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended("info_individualtrainee", instance) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_individualtrainee", instance) end
			row[2]:setColSpan(6):createText(Helper.unlockInfo(operatorinfo, tostring(name)))
			-- skills
			if menu.isInfoExtended("info_individualtrainee", instance) then
				table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
				for _, skillproperties in ipairs(skilltable) do
					local skillname = ReadText(1013, skillproperties.textid)
					local adjustedskill = skillproperties.value
					local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
					local mouseovertext = ReadText(1013, skillproperties.descriptionid)
					local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
					row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
					local locfontcolor = Helper.standardColor
					if operatorinfo_details then
						locfontcolor = (skillproperties.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow
					end
					row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
				end
			end
		end
		-- workforce
		local races = {}
		local n = C.GetNumAllRaces()
		local buf = ffi.new("RaceInfo[?]", n)
		n = C.GetAllRaces(buf, n)
		for i = 0, n - 1 do
			local entry = {}
			entry.id = ffi.string(buf[i].id)
			entry.name = ffi.string(buf[i].name)
			entry.workforceinfo = C.GetWorkForceInfo(inputobject, entry.id)
			if entry.workforceinfo.capacity > 0 then
				table.insert(races, entry)
			end
		end
		table.sort(races, Helper.sortName)
		if #races > 0 then
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(7):createText(ReadText(1001, 9415), Helper.headerRowCenteredProperties) -- Workforce
			for _, race in ipairs(races) do
				local row = inputtable:addRow(nil, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(4):createText(race.name)
				row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo, race.workforceinfo.current .. " / " .. race.workforceinfo.capacity), { halign = "right" })
			end
		end
		-- player personnel
		local npctable = GetNPCs(inputobject)
		for i = #npctable, 1, -1 do
			if not GetComponentData(npctable[i], "isplayerowned") then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == manager then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == shiptrader then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == individualtrainee then
				table.remove(npctable, i)
			end
		end
		if #npctable > 0 then
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(7):createText(ReadText(1001, 9416), Helper.headerRowCenteredProperties) -- Player Employees On Board
			for i, npc in ipairs(npctable) do
				npc = ConvertIDTo64Bit(npc)
				local extendinfoid = string.format("info_crewperson_r%d", i)
				local row = inputtable:addRow({ "info_crewnpc", npc, inputobject }, { bgColor = Helper.color.transparent })
				row[2]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended(extendinfoid, instance) and "-" or "+" end, { halign = "center" })
				row[2].handlers.onClick = function() return menu.buttonExtendInfo(extendinfoid, instance) end
				row[3]:setColSpan(3):createText(GetComponentData(npc, "name"), { mouseOverText = mouseovertext })
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = Helper.color.brightyellow, mouseOverText = ReadText(1026, 2) })
				if menu.isInfoExtended(extendinfoid, instance) then
					local skilltable = GetComponentData(npc, "skills")
					table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
					for _, skill in ipairs(skilltable) do
						local skillname = ReadText(1013, skill.textid)
						local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
						local mouseovertext = ReadText(1013, skill.descriptionid)
						local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
						row[3]:setColSpan(3):createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, x = Helper.standardIndentStep, color = (skill.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
						row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow, mouseOverText = mouseovertext })
					end
				end
			end
		end

		if C.CanControllableHaveAnyTrainees(inputobject) then
			menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, nil, isplayerowned)
		end
	elseif mode == "none" then
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(6):createText(ReadText(1001, 6526))
	end
end

function menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, aipilot, isplayerowned)
	-- capacity
	local peoplecapacity = C.GetPeopleCapacity(inputobject, "", false)
	local totalcrewcapacity = infocrew.capacity
	if mode == "ship" then
		totalcrewcapacity = totalcrewcapacity + 1
	end
	local totalnumpeople = infocrew.total
	if aipilot then
		totalnumpeople = totalnumpeople + 1
	end
	local titlerow
	if (mode == "ship") or (totalnumpeople > 0) then
		-- crew
		titlerow = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		titlerow[1]:setColSpan(7):createText(ReadText(1001, 80), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "crew_assigncrew"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(4):createText(ReadText(1001, 9078) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo, tostring(totalnumpeople)) .. " / " .. Helper.unlockInfo(operatorinfo, tostring(totalcrewcapacity)), { halign = "right" })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end
	-- crew assignment
	if operatorinfo and totalnumpeople > 0 then
		local sliderrows = {}
		local slidercounter = 0
		-- unassigned
		local row = inputtable:addRow(true, { bgColor = Helper.color.unselectable })
		row[1]:setBackgroundColSpan(6)
		row[2]:setColSpan(4):createText(ReadText(1001, 5207)) -- Unassigned
		row[6]:createText(function() return (tostring(infocrew.unassigned.total)) end, { halign = "right" })
		row[7]:createButton({ active = function () return infocrew.unassigned.total > 0 end, mouseOverText = ReadText(1026, 8002) }):setIcon("menu_dismiss")
		row[7].handlers.onClick = function () return menu.infoSubmenuFireAllNPCConfirm(inputobject, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		local rolewhitelist = {
			["prisoner"] = true,
			["passenger"] = true,
		}
		if mode == "ship" then
			rolewhitelist["service"] = true
			rolewhitelist["marine"] = true
		end
		if C.CanControllableHaveAnyTrainees(inputobject) then
			rolewhitelist["trainee_group"] = true
		end

		for i, roletable in ipairs(infocrew.current.roles) do
			if rolewhitelist[roletable.id] and (roletable.amount > 0 or roletable.canhire) then
				slidercounter = slidercounter + 1
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				--{ 
				--	id = ffi.string(peopletable[i].id), 
				--	name = ffi.string(peopletable[i].name), 
				--	desc = ffi.string(peopletable[i].desc), 
				--	amount = peopletable[i].amount, 
				--	canhire = peopletable[i].canhire, 
				--	numtiers = peopletable[i].numtiers, 
				--	tiers = {} 
				--}
				local row = inputtable:addRow(ffi.string(roletable.id), { bgColor = Helper.color.transparent, interactive = isplayerowned and roletable.canhire })
				--print("name: " .. ffi.string(roletable.name) .. ", canhire: " .. tostring(roletable.canhire))
				local maxselect = math.min(peoplecapacity, roletable.amount + infocrew.reassigned.roles[i].amount + infocrew.unassigned.total)
				local start = math.min(maxselect, roletable.amount + infocrew.reassigned.roles[i].amount)
				row[2]:setColSpan(6):createSliderCell({ height = config.mapRowHeight, start = start, minSelect = roletable.transferring, max = peoplecapacity, maxSelect = maxselect, readOnly = not isplayerowned or not roletable.canhire }):setText(ffi.string(roletable.name), { fontsize = config.mapFontSize })
				sliderrows[slidercounter] = { ["row"] = row, ["col"] = 2, ["roleindex"] = i,["id"] = roletable.id, ["name"] = roletable.name, ["desc"] = roletable.desc, ["amount"] = roletable.amount, ["numtiers"] = roletable.numtiers, ["canhire"] = roletable.canhire, ["tiers"] = {} }
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				local numtiers = roletable.numtiers
				for j, tiertable in ipairs(roletable.tiers) do
					if not tiertable.hidden then
						-- can query: .name, .skilllevel, .amount
						--{ 
						--	name = ffi.string(tiertable[j].name), 
						--	skilllevel = tiertable[j].skilllevel, 
						--	amount = tiertable[j].amount, 
						--	persons = {} 
						--}
						--print("tier name: " .. ffi.string(tiertable.name) .. ", skill level: " .. tostring(tiertable.skilllevel) .. ", num: " .. tostring(tiertable.amount))
						local row = inputtable:addRow(ffi.string(roletable.id) .. j, { bgColor = Helper.color.transparent, interactive = isplayerowned })
						local maxselect = math.min(peoplecapacity, tiertable.amount + infocrew.reassigned.roles[i].tiers[j].amount)
						local start = math.min(maxselect, tiertable.amount + infocrew.reassigned.roles[i].tiers[j].amount)
						row[3]:setColSpan(5):createSliderCell({ height = config.mapRowHeight, start = start, minSelect = tiertable.transferring, max = peoplecapacity, maxSelect = maxselect, readOnly = not isplayerowned }):setText(ffi.string(tiertable.name), { fontsize = config.mapFontSize })
						sliderrows[slidercounter].tiers[j] = { ["row"] = row, ["col"] = 3, ["roleindex"] = i, ["name"] = tiertable.name, ["skilllevel"] = tiertable.skilllevel, ["amount"] = tiertable.amount }
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				end
			end
		end
		if isplayerowned then
			local row = inputtable:addRow("UpdateCrew", { bgColor = Helper.color.transparent })
			row[2]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function() return ((infocrew.reassigned.total > 0) and (infocrew.unassigned.total == 0)) end }):setText(ReadText(1001, 2821), { halign = "center", fontsize = config.mapFontSize })	-- Confirm
			row[2].handlers.onClick = function() return menu.infoSubmenuConfirmCrewChanges(instance) end
			row[5]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function() return ((infocrew.reassigned.total > 0) or (infocrew.unassigned.total > 0)) end }):setText(ReadText(1001, 3318), { halign = "center", fontsize = config.mapFontSize })	-- Reset
			row[5].handlers.onClick = function() return menu.resetInfoSubmenu(nil, instance) end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			for i, role in ipairs(sliderrows) do
				-- TODO: cleanup these tables. not all data is used.
				local sliderupdatetable = { ["table"] = inputtable, ["row"] = role.row, ["col"] = role.col, ["tierrows"] = {}, ["text"] = role.name, ["xoffset"] = role.row[2].properties.x, ["width"] = role.row[2].properties.width }
				for j, tier in ipairs(role.tiers) do
					table.insert(sliderupdatetable.tierrows, { ["row"] = tier.row, ["col"] = tier.col, ["text"] = tier.name, ["xoffset"] = tier.row[2].properties.x, ["width"] = tier.row[2].properties.width })
				end

				role.row[2].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateCrewChanges(instance, newamount, sliderrows, i, false, nil, sliderupdatetable) end
				role.row[2].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
				role.row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				role.row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				for j, tier in ipairs(role.tiers) do
					tier.row[3].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateCrewChanges(instance, newamount, sliderrows, i, true, j, sliderupdatetable) end
					tier.row[3].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
					tier.row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
					tier.row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				end
			end
		end
		-- full crew list
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(7):createText(ReadText(1001, 9404), Helper.headerRowCenteredProperties) -- Full Crew List
		-- sorting
		local arrowWidth = Helper.scaleY(config.mapRowHeight)
		local row = inputtable:addRow(true, { bgColor = Helper.color.transparent })
		row[2]:setColSpan(2):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		row[4]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 2809)):setIcon((menu.crewSort == "name_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "name") or (menu.crewSort == "name_inv")) and Helper.color.white or Helper.color.transparent })
		row[4].handlers.onClick = function () menu.crewSort = (menu.crewSort == "name") and "name_inv" or "name"; menu.refreshInfoFrame() end
		row[5]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11200)):setIcon((menu.crewSort == "role_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "role") or (menu.crewSort == "role_inv")) and Helper.color.white or Helper.color.transparent })
		row[5].handlers.onClick = function () menu.crewSort = (menu.crewSort == "role") and "role_inv" or "role"; menu.refreshInfoFrame() end
		row[6]:setColSpan(2):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 9124)):setIcon((menu.crewSort == "skill_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "skill") or (menu.crewSort == "skill_inv")) and Helper.color.white or Helper.color.transparent })
		row[6].handlers.onClick = function () menu.crewSort = (menu.crewSort == "skill") and "skill_inv" or "skill"; menu.refreshInfoFrame() end
		-- skill display
		local roleOptions = {
			{ id = "post:aipilot",		text = ReadText(20208, 30101), icon = "", displayremoveoption = false },
			{ id = "post:manager",		text = ReadText(20208, 30301), icon = "", displayremoveoption = false },
			{ id = "post:shiptrader",	text = ReadText(20208, 30501), icon = "", displayremoveoption = false },
			{ id = "role:service",		text = ReadText(20208, 20103), icon = "", displayremoveoption = false },
			{ id = "role:marine",		text = ReadText(20208, 20203), icon = "", displayremoveoption = false },
		}
		table.sort(roleOptions, function (a, b) return a.text < b.text end)
		table.insert(roleOptions, 1, { id = "current", text = ReadText(1001, 8373), icon = "", displayremoveoption = false })
		local row = inputtable:addRow(true, { bgColor = Helper.color.transparent })
		row[2]:setColSpan(4):createText(ReadText(1001, 8399) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createDropDown(roleOptions, { startOption = menu.crewRole })
		row[6].handlers.onDropDownConfirmed = function (_, newrole) menu.noupdate = false; if menu.crewRole ~= newrole then menu.crewRole = newrole; menu.refreshInfoFrame() end end
		row[6].handlers.onDropDownActivated = function () menu.noupdate = true end

		inputtable:addEmptyRow(config.mapRowHeight / 2)

		local role, post, rolename
		if menu.crewRole ~= "current" then
			local type, id = string.match(menu.crewRole, "(.+):(.+)")
			if type == "post" then
				post = id
			elseif type == "role" then
				role = id
			end
			for _, option in ipairs(roleOptions) do
				if option.id == menu.crewRole then
					rolename = option.text
					break
				end
			end
		end

		local tierinfo
		if role then
			tierinfo = {}
			local numpeople = C.GetNumAllRoles()
			local peopletable = ffi.new("PeopleInfo[?]", numpeople)
			numpeople = C.GetPeople2(peopletable, numpeople, inputobject, true)
			for i = 0, numpeople - 1 do
				if ffi.string(peopletable[i].id) == role then
					local numtiers = peopletable[i].numtiers
					local tiertable = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers(tiertable, numtiers, inputobject, role)
					for j = 0, numtiers - 1 do
						tierinfo[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel }
					end
					table.sort(tierinfo, function (a, b) return a.skilllevel > b.skilllevel end)
				end
			end
		end

		local combinedcrew = menu.infoSubmenuCombineCrewTables(instance)
		local prevrole, prevtier
		for _, personentry in ipairs(combinedcrew) do
			if (menu.crewSort == "role") or (menu.crewSort == "role_inv") then
				if (not prevrole) or (prevrole ~= personentry.rolename) or (prevtier ~= personentry.tiername) then 
					prevrole = personentry.rolename
					prevtier = personentry.tiername

					local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
					row[1]:setColSpan(7):createText(personentry.rolename .. (personentry.tiername and (" - " .. personentry.tiername) or ""), Helper.headerRowCenteredProperties)
					row[1].properties.font = Helper.standardFont
				end
			elseif role and ((menu.crewSort == "skill") or (menu.crewSort == "skill_inv")) then
				local tiername
				for _, tierentry in ipairs(tierinfo) do
					if personentry.skill >= tierentry.skilllevel then
						tiername = tierentry.name
						break
					end
				end
				if (not prevrole) or (prevrole ~= rolename) or (prevtier ~= tiername) then 
					prevrole = rolename
					prevtier = tiername

					local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
					row[1]:setColSpan(7):createText(rolename .. (tiername and (" - " .. tiername) or ""), Helper.headerRowCenteredProperties)
					row[1].properties.font = Helper.standardFont
				end
			end

			local adjustedcombinedskill = math.floor(personentry.skill * 15 / 100)
			local extendinfoid = string.format("info_crewperson_%s", tostring(personentry.person))
			local printedname = personentry.name
			local mouseovertext = ""
			local color
			if C.IsPersonTransferScheduled(inputobject, personentry.person) then
				printedname = Helper.convertColorToText(Helper.color.brightyellow) .. "\027[warning]" .. printedname
				mouseovertext = ReadText(1026, 3228)
			elseif not C.HasPersonArrived(inputobject, personentry.person) then
				color = Helper.color.grey
				mouseovertext = ReadText(1026, 3247)
			end
			local printedskill = Helper.displaySkill(adjustedcombinedskill)
			local row = inputtable:addRow({ "info_crewperson", personentry.person, inputobject }, { bgColor = Helper.color.transparent })
			row[1]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended(extendinfoid, instance) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo(extendinfoid, instance) end
			row[2]:setColSpan(3):createText(printedname, { mouseOverText = mouseovertext, color = color })
			local roleColor, mouseovertext
			if (menu.crewRole ~= "current") and (role ~= personentry.roleid) and (post ~= personentry.roleid) then
				roleColor = Helper.color.grey
				mouseovertext = string.format(ReadText(1026, 3231), rolename)
			end
			row[5]:createText(personentry.rolename, { color = roleColor, mouseOverText = mouseovertext })
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = Helper.color.brightyellow, mouseOverText = ReadText(1026, 2) })
			if menu.isInfoExtended(extendinfoid, instance) then
				local numskills = C.GetNumSkills()
				local skilltable = ffi.new("Skill2[?]", numskills + 1)
				numskills = C.GetPersonSkillsForAssignment(skilltable, personentry.person, inputobject, role, post)
				local sortedskilltable = {}
				for i = 1, numskills do
					table.insert(sortedskilltable, skilltable[i])
				end
				table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
				for i, skill in ipairs(sortedskilltable) do
					local skillname = ReadText(1013, skill.textid)
					local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
					local mouseovertext = ReadText(1013, skill.descriptionid)
					local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
					row[3]:setColSpan(3):createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
					row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow, mouseOverText = mouseovertext })
				end
			end
		end
	end
end

function menu.setupLoadoutInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local object64 = ConvertStringTo64Bit(tostring(inputobject))
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Helper.color.white
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other") and menu.getFilterOption("think_diplomacy_highlightvisitor") then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end

	local loadout = {}
	if mode == "ship" or mode == "station" then
		loadout = { ["component"] = {}, ["macro"] = {}, ["ware"] = {} }
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				loadout.component[upgradetype.type] = {}
				local numslots = 0
				if C.IsComponentClass(inputobject, "defensible") then
					numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", upgradetype.type))
				end
				for j = 1, numslots do
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, upgradetype.type, j)
					if current ~= 0 then
						table.insert(loadout.component[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				loadout.macro[upgradetype.type] = {}
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(inputobject, "", upgradetype.type))
				for j = 1, numslots do
					local current = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(inputobject, upgradetype.type, j))
					if current ~= "" then
						table.insert(loadout.macro[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "software" then
				loadout.ware[upgradetype.type] = {}
				local numslots = C.GetNumSoftwareSlots(inputobject, "")
				local buf = ffi.new("SoftwareSlot[?]", numslots)
				numslots = C.GetSoftwareSlots(buf, numslots, inputobject, "")
				for j = 0, numslots - 1 do
					local current = ffi.string(buf[j].current)
					if current ~= "" then
						table.insert(loadout.ware[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "ammo" then
				loadout.macro[upgradetype.type] = {}
			end
		end
	end

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local defenceinfo_low =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_level")
	local defenceinfo_high =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_status")
	local unitinfo_capacity =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_capacity")
	local unitinfo_amount =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_amount")
	local unitinfo_details =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_details")
	local equipment_mods =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "equipment_mods")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(13):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(13):createText(ReadText(1001, 9413), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	-- object name
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[13]:createButton({ width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[13].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(12):setColSpan(6):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[7]:setColSpan(6):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[7].properties.halign = "right"
		row[7].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(12):setColSpan(12):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		local pilot = GetComponentData(inputobject, "assignedpilot")
		pilot = ConvertIDTo64Bit(pilot)
		local pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, ReadText(1001, 4847), {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end

		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- weapon config
		if isplayerowned and (#loadout.component.weapon > 0) then
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(13):createText(ReadText(1001, 9409), Helper.headerRowCenteredProperties) -- Weapon Configuration
			-- subheader
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[3]:setColSpan(5):createText(ReadText(1001, 9410), { font = Helper.standardFontBold }) -- Primary
			row[8]:setColSpan(6):createText(ReadText(1001, 9411), { font = Helper.standardFontBold }) -- Secondary
			-- active weapon groups
			local row = inputtable:addRow("info_weaponconfig_active", { bgColor = Helper.color.transparent })
			row[2]:createText(ReadText(1001, 11218))
			for j = 1, 4 do
				row[2 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(inputobject, true) == j end, { width = config.mapRowHeight, height = config.mapRowHeight, symbol = "arrow", bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, true) end })
				row[2 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(inputobject, true, j) end
			end
			for j = 1, 4 do
				row[7 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(inputobject, false) == j end, { width = config.mapRowHeight, height = config.mapRowHeight, symbol = "arrow", bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, false) end })
				row[7 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(inputobject, false, j) end
			end
			inputtable:addEmptyRow(config.mapRowHeight / 2)
			-- weapons
			for i, gun in ipairs(loadout.component.weapon) do
				local gun = ConvertStringTo64Bit(tostring(gun))
				local numweapongroups = C.GetNumWeaponGroupsByWeapon(inputobject, gun)
				local rawweapongroups = ffi.new("UIWeaponGroup[?]", numweapongroups)
				numweapongroups = C.GetWeaponGroupsByWeapon(rawweapongroups, numweapongroups, inputobject, gun)
				local uiweapongroups = { primary = {}, secondary = {} }
				for j = 0, numweapongroups - 1 do
					-- there are two sets: primary and secondary.
					-- each set has four groups.
					-- .primary tells you if this particular weapon is active in a group in the primary or secondary group set.
					-- .idx tells you which group in that group set it is active in.
					if rawweapongroups[j].primary then
						uiweapongroups.primary[rawweapongroups[j].idx] = true
					else
						uiweapongroups.secondary[rawweapongroups[j].idx] = true
					end
					--print("primary: " .. tostring(rawweapongroups[j].primary) .. ", idx: " .. tostring(rawweapongroups[j].idx))
				end

				local row = inputtable:addRow("info_weaponconfig" .. i, { bgColor = Helper.color.transparent })
				row[2]:createText(ffi.string(C.GetComponentName(gun)))

				-- primary weapon groups
				for j = 1, 4 do
					row[2 + j]:createCheckBox(uiweapongroups.primary[j], { width = config.mapRowHeight, height = config.mapRowHeight, bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, true) end })
					row[2 + j].handlers.onClick = function() menu.infoSetWeaponGroup(inputobject, gun, true, j, not uiweapongroups.primary[j]) end
				end

				-- secondary weapon groups
				for j = 1, 4 do
					row[7 + j]:createCheckBox(uiweapongroups.secondary[j], { width = config.mapRowHeight, height = config.mapRowHeight, bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, false) end })
					row[7 + j].handlers.onClick = function() menu.infoSetWeaponGroup(inputobject, gun, false, j, not uiweapongroups.secondary[j]) end
				end

				if IsComponentClass(gun, "missilelauncher") then
					local nummissiletypes = C.GetNumAllMissiles(inputobject)
					local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
					nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, inputobject)

					local gunmacro = GetComponentData(gun, "macro")
					local dropdowndata = {}
					for j = 0, nummissiletypes-1 do
						local ammomacro = ffi.string(missilestoragetable[j].macro)
						if C.IsAmmoMacroCompatible(gunmacro, ammomacro) then
							table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name"), icon = "", displayremoveoption = false})
						end
					end

					-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
					local currentammomacro = "empty"
					local dropdownactive = true
					if #dropdowndata == 0 then
						dropdownactive = false
						table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
					else
						-- NB: currentammomacro can be null
						currentammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(gun))
					end

					row = inputtable:addRow(("info_weaponconfig" .. i .. "_ammo"), { bgColor = Helper.color.transparent })
					row[2]:createText((ReadText(1001, 2800) .. ReadText(1001, 120)))	-- Ammunition, :
					row[3]:setColSpan(11):createDropDown(dropdowndata, {startOption = currentammomacro, active = dropdownactive})
					row[3].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(gun, newammomacro) end
				elseif pilot and IsValidComponent(pilot) and IsComponentClass(gun, "bomblauncher") then
					local numbombtypes = C.GetNumAllInventoryBombs(pilot)
					local bombstoragetable = ffi.new("AmmoData[?]", numbombtypes)
					numbombtypes = C.GetAllInventoryBombs(bombstoragetable, numbombtypes, pilot)

					local gunmacro = GetComponentData(gun, "macro")
					local dropdowndata = {}
					for j = 0, numbombtypes-1 do
						local ammomacro = ffi.string(bombstoragetable[j].macro)
						if C.IsAmmoMacroCompatible(gunmacro, ammomacro) then
							table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name"), icon = "", displayremoveoption = false})
						end
					end

					-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
					local currentammomacro = "empty"
					local dropdownactive = true
					if #dropdowndata == 0 then
						dropdownactive = false
						table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
					else
						-- NB: currentammomacro can be null
						currentammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(gun))
					end

					row = inputtable:addRow(("info_weaponconfig" .. i .. "_ammo"), { bgColor = Helper.color.transparent })
					row[2]:createText((ReadText(1001, 2800) .. ReadText(1001, 120)))	-- Ammunition, :
					row[3]:setColSpan(11):createDropDown(dropdowndata, {startOption = currentammomacro, active = dropdownactive})
					row[3].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(gun, newammomacro) end
				end
			end
		end
	end
	if (mode == "ship") or (mode == "station") then
		-- turret behaviour
		menu.turrets = {}
		menu.turretgroups = {}
		if isplayerowned and #loadout.component.turret > 0 then
			local hasnormalturrets = false
			local hasmissileturrets = false
			local hasoperationalnormalturrets = false
			local hasoperationalmissileturrets = false
			local hasonlytugturrets = true

			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(13):createText(ReadText(1001, 8612), Helper.headerRowCenteredProperties) -- Turret Behaviour
			local numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", "turret"))
			for j = 1, numslots do
				local groupinfo = C.GetUpgradeSlotGroup(inputobject, "", "turret", j)
				if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, "turret", j)
					if current ~= 0 then
						if (not hasmissileturrets) or (not hasnormalturrets) then
							local ismissileturret = C.IsComponentClass(current, "missileturret")
							hasmissileturrets = hasmissileturrets or ismissileturret
							hasnormalturrets = hasnormalturrets or (not ismissileturret)
						end
						if not GetComponentData(ConvertStringTo64Bit(tostring(current)), "istugweapon") then
							hasonlytugturrets = false
						end
						table.insert(menu.turrets, current)
					end
				end
			end

			local turretsizecounts = {}
			local n = C.GetNumUpgradeGroups(inputobject, "")
			local buf = ffi.new("UpgradeGroup2[?]", n)
			n = C.GetUpgradeGroups2(buf, n, inputobject, "")
			for i = 0, n - 1 do
				if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
					local group = { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }
					local groupinfo = C.GetUpgradeGroupInfo2(inputobject, "", group.context, group.path, group.group, "turret")
					if (groupinfo.count > 0) then
						group.operational = groupinfo.operational
						group.currentcomponent = groupinfo.currentcomponent
						group.currentmacro = ffi.string(groupinfo.currentmacro)
						group.slotsize = ffi.string(groupinfo.slotsize)
						group.sizecount = 0
						if (not hasmissileturrets) or (not hasnormalturrets) then
							local ismissileturret = IsMacroClass(group.currentmacro, "missileturret")
							hasmissileturrets = hasmissileturrets or ismissileturret
							hasnormalturrets = hasnormalturrets or (not ismissileturret)
							if ismissileturret then
								if not hasoperationalmissileturrets then
									hasoperationalmissileturrets = group.operational > 0
								end
							else
								if not hasoperationalnormalturrets then
									hasoperationalnormalturrets = group.operational > 0
								end
							end
						end
						if not GetComponentData(ConvertStringTo64Bit(tostring(group.currentcomponent)), "istugweapon") then
							hasonlytugturrets = false
						end

						if group.slotsize ~= "" then
							if turretsizecounts[group.slotsize] then
								turretsizecounts[group.slotsize] = turretsizecounts[group.slotsize] + 1
							else
								turretsizecounts[group.slotsize] = 1
							end
							group.sizecount = turretsizecounts[group.slotsize]
						end

						table.insert(menu.turretgroups, group)
					end
				end
			end
			
			if #menu.turretgroups > 0 then
				table.sort(menu.turretgroups, Helper.sortSlots)
			end

			if (#menu.turrets > 0) or (#menu.turretgroups > 0) then
				if mode == "ship" then
					local row = inputtable:addRow("info_turretconfig", { bgColor = Helper.color.transparent })
					row[2]:setColSpan(3):createText(ReadText(1001, 2963))
					
					-- Start Subsystem Targeting Orders callback
					local sto_callbackVal
					if callbacks ["sto_addTurretBehavioursMapMenu"] then
						for _, callback in ipairs (callbacks ["sto_addTurretBehavioursMapMenu"]) do
							sto_callbackVal = callback (row, inputobject)
						end
					end
					if not sto_callbackVal then
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(nil, not hasonlytugturrets), { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all") end })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllTurretModes(inputobject, newturretmode) end
					end
					-- End Subsystem Targeting Orders callback

					row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

					local row = inputtable:addRow("info_turretconfig_2", { bgColor = Helper.color.transparent })
					row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[5].handlers.onClick = function () return C.SetAllTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject)) end

					local dropdownCount = 1
					for i, turret in ipairs(menu.turrets) do
						inputtable:addEmptyRow(config.mapRowHeight / 2)

						local row = inputtable:addRow("info_turretconfig" .. i, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(3):createText(ffi.string(C.GetComponentName(turret)))
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(turret), { startOption = function () return menu.getDropDownTurretModeOption(turret) end })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetWeaponMode(turret, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
						dropdownCount = dropdownCount + 1
						if dropdownCount == 14 then
							inputtable.properties.maxVisibleHeight = inputtable:getFullHeight()
						end

						local row = inputtable:addRow("info_turretconfig" .. i .. "_2", { bgColor = Helper.color.transparent })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return C.IsWeaponArmed(turret) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetWeaponArmed(turret, not C.IsWeaponArmed(turret)) end
					end

					for i, group in ipairs(menu.turretgroups) do
						inputtable:addEmptyRow(config.mapRowHeight / 2)
						
						local name = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")

						local row = inputtable:addRow("info_turretgroupconfig" .. i, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(3):createText(name, { color = (group.operational > 0) and Helper.color.white or Helper.color.red })
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(group.currentcomponent), { startOption = function () return menu.getDropDownTurretModeOption(inputobject, group.context, group.path, group.group) end, active = group.operational > 0 })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetTurretGroupMode2(inputobject, group.context, group.path, group.group, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
						dropdownCount = dropdownCount + 1
						if dropdownCount == 14 then
							inputtable.properties.maxVisibleHeight = inputtable:getFullHeight()
						end

						local row = inputtable:addRow("info_turretgroupconfig" .. i .. "_2", { bgColor = Helper.color.transparent })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return C.IsTurretGroupArmed(inputobject, group.context, group.path, group.group) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetTurretGroupArmed(inputobject, group.context, group.path, group.group, not C.IsTurretGroupArmed(inputobject, group.context, group.path, group.group)) end
					end
				elseif mode == "station" then
					local turretmodes = {
						[1] = { id = "defend",			text = ReadText(1001, 8613),	icon = "",	displayremoveoption = false },
						[2] = { id = "attackenemies",	text = ReadText(1001, 8614),	icon = "",	displayremoveoption = false },
						[3] = { id = "attackcapital",	text = ReadText(1001, 8624),	icon = "",	displayremoveoption = false },
						[4] = { id = "attackfighters",	text = ReadText(1001, 8625),	icon = "",	displayremoveoption = false },
						[5] = { id = "missiledefence",	text = ReadText(1001, 8615),	icon = "",	displayremoveoption = false },
					}

					if hasnormalturrets then
						-- non-missile
						local row = inputtable:addRow("info_turretconfig", { bgColor = Helper.color.transparent })
						row[2]:setColSpan(3):createText(ReadText(1001, 8397))
						row[5]:setColSpan(9):createDropDown(turretmodes, { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all", false) end, active = hasoperationalnormalturrets, mouseOverText = (not hasoperationalnormalturrets) and ReadText(1026, 3235) or nil })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllNonMissileTurretModes(inputobject, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

						local row = inputtable:addRow("info_turretconfig_2", { bgColor = Helper.color.transparent })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject, false) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetAllNonMissileTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject, false)) end
					end
					if hasmissileturrets then
						-- missile
						local row = inputtable:addRow("info_turretconfig_missile", { bgColor = Helper.color.transparent })
						row[2]:setColSpan(3):createText(ReadText(1001, 9031))
						row[5]:setColSpan(9):createDropDown(turretmodes, { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all", true) end, active = hasoperationalmissileturrets, mouseOverText = (not hasoperationalnormalturrets) and ReadText(1026, 3235) or nil })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllMissileTurretModes(inputobject, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

						local row = inputtable:addRow("info_turretconfig_missile_2", { bgColor = Helper.color.transparent })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject, true) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetAllMissileTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject, true)) end
					end
				end
			end
		end
		-- drones
		local isplayeroccupiedship = menu.infoSubmenuObject == ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))

		local unitstoragetable = C.IsComponentClass(object64, "defensible") and GetUnitStorageData(object64) or { stored = 0, capacity = 0 }
		local locunitcapacity = Helper.unlockInfo(unitinfo_capacity, tostring(unitstoragetable.capacity))
		local locunitcount = Helper.unlockInfo(unitinfo_amount, tostring(unitstoragetable.stored))
		menu.drones = {}
		local dronetypes = {
			{ id = "orecollector",	name = ReadText(20214, 500),	displayonly = true },
			{ id = "gascollector",	name = ReadText(20214, 400),	displayonly = true },
			{ id = "defence",		name = ReadText(20214, 300) },
			{ id = "transport",		name = ReadText(20214, 900) },
			{ id = "build",			name = ReadText(20214, 1000),	skipmode = true },
			{ id = "repair",		name = ReadText(20214, 1100),	skipmode = true },
		}
		for _, dronetype in ipairs(dronetypes) do
			if C.GetNumStoredUnits(inputobject, dronetype.id, false) > 0 then
				local entry
				if not dronetype.skipmode then
					entry = {
						type = dronetype.id,
						name = dronetype.name,
						current = ffi.string(C.GetCurrentDroneMode(inputobject, dronetype.id)),
						modes = {},
						displayonly = dronetype.displayonly,
					}
					local n = C.GetNumDroneModes(inputobject, dronetype.id)
					local buf = ffi.new("DroneModeInfo[?]", n)
					n = C.GetDroneModes(buf, n, inputobject, dronetype.id)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						if (id ~= "trade") or (id == entry.current) then
							table.insert(entry.modes, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
						end
					end
				else
					entry = {
						type = dronetype.id,
						name = dronetype.name,
					}
				end
				table.insert(menu.drones, entry)
			end
		end
		if unitstoragetable.capacity > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(13):createText(ReadText(1001, 8619), Helper.headerRowCenteredProperties)
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locunitcount .. " / " .. locunitcapacity, { halign = "right" })
			-- drones
			if unitinfo_details then
				for i, entry in ipairs(menu.drones) do
					if i ~= 1 then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					local hasmodes = (mode == "ship") and entry.current
					-- drone name, amount and mode
					local row1 = inputtable:addRow("drone_config", { bgColor = Helper.color.transparent })
					row1[2]:createText(entry.name)
					row1[3]:setColSpan(isplayerowned and 2 or 11):createText(function () return Helper.unlockInfo(unitinfo_amount, C.GetNumStoredUnits(inputobject, entry.type, false)) end, { halign = isplayerowned and "left" or "right" })
					-- active and armed status
					local row2 = inputtable:addRow("drone_config", { bgColor = Helper.color.transparent })
					row2[2]:createText("    " .. ReadText(1001, 11229), { color = hasmodes and function () return C.IsDroneTypeArmed(inputobject, entry.type) and Helper.color.white or Helper.color.grey end or nil })
					row2[3]:setColSpan(isplayerowned and 2 or 11):createText(function () return Helper.unlockInfo(unitinfo_amount, C.GetNumUnavailableUnits(inputobject, entry.type)) end, { halign = isplayerowned and "left" or "right", color = hasmodes and function () return C.IsDroneTypeBlocked(inputobject, entry.type) and Helper.color.warningorange or (C.IsDroneTypeArmed(inputobject, entry.type) and Helper.color.white or Helper.color.grey) end or nil })
					
					-- drone mode support - disabled for mining drones, to avoid conflicts with order defined drone behaviour
					if hasmodes then
						local isblocked = C.IsDroneTypeBlocked(inputobject, entry.type)
						if isplayerowned then
							local active = (isplayeroccupiedship or (not entry.displayonly)) and (not isblocked)
							local mouseovertext = ""
							if isblocked then
								mouseovertext = ReadText(1026, 3229)
							elseif (not isplayeroccupiedship) and entry.displayonly then
								mouseovertext = ReadText(1026, 3230)
							end

							row1[5]:setColSpan(9):createDropDown(entry.modes, { startOption = function () return ffi.string(C.GetCurrentDroneMode(inputobject, entry.type)) end, active = active, mouseOverText = mouseovertext })
							row1[5].handlers.onDropDownConfirmed = function (_, newdronemode) C.SetDroneMode(inputobject, entry.type, newdronemode) end

							row2[5]:setColSpan(9):createButton({ active = active, mouseOverText = mouseovertext, height = config.mapRowHeight }):setText(function () return C.IsDroneTypeArmed(inputobject, entry.type) and ReadText(1001, 8622) or ReadText(1001, 8623) end, { halign = "center" })
							row2[5].handlers.onClick = function () return C.SetDroneTypeArmed(inputobject, entry.type, not C.IsDroneTypeArmed(inputobject, entry.type)) end
						end
					end
				end
			end
		end
		-- subordinates
		if isplayerowned then
			if C.IsComponentClass(inputobject, "controllable") then
				local subordinates = GetSubordinates(inputobject)
				local groups = {}
				local usedassignments = {}
				for _, subordinate in ipairs(subordinates) do
					local purpose, shiptype = GetComponentData(subordinate, "primarypurpose", "shiptype")
					local group = GetComponentData(subordinate, "subordinategroup")
					if group and group > 0 then
						if groups[group] then
							table.insert(groups[group].subordinates, subordinate)
							if shiptype == "resupplier" then
								groups[group].numassignableresupplyships = groups[group].numassignableresupplyships + 1
							end
							if purpose == "mine" then
								groups[group].numassignableminingships = groups[group].numassignableminingships + 1
							end
							if shiptype == "tug" then
								groups[group].numassignabletugships = groups[group].numassignabletugships + 1
							end
						else
							local assignment = ffi.string(C.GetSubordinateGroupAssignment(inputobject, group))
							usedassignments[assignment] = group
							groups[group] = { assignment = assignment, subordinates = { subordinate }, numassignableresupplyships = (shiptype == "resupplier") and 1 or 0, numassignableminingships = (purpose == "mine") and 1 or 0, numassignabletugships = (shiptype == "tug") and 1 or 0 }
						end
					end
				end

				if #subordinates > 0 then
					-- title
					local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
					row[1]:setColSpan(13):createText(ReadText(1001, 8626), Helper.headerRowCenteredProperties)

					local isstation = C.IsComponentClass(inputobject, "station")
					for i = 1, isstation and 5 or 10 do
						if groups[i] then
							local defenceactive = true
							if isstation then
								defenceactive = ((not usedassignments["defence"]) or (usedassignments["defence"] == i))
							end
							local supplyactive = (groups[i].numassignableresupplyships == #groups[i].subordinates) and ((not usedassignments["supplyfleet"]) or (usedassignments["supplyfleet"] == i))
							local subordinateassignments = {
								[1] = { id = "defence",			text = ReadText(20208, 40301),	icon = "",	displayremoveoption = false, active = defenceactive, mouseovertext = defenceactive and "" or ReadText(1026, 7840) },
								[2] = { id = "supplyfleet",		text = ReadText(20208, 40701),	icon = "",	displayremoveoption = false, active = supplyactive, mouseovertext = supplyactive and "" or ReadText(1026, 8601) },
							}
							local shiptype = GetComponentData(inputobject, "shiptype") 
							if shiptype == "resupplier" then
								table.insert(subordinateassignments, { id = "trade",			text = ReadText(20208, 40101),	icon = "",	displayremoveoption = false })
							end

							if isstation then
								local miningactive = (groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i))
								table.insert(subordinateassignments, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false, active = miningactive, mouseovertext = miningactive and "" or ReadText(1026, 8602) })
								local tradeactive = ((not usedassignments["trade"]) or (usedassignments["trade"] == i))
								table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, active = tradeactive, mouseovertext = tradeactive and ((groups[i].numassignableminingships > 0) and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8607)) or "") or ReadText(1026, 7840) })
								local tradeforbuildstorageactive = (groups[i].numassignableminingships == 0) and ((not usedassignments["tradeforbuildstorage"]) or (usedassignments["tradeforbuildstorage"] == i))
								table.insert(subordinateassignments, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false, active = tradeforbuildstorageactive, mouseovertext = tradeforbuildstorageactive and "" or ReadText(1026, 8603) })
								local salvageactive = (groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i))
								table.insert(subordinateassignments, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false, active = salvageactive, mouseovertext = salvageactive and "" or ReadText(1026, 8610) })
							elseif C.IsComponentClass(inputobject, "ship") then
								-- position defence
								local parentcommander = ConvertIDTo64Bit(GetCommander(inputobject))
								local isfleetcommander = (not parentcommander) and (#subordinates > 0)
								if (shiptype == "carrier") and isfleetcommander then
									table.insert(subordinateassignments, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false })
								end
								table.insert(subordinateassignments, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
								local active = true
								local mouseovertext = ""
								local buf = ffi.new("Order")
								if not C.GetDefaultOrder(buf, inputobject) then
									active = false
									mouseovertext = ReadText(1026, 8606)
								end
								table.insert(subordinateassignments, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
							end

							local isdockingpossible = false
							for _, subordinate in ipairs(groups[i].subordinates) do
								if IsDockingPossible(subordinate, inputobject) then
									isdockingpossible = true
									break
								end
							end
							local active = true
							local mouseovertext = ""
							if not GetComponentData(inputobject, "hasshipdockingbays") then
								active = false
								mouseovertext = ReadText(1026, 8604)
							elseif not isdockingpossible then
								active = false
								mouseovertext = ReadText(1026, 8605)
							end

							local row = inputtable:addRow("subordinate_config", { bgColor = Helper.color.transparent })
							row[2]:createText(function () menu.updateSubordinateGroupInfo(inputobject); return ReadText(20401, i) .. (menu.subordinategroups[i] and (" (" .. ((not C.ShouldSubordinateGroupDockAtCommander(inputobject, i)) and ((#menu.subordinategroups[i].subordinates - menu.subordinategroups[i].numdockedatcommander) .. "/") or "") .. #menu.subordinategroups[i].subordinates ..")") or "") end, { color = isblocked and Helper.color.warningorange or nil })
							row[3]:setColSpan(11):createDropDown(subordinateassignments, { startOption = function () menu.updateSubordinateGroupInfo(inputobject); return menu.subordinategroups[i] and menu.subordinategroups[i].assignment or "" end })
							row[3].handlers.onDropDownActivated = function () menu.noupdate = true end
							row[3].handlers.onDropDownConfirmed = function(_, newassignment) return Helper.dropdownAssignment(_, nil, i, inputobject, newassignment) end
							local row = inputtable:addRow("subordinate_config", { bgColor = Helper.color.transparent })
							
							-- Start Reactive Docking callback
							local rd_callbackVal
							if callbacks ["rd_addReactiveDockingMapMenu"] then
								for _, callback in ipairs (callbacks ["rd_addReactiveDockingMapMenu"]) do
									rd_callbackVal = callback (row, inputobject, i, mode, active, mouseovertext)
								end
							end
							if not rd_callbackVal then
								row[3]:setColSpan(11):createButton({ active = active, mouseOverText = mouseovertext, height = config.mapRowHeight }):setText(function () return C.ShouldSubordinateGroupDockAtCommander(inputobject, i) and ReadText(1001, 8630) or ReadText(1001, 8629) end, { halign = "center" })
								row[3].handlers.onClick = function () return C.SetSubordinateGroupDockAtCommander(inputobject, i, not C.ShouldSubordinateGroupDockAtCommander(inputobject, i)) end
							end
							-- End Reactive Docking callback
						end
					end
				end
			end
		end
		-- ammunition
		local nummissiletypes = C.GetNumAllMissiles(inputobject)
		local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
		nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, inputobject)
		local totalnummissiles = 0
		for i = 0, nummissiletypes - 1 do
			totalnummissiles = totalnummissiles + missilestoragetable[i].amount
		end
		local missilecapacity = 0
		if C.IsComponentClass(inputobject, "defensible") then
			missilecapacity = GetComponentData(inputobject, "missilecapacity")
		end
		local locmissilecapacity = Helper.unlockInfo(defenceinfo_low, tostring(missilecapacity))
		local locnummissiles = Helper.unlockInfo(defenceinfo_high, tostring(totalnummissiles))
		if totalnummissiles > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(13):createText(ReadText(1001, 2800), Helper.headerRowCenteredProperties) -- Ammunition
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locnummissiles .. " / " .. locmissilecapacity, { halign = "right" })
			if defenceinfo_high then
				for i = 0, nummissiletypes - 1 do
					local macro = ffi.string(missilestoragetable[i].macro)
					local row = inputtable:addRow({ "info_weapons", macro, inputobject }, { bgColor = Helper.color.transparent })
					row[2]:createText(GetMacroData(macro, "name"))
					row[8]:setColSpan(6):createText(tostring(missilestoragetable[i].amount), { halign = "right" })
				end
			end
		end
	end
	if mode == "ship" then
		-- countermeasures
		local numcountermeasuretypes = C.GetNumAllCountermeasures(inputobject)
		local countermeasurestoragetable = ffi.new("AmmoData[?]", numcountermeasuretypes)
		numcountermeasuretypes = C.GetAllCountermeasures(countermeasurestoragetable, numcountermeasuretypes, inputobject)
		local totalnumcountermeasures = 0
		for i = 0, numcountermeasuretypes - 1 do
			totalnumcountermeasures = totalnumcountermeasures + countermeasurestoragetable[i].amount
		end
		local countermeasurecapacity = GetComponentData(object64, "countermeasurecapacity")
		local loccountermeasurecapacity = Helper.unlockInfo(defenceinfo_low, tostring(countermeasurecapacity))
		local locnumcountermeasures = Helper.unlockInfo(defenceinfo_high, tostring(totalnumcountermeasures))
		if totalnumcountermeasures > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(13):createText(ReadText(20215, 1701), Helper.headerRowCenteredProperties) -- Countermeasures
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locnumcountermeasures .. " / " .. loccountermeasurecapacity, { halign = "right" })
			if defenceinfo_high then
				for i = 0, numcountermeasuretypes - 1 do
					local row = inputtable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
					row[2]:createText(GetMacroData(ffi.string(countermeasurestoragetable[i].macro), "name"))
					row[8]:setColSpan(6):createText(tostring(countermeasurestoragetable[i].amount), { halign = "right" })
				end
			end
		end
		-- deployables
		local consumables = {
			{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites,		callback = C.LaunchSatellite },
			{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons,		callback = C.LaunchNavBeacon },
			{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes,	callback = C.LaunchResourceProbe },
			{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers,		callback = C.LaunchLaserTower },
			{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines,			callback = C.LaunchMine },
		}
		local totalnumdeployables = 0
		local consumabledata = {}
		for _, entry in ipairs(consumables) do
			local n = entry.getnum(inputobject)
			local buf = ffi.new("AmmoData[?]", n)
			n = entry.getdata(buf, n, inputobject)
			consumabledata[entry.id] = {}
			for i = 0, n - 1 do
				table.insert(consumabledata[entry.id], { macro = ffi.string(buf[i].macro), name = GetMacroData(ffi.string(buf[i].macro), "name"), amount = buf[i].amount, capacity = buf[i].capacity })
				totalnumdeployables = totalnumdeployables + buf[i].amount
			end
		end
		local deployablecapacity = C.GetDefensibleDeployableCapacity(inputobject)
		local printednumdeployables = Helper.unlockInfo(defenceinfo_low, tostring(totalnumdeployables))
		local printeddeployablecapacity = Helper.unlockInfo(defenceinfo_low, tostring(deployablecapacity))
		if totalnumdeployables > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(13):createText(ReadText(1001, 1332), Helper.headerRowCenteredProperties) -- Deployables
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(printednumdeployables .. " / " .. printeddeployablecapacity, { halign = "right" })
			if defenceinfo_high then
				for _, entry in ipairs(consumables) do
					if #consumabledata[entry.id] > 0 then
						for _, data in ipairs(consumabledata[entry.id]) do
							local row = inputtable:addRow({ "info_deploy", data.macro, inputobject }, { bgColor = Helper.color.transparent })
							row[2]:createText(data.name)
							row[8]:setColSpan(6):createText(data.amount, { halign = "right" })
						end
					end
				end
				if isplayerowned then
					-- deploy
					local row = inputtable:addRow("info_deploy", { bgColor = Helper.color.transparent })
					row[3]:setColSpan(11):createButton({ height = config.mapRowHeight, active = function () return next(menu.infoTablePersistentData[instance].macrostolaunch) ~= nil end }):setText(ReadText(1001, 8390), { halign = "center" })
					row[3].handlers.onClick = function () return menu.buttonDeploy(instance) end
				end
			end
		end
	end
	if (mode == "ship") or (mode == "station") then
		-- loadout
		if (#loadout.component.weapon > 0) or (#loadout.component.turret > 0) or (#loadout.component.shield > 0) or (#loadout.component.engine > 0) or (#loadout.macro.thruster > 0) or (#loadout.ware.software > 0) then
			if defenceinfo_high then
				local hasshown = false
				-- title
				local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(13):createText(ReadText(1001, 9413), Helper.headerRowCenteredProperties) -- Loadout
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(5):createText(ReadText(1001, 7935), { font = Helper.standardFontBold })
				row[7]:setColSpan(4):createText(ReadText(1001, 1311), { font = Helper.standardFontBold, halign = "right" })
				row[11]:setColSpan(3):createText(ReadText(1001, 12), { font = Helper.standardFontBold, halign = "right" })

				inputtable:addEmptyRow(config.mapRowHeight / 2)

				local macroequipment = {
					{ type = "weapon", encyclopedia = "info_weapon" },
					{ type = "turret", encyclopedia = "info_weapon" },
					{ type = "shield", encyclopedia = "info_equipment" },
					{ type = "engine", encyclopedia = "info_equipment" },
				}
				for _, entry in ipairs(macroequipment) do
					if #loadout.component[entry.type] > 0 then
						if hasshown then
							inputtable:addEmptyRow(config.mapRowHeight / 2)
						end
						hasshown = true
						local locmacros = menu.infoCombineLoadoutComponents(loadout.component[entry.type])
						for macro, data in pairs(locmacros) do
							local row = inputtable:addRow({ entry.encyclopedia, macro, inputobject }, { bgColor = Helper.color.transparent })
							row[2]:setColSpan(5):createText(GetMacroData(macro, "name"))
							row[7]:setColSpan(4):createText(data.count .. " / " .. data.count + data.construction, { halign = "right" })
							local shieldpercent = data.shieldpercent
							local hullpercent = data.hullpercent
							if data.count > 0 then
								shieldpercent = shieldpercent / data.count
								hullpercent = hullpercent / data.count
							end
							row[11]:setColSpan(3):createShieldHullBar(shieldpercent, hullpercent, { scaling = false, width = row[11]:getColSpanWidth() / 2, x = row[11]:getColSpanWidth() / 4 })

							AddKnownItem(GetMacroData(macro, "infolibrary"), macro)
						end
					end
				end

				if #loadout.macro.thruster > 0 then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					-- ships normally only have 1 set of thrusters. in case a ship has more, this will list all of them.
					for i, val in ipairs(loadout.macro.thruster) do
						local row = inputtable:addRow({ "info_equipment", macro, inputobject }, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(12):createText(GetMacroData(val, "name"))

						AddKnownItem(GetMacroData(val, "infolibrary"), val)
					end
				end
				if #loadout.ware.software > 0 then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					for i, val in ipairs(loadout.ware.software) do
						local row = inputtable:addRow({ "info_software", val, inputobject }, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(12):createText(GetWareData(val, "name"))

						AddKnownItem("software", val)
					end
				end
			else
				local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
				row[2]:setColSpan(12):createText(ReadText(1001, 3210))
			end
		end
	end
	if mode == "ship" then
		-- mods
		-- title
		local row = inputtable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(13):createText(ReadText(1001, 8031), Helper.headerRowCenteredProperties)
		if equipment_mods and GetComponentData(object64, "hasanymod") then
			local hasshown = false
			-- chassis
			local hasinstalledmod, installedmod = Helper.getInstalledModInfo("ship", inputobject)
			if hasinstalledmod then
				if hasshown then
					inputtable:addEmptyRow(config.mapRowHeight / 2)
				end
				hasshown = true
				row = menu.addEquipmentModInfoRow(inputtable, "ship", installedmod, ReadText(1001, 8008))
			end
			-- weapon
			for i, weapon in ipairs(loadout.component.weapon) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("weapon", weapon)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, ffi.string(C.GetComponentName(weapon)))
				end
			end
			-- turret
			for i, group in ipairs(menu.turretgroups) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("turret", inputobject, group.context, group.group, true)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true

					local name = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, name)
				end
			end
			for i, turret in ipairs(menu.turrets) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("turret", turret)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, ffi.string(C.GetComponentName(turret)))
				end
			end
			-- shield
			local shieldgroups = {}
			local n = C.GetNumShieldGroups(inputobject)
			local buf = ffi.new("ShieldGroup[?]", n)
			n = C.GetShieldGroups(buf, n, inputobject)
			for i = 0, n - 1 do
				local entry = {}
				entry.context = buf[i].context
				entry.group = ffi.string(buf[i].group)
				entry.component = buf[i].component

				table.insert(shieldgroups, entry)
			end
			for i, entry in ipairs(shieldgroups) do
				if (entry.context == inputobject) and (entry.group == "") then
					shieldgroups.hasMainGroup = true
					-- force maingroup to first index
					table.insert(shieldgroups, 1, entry)
					table.remove(shieldgroups, i + 1)
					break
				end
			end
			for i, shieldgroupdata in ipairs(shieldgroups) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("shield", inputobject, shieldgroupdata.context, shieldgroupdata.group)
				if hasinstalledmod then
					local name = GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(shieldgroupdata.component)), "macro"), "name")
					if (i == 1) and shieldgroups.hasMainGroup then
						name = ReadText(1001, 8044)
					end
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "shield", installedmod, name)
				end
			end
			-- engine
			local hasinstalledmod, installedmod = Helper.getInstalledModInfo("engine", inputobject)
			if hasinstalledmod then
				if hasshown then
					inputtable:addEmptyRow(config.mapRowHeight / 2)
				end
				hasshown = true
				row = menu.addEquipmentModInfoRow(inputtable, "engine", installedmod, ffi.string(C.GetComponentName(loadout.component.engine[1])))
			end
		else
			local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
			row[2]:setColSpan(12):createText(Helper.unlockInfo(equipment_mods, ReadText(1001, 8394)))
		end
	end
	if mode == "none" then
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(12):createText(ReadText(1001, 6526))
	end
end

function menu.infologbookSearchHelper(entry, text, text2)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.title), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.text), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.entityname), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.factionname), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end

	return false
end

function menu.setupLogbookInfoSubmenuRows(inputtable, inputobject, instance, isvalid)
	if (not menu.infoTablePersistentData[instance].logbookData) or (menu.infoTablePersistentData[instance].logbookData.curobject ~= inputobject) then
		local objecttext = "none", ""
		local isuseid, issector = false, false
		if isvalid then
			isuseid = true
			local macro = GetComponentData(inputobject, "macro")
			if C.IsRealComponentClass(inputobject, "ship") then
			elseif C.IsRealComponentClass(inputobject, "station") then
			elseif C.IsComponentClass(inputobject, "sector") then
				isuseid = false
				issector = true
			elseif C.IsComponentClass(inputobject, "gate") or C.IsComponentClass(inputobject, "highway") then
				isuseid = false
			elseif C.IsComponentClass(inputobject, "mine") or C.IsComponentClass(inputobject, "navbeacon") or C.IsComponentClass(inputobject, "resourceprobe") or C.IsComponentClass(inputobject, "satellite") then
			elseif C.IsComponentClass(inputobject, "asteroid") then
			elseif C.IsComponentClass(inputobject, "object") then
			end
			if isuseid then
				objecttext = ffi.string(C.GetObjectIDCode(inputobject))
			else
				objecttext = GetComponentData (inputobject, "name")
			end
		end
		menu.infoTablePersistentData[instance].logbookData = { curobject = inputobject, curPage = 1, objecttext = objecttext, searchtext = "", isuseid = isuseid, issector = issector }
	end
	-- DebugError("objecttext: " .. tostring(menu.infoTablePersistentData[instance].logbookData.objecttext) .. " isuseid: " .. tostring(menu.infoTablePersistentData[instance].logbookData.isuseid))

	local logbookData = menu.infoTablePersistentData[instance].logbookData

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo = cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(10):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, {fixed = true, bgColor = Helper.defaultTitleBackgroundColor})
	row[1]:setColSpan(10):createText(ReadText(1001, 5700), Helper.headerRowCenteredProperties)
	local isplayerowned = GetComponentData(inputobject, "isplayerowned")
	if not isplayerowned then
		local row = inputtable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		local ownername = GetComponentData(inputobject, "ownername")
		if not ownername or ownername == "" then
			if menu.infoTablePersistentData[instance].logbookData.issector then
				row[1]:setColSpan(10):createText(ReadText(1001, 11647))
			else
				row[1]:setColSpan(10):createText(ReadText(1001, 11645))
			end
		else
			if menu.infoTablePersistentData[instance].logbookData.issector then
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11646), ownername))
			else
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11644), ownername))
			end
		end
	end

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	--- object name ---
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[10]:createButton({ width = config.mapRowHeight, cellBGColor = Helper.color.transparent }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[10].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if isvalid then
		row[1]:setBackgroundColSpan(9):setColSpan(7):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		if menu.infoTablePersistentData[instance].logbookData.isuseid then
			row[8]:setColSpan(2):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		else
			row[8]:setColSpan(2):createText(" ", Helper.headerRow1Properties) -- if "" border bottom will not render
		end
		row[8].properties.halign = "right"
		row[8].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(9):setColSpan(9):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if isvalid then
		config.infoLogbook.category = "all"
		config.infoLogbook.logbookPage = 100
		config.infoLogbook.logbookQueryLimit= 1000

		-- entries
		local numEntries = GetNumLogbook(config.infoLogbook.category)
		logbookData.logbook = {}
		for i = 1, math.ceil(numEntries / config.infoLogbook.logbookQueryLimit) do
			local offset = (i - 1) * config.infoLogbook.logbookQueryLimit
			local numQuery = math.min(config.infoLogbook.logbookQueryLimit, numEntries - offset)
			local templogbook = GetLogbook(offset + 1, numQuery, config.infoLogbook.category) or {}
			if #templogbook > 0 then
				for j, entry in ipairs(templogbook) do
					entry.index = offset + j
					if menu.infologbookSearchHelper(entry, logbookData.objecttext, logbookData.searchtext) then
						table.insert(logbookData.logbook, entry)
					end
				end
			end
		end

		numEntries = #logbookData.logbook
		local logbook
		if numEntries <= config.infoLogbook.logbookPage then
			logbookData.curPage = 1
			logbook = logbookData.logbook
		else
			local startIndex = numEntries - config.infoLogbook.logbookPage * logbookData.curPage + 1
			local endIndex = config.infoLogbook.logbookPage + startIndex - 1
			if startIndex < 1 then
				startIndex = 1
			end
			logbook = { table.unpack(logbookData.logbook, startIndex, endIndex) }
		end
		logbookData.numPages = math.max(1, math.ceil(numEntries / config.infoLogbook.logbookPage))

		local buttonsize = Helper.scaleY(config.mapRowHeight)
		local row = inputtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250), height = Helper.subHeaderHeight }):setText(logbookData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= logbookData.searchtext then logbookData.searchtext = text; menu.refreshInfoFrame() end end

		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[4]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[4].handlers.onClick = function () logbookData.searchtext = ""; menu.refreshInfoFrame() end

		row[5]:createButton({ scaling = false, active = logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[5].handlers.onClick = function () logbookData.curPage = 1; menu.refreshInfoFrame() end
		row[6]:createButton({ scaling = false, active = logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[6].handlers.onClick = function () logbookData.curPage = logbookData.curPage - 1; menu.refreshInfoFrame() end
		menu.logbookPageEditBox = row[7]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(logbookData.curPage .. " / " .. logbookData.numPages, { halign = "center" })
		row[7].handlers.onEditBoxActivated = function (widget) return menu.editboxInfoLogbookPageActivated(widget, instance) end
		row[7].handlers.onEditBoxDeactivated = function (_, text, textchanged) return menu.editboxInfoLogbookPage(instance, text, textchanged) end
		row[9]:createButton({ scaling = false, active = logbookData.curPage < logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[9].handlers.onClick = function () logbookData.curPage = logbookData.curPage + 1; menu.refreshInfoFrame() end
		row[10]:createButton({ scaling = false, active = logbookData.curPage < logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[10].handlers.onClick = function () logbookData.curPage = logbookData.numPages; menu.refreshInfoFrame() end

		inputtable:addEmptyRow(Helper.standardTextHeight / 2)

		if #logbook > 0 then
			for i = #logbook, 1, -1 do
				local entry = logbook[i]
				local textcolor = entry.highlighted and Helper.color.red or Helper.standardColor
				local row = inputtable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
				if entry.interaction and IsValidComponent(entry.interactioncomponent) then
					local mouseoverobject = entry.interactioncomponent
					if IsComponentClass(mouseoverobject, "zone") and not IsComponentClass(mouseoverobject, "highway") then
						mouseoverobject = GetContextByClass(mouseoverobject, "sector")
					end
					row[1]:setColSpan(9):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
					row[10]:createButton({ scaling = false, bgColor = Helper.color.transparent, mouseOverText = string.format(entry.interactiontext, GetComponentData(mouseoverobject, "name")), height = buttonsize }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize })
					row[10].handlers.onClick = function () return menu.buttonLogbookInteraction(entry) end
				else
					row[1]:setColSpan(10):createText(entry.index .. " - " .. entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
				end

				if (entry.entityname ~= "") or (entry.factionname ~= "") then
					local row = inputtable:addRow(false, { bgColor = Helper.color.transparent, borderBelow = false })
					if entry.entityname ~= "" then
						row[1]:setColSpan(2):createText(ReadText(1001, 5711) .. " " .. entry.entityname, { x = config.mapRowHeight })
					end
					row[3]:setColSpan(8):createText(entry.factionname, { halign = "right" })
				end

				if entry.text ~= "" then
					local row = inputtable:addRow(false, { bgColor = Helper.color.transparent, borderBelow = false })
					row[1]:setColSpan(10):createText(entry.text, { x = config.mapRowHeight, color = textcolor, wordwrap = true })
				end

				local row = inputtable:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createText(Helper.getPassedTime(entry.time), { mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.mapRowHeight })
				local moneystring = ""
				if entry.money ~= 0 then
					local moneycolor = (entry.money >= 0) and Helper.color.green or Helper.color.red
					moneystring = moneystring .. Helper.convertColorToText(moneycolor) .. ((entry.bonus >= 0) and "+" or "-") .. ConvertMoneyString(entry.money, false, true, nil, true) .. " " .. ReadText(1001, 101)
				end
				if entry.bonus ~= 0 then
					local bonuscolor = (entry.bonus >= 0) and Helper.color.green or Helper.color.red
					moneystring = moneystring .. " " .. Helper.convertColorToText(bonuscolor) .. "(" .. ((entry.bonus >= 0) and "+" or "-") .. " " .. ReadText(1001, 5712) .. " " .. ConvertMoneyString(entry.bonus, false, true, nil, true) .. " " .. ReadText(1001, 101) .. ")"
				end
				row[3]:setColSpan(8):createText(moneystring, { halign = "right" })

				if i ~= 1 then
					local row = inputtable:addRow(false, { bgColor = Helper.defaultSimpleBackgroundColor })
					row[1]:setColSpan(10):createText("", { fontsize = 1, minRowHeight = 1 })
				end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end
	else
		local row = inputtable:addRow(false, { bgColor = Helper.color.unselectable })
		row[2]:setColSpan(9):createText(ReadText(1001, 6526))
	end
end

-- NB: numcolumns has to match number of entries in inputrowdata.
function menu.addInfoSubmenuRow(instance, inputtable, inputrow, inputrowdata, isheader, withbutton, buttonactive, indent, indentsize, inputfont, mouseovertext, interactive)
	if not indent then
		indent = 0
	end
	if not indentsize then
		indentsize = Helper.standardIndentStep
	end

	if not inputfont then
		inputfont = Helper.standardFont
		if isheader then
			inputfont = Helper.standardFontBold
		end
	end

	local rowbgcolor = Helper.defaultSimpleBackgroundColor
	if not isheader then
		local isselectable
		if type(inputrowdata) ~= "table" then
			isselectable = inputrowdata
		else
			isselectable = inputrowdata[1]
		end
		if isselectable then
			rowbgcolor = Helper.color.transparent
		else
			rowbgcolor = Helper.color.unselectable
		end
	end

	if not mouseovertext then
		mouseovertext = ""
	end

	if type(inputrowdata) ~= "table" then
		DebugError("menu.addInfoSubmenuRow(): inputrowdata is not a table. inputrowdata: " .. tostring(inputrowdata) .. ".")
		inputrow = inputtable:addRow(inputrowdata, { bgColor = rowbgcolor, interactive = interactive })
	else
		inputrow = inputtable:addRow(inputrowdata[1], { bgColor = rowbgcolor, interactive = interactive })
	end

	if not buttonactive then
		buttonactive = false
	end

	if withbutton then
		inputrow[1]:createButton({ height = config.mapRowHeight, active = buttonactive }):setText(function() return (buttonactive and menu.isInfoExtended(inputrowdata[1], instance)) and "-" or "+" end, { halign = "center" })
		inputrow[1].handlers.onClick = function() return menu.buttonExtendInfo(inputrowdata[1], instance) end
		inputrow[1].properties.uiTriggerID = inputrowdata[1] .. "_toggle"
	end

	for i, val in ipairs(inputrowdata) do
		if i ~= 1 and type(val) == "number" then
			inputrowdata[i] = tostring(val)
		end
	end

	local xoffset = Helper.standardTextOffsetx + (indent * indentsize)

	if type(inputrowdata) ~= "table" then
		inputrow[2]:setColSpan(7)
		inputrow[2]:createText(inputrowdata, { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
	else
		if #inputrowdata == 2 then
			inputrow[2]:setColSpan(7):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
		elseif #inputrowdata == 3 then
			local row2span = 2
			if (type(inputrowdata[2]) ~= "function") and (type(inputrowdata[3]) ~= "function") then
				local str1width = C.GetTextWidth(inputrowdata[2], inputfont, Helper.scaleFont(inputfont, config.mapFontSize)) + Helper.scaleX(xoffset)
				local str2width = C.GetTextWidth(inputrowdata[3], inputfont, Helper.scaleFont(inputfont, config.mapFontSize))
				if (str1width > (inputrow[2]:getWidth() + inputrow[3]:getWidth() + Helper.borderSize)) and (str1width > str2width) then
					row2span = 4
				elseif str1width < inputrow[2]:getWidth() then
					row2span = 1
				end
			end
			inputrow[2]:setColSpan(row2span):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[2 + row2span]:setColSpan(7 - row2span):createText(inputrowdata[3], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		elseif #inputrowdata == 4 then
			inputrow[2]:setColSpan(2):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[4]:setColSpan(2):createText(inputrowdata[3], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[6]:setColSpan(3):createText(inputrowdata[4], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		elseif #inputrowdata == 5 then
			inputrow[2]:createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[3]:createText(inputrowdata[3], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[4]:setColSpan(2):createText(inputrowdata[4], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[6]:setColSpan(3):createText(inputrowdata[5], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		else
			DebugError("menu.addInfoSubmenuRow(): inputrowdata has an invalid number of entries: " .. tostring(#inputrowdata) .. ". only up to four entries supported.")
		end
	end

	return inputrow
end

function menu.addEquipmentModInfoRow(inputtable, modclass, installedmod, name)
	local color = Helper.modQualities[installedmod.Quality].color
	local row = inputtable:addRow(true, { bgColor = Helper.color.transparent })
	row[2]:createText(name .. "  \27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]")
	row[3]:setColSpan(10):createText(Helper.convertColorToText(color) .. installedmod.Name, { halign = "right" })

	-- default property
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key == installedmod.PropertyType then
			if installedmod[property.key] ~= property.basevalue then
				local effectcolor
				if installedmod[property.key] > property.basevalue then
					effectcolor = property.pos_effect and Helper.color.green or Helper.color.red
				else
					effectcolor = property.pos_effect and Helper.color.red or Helper.color.green
				end
				local row = inputtable:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(property.text, { x = Helper.standardIndentStep })
				row[8]:setColSpan(5):createText(Helper.convertColorToText(effectcolor) .. property.eval(installedmod[property.key]), { halign = "right", font = Helper.standardFontBold })
			end
			break
		end
	end
	-- other properties
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key ~= installedmod.PropertyType then
			if installedmod[property.key] ~= property.basevalue then
				local effectcolor
				if installedmod[property.key] > property.basevalue then
					effectcolor = property.pos_effect and Helper.color.green or Helper.color.red
				else
					effectcolor = property.pos_effect and Helper.color.red or Helper.color.green
				end
				local row = inputtable:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(property.text, { x = Helper.standardIndentStep })
				row[8]:setColSpan(5):createText(Helper.convertColorToText(effectcolor) .. property.eval(installedmod[property.key]), { halign = "right" })
			end
		end
	end

	return row
end

function menu.resetInfoSubmenu(i, instance)
	menu.infoTablePersistentData[instance].resetcrew = true
	if i then
		if menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i] then
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	else
		menu.infoTablePersistentData[instance].cashtransferdetails.transfers = {}
	end
	menu.infoTablePersistentData[instance].drops = {}

	if instance == "left" then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.refreshInfoFrame()
	elseif instance == "right" then
		menu.settoprow = GetTopRow(menu.infoTableRight)
		menu.refreshInfoFrame2()
	end
end

function menu.checkTransferDetails(i, instance)
	if menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i] and (menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount ~= 0) then
		return true
	end
	return false
end

function menu.infoSubmenuPrepareCrewInfo(instance)
	local locobject = menu.infoSubmenuObject
	if not locobject or (locobject == 0) then
		DebugError("menu.infoSubmenuPrepareCrewInfo() called with no selected object.")
		return
	elseif (not C.IsComponentClass(locobject, "ship")) and (not C.IsComponentClass(locobject, "station")) then
		DebugError("menu.infoSubmenuPrepareCrewInfo() called on " .. ffi.string(C.GetComponentName(locobject)) .. " which is not of class ship or station.")
		return
	end

	local infocrew = menu.infoTablePersistentData[instance].crew

	--infocrew = { 
	--	["object"] = nil, 
	--	["capacity"] = 0, 
	--	["total"] = 0, 
	--	["current"] = { ["total"] = 0, ["roles"] = {} }, 
	--	["unassigned"] = { ["total"] = 0, ["persons"] = {} }, 
	--	["reassigned"] = { ["total"] = 0, ["roles"] = {} } 
	--}
	infocrew.object = locobject
	infocrew.current.total = 0
	infocrew.unassigned.total = 0
	infocrew.unassigned.persons = {}
	infocrew.reassigned.total = 0
	infocrew.reassigned.roles = {}
	infocrew.total = 0
	infocrew.capacity = C.GetPeopleCapacity(locobject, "", false)

	local numpeople = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopletable, numpeople, locobject, true)
	for i = 0, numpeople - 1 do
		infocrew.current.roles[i + 1] = { id = ffi.string(peopletable[i].id), name = ffi.string(peopletable[i].name), desc = ffi.string(peopletable[i].desc), amount = peopletable[i].amount, transferring = 0, canhire = peopletable[i].canhire, numtiers = peopletable[i].numtiers, tiers = {} }
		infocrew.reassigned.roles[i + 1] = { id = ffi.string(peopletable[i].id), name = ffi.string(peopletable[i].name), desc = ffi.string(peopletable[i].desc), amount = 0, canhire = peopletable[i].canhire, numtiers = peopletable[i].numtiers, tiers = {} }
		infocrew.current.total = infocrew.current.total + peopletable[i].amount
		infocrew.total = infocrew.current.total + infocrew.unassigned.total + infocrew.reassigned.total

		local numtiers = peopletable[i].numtiers
		local tiertable = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers(tiertable, numtiers, locobject, infocrew.current.roles[i + 1].id)
		for j = 0, numtiers - 1 do
			infocrew.current.roles[i + 1].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, amount = tiertable[j].amount, persons = {} }
			infocrew.reassigned.roles[i + 1].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, amount = 0, persons = {} }

			local numpersons = tiertable[j].amount
			local persontable = ffi.new("NPCSeed[?]", numpersons)
			numpersons = C.GetRoleTierNPCs(persontable, numpersons, locobject, infocrew.current.roles[i + 1].id, infocrew.current.roles[i + 1].tiers[j + 1].skilllevel)
			local numTransferScheduled = 0
			for k = 0, numpersons - 1 do
				if C.IsPersonTransferScheduled(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				elseif not C.HasPersonArrived(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				end
				table.insert(infocrew.current.roles[i + 1].tiers[j + 1].persons, persontable[k])
			end
			infocrew.current.roles[i + 1].tiers[j + 1].transferring = numTransferScheduled
			infocrew.current.roles[i + 1].transferring = infocrew.current.roles[i + 1].transferring + numTransferScheduled
		end
		if numtiers == 0 then
			infocrew.current.roles[i + 1].tiers[1] = { hidden = true, name = "temp", skilllevel = 0, amount = peopletable[i].amount, persons = {} }
			infocrew.reassigned.roles[i + 1].tiers[1] = { hidden = true, name = "temp", skilllevel = 0, amount = 0, persons = {} }

			local numpersons = peopletable[i].amount
			local persontable = ffi.new("NPCSeed[?]", numpersons)
			numpersons = C.GetRoleTierNPCs(persontable, numpersons, locobject, infocrew.current.roles[i + 1].id, 0)
			local numTransferScheduled = 0
			for k = 0, numpersons - 1 do
				if C.IsPersonTransferScheduled(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				elseif not C.HasPersonArrived(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				end
				table.insert(infocrew.current.roles[i + 1].tiers[1].persons, persontable[k])
			end
			infocrew.current.roles[i + 1].tiers[1].transferring = numTransferScheduled
			infocrew.current.roles[i + 1].transferring = infocrew.current.roles[i + 1].transferring + numTransferScheduled
		end
	end
	for i, roletable in ipairs(infocrew.current.roles) do
		for j, tiertable in ipairs(roletable.tiers) do
			--int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
			table.sort(tiertable.persons, function(a, b) return C.GetPersonCombinedSkill(menu.infoSubmenuObject, a, nil, nil) > C.GetPersonCombinedSkill(menu.infoSubmenuObject, b, nil, nil) end)
		end
	end
end

function menu.infoSubmenuCombineCrewTables(instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	-- combines infocrew.current and infocrew.reassigned into one table for display
	local result = {}
	local locobject = menu.infoSubmenuObject
	if not locobject or (locobject == 0) then
		DebugError("menu.infoSubmenuCombineCrewTables() called with no selected object.")
		return result
	elseif (not C.IsComponentClass(locobject, "ship")) and (not C.IsComponentClass(locobject, "station")) then
		DebugError("menu.infoSubmenuCombineCrewTables() called on " .. ffi.string(C.GetComponentName(locobject)) .. " which is not of class ship or station.")
		return result
	end

	local role, post
	if menu.crewRole ~= "current" then
		local type, id = string.match(menu.crewRole, "(.+):(.+)")
		if type == "post" then
			post = id
		elseif type == "role" then
			role = id
		end
	end

	local checktable = {}
	local numpeople = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopletable, numpeople, locobject, true)
	for i = 0, numpeople - 1 do
		local roleid = ffi.string(peopletable[i].id)
		local rolename = ffi.string(peopletable[i].name)
		local numtiers = peopletable[i].numtiers
		local tiertable = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers(tiertable, numtiers, locobject, roleid)
		for j = 0, numtiers - 1 do
			local tiername = ffi.string(tiertable[j].name)
			for _, person in ipairs(infocrew.current.roles[i + 1].tiers[j + 1].persons) do
				if not checktable[person] then
					table.insert(result, {
						person = person,
						name = ffi.string(C.GetPersonName(person, menu.infoSubmenuObject)),
						currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, nil, nil),
						skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, role, post),
						roleid = roleid,
						rolename = rolename,
						tiername = tiername
					})
					checktable[person] = true
				end
			end
			for _, person in ipairs(infocrew.reassigned.roles[i + 1].tiers[j + 1].persons) do
				if not checktable[person.person] then
					table.insert(result, {
						person = person.person,
						name = ffi.string(C.GetPersonName(person.person, menu.infoSubmenuObject)),
						currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, nil, nil),
						skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, role, post),
						roleid = roleid,
						rolename = rolename,
						tiername = tiername
					})
					checktable[person.person] = true
				end
			end
		end
		if numtiers == 0 then
			for _, person in ipairs(infocrew.current.roles[i + 1].tiers[1].persons) do
				if not checktable[person] then
					table.insert(result, {
						person = person,
						name = ffi.string(C.GetPersonName(person, menu.infoSubmenuObject)),
						currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, nil, nil),
						skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, role, post),
						roleid = roleid,
						rolename = rolename
					})
					checktable[person] = true
				end
			end
			for _, person in ipairs(infocrew.reassigned.roles[i + 1].tiers[1].persons) do
				if not checktable[person.person] then
					table.insert(result, {
						person = person.person,
						name = ffi.string(C.GetPersonName(person.person, menu.infoSubmenuObject)),
						currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, nil, nil),
						skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, role, post),
						roleid = roleid,
						rolename = rolename
					})
					checktable[person.person] = true
				end
			end
		end
	end

	if menu.crewSort == "name" then
		table.sort(result, function (a, b) return Helper.sortName(a, b, false) end)
	elseif menu.crewSort == "name_inv" then
		table.sort(result, function (a, b) return Helper.sortName(a, b, true) end)
	elseif menu.crewSort == "skill" then
		table.sort(result, function (a, b) return a.skill > b.skill end)
	elseif menu.crewSort == "skill_inv" then
		table.sort(result, function (a, b) return a.skill < b.skill end)
	elseif menu.crewSort == "role" then
		table.sort(result, function (a, b) return menu.roleSorter(a, b, false) end)
		result = menu.sortBySkillinTiers(result)
	elseif menu.crewSort == "role_inv" then
		table.sort(result, function (a, b) return menu.roleSorter(a, b, true) end)
		result = menu.sortBySkillinTiers(result)
	end

	return result
end

function menu.roleSorter(a, b, invert)
	if a.rolename == b.rolename then
		return a.currentskill > b.currentskill
	end
	if invert then
		return a.rolename > b.rolename
	else
		return a.rolename < b.rolename
	end
end

-- after current role skill was used to sort the crew by current tiers, sort the tiers by the skill according to menu.crewRole
function menu.sortBySkillinTiers(result)
	local tiergroups = {}
	for _, personentry in ipairs(result) do
		local prevrole, prevtier
		if (not prevrole) or (prevrole ~= personentry.rolename) or (prevtier ~= personentry.tiername) then 
			prevrole = personentry.rolename
			prevtier = personentry.tiername

			table.insert(tiergroups, { personentry })
		else
			table.insert(tiergroups[#tiergroups], personentry)
		end
	end
	result = {}
	for _, group in ipairs(tiergroups) do
		table.sort(group, function (a, b) return a.skill > b.skill end)
		for _, personentry in ipairs(group) do
			table.insert(result, personentry)
		end
	end
	return result
end

function menu.infoSubmenuConfirmDrops(object, instance)
	local isplayeroccupiedship = (object == C.GetPlayerOccupiedShipID())
	for ware, amount in pairs(menu.infoTablePersistentData[instance].drops) do
		if amount > 0 then
			local s = (amount > 1) and "s" or ""
			if C.DropCargo(object, ware, amount) then
				--print(ffi.string(C.GetComponentName(object)) .. " successfully dropped " .. tostring(amount) .. " unit" .. s .. " of " .. tostring(ware) .. ".")
			else
				print(ffi.string(C.GetComponentName(object)) .. "'s attempt to drop " .. tostring(amount) .. " unit" .. s .. " of " .. tostring(ware) .. " was unsuccessful.")
			end
		end
	end
	menu.infoTablePersistentData[instance].drops = {}
	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateDrops(ware, oldamount, newamount, instance)
	menu.infoTablePersistentData[instance].drops[ware] = oldamount - newamount
end

function menu.infoSubmenuUpdateCrewChanges(instance, newamount, slidertable, sliderindex, istier, tierindex, sliderupdatetable)
	local infocrew = menu.infoTablePersistentData[instance].crew

	--print("peopletype: " .. ffi.string(slidertable[sliderindex].name) .. ", current actual amount: " .. (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount) .. ", new amount: " .. newamount)
	local oldamount = infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount
	if istier then
		oldamount = infocrew.current.roles[slidertable[sliderindex].roleindex].tiers[tierindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].tiers[tierindex].amount
	end
	local amountchange = newamount - oldamount
	local linkedtiers = {}
	-- TODO: review. there was a problem when reducing from tier after reducing from category and adding back from category without confirming. might get fixed after slider updating is fixed.
	--print("newamount: " .. newamount .. ", oldamount: " .. oldamount .. ", amount to change: " .. amountchange)

	if amountchange < 0 then
		-- reduce
		--print("reducing")
		local amountchanged = 0
		local done
		if infocrew.reassigned.total > 0 then
			for i, roletable in ipairs(infocrew.reassigned.roles) do
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				if roletable.id == slidertable[sliderindex].id then
					for j, tiertable in ipairs(roletable.tiers) do
						--print("role: " .. tostring(roletable.id) .. ", tier: " .. tostring(j))
						local go
						if istier then
							-- can query: name, skilllevel, amount
							if tiertable.skilllevel == slidertable[sliderindex].tiers[tierindex].skilllevel then
								go = true
							end
						else
							go = true
						end
						if go then
							for k = #tiertable.persons, 1, -1 do
								if amountchanged ~= amountchange then
									if type(tiertable.persons[k].person) == "table" then
										DebugError("menu.infoSubmenuUpdateCrewChanges(): person " .. k .. " from reassigned is of type table.")
									end
									table.insert(infocrew.unassigned.persons, { ["person"] = tiertable.persons[k].person, ["oldrole"] = roletable.id })
									infocrew.unassigned.total = infocrew.unassigned.total + 1

									table.remove(infocrew.reassigned.roles[i].tiers[j].persons, k)
									infocrew.reassigned.roles[i].tiers[j].amount = infocrew.reassigned.roles[i].tiers[j].amount - 1
									infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount - 1
									infocrew.reassigned.total = infocrew.reassigned.total - 1

									if #linkedtiers > 0 then
										local linkdone
										for l, linkedtier in ipairs(linkedtiers) do
											if linkedtier.index == j then
												linkedtier.amount = linkedtier.amount - 1
												linkdone = true
												break
											end
										end
										if not linkdone then
											table.insert(linkedtiers, { index = j, amount = -1 })
										end
									else
										table.insert(linkedtiers, { index = j, amount = -1 })
									end
									amountchanged = amountchanged - 1
								else
									done = true
									break
								end
							end
							go = nil
						end
						if done then
							break
						end
					end
				end
			end
		end
		if not done then
			for i, roletable in ipairs(infocrew.current.roles) do
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				if roletable.id == slidertable[sliderindex].id then
					for j, tiertable in ipairs(roletable.tiers) do
						--print("role: " .. tostring(roletable.id) .. ", tier: " .. tostring(j))
						local go
						if istier then
							-- can query: name, skilllevel, amount
							if tiertable.skilllevel == slidertable[sliderindex].tiers[tierindex].skilllevel then
								go = true
							end
						else
							go = true
						end
						if go then
							for k = #tiertable.persons, 1, -1 do
								if amountchanged ~= amountchange then
									if type(tiertable.persons[k]) == "table" then
										DebugError("menu.infoSubmenuUpdateCrewChanges(): person " .. k .. " from current is of type table.")
									end
									if (not C.IsPersonTransferScheduled(menu.infoSubmenuObject, tiertable.persons[k])) and C.HasPersonArrived(menu.infoSubmenuObject, tiertable.persons[k]) then
										table.insert(infocrew.unassigned.persons, { ["person"] = tiertable.persons[k], ["oldrole"] = roletable.id })
										infocrew.unassigned.total = infocrew.unassigned.total + 1

										table.remove(infocrew.current.roles[i].tiers[j].persons, k)
										infocrew.current.roles[i].tiers[j].amount = infocrew.current.roles[i].tiers[j].amount - 1
										infocrew.current.roles[i].amount = infocrew.current.roles[i].amount - 1
										infocrew.current.total = infocrew.current.total - 1

										if #linkedtiers > 0 then
											local linkdone
											for l, linkedtier in ipairs(linkedtiers) do
												if linkedtier.index == j then
													linkedtier.amount = linkedtier.amount - 1
													linkdone = true
													break
												end
											end
											if not linkdone then
												table.insert(linkedtiers, { index = j, amount = -1 })
											end
										else
											table.insert(linkedtiers, { index = j, amount = -1 })
										end
										amountchanged = amountchanged - 1
									end
								else
									done = true
									break
								end
							end
							go = nil
						end
						if done then
							break
						end
					end
				end
			end
		end
	else
		-- add
		--print("adding")
		if infocrew.unassigned.total < 1 then
			DebugError("menu.infoSubmenuUpdateCrewChanges(): tried reallocating crew with none unassigned.")
		else
			for i, roletable in ipairs(infocrew.current.roles) do
				if roletable.id == slidertable[sliderindex].id then
					local amountchanged = 0
					local done
					for j = #infocrew.unassigned.persons, 1, -1 do
						if amountchanged ~= amountchange then
							local newtier = C.GetPersonTier(infocrew.unassigned.persons[j].person, roletable.id, menu.infoSubmenuObject)
							local newcombinedskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, infocrew.unassigned.persons[j].person, roletable.id, nil)
							if infocrew.reassigned.roles[i].id ~= roletable.id then
								DebugError("menu.infoSubmenuUpdateCrewChanges(): reassigned role id: " .. tostring(infocrew.reassigned.roles[i].id) .. " does not match current role id: " .. tostring(roletable.id) .. ".")
							end
							for k, tiertable in ipairs(roletable.tiers) do
								if newtier == tiertable.skilllevel then
									table.insert(infocrew.reassigned.roles[i].tiers[k].persons, { ["person"] = infocrew.unassigned.persons[j].person, ["oldrole"] = infocrew.unassigned.persons[j].oldrole, ["newrole"] = roletable.id, ["newtier"] = newtier, ["combinedskill"] = newcombinedskill })
									infocrew.reassigned.roles[i].tiers[k].amount = infocrew.reassigned.roles[i].tiers[k].amount + 1
									infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount + 1
									infocrew.reassigned.total = infocrew.reassigned.total + 1

									if #linkedtiers > 0 then
										local linkdone
										for l, linkedtier in ipairs(linkedtiers) do
											if linkedtier.index == k then
												linkedtier.amount = linkedtier.amount + 1
												linkdone = true
												break
											end
										end
										if not linkdone then
											table.insert(linkedtiers, { index = k, amount = 1 })
										end
									else
										table.insert(linkedtiers, { index = k, amount = 1 })
									end
									break
								end
							end

							table.remove(infocrew.unassigned.persons, j)
							infocrew.unassigned.total = infocrew.unassigned.total - 1

							amountchanged = amountchanged + 1
						else
							done = true
							break
						end
					end
					if done then
						break
					end
				end
			end
		end
	end

	-- update all linked sliders.
	--local sliderupdatetable = { ["table"] = inputtable, ["row"] = role.row, ["col"] = 2, ["tierrows"] = {}, ["text"] = role.name, ["xoffset"] = role.row[2].properties.x, ["width"] = role.row[2].properties.width }
	if type(sliderupdatetable) == "table" and #sliderupdatetable.tierrows > 0 then
		-- update linked category slider
		local linkedrows = { {["row"] = sliderupdatetable.row, ["col"] = sliderupdatetable.col, ["amount"] = sliderupdatetable.row[sliderupdatetable.col].properties.start + amountchange} }
		--local linkedrows = { {["row"] = sliderupdatetable.row, ["amount"] = newamount} }
		if not istier then
			-- update linked tier slider/s
			if linkedtiers then
				linkedrows = {}
				for i, linkedtier in ipairs(linkedtiers) do
					table.insert(linkedrows, {["row"] = sliderupdatetable.tierrows[linkedtier.index].row, ["col"] = sliderupdatetable.tierrows[linkedtier.index].col, ["amount"] = sliderupdatetable.tierrows[linkedtier.index].row[sliderupdatetable.tierrows[linkedtier.index].col].properties.start + linkedtier.amount})
				end
			end
		end
		for i, linkedrow in ipairs(linkedrows) do
			local newlinkedslidervalue = linkedrow.amount
			--print("is tier? " .. tostring(istier) .. ", linked row: " .. tostring(linkedrow.row.index) .. ", category row: " .. tostring(sliderupdatetable.row.index))
			linkedrow.row[linkedrow.col].properties.start = newlinkedslidervalue
			if istier then
				sliderupdatetable.tierrows[tierindex].row[sliderupdatetable.tierrows[tierindex].col].properties.start = newamount
			else
				sliderupdatetable.row[sliderupdatetable.col].properties.start = newamount
			end
			--linkedrow.row[linkedrow.col].properties.maxSelect = (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount + infocrew.unassigned.total)
			--linkedrow.row[linkedrow.col].properties.maxSelect = istier and (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount + infocrew.unassigned.total) or (linkedrow.row[linkedrow.col].properties.start)
			Helper.setSliderCellValue(sliderupdatetable.table.id, linkedrow.row.index, linkedrow.col, newlinkedslidervalue)
		end
	end
end

function menu.infoSubmenuConfirmCrewChanges(instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	--print("reassigning " .. infocrew.reassigned.total .. " crew members.")
	local reassignedcrew = ffi.new("CrewTransferContainer[?]", infocrew.reassigned.total)
	local crewcounter = 0
	for i, roletable in ipairs(infocrew.reassigned.roles) do
		for j, tiertable in ipairs(roletable.tiers) do
			for k, persontable in ipairs(tiertable.persons) do
				--print("evaluating person " .. k .. ": " .. tostring(persontable.person))
				crewcounter = crewcounter + 1
				reassignedcrew[crewcounter - 1].seed = persontable.person
				reassignedcrew[crewcounter - 1].newroleid = Helper.ffiNewString(persontable.newrole)
				--print(tostring(crewcounter) .. ": reassigning person " .. k .. " with seed " .. tostring(persontable.person) .. " to role " .. tostring(persontable.newrole))

				table.insert(infocrew.current.roles[i].tiers[j].persons, persontable.person)
				infocrew.current.roles[i].tiers[j].amount = infocrew.current.roles[i].tiers[j].amount + 1
				infocrew.current.roles[i].amount = infocrew.current.roles[i].amount + 1
				infocrew.current.total = infocrew.current.total + 1

				infocrew.reassigned.roles[i].tiers[j].amount = infocrew.reassigned.roles[i].tiers[j].amount - 1
				infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount - 1
				infocrew.reassigned.total = infocrew.reassigned.total - 1
			end
			infocrew.reassigned.roles[i].tiers[j].persons = {}
		end
	end
	C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, crewcounter)
	if instance == "left" then
		menu.infoTablePersistentData["right"].resetcrew = true
	elseif instance == "right" then
		menu.infoTablePersistentData["left"].resetcrew = true
	end
	menu.refreshInfoFrame()
end

function menu.infoSubmenuReplacePilot(ship, oldpilot, newpilot, checkonly, contextmenu, instance)
	if not C.IsComponentClass(ship, "controllable") then
		return false
	end

	local infocrew = menu.infoTablePersistentData[instance].crew

	local oldpilotluaid = oldpilot and ConvertStringToLuaID(tostring(oldpilot))
	local post = (oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "poststring") or "aipilot"

	if not C.CanControllableHaveControlEntity(ship, post) then
		return false
	end

	-- select best pilot from entire crew for now.
	local bestpilot = newpilot or oldpilot or nil
	local bestcombinedskill = newpilot and C.GetPersonCombinedSkill(ship, newpilot, nil, post) or ((oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "combinedskill") or -1)
	--if oldpilot then
	--	print("old pilot: " .. ffi.string(C.GetComponentName(oldpilot)) .. " (" .. tostring(oldpilot) .. ")" .. ", combined skill: " .. tostring(bestcombinedskill))
	--end
	if not newpilot then
		-- if we want to restrict pilot candidates to people with a particular role, do that here.
		for i, roletable in ipairs(infocrew.current.roles) do
			if (roletable.id == "service") or (roletable.id == "marine") then
				for j, tiertable in ipairs(roletable.tiers) do
					for k, person in ipairs(tiertable.persons) do
						local evalcombinedskill = C.GetPersonCombinedSkill(ship, person, nil, post)
						if evalcombinedskill > bestcombinedskill then
							bestpilot = person
							bestcombinedskill = evalcombinedskill
						end
					end
				end
			end
		end
	end

	--print("bestpilot: " .. tostring(bestpilot))
	if bestpilot == oldpilot then
		--print("the old pilot: " .. ffi.string(C.GetComponentName(oldpilot)) .. " is already the best pilot in the crew. nothing changed.")
		return false
	elseif checkonly then
		--print("there is a better pilot available in the crew: " .. ffi.string(C.GetPersonName(bestpilot, ship)) .. ", combined skill: " .. tostring(bestcombinedskill))
		return true
	end

	local actor = { entity = nil, personcontrollable = ship, personseed = bestpilot }
	C.AssignHiredActor(actor, ship, post, nil, false)

	menu.infoSubmenuPrepareCrewInfo(instance)

	if contextmenu then
		menu.closeContextMenu()
	end
	menu.refreshInfoFrame(nil, 0)
end

function menu.infoSubmenuCancelTransfer(controllable, person)
	C.ReleasePersonFromCrewTransfer(controllable, person)

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.infoSubmenuFireNPCConfirm(controllable, entity, person, instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fireindividual", controllable = controllable, entity = entity, person = person, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.infoSubmenuFireAllNPCConfirm(controllable, instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fireall", controllable = controllable, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.infoSubmenuFireNPC(controllable, entity, person, instance)
	if entity then
		SignalObject(ConvertStringTo64Bit(tostring(entity)), "npc__control_dismissed")
	else
		C.RemovePerson(controllable, person)
	end
	menu.closeContextMenu()
	menu.updatePeopleInfo = getElapsedTime()
end

function menu.infoSubmenuUpdateTransferAmount(instance, value, idx, containercash)
	if not value then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no value")
		return
	end
	if not idx then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no idx")
		return
	end
	if not containercash then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no containercash")
		return
	end

	menu.infoTablePersistentData[instance].cashtransferdetails.transfers[idx].amount = value - containercash
	-- do not refresh. prevents smoothly dragging the slider.
end

function menu.infoSubmenuSetManagerAccountToEstimate(i, instance)
	local entry = menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i]
	if entry then
		local containermoney, estimate = GetComponentData(entry.object, "money", entry.estimatetype)
		if entry.supply then
			estimate = estimate + tonumber(C.GetSupplyBudget(entry.object)) / 100
		end
		if entry.tradewares then
			estimate = estimate + tonumber(C.GetTradeWareBudget(entry.object)) / 100
		end
		if C.IsComponentClass(entry.object, "station") then
			SetMaxBudget(entry.object, (estimate * 3) / 2)
			SetMinBudget(entry.object, estimate)
		end

		local amount = estimate - containermoney
		if amount > 0 then
			TransferPlayerMoneyTo(amount, entry.object)
		else
			TransferMoneyToPlayer(-amount, entry.object)
		end
		menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
	end

	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateManagerAccount(i, instance)
	local entry = menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i]
	if entry and entry.amount ~= 0 then
		if C.IsComponentClass(entry.object, "station") then
			local newstationcash = (GetAccountData(entry.object, "money") or 0) + entry.amount
			SetMaxBudget(entry.object, (newstationcash * 3) / 2)
			SetMinBudget(entry.object, newstationcash)
		end

		TransferPlayerMoneyTo(entry.amount, entry.object)
		menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
	end

	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateProductionTime(object64, moduleindex)
	local productionmodules = GetProductionModules(object64)
	if not productionmodules then
		print("no production modules found.")
		return ""
	end
	local productiondata = GetProductionModuleData(productionmodules[moduleindex])
	if not productiondata then
		print("no production data found.")
		return ""
	end
	local s = productiondata.remainingcycletime
	if not s then
		print("error: remaining cycle time is: " .. tostring(s))
		return ""
	end
	local formattedtime = ConvertTimeString(s, "%h:%M:%S")
	return formattedtime
end

function menu.buttonExtendInfo(buttondata, instance)
	if menu.extendedinfo[buttondata .. instance] then
		menu.extendedinfo[buttondata .. instance] = nil
	else
		menu.extendedinfo[buttondata .. instance] = true
	end

	if instance == "left" then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.refreshInfoFrame()
	elseif instance == "right" then
		menu.settoprow = GetTopRow(menu.infoTableRight)
		menu.refreshInfoFrame2()
	end
end

function menu.isInfoExtended(buttondata, instance)
	if menu.extendedinfo[buttondata .. instance] then
		return true
	end
	return false
end

function menu.createMissionMode(frame)
	-- kuertee start: bug-fix of sideBarWidth being nil
	if menu.sideBarWidth == nil then
		menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	end
	-- kuertee end: bug-fix of sideBarWidth being nil

	menu.setrow = 3
	menu.missionDoNotUpdate = true

	if menu.infoTableMode == "missionoffer" then
		menu.updateMissionOfferList()
	elseif menu.infoTableMode == "mission" then
		menu.updateMissions()

		if menu.missionMode == menu.activeMissionMode then
			if menu.highlightLeftBar[menu.infoTableMode] then
				menu.highlightLeftBar[menu.infoTableMode] = nil
				menu.refreshMainFrame = true
			end
		end
	end

	local ftable
	local isonline = Helper.isOnlineGame()
	if (menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation") or (not isonline) then
		ftable = frame:addTable(9 , { tabOrder = 1 })
		ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
		ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

		ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
		ftable:setColWidth(2, Helper.scaleY(config.mapRowHeight), false)
		-- in smaller resolutions, e.g. 1280x720, this can get negative due to different scalings used (this would be solved if we unify the scaling support as planned)
		ftable:setColWidth(3, math.max(1, menu.sideBarWidth - 2 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)), false)
		ftable:setColWidth(4, menu.sideBarWidth / 2, false)
		ftable:setColWidth(5, menu.sideBarWidth / 2 - Helper.borderSize, false)
		ftable:setColWidth(6, menu.sideBarWidth, false)
		ftable:setColWidth(7, menu.sideBarWidth, false)
		ftable:setColWidthPercent(9, 20)

		ftable:setDefaultBackgroundColSpan(2, 8)
	end

	if not isonline then
		menu.missionOfferMode = "normal"
	end

	if menu.infoTableMode == "missionoffer" then
		if (menu.missionOfferMode == "normal") or (not isonline) then
			local found = false
			-- important
			if #menu.missionOfferList["plot"] > 0 then
				local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(9):createText(ReadText(1001, 3340), Helper.headerRowCenteredProperties)
				for _, entry in ipairs(menu.missionOfferList["plot"]) do
					found = true
					menu.addMissionRow(ftable, entry)
				end
				if not found then
					local row = ftable:addRow("plotnone", { bgColor = Helper.color.transparent, interactive = false })
					if menu.missionModeCurrent == "plotnone" then
						menu.setrow = row.index
					end
					row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
				end
			end
			-- guild
			found = false
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(ReadText(1001, 3331), Helper.headerRowCenteredProperties)

			-- kuertee start: callback
			if callbacks ["createMissionMode_on_missionoffer_guild_start"] then
				for _, callback in ipairs (callbacks ["createMissionMode_on_missionoffer_guild_start"]) do
					callback (ftable)
				end
			end
			-- kuertee end: callback

			for _, data in ipairs(menu.missionOfferList["guild"]) do
				if #data.missions > 0 then
					found = true

					-- check if we need to expand for the current selected mission
					for _, entry in ipairs(data.missions) do
						if entry.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[data.id] = true
						end
					end

					if menu.expandedMissionGroups[data.id .. "offer"] == nil then
						menu.expandedMissionGroups[data.id .. "offer"] = true
					end
					local isexpanded = menu.expandedMissionGroups[data.id .. "offer"]
					local row = ftable:addRow(data.id, { bgColor = Helper.color.transparent })
					if data.id == menu.missionModeCurrent then
						menu.setrow = row.index
					end
					row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(data.id .. "offer", row.index) end
					row[2]:setColSpan(7):createText(data.name)
					row[9]:createText((#data.missions == 1) and ReadText(1001, 3335) or string.format(ReadText(1001, 3336), #data.missions), { halign = "right" })
			
					if isexpanded then
						for _, entry in ipairs(data.missions) do
							menu.addMissionRow(ftable, entry, 1)
						end
					end
				end
			end
			if not found then
				local row = ftable:addRow("guildnone", { bgColor = Helper.color.transparent, interactive = false })
				if menu.missionModeCurrent == "guildnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- other
			found = false
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(ReadText(1001, 3332), Helper.headerRowCenteredProperties)
			for _, entry in ipairs(menu.missionOfferList["other"]) do
				found = true
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("othernone", { bgColor = Helper.color.transparent, interactive = false })
				if menu.missionModeCurrent == "othernone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
		elseif menu.missionOfferMode == "operation" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "getVentures")
				Helper.updateVenturePlatforms()
				Helper.callExtensionFunction("multiverse", "createVentureOperation", menu, menu.infoFrame, "left", config.missionOfferTabs)
			end
		end
	elseif menu.infoTableMode == "mission" then
		local found = false

		-- kuertee start: callback
		if callbacks ["createMissionMode_replaceMissionModeCurrent"] then
			local oldMissionModeCurrent = menu.missionModeCurrent
			for _, callback in ipairs (callbacks ["createMissionMode_replaceMissionModeCurrent"]) do
				menu.missionModeCurrent = callback (menu.missionModeCurrent)
				if menu.missionModeCurrent ~= oldMissionModeCurrent then
					-- break immediately if changed
					break
				end
			end
		end
		-- kuertee end: callback

		if menu.missionMode == "plot" then
			-- important
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(ReadText(1001, 3341), Helper.headerRowCenteredProperties)
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList["plot"]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("plotnone", { bgColor = Helper.color.transparent, interactive = false })
				if menu.missionModeCurrent == "plotnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- guild
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(ReadText(1001, 3333), Helper.headerRowCenteredProperties)
			found = false
			for _, data in ipairs(menu.missionList["guild"]) do
				found = true

				-- check if we need to expand for the current selected mission
				for _, entry in ipairs(data.missions) do
					if entry.ID == menu.missionModeCurrent then
						menu.expandedMissionGroups[data.id] = true
					end
					for i, submission in ipairs(entry.subMissions) do
						if submission.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[data.id] = true
							menu.expandedMissionGroups[entry.ID] = true
						end
					end
				end

				local isexpanded = menu.expandedMissionGroups[data.id]
				local row = ftable:addRow(data.id, { bgColor = Helper.color.transparent })
				if data.id == menu.missionModeCurrent then
					menu.setrow = row.index
				end

				local color = Helper.color.white
				if data.active then
					color = Helper.color.mission
				end

				row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(data.id, row.index) end
				row[2]:setColSpan(7):createText(data.name, { color = color, font = font })
				row[9]:createText((#data.missions == 1) and ReadText(1001, 3337) or string.format(ReadText(1001, 3338), #data.missions), { halign = "right", color = color })
			
				if isexpanded then
					local hadThreadMission = false
					for _, entry in ipairs(data.missions) do
						if entry.threadtype ~= "" then
							hadThreadMission = true
						end
						if hadThreadMission and (entry.threadtype == "") then
							-- first non thread mission after threads
							hadThreadMission = false
							local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
							row[1]:setColSpan(9):createText("")
						end
						menu.addMissionRow(ftable, entry, 1)
					end
				end
			end
			if not found then
				local row = ftable:addRow("guildnone", { bgColor = Helper.color.transparent, interactive = false })
				if menu.missionModeCurrent == "guildnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- other
			local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(ReadText(1001, 3334), Helper.headerRowCenteredProperties)
			found = false
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList["other"]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("othernone", { bgColor = Helper.color.transparent, interactive = false })
				if menu.missionModeCurrent == "othernone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			found = true
			-- online
			if #menu.missionList["coalition"] > 0 then
				local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(9):createText(ReadText(1001, 11609), Helper.headerRowCenteredProperties)
				for _, entry in ipairs(menu.missionList["coalition"]) do
					menu.addMissionRow(ftable, entry)
				end
			end
		elseif menu.missionMode == "upkeep" then
			-- title
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(ReadText(1001, 3305), Helper.headerRowCenteredProperties)
			for containeridstring, data in pairs(menu.missionList[menu.missionMode]) do
				found = true

				-- check if we need to expand for the current selected mission
				for _, entry in ipairs(data.missions) do
					if entry.ID == menu.missionModeCurrent then
						menu.expandedMissionGroups[containeridstring] = true
					end
					for i, submission in ipairs(entry.subMissions) do
						if submission.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[containeridstring] = true
							menu.expandedMissionGroups[entry.ID] = true
						end
					end
				end

				local isexpanded = menu.expandedMissionGroups[containeridstring]
				local row = ftable:addRow(containeridstring, { bgColor = Helper.color.transparent })
				if containeridstring == menu.missionModeCurrent then
					menu.setrow = row.index
				end

				local color = Helper.color.white
				if data.active then
					color = Helper.color.mission
				end

				row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(containeridstring, row.index) end
				local container = ConvertStringTo64Bit(containeridstring)
				row[2]:setColSpan(7):createText(ffi.string(C.GetComponentName(container)) .. " (" .. ffi.string(C.GetObjectIDCode(container)) .. ")" , { color = color })
				row[9]:createText((#data.missions == 1) and ReadText(1001, 3337) or string.format(ReadText(1001, 3338), #data.missions), { halign = "right", color = color })
			
				if isexpanded then
					local hadThreadMission = false
					for _, entry in ipairs(data.missions) do
						if entry.threadtype ~= "" then
							hadThreadMission = true
						end
						if hadThreadMission and (entry.threadtype == "") then
							-- first non thread mission after threads
							hadThreadMission = false
							local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
							row[1]:setColSpan(9):createText("")
						end
						menu.addMissionRow(ftable, entry, 1)
					end
				end
			end
		else
			local title = ""
			for _, entry in ipairs(config.missionCategories) do
				if entry.category == menu.missionMode then
					title = entry.name
					break
				end
			end
			-- title
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(9):createText(title, Helper.headerRowCenteredProperties)
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList[menu.missionMode]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
		end
		if not found then
			local row = ftable:addRow("othernone", { bgColor = Helper.color.transparent, interactive = false })
			if menu.missionModeCurrent == "othernone" then
				menu.setrow = row.index
			end
			row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
		end
	end

	if (menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation") then
		ftable:setTopRow(menu.settoprow)
		ftable:setSelectedRow(menu.setrow)
		ftable:setSelectedCol(menu.setcol or 0)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	if (menu.infoTableMode ~= "missionoffer") or ((menu.missionOfferMode ~= "operation") and isonline) then
		local table_header = menu.createMissionModeHeader(frame, "left")

		ftable.properties.y = table_header.properties.y + table_header:getVisibleHeight() + Helper.borderSize

		table_header:addConnection(1, 2, true)
		ftable:addConnection(2, 2)
	end
end

function menu.createMissionModeHeader(frame, instance)
	local categories = (menu.infoTableMode == "missionoffer") and config.missionOfferTabs or config.missionCategories

	local ftable
	if instance == "left" then
		menu.missionModeHeaderTableLeft = frame:addTable(#categories + 1, { tabOrder = 1 })
		ftable = menu.missionModeHeaderTableLeft
	elseif instance == "right" then
		menu.missionModeHeaderTableRight = frame:addTable(#categories + 1, { tabOrder = 1 })
		ftable = menu.missionModeHeaderTableRight
	end
	
	local count = 1
	for i, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if entry.empty then
				ftable:setColWidth(count, menu.sideBarWidth / 2, false)
			else
				ftable:setColWidth(count, menu.sideBarWidth, false)
			end
			count = count + 1
		end
	end

	local row = ftable:addRow("tabs", { fixed = true, bgColor = Helper.color.transparent })
	local count = 1
	for _, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if not entry.empty then
				local bgcolor = Helper.defaultTitleBackgroundColor
				local color = Helper.color.white
				if menu.infoTableMode == "missionoffer" then
					if entry.category == menu.missionOfferMode then
						bgcolor = Helper.defaultArrowRowBackgroundColor
					end
					if entry.category == "operation" then
						local outcomes = GetVentureOutcomes()
						if next(outcomes) ~= nil then
							color = Helper.color.mission
						end
					end
				else
					if entry.category == menu.missionMode then
						bgcolor = Helper.defaultArrowRowBackgroundColor
					end
					if entry.category == menu.activeMissionMode then
						color = Helper.color.mission
					end
				end

				local loccount = count
				row[loccount]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
				if menu.infoTableMode == "missionoffer" then
					row[loccount].handlers.onClick = function () return menu.buttonMissionOfferSubMode(entry.category, loccount) end
				else
					row[loccount].handlers.onClick = function () return menu.buttonMissionSubMode(entry.category, loccount) end
				end
			end
			count = count + 1
		end
	end

	if menu.selectedRows["missionModeHeaderTable" .. instance] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["missionModeHeaderTable" .. instance])
		ftable:setSelectedCol(menu.selectedCols["missionModeHeaderTable" .. instance] or 0)
		menu.selectedRows["missionModeHeaderTable" .. instance] = nil
		menu.selectedCols["missionModeHeaderTable" .. instance] = nil
	end

	return ftable
end

function menu.addMissionRow(ftable, missionentry, indented, seqidx)
	local name = missionentry.name
	if seqidx then
		name = seqidx .. ReadText(1001, 120) .. " " .. name
	end
	local icon = "\27[" .. "missiontype_" .. missionentry.type .. "]"
	local color = Helper.color.white
	if missionentry.active then
		color = Helper.color.mission
	elseif missionentry.accepted then
		name = ReadText(1001, 6404) .. " - " .. name
		color = Helper.color.mission
		missionentry.duration = 0
	elseif missionentry.expired then
		name = ReadText(1001, 6402) .. " - " .. name
		color = Helper.color.grey
		missionentry.duration = 0
	end
	local faction = ""
	if missionentry.faction ~= "" then
		faction = GetFactionData(missionentry.faction, "shortname")
	end
	if missionentry.faction == "player" then
		faction = ""
	end
	local reward = missionentry.rewardtext
	if missionentry.reward > 0 then
		reward = ConvertMoneyString(missionentry.reward, false, true, 7, true) .. " " .. ReadText(1001, 101)
	end
	if reward ~= "" then
		reward = ReadText(1001, 3301) .. ReadText(1001, 120) .. " " .. reward
	end
	local difficulty = ""
	if missionentry.difficulty ~= 0 then
		difficulty = ConvertMissionLevelString(missionentry.difficulty)
	end

	if menu.missionModeCurrent == nil then
		menu.missionModeCurrent = missionentry.ID
	end

	local bgColor = Helper.defaultSimpleBackgroundColor
	if #missionentry.subMissions > 0 then
		bgColor = Helper.color.transparent
	elseif missionentry.expired then
		bgColor = Helper.color.darkgrey
	elseif missionentry.ID == menu.missionModeCurrent then
		bgColor = Helper.defaultArrowRowBackgroundColor
	end

	local row = ftable:addRow((missionentry.expired or missionentry.accepted) and true or { missionentry.ID }, { bgColor = bgColor })
	row[5]:setColSpan(4)
	local font = Helper.standardFont
	if missionentry.ID == menu.missionModeCurrent then
		menu.setrow = row.index
		if #missionentry.subMissions > 0 then
			font = Helper.standardFontBold
		end
	end
	if reward ~= "" then
		local lines = GetTextLines(reward, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), row[5]:getWidth())
		if reward ~= lines[1] then
			reward = utf8.sub(lines[1], 1, -3) .. "..."
		end
	end

	local missioncol = 1
	if #missionentry.subMissions > 0 then
		local isexpanded = menu.expandedMissionGroups[missionentry.ID]

		if indented == 1 then
			row[1]:setBackgroundColSpan(9)
			row[2]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonExpandMissionGroup(missionentry.ID, row.index, function() return menu.showMissionContext(missionentry.ID) end) end
			row[3]:setColSpan(7):createText(name, { color = color, font = font })
		else
			row[1]:setBackgroundColSpan(9):createButton():setText(isexpanded and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(missionentry.ID, row.index, function() return menu.showMissionContext(missionentry.ID) end) end
			row[2]:setColSpan(8):createText(name, { color = color, font = font })
		end

		if isexpanded then
			for i, submission in ipairs(missionentry.subMissions) do
				menu.addMissionRow(ftable, submission, (indented or 0) + 1, (missionentry.threadtype == "sequential") and i or nil)
			end
		end
	else
		if indented == 2 then
			row[1]:setColSpan(2)
			row[1].properties.cellBGColor = Helper.color.transparent
			row[3]:setBackgroundColSpan(7):setColSpan(2):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right" })
			missioncol = 3
		elseif indented == 1 then
			row[1].properties.cellBGColor = Helper.color.transparent
			row[2]:setBackgroundColSpan(8):setColSpan(3):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right" })
			missioncol = 2
		else
			row[1]:setColSpan(4):setBackgroundColSpan(9):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right" })
		end
	end
	row[missioncol].properties.helpOverlayID = missionentry.helpOverlayID
	row[missioncol].properties.helpOverlayText = " "
	row[missioncol].properties.helpOverlayHighlightOnly = true
	row[missioncol].properties.helpOverlayUseBackgroundSpan = true
end

function menu.getMissionTimeAndDifficulty(missionid, difficulty)
	local rawduration = 0
	if menu.infoTableMode == "mission" then
		if menu.updateMissionTime ~= getElapsedTime() then
			menu.updateMissions()
		end
		local missiondetails = C.GetMissionIDDetails(ConvertStringTo64Bit(missionid))
		rawduration = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)
	else
		if menu.updateMissionOfferTime ~= getElapsedTime() then
			menu.updateMissionOfferList()
		end

		local found = false
		local expired = false
		for _, category in ipairs(config.missionOfferCategories) do
			for i, entry in ipairs(menu.missionOfferList[category.category] or {}) do
				if entry.ID == missionid then
					found = true
					expired = entry.expired or entry.accepted
					break
				end
			end
		end
		if found and (not expired) then
			local name, description, offerdifficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, offerduration, _, _, _, _, actor = GetMissionOfferDetails(ConvertStringToLuaID(missionid))
			rawduration = offerduration
		end
	end

	local duration = ""
	if rawduration > 0 then
		duration = ConvertTimeString(rawduration, (rawduration >= 3600) and "%h:%M:%S" or "%M:%S")
	end
	
	return duration .. "\n" .. difficulty
end

function menu.updateMissionOfferList(clear)
	menu.updateMissionOfferTime = getElapsedTime()
	if (not menu.missionOfferList) or (not next(menu.missionOfferList)) then
		clear = true
	end
	if clear then
		menu.missionOfferList = {}
		for _, entry in ipairs(config.missionOfferCategories) do
			menu.missionOfferList[entry.category] = {}
		end
		menu.missionOfferByOnlineID = {}
	end

	local missionOfferList, missionOfferIDs = {}, {}
	Helper.ffiVLA(missionOfferList, "uint64_t", C.GetNumCurrentMissionOffers, C.GetCurrentMissionOffers, true)
	for i, id in ipairs(missionOfferList) do
		missionOfferIDs[tostring(id)] = i
	end

	for _, entry in ipairs(config.missionOfferCategories) do
		if entry.category == "guild" then
			for i, data in ipairs(menu.missionOfferList[entry.category]) do
				for j = #data.missions, 1, -1 do
					if missionOfferIDs[data.missions[j].ID] then
						missionOfferIDs[menu.missionOfferList[entry.category][i].missions[j].ID] = nil
					else
						if not menu.missionOfferList[entry.category][i].missions[j].accepted then
							menu.missionOfferList[entry.category][i].missions[j].expired = true
						end
					end
				end
			end
		else
			for i = #menu.missionOfferList[entry.category], 1, -1 do
				if missionOfferIDs[menu.missionOfferList[entry.category][i].ID] then
					missionOfferIDs[menu.missionOfferList[entry.category][i].ID] = nil
				else
					if not menu.missionOfferList[entry.category][i].accepted then
						menu.missionOfferList[entry.category][i].expired = true
					end
				end
			end
		end
	end
	
	for id in pairs(missionOfferIDs) do
		local missionofferid64 = ConvertStringTo64Bit(id)
		local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, _, _, _, _, actor = GetMissionOfferDetails(ConvertStringToLuaID(id))
		local missionGroup = C.GetMissionGroupDetails(missionofferid64)
		local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
		local onlineinfo = C.GetMissionOnlineInfo(missionofferid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionofferid64))
		if maintype ~= "tutorial" then
			local entry = {
				["name"] = name,
				["description"] = description,
				["difficulty"] = difficulty,
				["missionGroup"] = { id = groupID, name = groupName },
				["threadtype"] = threadtype,
				["type"] = subtype,
				["faction"] = faction or "",
				["oppfaction"] = oppfaction or "",
				["licence"] = licence,
				["reward"] = reward,
				["rewardtext"] = rewardtext,
				["briefingobjectives"] = briefingobjectives,
				["activebriefingstep"] = activebriefingstep,
				["duration"] = duration,
				["missiontime"] = missiontime,
				["ID"] = id,
				["actor"] = actor,
				["onlinechapter"] = onlinechapter,
				["onlineID"] = onlineid,
				["helpOverlayID"] = helpoverlayid,
				["subMissions"] = {},
			}

			if entry.missionGroup.id ~= "" then
				local index = 0
				for i, data in ipairs(menu.missionOfferList["guild"]) do
					if data.id == entry.missionGroup.id then
						index = i
						break
					end
				end
				if index ~= 0 then
					table.insert(menu.missionOfferList["guild"][index].missions, entry)
				else
					table.insert(menu.missionOfferList["guild"], { id = entry.missionGroup.id, name = entry.missionGroup.name, missions = { entry } })
				end
			else
				if maintype == "plot" then
					table.insert(menu.missionOfferList["plot"], entry)
				elseif onlinechapter ~= "" then
					table.insert(menu.missionOfferList["coalition"], entry)
					menu.missionOfferByOnlineID[entry.onlineID] = entry
				else
					table.insert(menu.missionOfferList["other"], entry)
				end
			end
		end
	end

	table.sort(menu.missionOfferList["guild"], Helper.sortName)
	for _, entry in ipairs(menu.missionOfferList["guild"]) do
		table.sort(entry.missions, menu.missionOfferSorter)
	end
	table.sort(menu.missionOfferList["plot"], menu.missionOfferSorter)
	table.sort(menu.missionOfferList["coalition"], menu.missionOfferSorter)
	table.sort(menu.missionOfferList["other"], menu.missionOfferSorter)
end

function menu.missionOfferSorter(a, b)
	if a.name == b.name then
		return a.ID > b.ID
	end
	return a.name < b.name
end

function menu.getMissionInfoHelper(mission)
	local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, upkeepalertlevel, hasobjective, threadmissionid = GetMissionDetails(mission)
	local missionid64 = ConvertIDTo64Bit(missionID)
	local missionGroup = C.GetMissionGroupDetails(missionid64)
	local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
	local onlineinfo = C.GetMissionOnlineInfo(missionid64)
	local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
	local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionid64))
	local objectiveText, timeout, progressname, curProgress, maxProgress = GetMissionObjective(mission)
	local subMissions, buf = {}, {}
	local subactive = false
	Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionid64)
	for _, submission in ipairs(buf) do
		local submissionEntry = menu.getMissionIDInfoHelper(submission)
		table.insert(subMissions, submissionEntry)
		if submissionEntry.active then
			subactive = true
		end
	end
	local entry = {
		["active"] = (mission == GetActiveMission()) or subactive,
		["name"] = name,
		["description"] = description,
		["difficulty"] = difficulty,
		["missionGroup"] = { id = groupID, name = groupName },
		["threadtype"] = threadtype,
		["maintype"] = maintype,
		["type"] = subtype,
		["faction"] = faction,
		["reward"] = reward,
		["rewardtext"] = rewardtext,
		["duration"] = (timeout and timeout ~= -1) and timeout or (missiontime or -1),		-- timeout can be nil, if mission has no objective
		["ID"] = tostring(missionid64),
		["associatedcomponent"] = ConvertIDTo64Bit(associatedcomponent),
		["abortable"] = abortable,
		["threadMissionID"] = ConvertIDTo64Bit(threadmissionid) or 0,
		["subMissions"] = subMissions,
		["onlinechapter"] = onlinechapter,
		["onlineID"] = onlineid,
		["helpOverlayID"] = helpoverlayid,
	}

	return entry
end

function menu.getMissionIDInfoHelper(missionID)
	local missionGroup = C.GetMissionGroupDetails(missionID)
	local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
	local onlineinfo = C.GetMissionOnlineInfo(missionID)
	local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
	local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionID))
	local subMissions, buf = {}, {}
	local subactive = false
	Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionID)
	for _, submission in ipairs(buf) do
		local submissionEntry = menu.getMissionIDInfoHelper(submission)
		table.insert(subMissions, submissionEntry)
		if submissionEntry.active then
			subactive = true
		end
	end
	local missiondetails = C.GetMissionIDDetails(missionID)
	local entry = {
		["active"] = (missionID == C.GetActiveMissionID()) or subactive,
		["name"] = ffi.string(missiondetails.missionName),
		["description"] = ffi.string(missiondetails.missionDescription),
		["difficulty"] = missiondetails.difficulty,
		["missionGroup"] = { id = groupID, name = groupName },
		["threadtype"] = ffi.string(missiondetails.threadType),
		["maintype"] = ffi.string(missiondetails.mainType),
		["type"] = ffi.string(missiondetails.subType),
		["faction"] = ffi.string(missiondetails.faction),
		["reward"] = tonumber(missiondetails.reward) / 100,
		["rewardtext"] = ffi.string(missiondetails.rewardText),
		["duration"] = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1),
		["ID"] = tostring(ConvertStringTo64Bit(tostring(missionID))),
		["associatedcomponent"] = missiondetails.associatedComponent,
		["abortable"] = missiondetails.abortable,
		["threadMissionID"] = missiondetails.threadMissionID,
		["subMissions"] = subMissions,
		["onlinechapter"] = onlinechapter,
		["onlineID"] = onlineid,
		["activebriefingstep"] = missiondetails.activeBriefingStep,
		["helpOverlayID"] = helpoverlayid,
	}

	return entry
end

function menu.addMissionToList(entry)
	if entry.maintype == "upkeep" then
		if entry.associatedcomponent then
			local container = C.GetContextByRealClass(entry.associatedcomponent, "container", true)
			if container ~= 0 then
				local containeridstring = tostring(container)

				if menu.missionList["upkeep"][containeridstring] then
					if entry.active then
						menu.missionList["upkeep"][containeridstring].active = true
					end
					table.insert(menu.missionList["upkeep"][containeridstring].missions, entry)
				else
					menu.missionList["upkeep"][containeridstring] = { active = entry.active, missions = { entry } }
				end
				if entry.active then
					menu.activeMissionMode = "upkeep"
				end
			end
		end
	elseif entry.maintype == "guidance" then
		table.insert(menu.missionList["guidance"], entry)
		if entry.active then
			menu.activeMissionMode = "guidance"
		end
	elseif entry.maintype == "plot" then
		table.insert(menu.missionList["plot"], entry)
		if entry.active then
			menu.activeMissionMode = "plot"
		end
	elseif entry.onlinechapter ~= "" then
		table.insert(menu.missionList["coalition"], entry)
		menu.missionByOnlineID[entry.onlineID] = entry
	else
		if entry.missionGroup.id ~= "" then
			local index = 0
			for i, data in ipairs(menu.missionList["guild"]) do
				if data.id == entry.missionGroup.id then
					index = i
					break
				end
			end
			if index ~= 0 then
				if entry.active then
					menu.missionList["guild"][index].active = true
				end
				table.insert(menu.missionList["guild"][index].missions, entry)
			else
				table.insert(menu.missionList["guild"], { id = entry.missionGroup.id, name = entry.missionGroup.name, active = entry.active, missions = { entry } })
			end
			if entry.active then
				menu.activeMissionMode = "plot"
			end
		else
			table.insert(menu.missionList["other"], entry)
			if entry.active then
				menu.activeMissionMode = "plot"
			end
		end
	end
end

function menu.updateMissions()
	menu.updateMissionTime = getElapsedTime()
	menu.missionList = {}
	menu.missionByOnlineID = {}
	menu.activeMissionMode = nil
	for _, entry in ipairs(config.missionCategories) do
		menu.missionList[entry.category] = {}
	end

	local numMissions = GetNumMissions()
	for i = 1, numMissions do
		local entry = menu.getMissionInfoHelper(i)
		if maintype ~= "tutorial" then
			if entry.threadMissionID == 0 then
				menu.addMissionToList(entry)
			end
		end
	end

	for _, entry in ipairs(config.missionCategories) do
		if (entry.category == "guild") or (entry.category == "upkeep") then
			for _, data in pairs(menu.missionList[entry.category]) do
				table.sort(data.missions, menu.missionListSorter)
			end
		else
			table.sort(menu.missionList[entry.category], menu.missionListSorter)
		end
	end
end

function menu.missionListSorter(a, b)
	if ((a.threadtype ~= "") and (b.threadtype ~= "")) or ((a.threadtype == "") and (b.threadtype == "")) then
		if config.missionMainTypeOrder[a.maintype] == config.missionMainTypeOrder[b.maintype] then
			return a.name < b.name
		end
		return config.missionMainTypeOrder[a.maintype] < config.missionMainTypeOrder[b.maintype]
	end

	return a.threadtype ~= ""
end

function menu.createVentureSeasonHeader(frame, instance)
	local ftable
	if instance == "left" then
		menu.ventureSeasonHeaderTableLeft = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		ftable = menu.ventureSeasonHeaderTableLeft
	elseif instance == "right" then
		menu.ventureSeasonHeaderTableRight = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		ftable = menu.ventureSeasonHeaderTableRight
	end

	for i, entry in ipairs(config.seasonCategories) do
		if entry.empty then
			ftable:setColWidth(i, menu.sideBarWidth / 2, false)
		else
			ftable:setColWidth(i, menu.sideBarWidth, false)
		end
	end

	local isonline = Helper.isOnlineGame()
	local invitations = {}
	if not OnlineGetCurrentTeam().isvalid then
		invitations = Helper.callExtensionFunction("multiverse", "getTeamInvites") or {}
	end

	local row = ftable:addRow("orders_tabs", { fixed = true, bgColor = Helper.color.transparent })
	local count = 1
	for _, entry in ipairs(config.seasonCategories) do
		if not entry.empty then
			local bgcolor = Helper.defaultTitleBackgroundColor
			local color = Helper.color.white
			if entry.category == menu.seasonMode[instance] then
				bgcolor = Helper.defaultArrowRowBackgroundColor
			end
			if entry.category == "ventureteam" then
				if not OnlineGetCurrentTeam().isvalid then
					if #invitations > 0 then
						color = Helper.color.mission
					end
				end
			end

			local active = (entry.category == "currentseason") or isonline
			-- TODO onlineUI
			if entry.category == "pastseasons" then
				active = false
			end

			local loccount = count
			row[loccount]:createButton({ active = active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
			row[loccount].handlers.onClick = function () return menu.buttonVentureSeasonSubMode(entry.category, loccount, instance) end
			count = count + 1
		else
			count = count + 1
		end
	end

	if menu.selectedRows["ventureSeasonHeaderTable" .. instance] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["ventureSeasonHeaderTable" .. instance])
		ftable:setSelectedCol(menu.selectedCols["ventureSeasonHeaderTable" .. instance] or 0)
		menu.selectedRows["ventureSeasonHeaderTable" .. instance] = nil
		menu.selectedCols["ventureSeasonHeaderTable" .. instance] = nil
	end

	return ftable
end

function menu.createVentureSeason(frame, instance)
	local infoTableData = menu.infoTableData[instance]
	local infoTablePersistentData = menu.infoTablePersistentData[instance]

	local numCols = 2
	local table_desc = frame:addTable(numCols, { tabOrder = 1, highlightMode = "off" })
	table_desc:setColWidthPercent(2, 33)
	table_desc:setDefaultBackgroundColSpan(1, numCols)

	local season = OnlineGetCurrentSeason()

	-- title
	local row = table_desc:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11322), Helper.titleTextProperties)

	-- description
	local row = table_desc:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11334), Helper.subHeaderTextProperties)

	local description = GetTextLines(season.description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), menu.infoTableWidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
	if #description > config.ventureSeasons.maxDescRows then
		-- scrollbar case
		description = GetTextLines(season.description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), menu.infoTableWidth - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
	end
	for linenum, descline in ipairs(description) do
		local row = table_desc:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(descline)
		if linenum == config.ventureSeasons.maxDescRows then
			visibleHeight = table_desc:getFullHeight()
		end
	end

	if visibleHeight then
		table_desc.properties.maxVisibleHeight = visibleHeight
	else
		table_desc.properties.maxVisibleHeight = table_desc:getFullHeight()
	end

	if menu.selectedRows["infotable" .. instance] then
		table_desc:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_desc:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local numCols = 2
	local table_info = frame:addTable(numCols, { tabOrder = 2 })
	table_info:setColWidthPercent(2, 50)
	table_info:setDefaultBackgroundColSpan(1, numCols)

	table_info:addEmptyRow(config.mapRowHeight / 2)

	-- reward
	local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11335), Helper.subHeaderTextProperties)

	local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(numCols):createIcon(season.rewardicon, { scaling = false, height = math.floor(menu.infoTableWidth * 9 / 32) })
		
	if season.isvalid then
		local rewardlist = { { text = season.rewardtext } }
		for i, entry in ipairs(rewardlist) do
			local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			if i == 1 then
				row[1]:createText(ReadText(1001, 11338) .. ReadText(1001, 120))
			end
			row[2]:createText(entry.text, { halign = "right" })
		end

		table_info:addEmptyRow(config.mapRowHeight / 2)

		-- details
		local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11336), Helper.subHeaderTextProperties)
	
		local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11339) .. ReadText(1001, 120))
		local seasonname = ""
		if (season.seasonnumber < 1) or (season.seasonnumber > 25) then
			seasonname = string.format(ReadText(1001, 11576), season.seasonnumber)
		else
			seasonname = string.format(ReadText(1001, 11576), ReadText(20402, season.seasonnumber))
		end
		row[2]:createText(seasonname, { halign = "right" })
	
		local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11340) .. ReadText(1001, 120))
		row[2]:createText(Helper.ventureSeasonTimeLeftText(), { halign = "right" })

		-- coalition
		local row = table_info:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11341) .. ReadText(1001, 120))

		local coalitionname = ""
		local currentcoalition = OnlineGetCurrentCoalition()
		if currentcoalition.isvalid then
			coalitionname = currentcoalition.name
		else
			coalitionname = ReadText(1001, 11577)
		end
		row[2]:createButton({ active = function() return (season.ispreseason or season.isrunning) and Helper.isOnlineGame() end }):setText(coalitionname, { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonVentureSeasonSubMode("coalition", 2, instance) end

		-- team
		local row = table_info:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11582) .. ReadText(1001, 120))

		local teamname = ""
		local currentteam = OnlineGetCurrentTeam()
		if currentteam.isvalid then
			teamname = currentteam.name
		else
			teamname = ReadText(1001, 11583)
		end
		row[2]:createButton({ active = function () local currentcoalition = OnlineGetCurrentCoalition(); return Helper.isOnlineGame() and currentcoalition.isvalid end }):setText(teamname, { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonVentureSeasonSubMode("ventureteam", 3, instance) end

		table_info:addEmptyRow(config.mapRowHeight / 2)

		--[[
		-- progress
		local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11337), Helper.subHeaderTextProperties)

		-- TODO onlineUI
		local seasonprogress = { rank = "\27MEmperor", venturescompleted = 3210 } -- TEMPTEXT Florian
		local progresslist = {
			{ text = ReadText(1001, 11342),		value = "rank",					type = "string" },
			{ text = ReadText(1001, 11343),		value = "venturescompleted",	type = "number" },
			{ text = ReadText(1001, 11344),		value = "venturesfailed",		type = "number" },
		}
		for i, entry in ipairs(progresslist) do
			local row = table_info:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(entry.text .. ReadText(1001, 120))
			local value = seasonprogress[entry.value]
			if value and (entry.type == "number") then
				value = ConvertIntegerString(value, true, 0, true)
			end
			row[2]:createText(value, { halign = "right" })
		end--]]
	end

	local table_header = menu.createVentureSeasonHeader(frame, instance)

	table_desc.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	table_info.properties.y = table_desc.properties.y + table_desc:getVisibleHeight() + Helper.borderSize

	table_header:addConnection(1, (instance == "left") and 2 or 3, true)
	table_desc:addConnection(2, (instance == "left") and 2 or 3)
	table_info:addConnection(3, (instance == "left") and 2 or 3)
end

function menu.createCheats(frame)
	-- (cheat only)
	local cheats = {
		[1] = {
			name = "Enable All Cheats",
			info = "Reveal stations, encyclopedia, map, research and adds money and seta.",
			callback = C.EnableAllCheats,
			shortcut = {"action", 290}, -- INPUT_ACTION_DEBUG_FEATURE_3
		},
		[2] = {
			name = "Reveal map",
			callback = C.RevealMap,
		},
		[3] = {
			name = "Reveal stations",
			callback = C.RevealStations,
		},
		[4] = {
			name = "Cheat 1bn Credits",
			callback = function () return C.AddPlayerMoney(100000000000) end,
		},
		[5] = {
			name = "Cheat SETA",
			callback = function () return AddInventory(nil, "inv_timewarp", 1) end,
		},
		[6] = {
			name = "Reveal encyclopedia",
			info = "Also reveals the map and completes all research.",
			callback = C.RevealEncyclopedia,
		},
		[7] = {
			name = "Spawn CVs",
			section = "gDebug_deployCVs",
		},
		[8] = {
			name = "Fill nearby Build Storages",
			section = "gDebug_station_buildresources",
		},
		[9] = {
			name = "Inc Crew skill",
			section = "gDebug_crewskill",
		},
		[10] = {
			name = "Open Flowchart Test",
			menu = "StationOverviewMenu",
		},
		[11] = {
			name = "Cheat All Research",
			callback = menu.cheatAllResearch,
		},
		[12] = {
			name = "Cheat Docking Traffic",
			sectionparam = C.CheatDockingTraffic,
			shortcut = {"action", 291}, -- INPUT_ACTION_DEBUG_FEATURE_4
		},
		[13] = {
			name = "Cheat Live Stream View Channels",
			info = "Makes all faction channels available in Live Stream View.",
			callback = C.CheatLiveStreamViewChannels,
		},
	}

	local ftable = frame:addTable(1 , { tabOrder = 1 })
	ftable:addConnection(1, 2, true)
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:createText("Cheats", Helper.headerRowCenteredProperties)

	for _, cheat in ipairs(cheats) do
		local row = ftable:addRow(true, {  })
		local shortcut = ""
		if cheat.shortcut then
			shortcut = Helper.formatOptionalShortcut(" \27A(%s)", cheat.shortcut[1], cheat.shortcut[2])
		end
		row[1]:createButton({ mouseOverText = cheat.info or "" }):setText(cheat.name .. shortcut)
		if cheat.callback then
			row[1].handlers.onClick = function () return cheat.callback() end
		elseif cheat.menu then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, cheat.menu, {0, 0}) menu.cleanup() end
		elseif cheat.section then
			row[1].handlers.onClick = function () Helper.closeMenuForNewConversation(menu, cheat.section, ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), nil, true) menu.cleanup() end
		end
	end
end

function menu.cheatAllResearch()
	local researchwares = {
		"research_module_defence",
		"research_module_habitation",
		"research_module_production",
		"research_module_storage",
		"research_module_dock",
		"research_module_build",
		"research_teleportation",
		"research_teleportation_range_01",
		"research_teleportation_range_02",
		"research_teleportation_range_03",
		"research_radioreceiver",
		"research_sensorbooster",
		"research_tradeinterface",
	}

	for _, research in ipairs(researchwares) do
		C.AddResearch(research)
	end
end

function menu.createPlayerInfo(frame, width, height, offsetx, offsety)
	local ftable = frame:addTable(3, { tabOrder = 18, width = width, height = height, x = offsetx, y = offsety, scaling = false })
	ftable:setColWidth(1, height)
	ftable:setColWidthPercent(3, 30)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent60 })
	local icon = row[1]:setBackgroundColSpan(3):createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = height, height = height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, width - height - Helper.borderSize))

	if menu.showMultiverse then
		row[2]:createText(function (cell) return Helper.playerInfoConfigTextLeft(cell, nil, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = math.max(0, (height - textheight) / 4) })
	else
		local button = row[2]:createButton({
			width = row[2]:getColSpanWidth(),
			height = Helper.scaleY(config.mapRowHeight),
			x = Helper.borderSize,
			y = Helper.borderSize,
			mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))),
			bgColor = function () return menu.allowResetView() and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor end,
			highlightColor = function () return menu.allowResetView() and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor end,
		})
		button:setText(function (cell) return Helper.playerInfoConfigTextLeft(cell, 0.7 * width - height - 2 * Helper.scaleY(Helper.standardTextHeight), menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = 0 })
		button:setText2("\27[menu_reset_view]", { halign = "right", scaling = true })
		button:setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		button.handlers.onClick = function () return menu.allowResetView() and menu.buttonResetView() or nil end
	end

	if OnlineIsCurrentTeamValid() then
		local button = row[3]:createButton({
			width = row[3]:getColSpanWidth(),
			height = Helper.scaleY(Helper.standardTextHeight),
			x = Helper.borderSize,
			y = Helper.borderSize,
			mouseOverText = ffi.string(C.GetMappedInputName("INPUT_ACTION_SHOW_CHAT_WINDOW")),
		})
		button:setText(function (cell) return Helper.playerInfoConfigTextRight(cell, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = 0, halign = "right" })
		button:setText2("\27[mt_chat_unread_low] " .. ReadText(1001, 11648), { scaling = true })
		button.handlers.onClick = function () return C.QuickMenuAccess("chat") end
	else
		row[3]:createText(function (cell) return Helper.playerInfoConfigTextRight(cell, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize, y = math.max(0, (height - textheight) / 4) })
	end
end

function menu.createSearchField(frame, width, height, offsetx, offsety, refresh)
	local editboxwidth = menu.infoTableWidth - Helper.round(2.5 * menu.editboxHeight) - Helper.borderSize

	local numCols = 7 + #config.layers
	local ftable = frame:addTable(numCols, { tabOrder = 4, width = width, height = height, x = offsetx, y = offsety, skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.semitransparent })
	if menu.searchTableMode ~= "info" then
		ftable:addConnection(1, 3, true)
	end
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setColWidth(2, math.max(4, Helper.scaleY(Helper.headerRow1Height) - Helper.scaleY(config.mapRowHeight) - Helper.borderSize), false)
	ftable:setColWidth(3, menu.sideBarWidth - Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize, false)
	for i = 2, #config.layers + 1 do
		ftable:setColWidth(i + 2, menu.sideBarWidth, false)
	end
	ftable:setColWidth(numCols - 1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setColWidth(numCols, Helper.scaleY(config.mapRowHeight), false)

	-- search field
	local rows = {
		[1] = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent }),
		[2] = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent }),
		[3] = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent }),
	}

	for i, entry in ipairs(config.layers) do
		local icon = entry.icon
		local onoffcolor = Helper.color.white
		if not menu.getFilterOption(entry.mode) then
			icon = icon .. "_disabled"
			onoffcolor = Helper.color.red
		end
		local mouseovertext = entry.name
		local hotkeyname = ffi.string(C.GetMappedInputName("INPUT_STATE_DETAILMONITOR_TOGGLE_FILTER_" .. i))
		if hotkeyname ~= "" then
			mouseovertext = mouseovertext .. " (" .. hotkeyname .. ")"
		end

		local button = rows[i][1]:setColSpan(5):createButton({ height = menu.editboxHeight, bgColor = bgcolor, mouseOverText = mouseovertext, scaling = false, helpOverlayID = (i == 1) and "toggle_trade" or "", helpOverlayText = " ", helpOverlayHighlightOnly = true})
		button:setIcon(icon, { width = menu.editboxHeight, height = menu.editboxHeight })
		button:setText(entry.shortname, { x = menu.editboxHeight, fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
		button:setIcon2("menu_on_off", { width = menu.editboxHeight, height = menu.editboxHeight, x = rows[i][1]:getWidth() - menu.editboxHeight, color = onoffcolor })
		button:setHotkey("INPUT_STATE_DETAILMONITOR_TOGGLE_FILTER_" .. i, { displayIcon = false })
		button.handlers.onClick = function () return menu.buttonSetFilterLayer(entry.mode, rows[i].index, i) end
	end
	-- editbox
	rows[1][7]:setColSpan(4):createEditBox({ height = menu.editboxHeight, defaultText = ReadText(1001, 3250), scaling = false, helpOverlayID = "map_searchbar", helpOverlayText = " ", helpOverlayHighlightOnly = true, restoreInteractiveObject = true }):setText("", { x = Helper.standardTextOffsetx, scaling = true }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	rows[1][7].handlers.onEditBoxDeactivated = menu.searchTextConfirmed

	-- search terms
	local setting, warefilter = menu.getTradeWareFilter()
	local maxsearchtermsdisplayed = 4

	local searchindex = 0
	for i = 1, math.min(maxsearchtermsdisplayed, #menu.searchtext) do
		local usedrow = rows[2]
		local col = 6 + i
		if col > 8 then
			usedrow = rows[3]
			col = col - 2
		end
		searchindex = searchindex + 1
		local untruncatedstring = menu.searchtext[i].text
		local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

		if menu.searchtext[i].blockRemove then
			usedrow[col]:createText(untruncatedstring, { halign = "center", cellBGColor = Helper.defaultButtonBackgroundColor })
		else
			usedrow[col]:createButton({
				height = menu.editboxHeight,
				helpOverlayID = "FilterItem" .. searchindex,
				helpOverlayText = " ", 
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and untruncatedstring or "",
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
			usedrow[col].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
		end
	end

	local searchindex = 0
	if #menu.searchtext < maxsearchtermsdisplayed then
		for i = 1, math.min(maxsearchtermsdisplayed - #menu.searchtext, #warefilter) do
			local usedrow = rows[2]
			local col = 6 + i + #menu.searchtext
			if col > 8 then
				usedrow = rows[3]
				col = col - 2
			end
			searchindex = searchindex + 1
			local untruncatedstring = GetWareData(warefilter[i], "name")
			local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

			usedrow[col]:createButton({
				height = menu.editboxHeight,
				helpOverlayID = "FilterWare" .. searchindex,
				helpOverlayText = " ", 
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and untruncatedstring or "",
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setIcon("maptr_supply", { width = menu.editboxHeight, height = menu.editboxHeight })
			usedrow[col].handlers.onClick = function () return menu.removeFilterOption(setting, setting.id, i) end
			usedrow[col].properties.uiTriggerID = "removefilteroption"
		end
	end

	if (#menu.searchtext + #warefilter) > maxsearchtermsdisplayed then
		rows[3][numCols - 1]:setColSpan(2):createText(string.format("%+d", (#menu.searchtext + #warefilter) - maxsearchtermsdisplayed), { y = (menu.editboxHeight - Helper.standardTextHeight) / 2, scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
	end

	menu.infoTable2OffsetY = ftable.properties.y + ftable:getFullHeight() + Helper.borderSize

	if menu.searchTableMode then
		if menu.holomap ~= 0 then
			C.SetMapStationInfoBoxMargin(menu.holomap, "right", menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder)
		end
		if (#menu.searchtext + #warefilter) > 0 then
			local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText("")
		end

		if menu.searchTableMode == "filter" then
			menu.createFilterMode(ftable, numCols)
		elseif menu.searchTableMode == "legend" then
			menu.createLegendMode(ftable, numCols)
		elseif menu.searchTableMode == "hire" then
			menu.createHireMode(ftable, numCols)
		end
	else
		if menu.holomap ~= 0 then
			C.SetMapStationInfoBoxMargin(menu.holomap, "right", 0)
		end
	end

	ftable:setTopRow(menu.topRows.filterTable)
	ftable:setSelectedRow(menu.selectedRows.filterTable)
	ftable:setSelectedCol(menu.selectedCols.filterTable or 0)

	menu.topRows.filterTable = nil
	menu.selectedRows.filterTable = nil
	menu.selectedCols.filterTable = nil

	if not refresh then
		menu.createInfoFrame2()
	end
end

function menu.allowResetView()
	if menu.holomap ~= 0 then
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		local radthreshold = math.rad(config.cameraResetThresholdAngle)
		-- offset rotation when camera is reset:
		--   yaw: 0
		--   pitch: -1.5533 = -179°
		--   roll: 0
		if (math.abs(mapstate.offset.yaw) > radthreshold) or (math.abs(mapstate.offset.roll) > radthreshold) or (mapstate.offset.pitch > -math.pi / 2 + radthreshold) then
			return true
		end

		return C.GetMapFocusComponent(menu.holomap) ~= C.GetPlayerObjectID()
	end
end

function menu.createInfoFrame2()
	menu.createInfoFrame2Running = true

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoFrameLayer2)

	-- infoTable
	local infoTableHeight = Helper.viewHeight - menu.infoTableOffsetY - menu.borderOffset

	menu.infoFrame2 = Helper.createFrameHandle(menu, {
		x = Helper.viewWidth - menu.infoTableOffsetX - menu.infoTableWidth,
		y = menu.infoTable2OffsetY,
		width = menu.infoTableWidth,
		height = infoTableHeight,
		layer = config.infoFrameLayer2,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = {},
		showBrackets = false,
		autoFrameHeight = true,
		helpOverlayID = "map_infoframe2",
	})

	if (menu.searchTableMode ~= "info") and (menu.mode ~= "orderparam_object") then
		menu.infoTablePersistentData.right.cashtransferdetails = {}
		menu.infoTablePersistentData.right.drops = {}
		menu.infoTablePersistentData.right.crew.object = nil
		menu.infoTablePersistentData.right.macrostolaunch = {}
	end
	
	menu.infoTableData = menu.infoTableData or {}
	menu.infoTableData.right = {}
	if (not menu.showMultiverse) and (menu.searchTableMode == "info") then
		if menu.infoMode.right == "objectinfo" then
			menu.infoFrame2.properties.autoFrameHeight = false
			menu.createInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectcrew" then
			menu.createCrewInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectloadout" then
			menu.createLoadoutInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectlogbook" then
			menu.createLogbookInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "orderqueue" then
			menu.createOrderQueue(menu.infoFrame2, menu.infoMode.right, "right")
		elseif menu.infoMode.right == "orderqueue_advanced" then
			menu.createOrderQueue(menu.infoFrame2, menu.infoMode.right, "right")
		elseif menu.infoMode.right == "standingorders" then
			menu.createStandingOrdersMenu(menu.infoFrame2, "right")
		end
	else
		-- empty

		-- kuertee start: callback
		-- menu.infoFrame2.properties.backgroundID = ""
		-- menu.infoFrame2.properties.showBrackets = false
		-- menu.infoFrame2.properties.autoFrameHeight = false
		-- menu.infoFrame2:addTable(0)

		local isCreated = false
		if callbacks ["createInfoFrame2_on_menu_infoModeRight"] then
			for _, callback in ipairs (callbacks ["createInfoFrame2_on_menu_infoModeRight"]) do
				if callback (menu.infoFrame2) then
					isCreated = true
				end
			end
		end
		if isCreated ~= true then
			menu.infoFrame2.properties.backgroundID = ""
			menu.infoFrame2.properties.showBrackets = false
			menu.infoFrame2.properties.autoFrameHeight = false
			menu.infoFrame2:addTable(0)
		end
		-- kuertee end: callback

	end

	menu.infoFrame2.properties.helpOverlayText = helpOverlayText
	menu.infoFrame2:display()
end

function menu.buttonRemoveSearchEntry(index)
	Helper.cancelEditBoxInput(menu.searchField, 1, 7)

	table.remove(menu.searchtext, index)
	Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
	menu.refreshMainFrame = true

	menu.refreshInfoFrame()
end

function menu.createSideBar(firsttime, frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if callbacks ["createSideBar_on_start"] then
		for _, callback in ipairs (callbacks ["createSideBar_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	-- start Forleyor_infoCenter Callback:
	if callbacks ["ic_createSideBar"] then
		for _, callback in ipairs (callbacks ["ic_createSideBar"]) do
			callback (config)
		end
	end
	-- end Forleyor_infoCenter:

	local spacingHeight = menu.sideBarWidth / 4
	local defaultInteractiveObject = false
	if menu.showMultiverse then
		defaultInteractiveObject = menu.ventureMode == nil
	else
		defaultInteractiveObject = menu.infoTableMode == nil
	end
	local ftable = frame:addTable(1, { tabOrder = 3, width = width, height = height, x = offsetx, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false, defaultInteractiveObject = defaultInteractiveObject })
	ftable:addConnection(1, 1, true)

	local foundselection
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local areventurescompatible = C.AreVenturesCompatible()
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if not entry.spacing then
				entry.active = true
				if menu.showMultiverse then
					if entry.mode ~= "ventureseason" then
						entry.active = areventurescompatible
					end
				else
					if menu.mode == "selectCV" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "hire" then

						-- if entry.mode ~= "propertyowned" then
						-- kuertee start:
						if not string.find (entry.mode, "propertyowned") then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "orderparam_object" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "selectComponent" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					end
				end
				if entry.active then
					local selectedmode = false
					if type(entry.mode) == "table" then
						for _, mode in ipairs(entry.mode) do
							if menu.showMultiverse then
								if mode == menu.ventureMode then
									selectedmode = true
									break
								end
							else
								if mode == menu.infoTableMode then
									selectedmode = true
									break
								end
							end
						end
					else
						if menu.showMultiverse then
							if entry.mode == menu.ventureMode then
								selectedmode = true
							end
						else
							if entry.mode == menu.infoTableMode then
								selectedmode = true
							end
						end
					end
					if selectedmode then
						foundselection = true
					end
				end
			end
		end
	end

	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				local mode = entry.mode
				if type(entry.mode) == "table" then
					mode = mode[1]
				end
				local row = ftable:addRow(true, { fixed = true })
				local bgcolor = Helper.defaultTitleBackgroundColor
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if menu.showMultiverse then
							if mode == menu.ventureMode then
								bgcolor = Helper.defaultArrowRowBackgroundColor
								break
							end
						else
							if mode == menu.infoTableMode then
								bgcolor = Helper.defaultArrowRowBackgroundColor
								break
							end
						end
					end
				else
					if menu.showMultiverse then
						if entry.mode == menu.ventureMode then
							bgcolor = Helper.defaultArrowRowBackgroundColor
						end
					else
						if entry.mode == menu.infoTableMode then
							bgcolor = Helper.defaultArrowRowBackgroundColor
						end
					end
				end
				local color = Helper.color.white
				if menu.highlightLeftBar[mode] then
					color = Helper.color.mission
				end
				
				row[1]:createButton({ active = entry.active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color })
				row[1].handlers.onClick = function () return menu.buttonToggleObjectList(mode) end
			end
		end
	end

	ftable:setSelectedRow(menu.selectedRows.sideBar)
	menu.selectedRows.sideBar = nil
end

function menu.createRightBar(frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if callbacks ["createRightBar_on_start"] then
		for _, callback in ipairs (callbacks ["createRightBar_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	local spacingHeight = menu.sideBarWidth / 4
	local ftable = frame:addTable(1, { tabOrder = 5, width = width, height = height, x = offsetx, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false, skipTabChange = true })
	ftable:addConnection(1, 4, true)

	for _, entry in ipairs(config.rightBar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				local mode = entry.mode
				if type(entry.mode) == "table" then
					mode = mode[1]
				end
				local row = ftable:addRow(true, { fixed = true })
				local active = true
				if menu.mode == "selectCV" then
					active = false
				elseif menu.mode == "hire" then
					active = false
				elseif menu.mode == "selectComponent" then
					active = false
				end
				local bgcolor = Helper.defaultTitleBackgroundColor
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.searchTableMode then
							bgcolor = Helper.defaultArrowRowBackgroundColor
							break
						end
					end
				else
					if entry.mode == menu.searchTableMode then
						bgcolor = Helper.defaultArrowRowBackgroundColor
					end
				end
				row[1]:createButton({ active = active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon)
				row[1].handlers.onClick = function () return menu.buttonToggleRightBar(mode) end
			end
		end
	end

	ftable:setSelectedRow(menu.selectedRows.rightBar)
	menu.selectedRows.rightBar = nil
end

function menu.createSelectedShips(frame)
	if menu.getNumSelectedComponents() == 0 then
		-- nothing to do
		frame:addTable(1, { tabOrder = 0, width = 1, scaling = false, reserveScrollBar = false })
		return
	end

	-- sort ships
	local selectedobjects = {}
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if C.IsObjectKnown(selectedcomponent) then
			local class = ffi.string(C.GetComponentClass(selectedcomponent))
			local icon, primarypurpose, hullpercent, shieldpercent, isplayerowned, isenemy, ismodule, ishostile = GetComponentData(selectedcomponent, "icon", "primarypurpose", "hullpercent", "shieldpercent", "isplayerowned", "isenemy", "ismodule", "ishostile")
			if not ismodule then
				local color = "neutral"
				if isplayerowned then
					color = "player"
				elseif ishostile then
					color = "hostile"
				elseif isenemy then
					color = "enemy"
				end
				local i = menu.findEntryByShipIcon(selectedobjects, icon, color)
				if i then
					selectedobjects[i].count			= selectedobjects[i].count			+ 1
					selectedobjects[i].hullpercent		= selectedobjects[i].hullpercent	+ hullpercent
					selectedobjects[i].shieldpercent	= selectedobjects[i].shieldpercent	+ shieldpercent
				else
					table.insert(selectedobjects, { icon = icon, color = color, class = class, purpose = primarypurpose, count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent })
				end
			end
		end
	end
	table.sort(selectedobjects, menu.sortShipsByClassAndPurpose)

	if #selectedobjects == 0 then
		-- nothing to do
		frame:addTable(1, { tabOrder = 0, width = 1, scaling = false, reserveScrollBar = false })
		return
	end

	local ftable
	if (#selectedobjects > 1) or (selectedobjects[1].count > 1) then
		-- display
		local numcolumns = 2 * menu.selectedShipsTableData.maxCols
		local columnwidth = math.ceil(menu.selectedShipsTableData.width / 2)
		local width = numcolumns * (columnwidth + Helper.borderSize) - Helper.borderSize
		ftable = frame:addTable(numcolumns, { tabOrder = 21, width = width, x = Helper.viewWidth / 2 - width / 2, y = 0, scaling = false, reserveScrollBar = false, skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.semitransparent })
		for i = 1, numcolumns do
			ftable:setColWidth(i, columnwidth)
		end
		ftable:setDefaultBackgroundColSpan(1, numcolumns)
		ftable:setDefaultComplexCellProperties("icon", "text", { font = Helper.standardFontOutlined, fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = menu.selectedShipsTableData.fontsize })

		-- title
		local titlewidth = math.ceil(C.GetTextWidth(" " .. ReadText(1001, 3251) .. " ", Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true)))
		local numtitlecols = math.ceil(titlewidth / (columnwidth + Helper.borderSize))
		if numtitlecols % 2 == 1 then
			numtitlecols = numtitlecols + 1
		end
		if numtitlecols > numcolumns - 2 then
			local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Helper.defaultTitleTrapezoidBackgroundColor, scaling = true })
			row[1]:setColSpan(numcolumns):createText(ReadText(1001, 3251), { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, halign = "center" })
		else
			local numbordercols = (numcolumns - numtitlecols) / 2
			local bordericonsize = Helper.scaleX(Helper.headerRow1Height)

			local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent, scaling = true })
			row[1]:setBackgroundColSpan(numcolumns):setColSpan(numbordercols):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = numbordercols * (columnwidth + Helper.borderSize) - bordericonsize, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor })
			local width = numtitlecols * (columnwidth + Helper.borderSize)
			row[numbordercols + 1]:setColSpan(numtitlecols):createIcon("solid", { height = bordericonsize, width = width, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor }):setText(ReadText(1001, 3251), { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = width / 2 })
			row[numbordercols + numtitlecols + 1]:setColSpan(numbordercols):createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor })
		end

		-- example text used
		local textheight = math.ceil(C.GetTextHeight(ReadText(1001, 42) .. "1", Helper.standardFontOutlined, menu.selectedShipsTableData.fontsize, 0))
		-- ship rows
		for i = 1, math.floor(#selectedobjects / menu.selectedShipsTableData.maxCols) + 1 do
			local numshipcolums = math.min(#selectedobjects - (i -1) * menu.selectedShipsTableData.maxCols, menu.selectedShipsTableData.maxCols)
			local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent })
			for j = 1, numshipcolums do
				local shipindex = (i - 1) * menu.selectedShipsTableData.maxCols + j
				local shipentry = selectedobjects[shipindex]
				local colindex = (j + 0.5 * (menu.selectedShipsTableData.maxCols - numshipcolums)) * 2 - 1
				local color = menu.holomapcolor.friendcolor
				if shipentry.color == "player" then
					color = menu.holomapcolor.playercolor
				elseif shipentry.color == "hostile" then
					color = menu.holomapcolor.hostilecolor
				elseif shipentry.color == "enemy" then
					color = menu.holomapcolor.enemycolor
				end
				row[colindex]:setColSpan(2):createIcon(C.IsIconValid(shipentry.icon) and shipentry.icon or "solid", { height = menu.selectedShipsTableData.height, width = menu.selectedShipsTableData.height + Helper.borderSize, color = color }):setText(ReadText(1001, 42) .. shipentry.count, { halign = "right", x = Helper.standardTextOffsetx, y = (menu.selectedShipsTableData.height - textheight) / 2 })
			end
			local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent })
			for j = 1, numshipcolums do
				local shipindex = (i - 1) * menu.selectedShipsTableData.maxCols + j
				local shipentry = selectedobjects[shipindex]
				local colindex = (j + 0.5 * (menu.selectedShipsTableData.maxCols - numshipcolums)) * 2 - 1
				row[colindex]:setColSpan(2):createShieldHullBar(shipentry.shieldpercent / shipentry.count, shipentry.hullpercent / shipentry.count, { height = 10, y = 5 })
			end
		end
	else
		local component = next(menu.selectedcomponents)
		local selectedcomponent = ConvertStringTo64Bit(component)
		local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(selectedcomponent, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
		local objecttitle = ffi.string(C.GetComponentName(selectedcomponent))
		if C.IsComponentClass(selectedcomponent, "container") then
			objecttitle = objecttitle .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")"
		end
		local objecttitlewidth = math.ceil(C.GetTextWidth(objecttitle, Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true))) + 2 * Helper.standardTextOffsetx
		local objecticon = GetComponentData(selectedcomponent, "icon")
		if C.IsComponentClass(selectedcomponent, "highway") then
			local entrygate = GetComponentData(selectedcomponent, "entrygate")
			objecticon = GetComponentData(entrygate, "icon")
		end
		local bordericonsize = Helper.scaleX(Helper.headerRow1Height)
		local colwidth = math.ceil(objecttitlewidth / 2)
		local bordercolwidth

		local numcolumns = 7
		local width = math.max(menu.selectedShipsTableData.singleObjectWidth, 2 * colwidth + 2 * menu.selectedShipsTableData.width + 2 * bordericonsize + (numcolumns - 1) * Helper.borderSize)
		if width > Helper.viewWidth - 2 * (menu.infoTableOffsetX + menu.infoTableWidth + 2 * Helper.borderSize) then
			if width > menu.selectedShipsTableData.singleObjectWidth then
				bordercolwidth = bordericonsize
				colwidth = nil
			end
			width = Helper.viewWidth - 2 * (menu.infoTableOffsetX + menu.infoTableWidth + 2 * Helper.borderSize)
		end
		ftable = frame:addTable(numcolumns, { tabOrder = 21, width = width, x = Helper.viewWidth / 2 - width / 2, y = 0, scaling = false, reserveScrollBar = false, skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.semitransparent })
		ftable:setColWidth(2, menu.selectedShipsTableData.width)
		ftable:setColWidth(4, 1)
		ftable:setColWidth(6, menu.selectedShipsTableData.width)
		if colwidth then
			ftable:setColWidth(3, colwidth)
			ftable:setColWidth(5, colwidth)
		end
		if bordercolwidth then
			ftable:setColWidth(1, bordercolwidth)
			ftable:setColWidth(7, bordercolwidth)
		else
			ftable:setColWidthMin(1, bordericonsize)
			ftable:setColWidthMin(7, bordericonsize)
		end
		ftable:setDefaultBackgroundColSpan(1, numcolumns)
		ftable:setDefaultCellProperties("text", { fontsize = menu.selectedShipsTableData.fontsize; minRowHeight = menu.selectedShipsTableData.textHeight })
		ftable:setDefaultComplexCellProperties("icon", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("icon", "text2", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = menu.selectedShipsTableData.fontsize })

		-- title
		local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent, scaling = true })
		row[1]:setBackgroundColSpan(numcolumns):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = row[1]:getWidth() + Helper.borderSize - bordericonsize, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor })
		row[2]:setColSpan(5)
		local middlewidth = row[2]:getColSpanWidth() + Helper.borderSize
		row[2]:createIcon("solid", { height = bordericonsize, width = middlewidth, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor }):setText(ReadText(1001, 11636), { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = middlewidth / 2 })
		row[7]:createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor })

		local row = ftable:addRow(nil, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent, scaling = true })
		local color = isplayerowned and menu.holomapcolor.playercolor or menu.holomapcolor.friendcolor
		if isplayerowned then
			color = menu.holomapcolor.playercolor
			if selectedcomponent == C.GetPlayerObjectID() then
				color = menu.holomapcolor.currentplayershipcolor
			end
		elseif isonlineobject and menu.getFilterOption("layer_other") and menu.getFilterOption("think_diplomacy_highlightvisitor") then
			color = menu.holomapcolor.visitorcolor
		elseif ishostile then
			color = menu.holomapcolor.hostilecolor
		elseif isenemy then
			color = menu.holomapcolor.enemycolor
		end
		row[2]:createText("\27[" .. objecticon .. "]", { color = color, halign = "right", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = 0 })
		row[3]:setColSpan(3):createText(objecttitle, { color = color, halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, minRowHeight = Helper.headerRow1Height })
		row[6]:createObjectShieldHullBar(selectedcomponent)

		if isplayerowned then
			if C.IsComponentClass(selectedcomponent, "ship") then
				local row = ftable:addRow(nil, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(ReadText(1001, 16), { halign = "center" })
				row[4]:createText("", { x = 0 })
				row[5]:setColSpan(3):createText(ReadText(1001, 8355), { halign = "center" })
				-- line
				local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.white })
				row[1]:setColSpan(3):createText("", { height = 2 })
				row[4]:createText("", { height = 2, cellBGColor = Helper.color.transparent, x = 0 })
				row[5]:setColSpan(3):createText("", { height = 2 })

				local sideorder = { "left", "right" }
				local rows = {
					left = {},
					right = {},
				}
				-- order
				local _, _, _, name, _, _, _, targetname = menu.getOrderInfo(selectedcomponent, true)
				table.insert(rows.left, { entrytype = "text", text = name .. ((targetname ~= "") and (ReadText(1001, 120) .. " " .. targetname) or ""), properties = { halign = "center", color = menu.holomapcolor.playercolor } })
				-- failed orders
				local hasloop = ffi.new("bool[1]", 0)
				C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
				hasloop = hasloop[0]
				local n = C.GetNumOrderFailures(selectedcomponent, hasloop == true)
				if n > 0 then
					table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11621) .. ReadText(1001, 120), properties = { halign = "center", color = Helper.color.warningorange } })

					local buf = ffi.new("OrderFailure[?]", n)
					n = C.GetOrderFailures(buf, n, selectedcomponent, hasloop == true)
					local failure = buf[0]

					local orderdefid = ffi.string(failure.orderdef)
					local orderfailuredef
					local found = false
					for _, orderdef in ipairs(menu.orderdefs) do
						if orderdef.id == orderdefid then
							orderfailuredef = orderdef
							found = true
							break
						end
					end
					if not found then
						DebugError("Order failure of '" .. tostring(selectedcomponent) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
					end

					table.insert(rows.left, { entrytype = "text", text = orderfailuredef and orderfailuredef.name or "", properties = { halign = "center", color = Helper.color.warningorange } })
					table.insert(rows.left, { entrytype = "text", text = ffi.string(failure.message), properties = { halign = "center", color = Helper.color.warningorange } })
					if n > 2 then
						table.insert(rows.left, { entrytype = "text", text = string.format(ReadText(1001, 11631), n - 1), properties = { halign = "center", color = Helper.color.warningorange } })
					elseif n > 1 then
						table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11630), properties = { halign = "center", color = Helper.color.warningorange } })
					end
				else
					local failure = ffi.new("OrderFailure")
					if C.GetDefaultOrderFailure(failure, selectedcomponent) then
						table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11621) .. ReadText(1001, 120), properties = { halign = "center", color = Helper.color.warningorange } })

						local orderdefid = ffi.string(failure.orderdef)
						local orderfailuredef
						local found = false
						for _, orderdef in ipairs(menu.orderdefs) do
							if orderdef.id == orderdefid then
								orderfailuredef = orderdef
								found = true
								break
							end
						end
						if not found then
							DebugError("Default order failure of '" .. tostring(selectedcomponent) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
						end

						table.insert(rows.left, { entrytype = "text", text = orderfailuredef and orderfailuredef.name or "", properties = { halign = "center", color = Helper.color.warningorange } })
						table.insert(rows.left, { entrytype = "text", text = ffi.string(failure.message), properties = { halign = "center", color = Helper.color.warningorange } })
					end
				end

				-- capacity
				local numtransporttypes = C.GetNumCargoTransportTypes(selectedcomponent, true)
				local currenttransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(currenttransporttypes, numtransporttypes, selectedcomponent, true, false)
				local futuretransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(futuretransporttypes, numtransporttypes, selectedcomponent, true, true)
				for i = 0, numtransporttypes - 1 do
					table.insert(rows.right, { entrytype = "capacity", text = ReadText(1001, 1402) .. " (" .. ffi.string(futuretransporttypes[i].name) .. ")" .. ReadText(1001, 120), currentused = currenttransporttypes[i].spaceused, futureused = futuretransporttypes[i].spaceused, capacity = futuretransporttypes[i].capacity })
				end
				-- cargo
				local cargo = GetComponentData(selectedcomponent, "cargo")
				local futurecargo = GetCargoAfterTradeOrders(selectedcomponent, true)
				local wares = {}
				for ware, amount in pairs(cargo) do
					table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = amount, future = futurecargo[ware] or 0 })
				end
				for ware, amount in pairs(futurecargo) do
					if not cargo[ware] then
						table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = 0, future = amount })
					end
				end
				table.sort(wares, function (a, b) return a.future > b.future end)
				local setting, list = menu.getTradeWareFilter()
				for i, entry in ipairs(wares) do
					local color, script = menu.getWareButtonColorAndScript(list, setting, entry.ware)
					table.insert(rows.right, { entrytype = "ware", text = entry.name, current = entry.current, future = entry.future, max = GetWareCapacity(selectedcomponent, entry.ware), color = color, script = script })
				end
				-- display rows
				for i = 1, 5 do
					local row
					for _, side in ipairs(sideorder) do
						if rows[side][i] then
							local entry = rows[side][i]
							if not row then
								row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
							end
							if entry.entrytype == "text" then
								row[(side == "left") and 1 or 5]:setColSpan(3):createText(entry.text, entry.properties)
							elseif entry.entrytype == "capacity" then
								if side == "right" then
									row[5]:setColSpan(3)

									local mouseovertext
									local amounttext = menu.formatWareAmount(entry.currentused, entry.futureused, entry.capacity)
									local text = TruncateText(entry.text, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[5]:getWidth() - menu.getAmountTextWidth(amounttext))
									if text ~= entry.text then
										mouseovertext = entry.text .. " " .. amounttext
									end

									local xoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.futureused, start = entry.currentused, max = entry.capacity, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultFlowchartDiff2Color, negChangeColor = Helper.defaultFlowchartDiff1Color, markerColor = Helper.color.transparent, width = width, x = xoffset, scaling = false })
									row[5]:createIcon("solid", { color = { r = 0, g = 0, b = 0, a = 1 }, height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
									row[5]:setText(text)
									row[5]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
								end
							elseif entry.entrytype == "ware" then
								if side == "right" then
									row[5]:setColSpan(3)
									local xoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.future, start = entry.current, max = entry.max, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultFlowchartDiff2Color, negChangeColor = Helper.defaultFlowchartDiff1Color, markerColor = Helper.color.transparent, width = width, x = xoffset, scaling = false })
									row[5]:createButton({ bgColor = Helper.color.transparent, height = menu.selectedShipsTableData.textHeight })
									row[5]:setText(entry.text, { color = entry.color })
									row[5]:setText2(menu.formatWareAmount(entry.current, entry.future), { halign = "right", color = entry.color })
									row[5].handlers.onClick = entry.script
								end
							end
						end
					end
				end
				if #rows.right > 5 then
					local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
					row[5]:setColSpan(3):createText(string.format("%+d %s", #rows.right - 5, ((#rows.right - 5) > 1) and ReadText(1001, 46) or ReadText(1001, 45)))
				end
			elseif C.IsComponentClass(selectedcomponent, "station") then
				local row = ftable:addRow(nil, { fixed = true, borderBelow = false, bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(ReadText(1001, 3305), { halign = "center" })
				row[4]:createText("", { x = 0 })
				row[5]:setColSpan(3):createText(ReadText(1001, 63), { halign = "center" })
				-- line
				local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.white })
				row[1]:setColSpan(3):createText("", { height = 2 })
				row[4]:createText("", { height = 2, cellBGColor = Helper.color.transparent, x = 0 })
				row[5]:setColSpan(3):createText("", { height = 2 })

				local sideorder = { "left", "right" }
				local rows = {
					left = {},
					right = {},
				}
				-- upkeep missions
				local upkeepMissions = {}
				if menu.upkeepMissionData[tostring(selectedcomponent)] then
					for _, entry in ipairs(menu.upkeepMissionData[tostring(selectedcomponent)]) do
						table.insert(upkeepMissions, { alertLevel = entry.alertLevel, name = entry.name })
					end
				end
				table.sort(upkeepMissions, function (a, b) return a.alertLevel > b.alertLevel end)

				for i, entry in ipairs(upkeepMissions) do
					local color = Helper.color.white
					if entry.alertLevel == 1 then
						color = menu.holomapcolor.lowalertcolor
					elseif entry.alertLevel == 2 then
						color = menu.holomapcolor.mediumalertcolor
					else
						color = menu.holomapcolor.highalertcolor
					end
					table.insert(rows.left, { entrytype = "text", text = entry.name, properties = { halign = "center", color = color } })
				end

				-- ware reservations
				local reservationscapacity = menu.getReservationsVolumeByTransportType(selectedcomponent)
				local reservationscargo = menu.getReservationsAmountByWareType(selectedcomponent)

				-- capacity
				local numtransporttypes = C.GetNumCargoTransportTypes(selectedcomponent, true)
				local currenttransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(currenttransporttypes, numtransporttypes, selectedcomponent, true, false)
				
				for i = 0, numtransporttypes - 1 do
					local storagename = ffi.string(currenttransporttypes[i].name)
					local futureamount = currenttransporttypes[i].spaceused
					if reservationscapacity[string.lower(storagename)] then
						futureamount = futureamount + reservationscapacity[string.lower(storagename)]
					end

					table.insert(rows.right, { entrytype = "capacity", text = ReadText(1001, 1402) .. " (" .. storagename .. ")" .. ReadText(1001, 120), currentused = currenttransporttypes[i].spaceused, futureused = futureamount, capacity = currenttransporttypes[i].capacity })
				end
				-- cargo
				local cargo = GetComponentData(selectedcomponent, "cargo")
				local wares = {}
				for ware, amount in pairs(cargo) do
					local futureamount = amount
					if reservationscargo[ware] then
						futureamount = futureamount + reservationscargo[ware]
					end

					table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = amount, future = futureamount })
				end
				table.sort(wares, function (a, b) return a.future > b.future end)
				local setting, list = menu.getTradeWareFilter()
				for i, entry in ipairs(wares) do
					local color, script = menu.getWareButtonColorAndScript(list, setting, entry.ware)
					local productionlimit = GetWareProductionLimit(selectedcomponent, entry.ware)
					table.insert(rows.right, { entrytype = "ware", text = entry.name, current = entry.current, future = entry.future, max = math.max(entry.current, productionlimit), color = color, script = script })
				end
				-- display rows
				for i = 1, 5 do
					local row
					for _, side in ipairs(sideorder) do
						if rows[side][i] then
							local entry = rows[side][i]
							if not row then
								row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
							end
							if entry.entrytype == "text" then
								row[(side == "left") and 1 or 5]:setColSpan(3):createText(entry.text, entry.properties)
							elseif entry.entrytype == "capacity" then
								if side == "right" then
									row[5]:setColSpan(3)

									local mouseovertext
									local amounttext = menu.formatWareAmount(entry.currentused, entry.futureused, entry.capacity)
									local widthdelta = row[5]:getWidth() - menu.getAmountTextWidth(amounttext)
									local text = ""
									if widthdelta > 0 then
										text = TruncateText(entry.text, Helper.standardFont, menu.selectedShipsTableData.fontsize, widthdelta)
									end
									if text ~= entry.text then
										mouseovertext = entry.text .. " " .. amounttext
									end

									local xoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.futureused, start = entry.currentused, max = entry.capacity, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultFlowchartDiff2Color, negChangeColor = Helper.defaultFlowchartDiff1Color, markerColor = Helper.color.transparent, width = width, x = xoffset, scaling = false })
									row[5]:createIcon("solid", { color = { r = 0, g = 0, b = 0, a = 1 }, height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
									row[5]:setText(text)
									row[5]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
								end
							elseif entry.entrytype == "ware" then
								if side == "right" then
									row[5]:setColSpan(3)
									local barxoffset = 1 + Helper.borderSize
									local width = row[5]:getColSpanWidth()
									row[4]:createStatusBar({ current = entry.future, start = entry.current, max = entry.max, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultFlowchartDiff2Color, negChangeColor = Helper.defaultFlowchartDiff1Color, markerColor = Helper.color.transparent, width = width, x = barxoffset, scaling = false })
									row[5]:createButton({ bgColor = Helper.color.transparent, height = menu.selectedShipsTableData.textHeight })
									row[5]:setText(entry.text, { color = entry.color, x = Helper.standardIndentStep })
									row[5]:setText2(menu.formatWareAmount(entry.current, entry.future), { halign = "right", color = entry.color })
									row[5].handlers.onClick = entry.script
								end
							end
						end
					end
				end
				if (#rows.left > 5) or (#rows.right > 5) then
					local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
					if #rows.left > 5 then
						row[1]:setColSpan(3):createText(string.format("%+d %s", #rows.left - 5, ((#rows.left - 5) > 1) and ReadText(1001, 5702) or ReadText(1001, 5702)))
					end
					if #rows.right > 5 then
						row[5]:setColSpan(3):createText(string.format("%+d %s", #rows.right - 5, ((#rows.right - 5) > 1) and ReadText(1001, 46) or ReadText(1001, 45)))
					end
				end
			end
		end
	end

	ftable.properties.y = Helper.viewHeight - ftable:getFullHeight() - menu.borderOffset
end

function menu.sortShipsByClassAndPurpose(a, b)
	local aclass = config.classOrder[a.class] or 0
	local bclass = config.classOrder[b.class] or 0
	if aclass == bclass then
		local apurpose = (a.purpose ~= "") and config.purposeOrder[a.purpose] or 0
		local bpurpose = (b.purpose ~= "") and config.purposeOrder[b.purpose] or 0
		return apurpose < bpurpose
	else
		return aclass < bclass
	end
end

function menu.sortShipsByClassAndPurposeReverse(a, b)
	local apurpose = (a.purpose ~= "") and config.purposeOrder[a.purpose] or 0
	local bpurpose = (b.purpose ~= "") and config.purposeOrder[b.purpose] or 0
	if apurpose == bpurpose then
		local aclass = config.classOrder[a.class] or 0
		local bclass = config.classOrder[b.class] or 0
		return aclass < bclass
	else
		return apurpose > bpurpose
	end
end

function menu.findEntryByShipIcon(array, icon, color)
	for i, entry in ipairs(array) do
		if (entry.icon == icon) and (entry.color == color) then
			return i
		end
	end
end

function menu.createTopLevel(frame)
	if (menu.mode == "hire") or (menu.mode == "selectCV") or (menu.mode == "orderparam_object") or (menu.mode == "selectComponent") then
		local width = 400
		local ftable = frame:addTable(1, {
			tabOrder = 20,
			width = width,
			x = Helper.viewWidth / 2 - width / 2,
			y = Helper.topLevelConfig.y,
			scaling = false,
			reserveScrollBar = false,
			skipTabChange = true,
			backgroundID = "solid",
			backgroundColor = Helper.color.semitransparent,
		})
		local row = ftable:addRow(false, { fixed = true })

		local title = ""
		if menu.mode == "hire" then
			title = (menu.modeparam[3] ~= 0) and ReadText(1001, 3500) or ReadText(1001, 3264)
		elseif menu.mode == "selectCV" then
			title = ReadText(1001, 7942)
		elseif menu.mode == "orderparam_object" then
			local sectorallowed, onlysectorallowed = false, false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = true
							onlysectorallowed = #menu.modeparam[2].inputparams.class == 1
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end

			if onlysectorallowed then
				title = ReadText(1001, 11238)
			elseif sectorallowed then
				title = ReadText(1001, 11239)
			else
				title = ReadText(1001, 8325)
			end
		elseif menu.mode == "selectComponent" then
			title = menu.modeparam[5] or ReadText(1001, 8325)
		end

		row[1]:createText(title, Helper.titleTextProperties)
		row[1].properties.scaling = true

		local infotext
		if menu.mode == "hire" then
			infotext = function() return menu.selectModeInfoText(ReadText(1001, 11613)) end
		elseif menu.mode == "orderparam_object" then
			local sectorallowed = false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = true
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end
			infotext = function() return menu.selectModeInfoText(sectorallowed and ReadText(1001, 11635) or ReadText(1001, 11634)) end
		end

		if infotext then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(infotext, { wordwrap = true, scaling = true })
		end
	else
		menu.topLevelHeight = Helper.createTopLevelTab(menu, menu.showMultiverse and "multiversemap" or "map", frame, (menu.mode == "tradecontext") and ReadText(1001, 7104) or "", menu.conversationMenu, true)
	end
end

function menu.selectModeInfoText(text)
	local mode = GetControllerInfo()
	if (mode == "gamepad") or (mode == "joystick") then
		return string.format(text, ffi.string(C.GetMappedInputName("INPUT_STATE_CONTROLLERMOUSEBUTTON_RIGHT")))
	else
		return string.format(text, ReadText(1019, 3))
	end
end

function menu.onTabScroll(direction)
	if direction == "right" then
		Helper.scrollTopLevel(menu, menu.showMultiverse and "multiversemap" or "map", 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, menu.showMultiverse and "multiversemap" or "map", -1)
	end
end

function menu.onInputModeChanged(_, mode)
	if not menu.noupdate then
		menu.refreshMainFrame = true
	else
		menu.inputModeHasChanged = true
	end
end

function menu.createNewOrderContext(frame, instance)
	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local aipilot = GetComponentData(menu.infoSubmenuObject, "assignedaipilot")
	local adjustedskill = aipilot and math.floor(C.GetEntityCombinedSkill(ConvertIDTo64Bit(aipilot), nil, "aipilot")) or -1

	-- title
	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(menu.contextMenuData.default and ReadText(1001, 8321) or ReadText(1001, 3238), Helper.headerRowCenteredProperties)

	for category, orderdefs in Helper.orderedPairs(menu.orderdefsbycategory) do
		if category ~= "internal" then
			if (not menu.contextMenuData.default) or (category ~= "coordination") then
				local header = false
				for _, orderdef in ipairs(orderdefs) do
					if (menu.contextMenuData.default and orderdef.infinite) or ((not menu.contextMenuData.default) and ((not menu.infoTableData[instance].hasloop) or orderdef.loopable)) then
						if not header then
							local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
							row[1]:createText(orderdef.categoryname, Helper.headerRowCenteredProperties)
							header = true
						end
			
						local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						local button = row[1]:createButton({ active = C.IsOrderSelectableFor(orderdef.id, menu.infoSubmenuObject), bgColor = Helper.color.transparent, mouseOverText = orderdef.description }):setText(orderdef.name)
						if menu.contextMenuData.default then
							local printedSkillReq = math.floor(orderdef.requiredSkill * 15 / 100)
							button.properties.active = button.properties.active and (orderdef.requiredSkill <= adjustedskill)
							button:setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Helper.color.brightyellow })
						end
						row[1].handlers.onClick = function () return menu.buttonNewOrder(orderdef.id, menu.contextMenuData.default, instance) end
						row[1].properties.uiTriggerID = orderdef.name
					end
				end
			end
		end
	end

	if menu.contextMenuData.default then
		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11266), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		local button = row[1]:createButton({ bgColor = Helper.color.transparent, mouseOverText = ReadText(1026, 3269) }):setText(ReadText(1001,11267))
		if menu.contextMenuData.default then
			button.properties.active = button.properties.active and (math.floor(menu.orderloopskill * 100 / 15) <= adjustedskill)
			button:setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Helper.color.brightyellow })
		end
		row[1].handlers.onClick = function () return menu.buttonNewOrder("loop", menu.contextMenuData.default, instance) end
		row[1].properties.uiTriggerID = "looporders"
	end
end

function menu.createOrderparamWareContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	menu.contextMenuData.wares = {}
	
	if param.inputparams.mining then
		local sector = ConvertIDTo64Bit(param.inputparams.mining[1])
		local pos = param.inputparams.mining[2]
		local nummineables = C.GetNumMineablesAtSectorPos(sector, pos)
		local mineables = ffi.new("YieldInfo[?]", nummineables)
		nummineables = C.GetMineablesAtSectorPos(mineables, nummineables, sector, pos)
		for i = 0, nummineables - 1 do
			table.insert(menu.contextMenuData.wares, ffi.string(mineables[i].wareid))
		end
	elseif param.inputparams.cargoof then
		local buf = GetComponentData(param.inputparams.cargoof, "cargo")
		for ware in pairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	elseif param.inputparams.soldby then
		local buf = GetComponentData(param.inputparams.soldby, "products")
		for _, ware in ipairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	elseif param.inputparams.boughtby then
		local buf = GetComponentData(param.inputparams.boughtby, "allresources")
		for _, ware in ipairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	else 
		for name, ware in pairs(menu.economyWares) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	end
	if param.inputparams.cancarry then
		for i = #menu.contextMenuData.wares, 1, -1 do
			local ware = menu.contextMenuData.wares[i]
			if GetWareCapacity(param.inputparams.cancarry, ware, true) == 0 then
				table.remove(menu.contextMenuData.wares, i)
			end
		end
	end
	if param.inputparams.isminable then
		for i = #menu.contextMenuData.wares, 1, -1 do
			local ware = menu.contextMenuData.wares[i]
			if GetWareData(ware, "isminable") ~= (param.inputparams.isminable == 1) then
				table.remove(menu.contextMenuData.wares, i)
			end
		end
	end

	if (param.type == "list") then
		menu.contextMenuData.selectedWares = {}
		menu.contextMenuData.origSelectedWares = {}
		if param.value then
			for _, ware in ipairs(param.value) do
				menu.contextMenuData.selectedWares[ware] = true
				menu.contextMenuData.origSelectedWares[ware] = true
			end
		end
	end

	table.sort(menu.contextMenuData.wares, Helper.sortWareName)

	-- do this first so we still have a table row for the buttons before the list can use them all up
	local buttontable
	if param.type == "list" then
		if #menu.contextMenuData.wares > 0 then
			buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

			local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ active = function () return ((not param.required) or (next(menu.contextMenuData.selectedWares) ~= nil)) and menu.isWareSelectionChanged() end }):setText(ReadText(1001, 14), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, menu.contextMenuData.selectedWares, instance) end
			row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
			row[2].handlers.onClick = function () return menu.onCloseElement("back") end
		end
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	if param.type == "list" then
		-- title
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedWares) do count = count + 1 end; return #menu.contextMenuData.wares == count end, { height = config.mapRowHeight })
		row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleWareList(checked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 8376), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.wares > 0 then
			for _, ware in ipairs(menu.contextMenuData.wares) do
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedWares[ware] or false end, { height = config.mapRowHeight })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxSetWareList(ware, checked) end
				row[2]:setColSpan(2):createText(GetWareData(ware, "name"))
			end

			local waresheight = ftable:getFullHeight()
			local buttonheight = buttontable:getFullHeight()
			if frame.properties.y + ftable.properties.y + waresheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
				buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
				ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
			else
				buttontable.properties.y = ftable.properties.y + waresheight + Helper.borderSize
			end

			ftable:addConnection(1, 3, true)
			buttontable:addConnection(2, 3)
		else
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	else
		-- title
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(3):createText(ReadText(1001, 8306), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.wares > 0 then
			for _, ware in ipairs(menu.contextMenuData.wares) do
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createButton({ bgColor = Helper.color.transparent, height = config.mapRowHeight }):setText(GetWareData(ware, "name"))
				row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, ware, instance) end
			end
		else
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	end
end

function menu.isWareSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedWares) do
		if not menu.contextMenuData.origSelectedWares[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedWares) do
		if not menu.contextMenuData.selectedWares[ware] then
			return true
		end
	end
	return false
end

function menu.createOrderparamSectorContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	menu.contextMenuData.sectors = {}
	
	if param.inputparams.hasresources then
		local neededresources = {}
		for _, ware in ipairs(param.inputparams.hasresources) do
			neededresources[ware] = true
		end

		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				local sector64 = ConvertIDTo64Bit(sector)
				local resources = {}
				local n = C.GetNumDiscoveredSectorResources(sector64)
				local buf = ffi.new("WareYield[?]", n)
				n = C.GetDiscoveredSectorResources(buf, n, sector64)
				for i = 0, n - 1 do
					if neededresources[ffi.string(buf[i].ware)] then
						table.insert(menu.contextMenuData.sectors, sector64)
						break
					end
				end
			end
		end
	else 
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.sectors, ConvertIDTo64Bit(sector))
			end
		end
	end

	if (param.type == "list") then
		menu.contextMenuData.selectedSectors = {}
		menu.contextMenuData.origSelectedSectors = {}
		if param.value then
			for _, sector in ipairs(param.value) do
				menu.contextMenuData.selectedSectors[tostring(ConvertIDTo64Bit(sector))] = true
				menu.contextMenuData.origSelectedSectors[tostring(ConvertIDTo64Bit(sector))] = true
			end
		end
	end

	table.sort(menu.contextMenuData.sectors, Helper.sortComponentName)

	if param.type == "list" then
		-- title
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedSectors) do count = count + 1 end; return #menu.contextMenuData.sectors == count end, { height = config.mapRowHeight })
		row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleSectorList(checked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 9177), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.sectors > 0 then
			for _, sector in ipairs(menu.contextMenuData.sectors) do
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedSectors[tostring(sector)] or false end, { height = config.mapRowHeight })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxSetSectorList(sector, checked) end
				row[2]:setColSpan(2):createText(GetComponentData(sector, "name"))
			end

			local buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

			local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ active = function () return ((not param.required) or (next(menu.contextMenuData.selectedSectors) ~= nil)) and menu.isSectorSelectionChanged() end }):setText(ReadText(1001, 14), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, menu.contextMenuData.selectedSectors, instance) end
			row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
			row[2].handlers.onClick = function () return menu.onCloseElement("back") end

			local sectorsheight = ftable:getFullHeight()
			local buttonheight = buttontable:getFullHeight()
			if frame.properties.y + ftable.properties.y + sectorsheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
				buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
				ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
			else
				buttontable.properties.y = ftable.properties.y + sectorsheight + Helper.borderSize
			end

			ftable:addConnection(1, 3, true)
			buttontable:addConnection(2, 3)
		else
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	else
		-- title
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(3):createText(ReadText(1001, 11238), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.sectors > 0 then
			for _, sector in ipairs(menu.contextMenuData.sectors) do
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createButton({ bgColor = Helper.color.transparent, height = config.mapRowHeight }):setText(GetComponentData(sector, "name"))
				row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, sector, instance) end
			end
		else
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	end
end

function menu.isSectorSelectionChanged()
	for sector in pairs(menu.contextMenuData.selectedSectors) do
		if not menu.contextMenuData.origSelectedSectors[sector] then
			return true
		end
	end
	for sector in pairs(menu.contextMenuData.origSelectedSectors) do
		if not menu.contextMenuData.selectedSectors[sector] then
			return true
		end
	end
	return false
end

function menu.createFilterparamWareContext(frame)
	local buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

	local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = menu.isWareSelectionChanged }):setText(ReadText(1001, 14), { halign = "center" })
	row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, menu.contextMenuData.setting, menu.contextMenuData.setting.id, menu.contextMenuData.selectedWares) end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.onCloseElement("back") end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	menu.contextMenuData.wares = menu.contextMenuData.setting.listOptions()
	menu.contextMenuData.selectedWares = {}
	menu.contextMenuData.origSelectedWares = {}
	local list = menu.getFilterOption(menu.contextMenuData.setting.id) or {}
	for _, ware in ipairs(list) do
		menu.contextMenuData.selectedWares[ware] = true
		menu.contextMenuData.origSelectedWares[ware] = true
	end
	table.sort(menu.contextMenuData.wares, Helper.sortWareName)

	-- title
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedWares) do count = count + 1 end; return #menu.contextMenuData.wares == count end, { height = config.mapRowHeight })
	row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleWareList(checked) end
	row[2]:setColSpan(2):createText(ReadText(1001, 8376), Helper.headerRowCenteredProperties)

	if #menu.contextMenuData.wares > 0 then
		for _, ware in ipairs(menu.contextMenuData.wares) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(function () return menu.contextMenuData.selectedWares[ware] or false end, { height = config.mapRowHeight })
			row[1].handlers.onClick = function (_, checked) return menu.checkboxSetWareList(ware, checked) end
			row[2]:setColSpan(2):createText(GetWareData(ware, "name"))
		end
	else
		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
	end

	local waresheight = ftable:getFullHeight()
	local buttonheight = buttontable:getFullHeight()
	if frame.properties.y + ftable.properties.y + waresheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
		buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
		ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
	else
		buttontable.properties.y = ftable.properties.y + waresheight + Helper.borderSize
	end

	ftable:addConnection(1, 3, true)
	buttontable:addConnection(2, 3)
end

function menu.createOrderparamFormationShapeContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 8307), Helper.headerRowCenteredProperties)

	menu.contextMenuData.formationshapes = {}
	local n = C.GetNumFormationShapes()
	local buf = ffi.new("UIFormationInfo[?]", n)
	n = C.GetFormationShapes(buf, n)
	for i = 0, n - 1 do
		table.insert(menu.contextMenuData.formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape) })
	end

	table.sort(menu.contextMenuData.formationshapes, Helper.sortName)

	for _, formation in ipairs(menu.contextMenuData.formationshapes) do
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:createButton({ bgColor = Helper.color.transparent }):setText(formation.name)
		row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, formation.shape, instance) end
	end
end

function menu.defaultInteraction(component, posrot, posrotvalid, offsetx, offsety)
	local occupiedship = C.GetPlayerOccupiedShipID()
	if C.IsComponentClass(component, "sector") then
		local playerprecise = (#menu.selectedcomponents == 1)
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			if (selectedcomponent ~= occupiedship) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
				if GetComponentData(selectedcomponent, "isplayerowned") then
					menu.orderMoveWait(selectedcomponent, component, posrot, playerprecise, false)
				end
			end
		end
	elseif GetComponentData(ConvertStringToLuaID(tostring(component)), "isenemy") then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			if (selectedcomponent ~= occupiedship) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["Attack"].loopable) then
				if GetComponentData(selectedcomponent, "isplayerowned") then
					menu.orderAttack(selectedcomponent, component, false)
				end
			end
		end
	elseif C.IsComponentClass(component, "station") then
		local issingleloopship
		if menu.getNumSelectedComponents() == 1 then
			local component = next(menu.selectedcomponents)
			local selectedcomponent = ConvertStringTo64Bit(component)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			issingleloopship = hasloop[0]
		end

		if not issingleloopship then
			menu.contextMenuMode = "trade"
			menu.contextMenuData = { component = ConvertStringTo64Bit(tostring(component)), orders = {} }

			local numwarerows, numinforows = menu.initTradeContextData()
			menu.updateTradeContextDimensions(numwarerows, numinforows)

			local width = menu.tradeContext.width
			local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize

			if offsetx + width > Helper.viewWidth - Helper.frameBorder then
				offsetx = Helper.viewWidth - width - Helper.frameBorder
			end
			if offsety + height > Helper.viewHeight - Helper.frameBorder then
				offsety = Helper.viewHeight - height - Helper.frameBorder
			end
			menu.createContextFrame(width, height, offsetx, offsety)
		end
	end
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.getTransportTagsFromString(s)
	local types = {}
	while string.len(s) > 0 do
		local pos = string.find(s, " ", 1, true)
		if not pos then
			types[s] = true
			break
		elseif pos > 1 then
			types[string.sub(s, 1, pos - 1)] = true
		end
		s = string.sub(s, pos + 1)
	end
	return types
end

function menu.getCargoTransportTypes(container, aftertradeorders)
	local transporttypes = { }
	local n = C.GetNumCargoTransportTypes(container, true)
	local buf = ffi.new("StorageInfo[?]", n)
	n = C.GetCargoTransportTypes(buf, n, container, true, aftertradeorders)

	-- Fill transporttypes list
	for i = 0, n - 1 do
		local tags = menu.getTransportTagsFromString(ffi.string(buf[i].transport))
		local name
		if tags.container and tags.solid and tags.liquid then -- no not add Condensate Storage!
			name = ReadText(20109, 801)		-- Universal Storage
		elseif tags.container then
			name = ReadText(20109, 101)		-- Container Storage
		elseif tags.solid then
			name = ReadText(20109, 301)		-- Solid Storage
		elseif tags.liquid then
			name = ReadText(20109, 601)		-- Liquid Storage
		elseif tags.condensate then
			name = ReadText(20109, 9801)	-- Condensate Storage
		else
			name = ffi.string(buf[i].name)	-- Should never happen
		end
		table.insert(transporttypes, { name = name, tags = tags, initialstored = 0, stored = 0, capacity = buf[i].capacity })
	end
	-- Sort transport types (first container, then solid, then liquid, then condensate, then universal, then anything else)
	-- NOTE: Universal storage isn't supposed to be mixed with container, solid, liquid or condensate storage, but if it is, then the order is important,
	-- so that the storage visualisation doesn't break completely (fill container/solid/liquid/condensate storage instead of universal storage)
	table.sort(transporttypes,
		function (a, b)
			if a.tags.condensate ~= b.tags.condensate then
				return not a.tags.condensate
			elseif a.tags.liquid ~= b.tags.liquid then
				return not a.tags.liquid
			elseif a.tags.solid ~= b.tags.solid then
				return not a.tags.solid
			elseif a.tags.container ~= b.tags.container then
				return not a.tags.container
			else
				return a.name < b.name
			end
		end)

	-- initialize initialstored
	menu.getTradeContextInitialStorageData(container, transporttypes, aftertradeorders)

	return transporttypes
end

function menu.initTradeContextData()
	local convertedTradeOfferContainer = ConvertStringToLuaID(tostring(menu.contextMenuData.component))

	-- Ships
	local occupiedship = C.GetPlayerOccupiedShipID()
	menu.contextMenuData.isoccupiedshipdocked = false
	if occupiedship ~= 0 then
		menu.contextMenuData.isoccupiedshipdocked = C.GetCommonContext(occupiedship, menu.contextMenuData.component, true, true, C.GetContextByClass(occupiedship, "zone", false), false) ~= 0
	end
	menu.contextMenuData.ships = menu.getShipList(menu.contextMenuData.isoccupiedshipdocked, false)
	for i, ship in ipairs(menu.contextMenuData.ships) do
		if ConvertIDTo64Bit(ship.shipid) == menu.contextMenuData.component then
			table.remove(menu.contextMenuData.ships, i)
			break
		end
	end
	local convertedCurrentShip
	if not menu.contextMenuData.currentShip then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if menu.contextMenuData.isoccupiedshipdocked or (selectedcomponent ~= occupiedship) then
				local isplayerowned, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isdeployable")
				if isplayerowned and C.IsComponentClass(selectedcomponent, "ship") and (not isdeployable) then
					menu.contextMenuData.currentShip = selectedcomponent
					convertedCurrentShip = ConvertStringToLuaID(id)
					break
				end
			end
		end
		if not menu.contextMenuData.currentShip then
			if #menu.contextMenuData.ships > 0 then
				if menu.contextMenuData.isoccupiedshipdocked then
					for _, ship in ipairs(menu.contextMenuData.ships) do
						if ConvertIDTo64Bit(ship.shipid) == occupiedship then
							menu.contextMenuData.currentShip = ConvertIDTo64Bit(ship.shipid)
							convertedCurrentShip = ship.shipid
							break
						end
					end
				end
				if not menu.contextMenuData.currentShip then
					menu.contextMenuData.currentShip = ConvertIDTo64Bit(menu.contextMenuData.ships[1].shipid)
					convertedCurrentShip = menu.contextMenuData.ships[1].shipid
				end
			else
				menu.contextMenuData.currentShip = 0
				convertedCurrentShip = nil
			end
		end
	else
		convertedCurrentShip = ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip))
	end

	local currentship64 = ConvertIDTo64Bit(convertedCurrentShip)
	local iscurrentshipdocked = currentship64 and C.GetCommonContext(currentship64, menu.contextMenuData.component, true, true, C.GetContextByClass(currentship64, "zone", false), false) ~= 0
	menu.contextMenuData.immediate = false
	if menu.contextMenuData.isoccupiedshipdocked and (menu.contextMenuData.currentShip == occupiedship) then
		-- occupied ship wants to trade with tradeoffercontainer, use trade computer
		menu.contextMenuData.immediate = true
		menu.contextMenuData.immediateObject = menu.contextMenuData.currentShip
	elseif iscurrentshipdocked then
		if not GetComponentData(convertedCurrentShip, "aipilot") then
			-- current ship has common context with tradeoffercontainer and no ai pilot, use trade computer
			menu.contextMenuData.immediate = true
			menu.contextMenuData.immediateObject = menu.contextMenuData.currentShip
		elseif C.IsComponentClass(menu.contextMenuData.component, "ship") and (not GetComponentData(convertedTradeOfferContainer, "aipilot")) then
			-- current ship has common context with tradeoffercontainer and the tradeoffercontainer is a ship and has no ai pilot, use trade computer on that ship
			menu.contextMenuData.immediate = true
			menu.contextMenuData.immediateObject = menu.contextMenuData.component
		end
	end
	menu.contextMenuData.playerMoney = GetPlayerMoney()

	-- virtual cargo mode
	if convertedCurrentShip then
		local numtradecomputertrades = tonumber(C.GetNumTradeComputerOrders(menu.contextMenuData.currentShip))
		SetVirtualCargoMode(convertedCurrentShip, true, menu.contextMenuData.immediate and numtradecomputertrades or -1)
	end
	if menu.contextMenuData.wareexchange then
		if C.IsComponentOperational(menu.contextMenuData.component) then
			SetVirtualCargoMode(convertedTradeOfferContainer, true, -1)
			menu.contextMenuData.currentothercargo = GetCargoAfterTradeOrders(convertedTradeOfferContainer)
			menu.contextMenuData.currentotherammo = GetAmmoCountAfterTradeOrders(convertedTradeOfferContainer)
		end
	end

	menu.contextMenuData.currentcargo = convertedCurrentShip and GetCargoAfterTradeOrders(convertedCurrentShip) or {}
	menu.contextMenuData.currentammo = convertedCurrentShip and GetAmmoCountAfterTradeOrders(convertedCurrentShip) or {}

	-- Trade offers
	menu.contextMenuData.buyoffers = {}
	menu.contextMenuData.selloffers = {}
	menu.contextMenuData.missionoffers = {}
	menu.contextMenuData.buywares = {}
	menu.contextMenuData.sellwares = {}
	menu.contextMenuData.missionwares = {}
	menu.contextMenuData.buyammowares = {}
	menu.contextMenuData.sellammowares = {}
	menu.contextMenuData.missionoffersbyid = {}

	local tradeoffers, nontradeoffers = {}, {}
	if menu.contextMenuData.wareexchange then
		tradeoffers = GetWareExchangeTradeList(convertedCurrentShip, convertedTradeOfferContainer)
		-- Mark any equipment wares as such (only relevant for ware exchange)
		for _, tradedata in pairs(tradeoffers) do
			if tradedata.ware then
				tradedata.ammotypename = menu.getAmmoTypeNameByWare(tradedata.ware)
			end
		end
	else
		tradeoffers = GetTradeList(convertedTradeOfferContainer, convertedCurrentShip)
		nontradeoffers = GetTradeList(convertedTradeOfferContainer, convertedCurrentShip, false)
	end
	for _, tradedata in pairs(tradeoffers) do
		if tradedata.ware and ((not menu.contextMenuData.shadyOnly) or tradedata.isshady) then
			local currentwares = tradedata.ammotypename and menu.contextMenuData.currentammo or menu.contextMenuData.currentcargo
			local currentotherwares = tradedata.ammotypename and menu.contextMenuData.currentotherammo or menu.contextMenuData.currentothercargo	-- may be nil
			local buywares = tradedata.ammotypename and menu.contextMenuData.buyammowares or menu.contextMenuData.buywares
			local sellwares = tradedata.ammotypename and menu.contextMenuData.sellammowares or menu.contextMenuData.sellwares

			if tradedata.isbuyoffer then
				tradedata.active = convertedCurrentShip and currentwares[tradedata.ware] and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
				if tradedata.ismissionoffer then
					table.insert(menu.contextMenuData.missionoffers, tradedata)
					menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
					if menu.contextMenuData.missionwares[tradedata.ware] then
						table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
					else
						menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
					end
				else
					table.insert(menu.contextMenuData.buyoffers, tradedata)
					buywares[tradedata.ware] = tradedata
				end
				if tradedata.active and currentotherwares then
					currentotherwares[tradedata.ware] = currentotherwares[tradedata.ware] or 0
				end 
			elseif tradedata.isselloffer then
				tradedata.active = convertedCurrentShip and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
				if tradedata.ismissionoffer then
					table.insert(menu.contextMenuData.missionoffers, tradedata)
					menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
					if menu.contextMenuData.missionwares[tradedata.ware] then
						table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
					else
						menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
					end
				else
					table.insert(menu.contextMenuData.selloffers, tradedata)
					sellwares[tradedata.ware] = tradedata
				end
				if tradedata.active then
					currentwares[tradedata.ware] = currentwares[tradedata.ware] or 0
				end
			end
		end
	end
	for _, tradedata in pairs(nontradeoffers) do
		if tradedata.ware and ((not menu.contextMenuData.shadyOnly) or tradedata.isshady) then
			local currentwares = tradedata.ammotypename and menu.contextMenuData.currentammo or menu.contextMenuData.currentcargo
			local currentotherwares = tradedata.ammotypename and menu.contextMenuData.currentotherammo or menu.contextMenuData.currentothercargo	-- may be nil
			local buywares = tradedata.ammotypename and menu.contextMenuData.buyammowares or menu.contextMenuData.buywares
			local sellwares = tradedata.ammotypename and menu.contextMenuData.sellammowares or menu.contextMenuData.sellwares

			if tradedata.isbuyoffer then
				if tradedata.ismissionoffer then
					if not menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] then
						tradedata.active = convertedCurrentShip and currentwares[tradedata.ware] and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
						table.insert(menu.contextMenuData.missionoffers, tradedata)
						menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
						if menu.contextMenuData.missionwares[tradedata.ware] then
							table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
						else
							menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
						end
						if tradedata.active and currentotherwares then
							currentotherwares[tradedata.ware] = currentotherwares[tradedata.ware] or 0
						end
					end
				elseif not buywares[tradedata.ware] then
					tradedata.active = false
					tradedata.stale = true
					table.insert(menu.contextMenuData.buyoffers, tradedata)
					buywares[tradedata.ware] = tradedata
				end
			elseif tradedata.isselloffer then
				if tradedata.ismissionoffer then
					if not menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] then
						tradedata.active = convertedCurrentShip and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
						table.insert(menu.contextMenuData.missionoffers, tradedata)
						menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
						if menu.contextMenuData.missionwares[tradedata.ware] then
							table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
						else
							menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
						end
						if tradedata.active then
							currentwares[tradedata.ware] = currentwares[tradedata.ware] or 0
						end
					end
				elseif not sellwares[tradedata.ware] then
					tradedata.active = false
					tradedata.stale = true
					table.insert(menu.contextMenuData.selloffers, tradedata)
					sellwares[tradedata.ware] = tradedata
				end
			end
		end
	end

	-- Distribute cargo to transport type capacities
	menu.contextMenuData.transporttypes = (menu.contextMenuData.currentShip ~= 0) and menu.getCargoTransportTypes(menu.contextMenuData.currentShip, true) or {}
	menu.contextMenuData.othershiptransporttypes = (menu.contextMenuData.wareexchange and menu.contextMenuData.component ~= 0) and menu.getCargoTransportTypes(menu.contextMenuData.component, true) or {}

	menu.contextMenuData.ammotypes = { }
	if menu.contextMenuData.wareexchange and menu.contextMenuData.component ~= 0 then
		-- ammo is only relevant and visible in ware exchange case
		local missilecapacity1, countermeasurecapacity1, deployablecapacity1 = GetComponentData(convertedCurrentShip, "missilecapacity", "countermeasurecapacity", "deployablecapacity")
		local missilecapacity2, countermeasurecapacity2, deployablecapacity2 = GetComponentData(convertedTradeOfferContainer, "missilecapacity", "countermeasurecapacity", "deployablecapacity")
		local unitcapacity1 = GetUnitStorageData(convertedCurrentShip).capacity
		local unitcapacity2 = GetUnitStorageData(convertedTradeOfferContainer).capacity
		-- missiles
		if missilecapacity1 > 0 or missilecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 1304), type = "missile", stored = 0, otherstored = 0, capacity = missilecapacity1, othercapacity = missilecapacity2 })
		end
		-- countermeasures
		if countermeasurecapacity1 > 0 or countermeasurecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8063), type = "countermeasure", stored = 0, otherstored = 0, capacity = countermeasurecapacity1, othercapacity = countermeasurecapacity2 })
		end
		-- units
		if unitcapacity1 > 0 or unitcapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8), type = "unit", stored = 0, otherstored = 0, capacity = unitcapacity1, othercapacity = unitcapacity2 })
		end
		-- units
		if deployablecapacity1 > 0 or deployablecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8064), type = "deployable", stored = 0, otherstored = 0, capacity = deployablecapacity1, othercapacity = deployablecapacity2 })
		end
	end

	-- cost
	menu.contextMenuData.totalbuyprofit = 0
	menu.contextMenuData.totalsellcost = 0
	menu.contextMenuData.referenceprofit = 0

	-- Merge selloffers and buyoffers into waredatalist
	local waredatatable = {}
	local waredatalist = {}
	for _, tradedata in ipairs(menu.contextMenuData.selloffers) do
		if not menu.contextMenuData.wareexchange then
			AddKnownItem("wares", tradedata.ware)
		end
		local waredata = { ware = tradedata.ware, active = tradedata.active, sell = tradedata, stale = tradedata.stale }
		waredatatable[tradedata.ware] = waredata
		table.insert(waredatalist, waredata)
	end
	for _, tradedata in ipairs(menu.contextMenuData.buyoffers) do
		local waredata = waredatatable[tradedata.ware]
		if not waredata then
			if not menu.contextMenuData.wareexchange then
				AddKnownItem("wares", tradedata.ware)
			end
			waredata = { ware = tradedata.ware, stale = tradedata.stale }
			waredatatable[tradedata.ware] = waredata
			table.insert(waredatalist, waredata)
		end
		waredata.buy = tradedata
		waredata.active = waredata.active or tradedata.active
		waredata.stale = waredata.stale and tradedata.stale
	end
	for _, tradedata in ipairs(menu.contextMenuData.missionoffers) do
		if not menu.contextMenuData.wareexchange then
			AddKnownItem("wares", tradedata.ware)
		end
		local waredata = { ware = tradedata.ware, active = tradedata.active, mission = ConvertIDTo64Bit(tradedata.mission), stale = tradedata.stale }
		if tradedata.isbuyoffer then
			waredata.buy = tradedata
		else
			waredata.sell = tradedata
		end
		table.insert(waredatalist, waredata)
	end
	-- Sort wares: First by cargo/ammo type, then active before inactive, then sorted by name
	table.sort(waredatalist,
		function (a, b)
			local aidx, bidx = menu.getAmmoDataIdxByWare(a.ware), menu.getAmmoDataIdxByWare(b.ware)
			if aidx ~= bidx then
				return aidx < bidx
			elseif (not a.active) ~= (not b.active) then
				return not b.active
			else
				return Helper.sortWareName(a.ware, b.ware)
			end
		end)

	-- Store waredatalist so we always know how many lines there are in the shiptable
	menu.contextMenuData.waredatalist = waredatalist

	-- If no wares, there is still a line displayed ("No known offers" / "No wares")
	local numwarerows = math.max(1, #menu.contextMenuData.waredatalist)
	local numinforows = math.max(#menu.contextMenuData.transporttypes, #menu.contextMenuData.othershiptransporttypes) + #menu.contextMenuData.ammotypes
	if not menu.contextMenuData.wareexchange and numinforows < 2 then
		numinforows = 2			-- reserve space for "Profits from sales" and "Transaction value"
	end
	return numwarerows, numinforows
end

function menu.sortByActiveAndName(a, b)
	if a.active == b.active then 
		return Helper.sortName(a, b)
	end
	return a.active
end

function menu.sortByActiveAndWareName(a, b)
	if a.active == b.active then 
		return GetWareData(a.ware, "name") < GetWareData(b.ware, "name")
	end
	return a.active
end

function menu.getAmmoTypeNameByWare(ware)
	local transport, macro = GetWareData(ware, "transport", "component")
	if transport == "equipment" and macro ~= "" then
		if IsMacroClass(macro, "missile") then
			return "missile"
		elseif IsMacroClass(macro, "countermeasure") then
			return "countermeasure"
		elseif GetMacroData(macro, "isunit") then
			return "unit"
		elseif GetMacroData(macro, "isdeployable") then
			return "deployable"
		end
	end
	return nil
end

function menu.getAmmoDataIdxByWare(ware)
	local ammotypename = menu.getAmmoTypeNameByWare(ware)
	if ammotypename then
		for idx, equipmentdata in ipairs(menu.contextMenuData.ammotypes) do
			if equipmentdata.type == ammotypename then
				return idx
			end
		end
	end
	return 0
end

function menu.getAmmoDataByWare(ware)
	local idx = menu.getAmmoDataIdxByWare(ware)
	if idx > 0 then
		return menu.contextMenuData.ammotypes[idx]
	end
	return nil
end

function menu.updateTradeCost()
	local convertedCurrentShip = ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip))
	local convertedTradeOfferContainer = ConvertStringToLuaID(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer = GetComponentData(convertedTradeOfferContainer, "isplayerowned")

	for _, transporttype in ipairs(menu.contextMenuData.transporttypes) do
		transporttype.stored = 0
	end
	for ware, amount in pairs(menu.contextMenuData.currentcargo) do
		local transport, volume = GetWareData(ware, "transport", "volume")
		for _, transporttype in ipairs(menu.contextMenuData.transporttypes) do
			if transporttype.tags[transport] then
				local orderamount = menu.getCargoOrderAmountByWare(ware)
				transporttype.stored = transporttype.stored + (amount - orderamount) * volume
				break
			end
		end
	end

	for _, ammotype in ipairs(menu.contextMenuData.ammotypes) do
		ammotype.stored = 0
		ammotype.otherstored = 0
	end
	for ware, amount in pairs(menu.contextMenuData.currentammo) do
		local ammotype = menu.getAmmoDataByWare(ware)
		if ammotype then
			ammotype.stored = ammotype.stored + amount - menu.getAmmoOrderAmountByWare(ware)
		end
	end

	if menu.contextMenuData.wareexchange then
		for _, transporttype in ipairs(menu.contextMenuData.othershiptransporttypes) do
			transporttype.stored = transporttype.initialstored
		end
		for ware, amount in pairs(menu.contextMenuData.currentothercargo) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			-- below is done to handle trade partners that have more than one storage module type with a particular storage type (ex: solid and universal)
			local leftover = 0
			local orderamount = menu.getCargoOrderAmountByWare(ware)
			if orderamount ~= 0 then
				for _, transporttype in ipairs(menu.contextMenuData.othershiptransporttypes) do
					--print("init stored: " .. tostring(transporttype.stored))
					if transporttype.tags[transport] then
						local volumechange = orderamount * volume
						if leftover > 0 then
							volumechange = leftover * volume
							--print("1.1 ware: " .. tostring(ware) .. ", volumechange: " .. tostring(volumechange) .. ", transporttype.capacity: " .. tostring(transporttype.capacity))
						end

						--print(tostring(_) .. ": 2.0 ware: " .. tostring(ware) .. ", orderamount: " .. tostring(orderamount) .. ", volumechange: " .. tostring(volumechange) .. ", transporttype.capacity: " .. tostring(transporttype.capacity))
						if (transporttype.stored + volumechange) > transporttype.capacity then
							local evalamount = orderamount
							local evalvolume = transporttype.stored + volumechange
							while evalvolume > transporttype.capacity do
								evalamount = evalamount - 1
								evalvolume = transporttype.stored + evalamount * volume
							end
							transporttype.stored = evalvolume
							leftover = orderamount - evalamount
							--print("2.1 ware: " .. tostring(ware) .. ", leftover volume: " .. tostring(leftover * volume))
						else
							leftover = 0
							transporttype.stored = transporttype.stored + volumechange
							--print("2.2 ware: " .. tostring(ware) .. ", total stored: " .. tostring(transporttype.stored) .. ", capacity: " .. tostring(transporttype.capacity))
							break
						end
					end
				end
			end
		end
		for ware, amount in pairs(menu.contextMenuData.currentotherammo) do
			local ammotype = menu.getAmmoDataByWare(ware)
			if ammotype then
				ammotype.otherstored = ammotype.otherstored + amount + menu.getAmmoOrderAmountByWare(ware)
			end
		end
	end

	menu.contextMenuData.totalbuyprofit = 0
	menu.contextMenuData.totalsellcost = 0
	menu.contextMenuData.referenceprofit = 0
	if not isplayertradeoffercontainer then
		for id, amount in pairs(menu.contextMenuData.orders) do
			local tradeoffer = menu.getTradeOfferByID(ConvertStringToLuaID(tostring(id)))
			local price = tradeoffer and tradeoffer.price or 0
			if amount < 0 then
				-- station sells
				menu.contextMenuData.totalsellcost = menu.contextMenuData.totalsellcost + RoundTotalTradePrice(price * -amount)
			elseif amount > 0 then
				-- station buys
				menu.contextMenuData.totalbuyprofit = menu.contextMenuData.totalbuyprofit + RoundTotalTradePrice(price * amount)
			end
			if price ~= 0 and amount ~= 0 then
				local defaultrefprofit = GetReferenceProfit(convertedCurrentShip, tradeoffer.ware, price, 0) or 0
				local newrefprofit = GetReferenceProfit(convertedCurrentShip, tradeoffer.ware, price, amount) or 0
				menu.contextMenuData.referenceprofit = menu.contextMenuData.referenceprofit + newrefprofit - defaultrefprofit
			end
		end
	end
end

function menu.getCargoOrderAmountByWare(ware)
	local result = 0
	local buyoffer = menu.contextMenuData.buywares[ware]
	if buyoffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(buyoffer.id)] or 0)
	end
	local selloffer = menu.contextMenuData.sellwares[ware]
	if selloffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(selloffer.id)] or 0)
	end
	local missionoffers = menu.contextMenuData.missionwares[ware]
	if missionoffers then
		for _, missionoffer in ipairs(missionoffers) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(missionoffer.id)] or 0)
		end
	end
	return result
end

function menu.getAmmoOrderAmountByWare(ware)
	local result = 0
	local buyoffer = menu.contextMenuData.buyammowares[ware]
	if buyoffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(buyoffer.id)] or 0)
	end
	local selloffer = menu.contextMenuData.sellammowares[ware]
	if selloffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(selloffer.id)] or 0)
	end
	return result
end

function menu.getTradeOfferByID(id)
	for _, tradedata in ipairs(menu.contextMenuData.buyoffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end
	for _, tradedata in ipairs(menu.contextMenuData.selloffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end
	for _, tradedata in ipairs(menu.contextMenuData.missionoffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end

	return nil
end

function menu.getTradeContextStorableAmountAfterTradeOrders(ship, ware, ammotypename)
	if ammotypename == "missile" then
		return C.GetFreeMissileStorageAfterTradeOrders(ship)
	elseif ammotypename == "countermeasure" then
		return C.GetFreeCountermeasureStorageAfterTradeOrders(ship)
	elseif ammotypename == "unit" then
		return GetFreeUnitStorageAfterTradeOrders(ConvertStringToLuaID(tostring(ship)))
	elseif ammotypename == "deployable" then
		return C.GetFreeDeployableStorageAfterTradeOrders(ship)
	end
	return GetFreeCargoAfterTradeOrders(ConvertStringToLuaID(tostring(ship)), ware)
end

function menu.getTradeContextRowContent(waredata)
	local convertedCurrentShip = ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip))
	local nonVirtualShipCargo = {}
	if menu.contextMenuData.currentShip ~= 0 then
		nonVirtualShipCargo = GetComponentData(convertedCurrentShip, "cargo")
	end
	local convertedTradeOfferContainer = ConvertStringTo64Bit(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer, hastradesubscription = GetComponentData(convertedTradeOfferContainer, "isplayerowned", "tradesubscription")
	local name = GetWareData(waredata.ware, "name")
	local activecolor = (waredata.active and Helper.color.white or Helper.color.grey)
	local color = activecolor
	local mouseovertext = ""

	if waredata.mission then
		name = Helper.convertColorToText(Helper.color.mission) .. "\027[menu_mission_trade]\027X" .. name
		local mission = menu.getMissionIDInfoHelper(waredata.mission)
		mouseovertext = Helper.convertColorToText(Helper.color.mission) .. mission.name .. "\027X"
	end

	local numillegalfactions = C.GetNumIllegalToFactions(waredata.ware)
	local buf = ffi.new("const char*[?]", numillegalfactions)
	numillegalfactions = C.GetIllegalToFactions(buf, numillegalfactions, waredata.ware)
	if numillegalfactions > 0 then
		name = "\027[workshop_error]" .. name
		color = waredata.active and Helper.color.illegal or Helper.color.illegaldark
		local mouseovertextcolor = Helper.color.illegal
		if mouseovertext ~= "" then
			mouseovertext = mouseovertext .. "\n"
		end
		mouseovertext = mouseovertext .. Helper.convertColorToText(mouseovertextcolor) .. ReadText(1001, 2437) .. ReadText(1001, 120)
		for i = 0, numillegalfactions - 1 do
			mouseovertext = mouseovertext .. "\n" .. GetFactionData(ffi.string(buf[i]), "name")
		end
	end

	local warnings, optionalsellwarnings, optionalbuywarnings = {}, {}, {}
	local pricemodifiers = {}
	local hassellamount, hasbuyamount = false, false

	local selloffer_max, selloffer_maxselect, selloffer_curorder = 0, 0, 0
	if waredata.sell then
		if waredata.sell.amount > 0 then
			hassellamount = true
		end
		selloffer_curorder = math.min(0, menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.sell.id)] or 0)
		local affordableamount = isplayertradeoffercontainer and waredata.sell.amount or GetNumAffordableTradeItems(GetPlayerMoney() - menu.contextMenuData.totalsellcost + RoundTotalTradePrice(-(menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.sell.id)] or 0) * waredata.sell.price), waredata.sell.price)
		local storableamount = (menu.contextMenuData.currentShip ~= 0) and menu.getTradeContextStorableAmountAfterTradeOrders(menu.contextMenuData.currentShip, waredata.ware, waredata.sell.ammotypename) or 0
		-- curorder was already added to virtual cargo, don't count it twice
		storableamount = storableamount - selloffer_curorder
		selloffer_max = waredata.sell.amount
		selloffer_maxselect = math.min(waredata.sell.amount, affordableamount, storableamount)

		if menu.contextMenuData.currentShip ~= 0 then
			if selloffer_maxselect == 0 then
				if not CheckSuitableTransportType(menu.contextMenuData.currentShip, waredata.ware) then
					warnings[1] = ReadText(1001, 2969)
				elseif storableamount < waredata.sell.amount and storableamount < affordableamount then
					warnings[1] = ReadText(1001, 8337)
				elseif affordableamount < waredata.sell.amount and affordableamount < storableamount then
					warnings[2] = ReadText(1001, 8338)
				end
			else
				if not CheckSuitableTransportType(menu.contextMenuData.currentShip, waredata.ware) then
					optionalsellwarnings[1] = ReadText(1001, 2969)
				elseif storableamount < waredata.sell.amount and storableamount < affordableamount then
					optionalsellwarnings[1] = ReadText(1001, 8337)
				elseif affordableamount < waredata.sell.amount and affordableamount < storableamount then
					optionalsellwarnings[2] = ReadText(1001, 8338)
				end
			end
		end

		if not waredata.sell.active then
			selloffer_max, selloffer_maxselect, selloffer_curorder = 0, 0, 0
		end
	end

	local buyoffer_max, buyoffer_maxselect, buyoffer_curorder = 0, 0, 0
	local hasdesiredbuyamount = false
	if waredata.buy then
		if waredata.buy.amount > 0 then
			hasbuyamount = true
		end
		if waredata.buy.desiredamount > 0 then
			hasdesiredbuyamount = true
		end
		buyoffer_curorder = math.max(0, menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.buy.id)] or 0)
		local availableamount = (waredata.buy.ammotypename and menu.contextMenuData.currentammo[waredata.ware] or menu.contextMenuData.currentcargo[waredata.ware]) or 0
		buyoffer_maxselect = math.min(waredata.buy.amount, availableamount)
		buyoffer_max = waredata.buy.amount

		local othershipstorableamount
		if menu.contextMenuData.wareexchange then
			othershipstorableamount = menu.getTradeContextStorableAmountAfterTradeOrders(menu.contextMenuData.component, waredata.ware, waredata.buy.ammotypename)
			-- curorder was already added to virtual cargo, don't count it twice
			othershipstorableamount = othershipstorableamount + buyoffer_curorder
			buyoffer_maxselect = math.min(buyoffer_maxselect, othershipstorableamount)
		end
		
		if menu.contextMenuData.currentShip ~= 0 then
			if buyoffer_maxselect == 0 then
				if menu.contextMenuData.wareexchange and othershipstorableamount < waredata.buy.amount and othershipstorableamount < availableamount then
					warnings[3] = ReadText(1001, 8339)
				elseif availableamount < waredata.buy.amount then
					warnings[4] = ((nonVirtualShipCargo[waredata.ware] or 0) > 0) and ReadText(1001, 8375) or ReadText(1001, 8340)
				end
			else
				if menu.contextMenuData.wareexchange and othershipstorableamount < waredata.buy.amount and othershipstorableamount < availableamount then
					optionalbuywarnings[3] = ReadText(1001, 8339)
				elseif availableamount < waredata.buy.amount then
					optionalbuywarnings[4] = ((nonVirtualShipCargo[waredata.ware] or 0) > 0) and ReadText(1001, 8375) or ReadText(1001, 8340)
				end
			end
		end

		if not waredata.buy.active then
			buyoffer_max, buyoffer_maxselect, buyoffer_curorder = 0, 0, 0
		end
	end

	if not hastradesubscription then
		warnings[6] = ReadText(1001, 11602)
	elseif (not hassellamount) and (not hasbuyamount) then
		if hasdesiredbuyamount then
			warnings[5] = ReadText(1001, 11213)
		else
			warnings[5] = ReadText(1001, 8341)
		end
	end

	-- In case both selloffer and buyoffer exist, we can show both offer amounts, but all other columns can only show data for one offer.
	-- In that case prefer selloffer data (for buying - change to buyoffer when player attempts to sell)
	local tradedata = waredata.sell
	if waredata.buy then
		if (buyoffer_curorder ~= 0) or ((not waredata.sell) or (waredata.sell.amount == 0)) then
			tradedata = waredata.buy
		end
	end

	local avgprice = GetWareData(waredata.ware, "avgprice")
	local adjustment = avgprice ~= 0 and (tradedata.price / avgprice - 1) or 0
	local pricecolor = Helper.interpolatePriceColor(waredata.ware, tradedata.price, tradedata == waredata.sell, activecolor)

	local strquantitybonustype = ""
	if tradedata.quantityfactor > 1 then
		strquantitybonustype = tradedata.isselloffer and ReadText(1001, 2929) or ReadText(1001, 2905)
	else
		strquantitybonustype = tradedata.isselloffer and ReadText(1001, 2904) or ReadText(1001, 2930)
	end
	pricemodifiers[1] = { text = strquantitybonustype, amount = Helper.diffpercent(((tradedata.quantityfactor - 1) * 100) or 0, tradedata.isbuyoffer) .. " %" }

	if tradedata.pricemodifiers and #tradedata.pricemodifiers ~= 0 then
		local modifiersum = 0
		for i, p in ipairs(tradedata.pricemodifiers) do
			if tradedata.isselloffer then
				modifiersum = modifiersum - p.amount
			else
				modifiersum = modifiersum + p.amount
			end
		end

		for i, p in ipairs(tradedata.pricemodifiers) do
			local amount = p.amount
			if tradedata.isselloffer then
				amount = -amount
			end
			if modifiersum ~= 0 then
				amount = amount * math.floor(modifiersum + 0.5) / modifiersum
			end

			table.insert(pricemodifiers, {
				text = p.name .. (p.expire >= 0 and " (" .. Helper.timeDuration(p.expire) .. ")" or ""),
				amount = Helper.diffpercent(Helper.round(amount), tradedata.isbuyoffer) .. " %"
			})
		end
	end
	table.insert(pricemodifiers, { text = ReadText(1001, 11212), amount = Helper.diffpercent(adjustment * 100, tradedata.isbuyoffer) .. " %" })

	local movedamount = -(selloffer_curorder < 0 and selloffer_curorder or buyoffer_curorder)
	local shipamount = (menu.contextMenuData.currentcargo[waredata.ware] or menu.contextMenuData.currentammo[waredata.ware] or 0) + movedamount
	local shipamountcolor = (movedamount > 0 and Helper.color.lightgreen) or (movedamount < 0 and Helper.color.red) or color

	local othershipamount = (menu.contextMenuData.currentothercargo and (menu.contextMenuData.currentothercargo[waredata.ware] or menu.contextMenuData.currentotherammo[waredata.ware]) or 0) - movedamount
	local othershipamountcolor = (movedamount > 0 and Helper.color.red) or (movedamount < 0 and Helper.color.lightgreen) or color

	local scale = {
		--min       = waredata.buy and waredata.buy.ammotypename and -buyoffer_max or -buyoffer_maxselect, -- use real max only for ammo
		min       = -buyoffer_maxselect, --TODO: max
		minselect = -buyoffer_maxselect,
		--max       = waredata.sell and waredata.sell.ammotypename and selloffer_max or selloffer_maxselect, -- use real max only for ammo
		max       = selloffer_maxselect, --TODO: max
		maxselect = selloffer_maxselect,
		start     = movedamount,
		step      = 1,
		suffix    = "",
		fromcenter = true,
		righttoleft = true
	}

	local shiptargetamount = (menu.contextMenuData.currentShip ~= 0) and GetWareProductionLimit(menu.contextMenuData.currentShip, waredata.ware) or 0
	local othershiptargetamount = GetWareProductionLimit(ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), waredata.ware)
	local othershipreserved = C.GetWareReservationsForWare(menu.contextMenuData.component, waredata.ware, false)

	local content = { {}, {}, {}, {}, nil, {}, {}, warnings, optionalsellwarnings, optionalbuywarnings, pricemodifiers }
	-- name
	content[1].text = name
	content[1].color = color
	content[1].mouseover = mouseovertext
	-- price
	if not menu.contextMenuData.wareexchange then
		content[2].text = (not waredata.stale) and ((isplayertradeoffercontainer and "-" or ConvertMoneyString(Helper.round(tradedata.price, 2), true, true, 0, true)) .. " " .. ReadText(1001, 101)) or ""
		content[2].color = pricecolor
		content[2].mouseover = (not waredata.stale) and (isplayertradeoffercontainer and "" or (Helper.diffpercent(adjustment * 100, tradedata.isbuyoffer) .. ReadText(1001, 8304))) or ""
	end
	-- amount
	content[3].text = ConvertIntegerString(shipamount, true, 0, true) .. ((shiptargetamount > 0) and (" (" .. ConvertIntegerString(shiptargetamount, true, 2, true, true) .. ")") or "")
	content[3].color = shipamountcolor
	-- slidercell
	content[4].scale = scale
	content[4].color = color
	if menu.contextMenuData.wareexchange then
		-- other ship amount
		content[6].text = ConvertIntegerString(othershipamount, true, 0, true) .. ((othershiptargetamount > 0) and (" (" .. ConvertIntegerString(othershiptargetamount, true, 2, true, true) .. ")") or "")
		content[6].color = othershipamountcolor
		if othershipreserved > 0 then
			content[6].mouseover = string.format(ReadText(1026, 3266), ConvertIntegerString(othershipreserved, true, 0, true))
		end
	else
		-- sell offer
		content[6].text = (waredata.sell and (not waredata.sell.stale)) and ConvertIntegerString(waredata.sell.amount - math.max(movedamount, 0), true, 0, true) or ""
		content[6].color = color
		-- buy offer
		content[7].text = (waredata.buy and (not waredata.buy.stale)) and (hasbuyamount and ConvertIntegerString(waredata.buy.amount - math.max(-movedamount, 0), true, 0, true) or (hasdesiredbuyamount and ConvertIntegerString(waredata.buy.desiredamount - math.max(-movedamount, 0), true, 0, true) or "")) or ""
		content[7].color = color
	end
	return content
end

-- Only use this to get initial storage data. If we use this with every virtual storage change, we have to reset virtual cargo every time wares are removed from virtual cargo of othercontainer in the menu. Otherwise, this will result in a mismatch between the storage data in the menu and after the actual trade because each change is treated as a separate trade in virtual cargo.
-- For example: If we add A, add B, then remove A; virtual cargo treats this as three separate transactions and will fill storage accordingly; but the actual trade will only have one transaction: add B.
function menu.getTradeContextInitialStorageData(container, transporttypes, aftertradeorders)
	local numtransporttypes = C.GetNumCargoTransportTypes(container, true)
	local virtualtransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
	numtransporttypes = C.GetCargoTransportTypes(virtualtransporttypes, numtransporttypes, container, true, aftertradeorders)

	--typedef struct {
	--	const char* name;
	--	const char* transport;
	--	uint32_t spaceused;
	--	uint32_t capacity;
	--} StorageInfo;

	for _, transporttype in ipairs(transporttypes) do
		for j = 0, numtransporttypes - 1 do
			local tags = menu.getTransportTagsFromString(ffi.string(virtualtransporttypes[j].transport))

			local invalid = false
			for tag, _ in pairs(tags) do
				if not transporttype.tags[tag] then invalid = true; break end
			end
			if not invalid then
				for tag, _ in pairs(transporttype.tags) do
					if not tags[tag] then invalid = true; break end
				end
			end
			if not invalid then
				transporttype.initialstored = virtualtransporttypes[j].spaceused
				break
			end
		end
	end
end

function menu.getTradeContextShipStorageContent(othership)
	local storagecontent = {}

	for i, transporttype in ipairs(othership and menu.contextMenuData.othershiptransporttypes or menu.contextMenuData.transporttypes) do
		if i > menu.tradeContext.numinforows then
			break
		end
		local spaceused = transporttype.stored
		spaceused = math.max(0, math.min(spaceused, transporttype.capacity))
		table.insert(storagecontent, {
			name = transporttype.name,
			color = Helper.color.white,
			scale = {
				min       = 0,
				max       = transporttype.capacity,
				start     = spaceused,
				step      = 1,
				suffix    = ReadText(1001, 110),
				readonly  = true
			}
		})
	end

	-- add empty line if one ship has ammo of a type, but other doesn't
	for _, ammotype in ipairs(menu.contextMenuData.ammotypes) do
		if #storagecontent >= menu.tradeContext.numinforows then
			break
		end
		local spaceused = othership and ammotype.otherstored or ammotype.stored
		local capacity = othership and ammotype.othercapacity or ammotype.capacity
		spaceused = math.max(0, math.min(spaceused, capacity))
		table.insert(storagecontent, {
			name = ammotype.name,
			color = Helper.color.white,
			scale = {
				min       = 0,
				max       = capacity,
				start     = spaceused,
				step      = 1,
				suffix    = "     ",
				readonly  = true
			}
		})
	end

	return storagecontent
end

function menu.createTradeContext(frame)
	menu.skipTradeRowChange = true
	
	local convertedTradeOfferContainer = ConvertStringTo64Bit(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer = GetComponentData(convertedTradeOfferContainer, "isplayerowned")

	menu.updateTradeCost()
	local convertedCurrentShip = ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip))

	-- menu setup
	local width = menu.contextMenuData.width
	local amountcolumnwidth = 100
	local pricecolumnwidth = 100

	local columnwidth_ware   -- calculated below
	local columnwidth_price			= math.floor(width * 12 / 100)
	local columnwidth_shipstorage	= math.floor(width * 12 / 100)
	local columnwidth_sliderleft	= math.floor(width * 15 / 100)
	local columnwidth_sliderright	= math.floor(width * 15 / 100)
	local columnwidth_selloffer		= math.floor(width * 12 / 100)
	local columnwidth_buyoffer		= math.floor(width * 12 / 100)
	local columnwidth_reservation	= Helper.scaleY(config.mapRowHeight)
	if menu.contextMenuData.wareexchange then
		-- nearly symmetrical menu layout in ware exchange case:
		--   price column = only a dummy in this case, always included in colspan.
		--   selloffer column = other ship storage
		--   buyoffer column = unused (almost same width as ware column)
		columnwidth_price = 1
		local remainingwidth = width - 6 * Helper.borderSize
			- columnwidth_price
			- columnwidth_shipstorage
			- columnwidth_sliderleft
			- columnwidth_sliderright
			- columnwidth_selloffer
		-- nearly symmetrical menu layout: 
		columnwidth_ware = math.ceil(remainingwidth / 2)
		columnwidth_buyoffer = remainingwidth - columnwidth_ware
	else
		-- regular trade case
		columnwidth_ware = width - 6 * Helper.borderSize
			- columnwidth_price
			- columnwidth_shipstorage
			- columnwidth_sliderleft
			- columnwidth_sliderright
			- columnwidth_selloffer
			- columnwidth_buyoffer
	end

	-- ship
	local shiptable = frame:addTable(9, { tabOrder = 2, maxVisibleHeight = menu.tradeContext.shipheight, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, reserveScrollBar = false })
	shiptable:setColWidth(1, columnwidth_ware, false)
	shiptable:setColWidth(2, columnwidth_price, false)
	shiptable:setColWidth(3, columnwidth_shipstorage, false)
	shiptable:setColWidth(4, columnwidth_sliderleft, false)
	shiptable:setColWidth(5, columnwidth_sliderright, false)
	shiptable:setColWidth(6, columnwidth_reservation, false)
	shiptable:setColWidth(7, columnwidth_selloffer - columnwidth_reservation - Helper.borderSize, false)
	shiptable:setColWidth(8, columnwidth_reservation, false)
	shiptable:setColWidth(9, columnwidth_buyoffer - columnwidth_reservation - Helper.borderSize, false)
	shiptable:setDefaultBackgroundColSpan(1, 9)

	local shipOptions = {}
	local curShipOption = tostring(convertedCurrentShip)

	local sortedShips = {}
	local found = false
	for _, ship in ipairs(menu.contextMenuData.ships) do
		local shipid = ConvertIDTo64Bit(ship.shipid)
		if shipid == convertedCurrentShip then
			found = true
		end

		local class = ffi.string(C.GetComponentClass(ConvertStringTo64Bit(tostring(ship.shipid))))
		local icon, primarypurpose = GetComponentData(ship.shipid, "icon", "primarypurpose")
		local i = menu.findEntryByShipIcon(sortedShips, icon)
		if i then
			table.insert(sortedShips[i].ships, { shipid = shipid, name = ship.name })
		else
			table.insert(sortedShips, { icon = icon, class = class, purpose = primarypurpose, ships = { { shipid = shipid, name = ship.name } } })
		end
	end
	if (not found) and (menu.contextMenuData.currentShip ~= 0) then
		local ship = { shipid = convertedCurrentShip, name = ffi.string(C.GetComponentName(menu.contextMenuData.currentShip)) }

		local class = ffi.string(C.GetComponentClass(menu.contextMenuData.currentShip))
		local icon, primarypurpose = GetComponentData(ship.shipid, "icon", "primarypurpose")
		local i = menu.findEntryByShipIcon(sortedShips, icon)
		if i then
			table.insert(sortedShips[i].ships, ship)
		else
			table.insert(sortedShips, { icon = icon, class = class, purpose = primarypurpose, ships = { ship } })
		end
	end
	table.sort(sortedShips, menu.sortShipsByClassAndPurposeReverse)

	for _, data in ipairs(sortedShips) do
		table.sort(data.ships, Helper.sortName)
		for _, ship in ipairs(data.ships) do
			table.insert(shipOptions, { id = tostring(ship.shipid), text = "\27[" .. data.icon .. "] " .. ship.name .. " (" .. ffi.string(C.GetObjectIDCode(ship.shipid)) .. ")", icon = "", displayremoveoption = false })
		end
	end

	local iscapship = IsComponentClass(convertedCurrentShip, "ship_l") or IsComponentClass(convertedCurrentShip, "ship_xl")
	local ispartnersmallship = IsComponentClass(convertedTradeOfferContainer, "ship_m") or IsComponentClass(convertedTradeOfferContainer, "ship_s")
	local missingdrones = true
	if iscapship and (not ispartnersmallship) then
		local shipunits = GetUnitStorageData(convertedCurrentShip, "transport")
		local stationunits = GetUnitStorageData(convertedTradeOfferContainer, "transport")
		for _, unit in ipairs(shipunits) do
			if unit.amount > 0 then
				missingdrones = false
				break
			end
		end
		if missingdrones then
			for _, unit in ipairs(stationunits) do
				if unit.amount > 0 then
					missingdrones = false
					break
				end
			end
		end
	else
		missingdrones = false
	end
	local candock = true
	if convertedCurrentShip and (convertedCurrentShip ~= 0) then
		if (not menu.contextMenuData.wareexchange) or IsComponentClass(convertedTradeOfferContainer, "station") then
			candock = IsDockingPossible(convertedCurrentShip, convertedTradeOfferContainer, nil, true)
		end
	end
	local isplayertraderestricted = isplayertradeoffercontainer and C.IsContainerTradingWithFactionRescricted(menu.contextMenuData.component, "player")

	local shipsectorname, blacklistgroup = "", "civilian"
	if convertedCurrentShip and (convertedCurrentShip ~= 0) then
		shipsectorname, blacklistgroup = GetComponentData(convertedCurrentShip, "sector", "blacklistgroup")
	end
	local stationsector = ConvertIDTo64Bit(GetComponentData(convertedTradeOfferContainer, "sectorid"))

	-- title
	local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setBackgroundColSpan(4):setColSpan(4):createDropDown(shipOptions, { startOption = curShipOption, height = Helper.headerRow1Height, helpOverlayID = "trade_context_shipOptions", helpOverlayText = " ", helpOverlayHighlightOnly = true,  }):setTextProperties({ halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, color = Helper.color.green })
	row[1].handlers.onDropDownConfirmed = menu.dropdownShip

	local name = Helper.unlockInfo(IsInfoUnlockedForPlayer(convertedTradeOfferContainer, "name"), ffi.string(C.GetComponentName(menu.contextMenuData.component)) .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.component)) .. ")")
	local color = Helper.color.white
	if isplayertradeoffercontainer then
		color = Helper.color.green
	end
	local mouseovertext
	if C.IsComponentBlacklisted(convertedTradeOfferContainer, "objectactivity", blacklistgroup, convertedCurrentShip) then
		color = Helper.color.warningorange
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 3257)
		else
			mouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 3256)
		end
	end
	if mouseovertext then
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. "\27X\n" .. ReadText(1026, 3258)
		end
	end
	row[5]:setColSpan(5):createText(name, { halign = "center", color = color, font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety, mouseOverText = mouseovertext })

	-- locations
	local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:setBackgroundColSpan(4):setColSpan(4):createText(shipsectorname, { halign = "center" })

	local color = Helper.color.white
	local mouseovertext
	if C.IsComponentBlacklisted(stationsector, "sectortravel", blacklistgroup, convertedCurrentShip) then
		color = Helper.color.warningorange
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 3253)
		else
			mouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 3252)
		end
	end
	if C.IsComponentBlacklisted(stationsector, "sectoractivity", blacklistgroup, convertedCurrentShip) then
		color = Helper.color.warningorange
		if mouseovertext then
			mouseovertext = mouseovertext .. "\n"
		else
			mouseovertext = ""
		end
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 3255)
		else
			mouseovertext = mouseovertext .. Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 3254)
		end
	end
	if mouseovertext then
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. "\27X\n" .. ReadText(1026, 3258)
		end
	end
	row[5]:setColSpan(5):createText(ffi.string(C.GetComponentName(stationsector)), { halign = "center", color = color, mouseOverText = mouseovertext })

	-- table header
	local hasshiptargetamounts = false
	local hasothershipttargetamounts = false
	for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
		local shiptargetamount = 0
		if menu.contextMenuData.currentShip ~= 0 then
			shiptargetamount = GetWareProductionLimit(menu.contextMenuData.currentShip, waredata.ware)
		end
		if shiptargetamount > 0 then
			hasshiptargetamounts = true
			if hasothershipttargetamounts then
				break
			end
		end
		local othershiptargetamount = GetWareProductionLimit(ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), waredata.ware)
		if othershiptargetamount > 0 then
			hasothershipttargetamounts = true
			if hasshiptargetamounts then
				break
			end
		end
	end

	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.unselectable })
	if menu.contextMenuData.wareexchange then
		row[1]:setColSpan(2):setBackgroundColSpan(1):createText(ReadText(1001, 45), { font = Helper.standardFontBold })
		row[3]:setColSpan(3):createText(ReadText(1001, 5) .. (hasshiptargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), { font = Helper.standardFontBold })
		row[6]:setColSpan(4):createText(((C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 5)) or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 3)) or ReadText(1001, 9426)) .. (hasothershipttargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), { font = Helper.standardFontBold })
	else
		row[1]:setBackgroundColSpan(1):createText(ReadText(1001, 45), { font = Helper.standardFontBold })
		row[2]:createText(ReadText(1001, 2808), { font = Helper.standardFontBold })
		row[3]:setColSpan(2):createText(ReadText(1001, 5) .. (hasshiptargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), { font = Helper.standardFontBold })
		row[6]:setColSpan(2):createText(ReadText(1001, 8308), { font = Helper.standardFontBold })
		row[8]:setColSpan(2):createText(ReadText(1001, 8309), { font = Helper.standardFontBold })
	end

	-- line
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.grey })
	row[1]:setColSpan(9):createText("", { fontsize = 1, height = 1 })

	-- ware list
	local warningcontent = {}
	local pricemodifiers = {}
	local warningcolor = Helper.color.red

	local maxVisibleHeight

	if #menu.contextMenuData.waredatalist == 0 then
		menu.selectedTradeWare = nil
		local row = shiptable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(9):createText(menu.contextMenuData.wareexchange and ReadText(1001, 8310) or ReadText(1001, 8311))
	else
		-- check selectedTradeWare
		local tradewarefound = false
		if menu.selectedTradeWare then
			for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
				if (waredata.ware == menu.selectedTradeWare.ware) and (waredata.mission == menu.selectedTradeWare.mission) then
					tradewarefound = true
					break
				end
			end
			if not tradewarefound then
				menu.selectedTradeWare = nil
			end
		end

		local reservations, missionreservations = {}, {}
		local n = C.GetNumContainerWareReservations2(menu.contextMenuData.component, true, true, true)
		local buf = ffi.new("WareReservationInfo2[?]", n)
		n = C.GetContainerWareReservations2(buf, n, menu.contextMenuData.component, true, true, true)
		for i = 0, n - 1 do
			if (buf[i].missionid ~= 0) or (not buf[i].isvirtual) then
				local ware = ffi.string(buf[i].ware)
				local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
				local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
				local reservationref = (buf[i].missionid ~= 0) and missionreservations or reservations
				if reservationref[ware] then
					table.insert(reservationref[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, mission = buf[i].missionid })
				else
					reservationref[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, mission = buf[i].missionid } }, [invbuyflag] = {} }
				end
			end
		end
		for _, data in pairs(reservations) do
			table.sort(data.buyoffer, menu.etaSorter)
			table.sort(data.selloffer, menu.etaSorter)
		end
		for _, data in pairs(missionreservations) do
			table.sort(data.buyoffer, menu.etaSorter)
			table.sort(data.selloffer, menu.etaSorter)
		end

		for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
			local content = menu.getTradeContextRowContent(waredata)

			local row = shiptable:addRow({ ware = waredata.ware, mission = waredata.mission }, { bgColor = Helper.color.transparent })
			local callback = menu.getAmmoTypeNameByWare(waredata.ware) and menu.slidercellShipAmmo or menu.slidercellShipCargo
			if menu.contextMenuData.wareexchange then
				row[1]:setColSpan(2):createText(content[1].text, { color = content[1].color })
				row[3]:createText(content[3].text, { color = content[3].color, halign = "right" })
				row[4]:setColSpan(2):createSliderCell({ start = content[4].scale.start, min = content[4].scale.min, minSelect = content[4].scale.minselect, max = content[4].scale.max, maxSelect = content[4].scale.maxselect, step = content[4].scale.step, suffix = content[4].scale.suffix, fromCenter = content[4].scale.fromcenter, rightToLeft = content[4].scale.righttoleft, height = Helper.standardTextHeight })
				row[4].handlers.onSliderCellChanged = function (_, value) return callback(waredata.sell and waredata.sell.id, waredata.buy and waredata.buy.id, waredata.ware, 0, value) end
				row[4].handlers.onSliderCellConfirm = function () return menu.slidercellTradeConfirmed(waredata.ware) end
				waredata.sellcol = 6
				row[6]:setColSpan(2):createText(content[6].text, { color = content[6].color, halign = "right", mouseOverText = content[6].mouseover })
			else
				row[1]:createText(content[1].text, { color = content[1].color, mouseOverText = content[1].mouseover })
				row[2]:createText(content[2].text, { color = content[2].color, halign = "right", mouseOverText = content[2].mouseover })
				row[3]:createText(content[3].text, { color = content[3].color, halign = "right" })
				row[4]:setColSpan(2):createSliderCell({ start = content[4].scale.start, min = content[4].scale.min, minSelect = content[4].scale.minselect, max = content[4].scale.max, maxSelect = content[4].scale.maxselect, step = content[4].scale.step, suffix = content[4].scale.suffix, fromCenter = content[4].scale.fromcenter, rightToLeft = content[4].scale.righttoleft, height = Helper.standardTextHeight })
				row[4].handlers.onSliderCellChanged = function (_, value) return callback(waredata.sell and waredata.sell.id, waredata.buy and waredata.buy.id, waredata.ware, 0, value) end
				row[4].handlers.onSliderCellConfirm = function () return menu.slidercellTradeConfirmed(waredata.ware) end

				local reservationref = waredata.mission and missionreservations or reservations
				local colspan = 2
				if reservationref[waredata.ware] and (#reservationref[waredata.ware].selloffer > 0) then
					local mouseovertext = ""
					for i, reservation in ipairs(reservationref[waredata.ware].selloffer) do
						if (not waredata.mission) or (waredata.mission == reservation.mission) then
							local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
							if isplayerowned or isplayertradeoffercontainer then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n"
								end
								local name = (isplayerowned and Helper.convertColorToText(Helper.color.green) or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
								mouseovertext = mouseovertext .. name .. " - " .. (waredata.mission and Helper.convertColorToText(Helper.color.mission) or "") .. ReadText(1001, 1202) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(reservation.amount, true, 0, true) .. "\27X"
							end
						end
					end
					if mouseovertext ~= "" then
						colspan = 1
						mouseovertext = ReadText(1001, 7946) .. ReadText(1001, 120) .. "\n" .. mouseovertext
						row[6]:createIcon("menu_hourglass", { color = waredata.mission and Helper.color.mission or nil, height = config.mapRowHeight, mouseOverText = mouseovertext })
					end
				end
				waredata.sellcol = 8 - colspan
				row[8 - colspan]:setColSpan(colspan):createText(content[6].text, { color = content[6].color, halign = "right", mouseOverText = content[6].mouseover })
				colspan = 2
				if reservationref[waredata.ware] and (#reservationref[waredata.ware].buyoffer > 0) then
					local mouseovertext = ""
					for i, reservation in ipairs(reservationref[waredata.ware].buyoffer) do
						if (not waredata.mission) or (waredata.mission == reservation.mission) then
							local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
							if isplayerowned or isplayertradeoffercontainer then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n"
								end
								local name = (isplayerowned and Helper.convertColorToText(Helper.color.green) or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
								mouseovertext = mouseovertext .. name .. " - " .. (waredata.mission and Helper.convertColorToText(Helper.color.mission) or "") .. ReadText(1001, 1202) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(reservation.amount, true, 0, true) .. "\27X"
							end
						end
					end
					if mouseovertext ~= "" then
						colspan = 1
						mouseovertext = ReadText(1001, 7946) .. ReadText(1001, 120) .. "\n" .. mouseovertext
						row[8]:createIcon("menu_hourglass", { color = waredata.mission and Helper.color.mission or nil, height = config.mapRowHeight, mouseOverText = mouseovertext })
					end
				end
				waredata.buycol = 10 - colspan
				row[10 - colspan]:setColSpan(colspan):createText(content[7].text, { color = content[7].color, halign = "right" })
			end

			if not menu.selectedRows.contextshiptable then
				if (waredata.sell and IsSameTrade(waredata.sell.id, menu.contextMenuData.tradeid)) or (waredata.buy and IsSameTrade(waredata.buy.id, menu.contextMenuData.tradeid)) then
					menu.selectedTradeWare = { ware = waredata.ware, mission = waredata.mission }
					menu.topRows.contextshiptable = math.min(4 + i, 4 + #menu.contextMenuData.waredatalist - (menu.tradeContext.warescrollwindowsize - 1))
					shiptable:setSelectedRow(row.index)
				end
			end
			if not menu.selectedTradeWare then
				menu.selectedTradeWare = { ware = waredata.ware, mission = waredata.mission }
			end
			if (waredata.ware == menu.selectedTradeWare.ware) and (waredata.mission == menu.selectedTradeWare.mission) then
				warningcontent = content[8]
				if waredata.ware == menu.showOptionalWarningWare then
					if content[4].scale.start == content[4].scale.maxselect then
						warningcontent = content[9]
						warningcolor = Helper.color.warningorange
					elseif content[4].scale.start == content[4].scale.minselect then
						warningcontent = content[10]
						warningcolor = Helper.color.warningorange
					else
						menu.showOptionalWarningWare = nil
					end
				end

				pricemodifiers = content[11]
			end

			if i == menu.tradeContext.warescrollwindowsize then
				maxVisibleHeight = shiptable:getFullHeight()
			end
		end
	end

	shiptable.properties.maxVisibleHeight = maxVisibleHeight or shiptable:getFullHeight()

	shiptable:setTopRow(menu.topRows.contextshiptable)
	if menu.selectedRows.contextshiptable then
		shiptable:setSelectedRow(menu.selectedRows.contextshiptable)
	end
	menu.topRows.contextshiptable = nil
	menu.selectedRows.contextshiptable = nil

	-- info and buttons
	-- the button table is split into left and right side below the "zero" position of the sliders
	local columnwidth_bottomleft		= columnwidth_ware + columnwidth_price + columnwidth_shipstorage + columnwidth_sliderleft + 3 * Helper.borderSize
	local columnwidth_bottomright		= columnwidth_sliderright + columnwidth_selloffer + columnwidth_buyoffer + 2 * Helper.borderSize
	-- trade menu case:
	-- split bottom right twice: Once into 2/3 + 1/3 for money output, and 1/2 + 1/2 for the buttons
	-- A-----------------------------------------B------------C----D--------E
	-- | Ship storage details  (bottomleft)      | Profits:        | 100 Cr |
	-- +-----------------------------------------+------------+----+--------+
	-- |                                         | LeftButton | RightButton |
	-- +-----------------------------------------+------------+----+--------+
	local columnwidth_br_leftoutput		= math.floor((columnwidth_bottomright - Helper.borderSize) * 2 / 3)			-- BD
	local columnwidth_br_rightoutput	= columnwidth_bottomright - columnwidth_br_leftoutput - Helper.borderSize	-- DE
	local columnwidth_br_leftbutton		= math.floor((columnwidth_bottomright - Helper.borderSize) / 2)				-- BC
	local columnwidth_br_rightbutton	= columnwidth_bottomright - columnwidth_br_leftbutton - Helper.borderSize	-- CE
	local columnwidth_br_bottomoverlap	= columnwidth_bottomright - columnwidth_br_leftbutton - columnwidth_br_rightoutput - 2 * Helper.borderSize			-- CD
	-- ware exchange menu case:
	-- "zero" position is in the center. Split bottom right twice, so that each button occupies ca. 20% of the width (40% together)
	-- A-----------------------------------B-----C------------D-------------E
	-- | Ship storage details (bottomleft) | Other ship storage details     |
	-- +-----------------------------------+-----+------------+-------------+
	-- |                                         | LeftButton | RightButton |
	-- +-----------------------------------+-----+------------+-------------+
	local columnwidth_wx_br_leftbutton	= math.floor((columnwidth_bottomright - 2 * Helper.borderSize) * 2 / 5)		-- CD
	local columnwidth_wx_br_rightbutton	= columnwidth_wx_br_leftbutton												-- DE
	local columnwidth_wx_br_leftspacing	= columnwidth_bottomright - columnwidth_wx_br_leftbutton - columnwidth_wx_br_rightbutton - 2 * Helper.borderSize	-- BC

	local showdiscountinfo = (not menu.contextMenuData.wareexchange) and (not isplayertradeoffercontainer)
	local numcols = showdiscountinfo and 6 or 4
	local coloffset = showdiscountinfo and 2 or 0
	menu.tradeContext.coloffset = coloffset
	local buttontable = frame:addTable(numcols, { tabOrder = 3, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight() + Helper.borderSize, width = menu.contextMenuData.width, reserveScrollBar = false })
	if showdiscountinfo then
		buttontable:setColWidth(1, 2 * math.floor(columnwidth_bottomleft / 3), false)
		buttontable:setColWidth(2, math.floor(0.6 * columnwidth_bottomleft / 3) - 2 * Helper.borderSize, false)
		buttontable:setColWidth(3, math.floor(0.4 * columnwidth_bottomleft / 3), false)
		buttontable:setColWidth(4, columnwidth_br_leftbutton,     false)
		buttontable:setColWidth(5, columnwidth_br_bottomoverlap,  false)
		buttontable:setColWidth(6, columnwidth_br_rightoutput,    false)
		buttontable:setDefaultBackgroundColSpan(2, 2)
		buttontable:setDefaultBackgroundColSpan(4, 3)
	elseif menu.contextMenuData.wareexchange then
		buttontable:setColWidth(1, columnwidth_bottomleft, false)
		buttontable:setColWidth(2, columnwidth_wx_br_leftspacing, false)
		buttontable:setColWidth(3, columnwidth_wx_br_leftbutton,  false)
		buttontable:setColWidth(4, columnwidth_wx_br_rightbutton, false)
		buttontable:setDefaultBackgroundColSpan(2, 3)
	else
		buttontable:setColWidth(1, columnwidth_bottomleft, false)
		buttontable:setColWidth(2, columnwidth_br_leftbutton,     false)
		buttontable:setColWidth(3, columnwidth_br_bottomoverlap,  false)
		buttontable:setColWidth(4, columnwidth_br_rightoutput,    false)
		buttontable:setDefaultBackgroundColSpan(2, 3)
	end

	-- line
	local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.grey })
	row[1]:setColSpan(numcols):createText("", { fontsize = 1, height = 1 })

	-- rows
	local headerrow = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.unselectable })
	local inforows = {}
	local warningrows = {}
	for i = 1, menu.tradeContext.numinforows do
		inforows[i] = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	end
	local headerrow2 = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	for i = 1, menu.tradeContext.numwarningrows do
		warningrows[i] = buttontable:addRow(i == menu.tradeContext.numwarningrows, { fixed = true, bgColor = Helper.color.transparent })
	end

	-- storage details
	local storagecontent = menu.getTradeContextShipStorageContent()
	local storageheader = #storagecontent > 0 and ReadText(1001,8312) or ReadText(1001,8313)
	for i, content in ipairs(storagecontent) do
		if i <= menu.tradeContext.numinforows then
			inforows[i][1]:createSliderCell({ min = content.scale.min, max = content.scale.max, start = content.scale.start, step = content.scale.step, suffix = content.scale.suffix, readOnly = content.scale.readonly, height = Helper.standardTextHeight }):setText(content.name, { color = content.color })
		end
	end

	-- warnings
	local i = 0
	if not candock then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 6211), { color = Helper.color.red })
		end
	end
	if missingdrones then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 2978), { color = Helper.color.red })
		end
	end

	for _, content in pairs(warningcontent) do
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(content, { color = warningcolor, wordwrap = true })
		end
	end

	if isplayertraderestricted then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 6212), { color = Helper.color.warningorange })
		end
	end

	local confirmbuttonactive = false
	if candock and (not missingdrones) then
		for _, amount in pairs(menu.contextMenuData.orders) do
			if amount ~= 0 then
				confirmbuttonactive = true
				break
			end
		end
	end

	if menu.contextMenuData.wareexchange then
		local otherstoragecontent = menu.getTradeContextShipStorageContent(true)
		local otherstorageheader = #otherstoragecontent > 0 and 
			(
				(C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 8312)) 
				or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 8314)) 
				or ReadText(1001,8316)
			) 
			or (
				(C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 8313)) 
				or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 8315)) 
				or ReadText(1001,8317)
			)

		-- header
		headerrow[1]:createText(storageheader, { halign = "center", font = Helper.standardFontBold })
		headerrow[2]:setColSpan(3):createText(otherstorageheader, { halign = "center", font = Helper.standardFontBold })

		-- other ship info
		for i = 1, menu.tradeContext.numinforows do
			local content = otherstoragecontent[i]
			if content then
				inforows[i][2]:setColSpan(3):createSliderCell({ min = content.scale.min, max = content.scale.max, start = content.scale.start, step = content.scale.step, suffix = content.scale.suffix, readOnly = content.scale.readonly, height = Helper.standardTextHeight }):setText(content.name, { color = content.color })
			end
		end

		-- warning header
		headerrow2[1]:createText(next(warningcontent) and ReadText(1001, 8342) or "", { halign = "center", font = Helper.standardFontBold })

		-- buttons
		warningrows[menu.tradeContext.numwarningrows][3]:createButton({ active = confirmbuttonactive, height = Helper.standardTextHeight }):setText(ReadText(1001, 2821), { halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][3].handlers.onClick = menu.buttonConfirmTrade
		warningrows[menu.tradeContext.numwarningrows][3].properties.uiTriggerID = "confirmtrade"
		warningrows[menu.tradeContext.numwarningrows][4]:createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 64), { halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][4].handlers.onClick = menu.buttonCancelTrade
		warningrows[menu.tradeContext.numwarningrows][4].properties.uiTriggerID = "canceltrade"
	else
		-- profits from sales
		local profit = menu.contextMenuData.referenceprofit
		local profitcolor = Helper.color.white
		if profit < 0 then
			profitcolor = Helper.color.red
		elseif profit > 0 then
			profitcolor = Helper.color.green
		end
		inforows[menu.tradeContext.numinforows - 1][2 + coloffset]:createText(ReadText(1001, 8305) .. ReadText(1001, 120))
		inforows[menu.tradeContext.numinforows - 1][3 + coloffset]:setColSpan(2):createText(ConvertMoneyString(profit, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = profitcolor })

		-- transaction value
		local total = menu.contextMenuData.totalbuyprofit - menu.contextMenuData.totalsellcost
		local transactioncolor = Helper.color.white
		if total < 0 then
			transactioncolor = Helper.color.red
		elseif total > 0 then
			transactioncolor = Helper.color.green
		end
		inforows[menu.tradeContext.numinforows][2 + coloffset]:createText(ReadText(1001, 2005) .. ReadText(1001, 120)) -- Transaction value, :
		inforows[menu.tradeContext.numinforows][3 + coloffset]:setColSpan(2):createText(ConvertMoneyString(total, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = transactioncolor })

		-- pricing details
		if showdiscountinfo and (#pricemodifiers > 0) then
			for i, entry in ipairs(pricemodifiers) do
				if i < #pricemodifiers then
					local row
					if i <= menu.tradeContext.numinforows then
						row = inforows[i]
					elseif i == menu.tradeContext.numinforows + 1 then
						row = headerrow2
					elseif i <= menu.tradeContext.numinforows + 1 + menu.tradeContext.numwarningrows - 1 then
						row = warningrows[i - menu.tradeContext.numinforows - 1]
					end
					if row then
						row[2]:createText(entry.text, { x = config.tradeContextMenuInfoBorder })
						row[3]:createText(entry.amount, { x = config.tradeContextMenuInfoBorder, halign = "right" })
					end
				end
			end
			local y = math.max(0, warningrows[menu.tradeContext.numwarningrows]:getHeight() - Helper.scaleY(Helper.standardTextHeight))
			warningrows[menu.tradeContext.numwarningrows][2]:createText(pricemodifiers[#pricemodifiers].text, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = Helper.scaleX(config.tradeContextMenuInfoBorder), y = y })
			warningrows[menu.tradeContext.numwarningrows][3]:createText(pricemodifiers[#pricemodifiers].amount, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = Helper.scaleX(config.tradeContextMenuInfoBorder), y = y, halign = "right" })
		end

		-- header
		headerrow[1]:createText(storageheader, { halign = "center", font = Helper.standardFontBold })
		if showdiscountinfo then
			headerrow[2]:setColSpan(2):createText(ReadText(1001, 11211), { halign = "center", font = Helper.standardFontBold })
		end
		headerrow[2 + coloffset]:setColSpan(3):createText(ReadText(1001, 2006), { halign = "center", font = Helper.standardFontBold })

		-- warning header
		headerrow2[1]:createText(next(warningcontent) and ReadText(1001, 8342) or "", { halign = "center", font = Helper.standardFontBold })

		-- buttons
		local y = math.max(0, warningrows[menu.tradeContext.numwarningrows]:getHeight() - Helper.scaleY(Helper.standardTextHeight))
		if (not GetComponentData(menu.contextMenuData.component, "tradesubscription")) and (#menu.contextMenuData.missionoffers == 0) then
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset]:createButton({ active = (menu.contextMenuData.currentShip ~= 0) and C.IsOrderSelectableFor("Player_DockToTrade", menu.contextMenuData.currentShip), scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 7858), { scaling = true, halign = "center" })
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].handlers.onClick = menu.buttonDockToTrade
		else
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset]:createButton({ active = confirmbuttonactive, helpOverlayID = "map_confirmtrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 2821), { scaling = true, halign = "center" })
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].handlers.onClick = menu.buttonConfirmTrade
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].properties.uiTriggerID = "confirmtrade"
		end
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset]:setColSpan(2):createButton({ scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 64), { scaling = true, halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset].handlers.onClick = menu.buttonCancelTrade
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset].properties.uiTriggerID = "canceltrade"
	end

	if buttontable.properties.y + buttontable:getFullHeight() > Helper.viewHeight - frame.properties.y then
		frame.properties.y = Helper.viewHeight - buttontable.properties.y - buttontable:getFullHeight() - Helper.frameBorder
	end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index
end

function menu.createTradeLoopContext(frame)
	local shiptable = frame:addTable(3, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 11273), Helper.headerRowCenteredProperties)

	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	local name, color = "", Helper.color.white
	if C.IsComponentClass(menu.contextMenuData.component, "container") then
		name, color = menu.getContainerNameAndColors(menu.contextMenuData.component, 0, false, false)
		row[1]:setColSpan(3):createText(ReadText(1001, (menu.contextMenuData.loop == "SingleBuy") and 11110 or 11111) .. ReadText(1001, 120) .. " " .. Helper.convertColorToText(color) .. name, Helper.headerRowCenteredProperties)
	else
		name = ffi.string(C.GetComponentName(menu.contextMenuData.component))
		row[1]:setColSpan(3):createText(ReadText(1001, (menu.contextMenuData.loop == "SingleBuy") and 11112 or 11113) .. ReadText(1001, 120) .. " " .. Helper.convertColorToText(color) .. name, Helper.headerRowCenteredProperties)
	end

	-- ware list
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 11276) .. ReadText(1001, 120))

	local waresinloop = {}
	local maxbought, minsold = {}, {}
	local n = C.GetNumOrders(menu.contextMenuData.currentShip)
	local buf = ffi.new("Order[?]", n)
	n = C.GetOrders(buf, n, menu.contextMenuData.currentShip)
	for i = 0, n - 1 do
		if ffi.string(buf[i].orderdef) == "SingleBuy" then
			local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), i + 1)
			if next(orderparams) then
				local ware
				if orderparams[1].type == "ware" then
					ware = orderparams[1].value
				end
				local maxamount = 0
				if orderparams[5].type == "number" then
					maxamount = math.floor(orderparams[5].value)
				end
				if ware then
					if not waresinloop[ware] then
						waresinloop[ware] = GetWareData(ware, "name")
					end
					if maxbought[ware] then
						maxbought[ware] = math.max(maxamount, maxbought[ware])
					else
						maxbought[ware] = maxamount
					end
				end
			end
		elseif ffi.string(buf[i].orderdef) == "SingleSell" then
			local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), i + 1)
			if next(orderparams) then
				local ware
				if orderparams[1].type == "ware" then
					ware = orderparams[1].value
				end
				local maxamount = 0
				if orderparams[5].type == "number" then
					maxamount = math.floor(orderparams[5].value)
				end
				if ware then
					if not waresinloop[ware] then
						waresinloop[ware] = GetWareData(ware, "name")
					end
					if minsold[ware] then
						minsold[ware] = math.min(maxamount, minsold[ware])
					else
						minsold[ware] = maxamount
					end
				end
			end
		end
	end

	local sortedwares = {}
	for ware, name in pairs(waresinloop) do
		table.insert(sortedwares, { ware = ware, name = name })
	end
	table.sort(sortedwares, Helper.sortName)
	if #sortedwares > 0 then
		for i, entry in ipairs(sortedwares) do
			local row = shiptable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText("   " .. entry.name)
			local availableamount = 0
			if minsold[entry.ware] then
				if maxbought[entry.ware] then
					if minsold[entry.ware] > maxbought[entry.ware] then
						availableamount = maxbought[entry.ware]
					else
						availableamount = minsold[entry.ware]
					end
				end
			elseif maxbought[entry.ware] then
				availableamount = maxbought[entry.ware]
			end
			row[3]:createText(availableamount, { halign = "right" })
			if i == 5 then
				shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
			end
		end
	else
		local row = shiptable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText("   ---")
	end

	-- info & buttons
	local buttontable = frame:addTable(4, { tabOrder = 1, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight(), width = menu.contextMenuData.width })
	local colwidth = math.floor((menu.contextMenuData.width - 2 * Helper.borderSize) / 3)
	local checkboxwidth = Helper.scaleY(Helper.standardTextHeight)
	buttontable:setColWidth(1, checkboxwidth, false)
	buttontable:setColWidth(2, colwidth - checkboxwidth, false)

	-- cargo
	local cargo = GetComponentData(menu.contextMenuData.currentShip, "cargo")
	local extrawares = {}
	for ware, amount in pairs(cargo) do
		if not maxbought[ware] then
			extrawares[ware] = amount
		elseif amount > maxbought[ware] then
			extrawares[ware] = amount - maxbought[ware]
		end
	end

	local transportypes = menu.getCargoTransportTypes(menu.contextMenuData.currentShip, false)
	for _, transporttype in ipairs(transportypes) do
		transporttype.usedcargocapacity = 0
		for ware, amount in pairs(maxbought) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			if transporttype.tags[transport] then
				transporttype.usedcargocapacity = transporttype.usedcargocapacity + amount * volume
			end
		end
		for ware, amount in pairs(extrawares) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			if transporttype.tags[transport] then
				transporttype.usedcargocapacity = transporttype.usedcargocapacity + amount * volume
			end
		end
		transporttype.usedcargocapacity = math.max(0, math.min(transporttype.capacity, transporttype.usedcargocapacity))
		local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createSliderCell({ min = 0, max = transporttype.capacity, start = transporttype.usedcargocapacity, step = 1, suffix = ReadText(1001, 110), readOnly = true, height = Helper.standardTextHeight }):setText(ReadText(1001, 11277))
	end
	
	if menu.contextMenuData.loop == "SingleBuy" then
		-- use ware reservations
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		menu.contextMenuData.reservecargo = C.GetShipTradeLoopCargoReservationSetting(menu.contextMenuData.currentShip)
		row[1]:createCheckBox(menu.contextMenuData.reservecargo, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, mouseOverText = ReadText(1026, 3275) })
		row[1].handlers.onClick = function () C.SetShipTradeLoopCargoReservationOverride(menu.contextMenuData.currentShip, not menu.contextMenuData.reservecargo); menu.refreshContextFrame() end
		row[2]:setColSpan(3):createText(ReadText(1001, 11641), { mouseOverText = ReadText(1026, 3275) })
	end

	buttontable:addEmptyRow(config.mapRowHeight / 2)

	-- destination
	local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 11278))
	row[3]:setColSpan(2):createText(name, { halign = "center" })

	local tradewares, foundwares, currentwareactive = {}, {}
	local tradeoffers = GetTradeList(menu.contextMenuData.component, menu.contextMenuData.currentShip, false)
	for _, tradedata in pairs(tradeoffers) do
		if ((menu.contextMenuData.loop == "SingleBuy") and tradedata.isselloffer) or ((menu.contextMenuData.loop == "SingleSell") and tradedata.isbuyoffer) then
			if not foundwares[tradedata.ware] then
				foundwares[tradedata.ware] = true

				local name, transport = GetWareData(tradedata.ware, "name", "transport")
				local active = C.CanContainerTransport(menu.contextMenuData.currentShip, transport)
				if (tradedata.ware == menu.contextMenuData.ware) and active then
					currentwareactive = true
				end
				table.insert(tradewares, { id = tradedata.ware, text = name, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ReadText(1001, 2969) })
			end
		end
	end
	table.sort(tradewares, function (a, b) return a.text < b.text end)
	if not currentwareactive then
		menu.contextMenuData.ware = nil
	end

	if menu.contextMenuData.loop == "SingleBuy" then
		-- buy ware
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 11279))
		row[3]:setColSpan(2):createDropDown(tradewares, { startOption = menu.contextMenuData.ware, height = config.mapRowHeight }):setTextProperties({ halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, ware) menu.contextMenuData.ware = ware; menu.contextMenuData.amount = nil; menu.contextMenuData.price = nil; menu.refreshContextFrame() end

		-- buy up to
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 11281))
		menu.contextMenuData.max = 1
		if menu.contextMenuData.ware then
			local volume, transport = GetWareData(menu.contextMenuData.ware, "volume", "transport")
			for _, transporttype in ipairs(transportypes) do
				if transporttype.tags[transport] then
					local capacity = transporttype.capacity
					if menu.contextMenuData.reservecargo then
						capacity = capacity - transporttype.usedcargocapacity
					end
					menu.contextMenuData.max = math.floor(capacity / volume)
					if menu.contextMenuData.reservecargo then
						menu.contextMenuData.max = menu.contextMenuData.max + (maxbought[menu.contextMenuData.ware] or 0)
					end
				end
			end
		end
		local minselect = 1
		if menu.contextMenuData.max == 0 then
			minselect = 0
			menu.contextMenuData.amount = 0
		elseif menu.contextMenuData.amount then
			menu.contextMenuData.amount = math.max(minselect, menu.contextMenuData.amount)
		end
		local start = menu.contextMenuData.amount or menu.contextMenuData.max
		start = math.min(start, menu.contextMenuData.max)
		row[3]:setColSpan(2):createSliderCell({ min = 0, minSelect = minselect, max = menu.contextMenuData.max, start = start, step = 1, height = Helper.standardTextHeight })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.amount = value end

		-- max price
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1041, 10059))
		local avgprice, minprice, maxprice = 0, 0, 0
		if menu.contextMenuData.ware then
			avgprice, minprice, maxprice = GetWareData(menu.contextMenuData.ware, "avgprice", "minprice", "maxprice")
		end
		row[3]:setColSpan(2):createSliderCell({ min = minprice, max = maxprice, start = menu.contextMenuData.price or avgprice, step = 1, height = Helper.standardTextHeight, suffix = ReadText(1001, 101), hideMaxValue = true })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.price = value end
	else
		-- sell ware
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 11280))
		row[3]:setColSpan(2):createDropDown(tradewares, { startOption = menu.contextMenuData.ware, height = config.mapRowHeight }):setTextProperties({ halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, ware) menu.contextMenuData.ware = ware; menu.contextMenuData.amount = nil; menu.contextMenuData.price = nil; menu.refreshContextFrame() end

		-- sell all but
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 11601))
		menu.contextMenuData.max = 0
		if menu.contextMenuData.ware then
			menu.contextMenuData.max = GetWareCapacity(menu.contextMenuData.currentShip, menu.contextMenuData.ware)
		end
		row[3]:setColSpan(2):createSliderCell({ min = 0, max = menu.contextMenuData.max, start = menu.contextMenuData.amount or 0, step = 1, height = Helper.standardTextHeight })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.amount = value end

		-- min price
		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1041, 10070))
		local avgprice, minprice, maxprice = 0, 0, 0
		if menu.contextMenuData.ware then
			avgprice, minprice, maxprice = GetWareData(menu.contextMenuData.ware, "avgprice", "minprice", "maxprice")
		end
		row[3]:setColSpan(2):createSliderCell({ min = minprice, max = maxprice, start = menu.contextMenuData.price or avgprice, step = 1, height = Helper.standardTextHeight, suffix = ReadText(1001, 101), hideMaxValue = true })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.price = value end
	end

	buttontable:addEmptyRow(config.mapRowHeight / 2)

	local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	local active = true
	local mouseovertext = ""
	if menu.contextMenuData.ware == nil then
		active = false
		mouseovertext = ReadText(1026, 3260)
	elseif (menu.contextMenuData.loop == "SingleBuy") and (menu.contextMenuData.amount == 0) then
		active = false
		mouseovertext = "\27R" .. ReadText(1001, 1605)
	end
	row[1]:setColSpan(2):createButton({ active = active, mouseOverText = mouseovertext }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonConfirmTradeLoop
	row[4]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[4].handlers.onClick = function () return menu.closeContextMenu("back") end

	if menu.contextselectedrow then
		buttontable:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index

	-- adjust frame position
	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - Helper.frameBorder
	end
	local neededheight = buttontable.properties.y + buttontable:getVisibleHeight()
	if frame.properties.y + neededheight > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.initCrewTransferData()
	menu.contextMenuData.crew = { left = { total = 0, moved = 0, capacity = C.GetPeopleCapacity(menu.contextMenuData.leftShip, "", false), transferList = {} }, right = { total = 0, moved = 0, capacity = C.GetPeopleCapacity(menu.contextMenuData.rightShip, "", false), transferList = {} }, exchangeCaptains = false }
	menu.contextMenuData.crew.right.isplayerowned = true
	if C.IsComponentClass(menu.contextMenuData.rightShip, "station") then
		local isshipyard, iswharf, isequipmentdock, isplayerowned = GetComponentData(menu.contextMenuData.rightShip, "isshipyard", "iswharf", "isequipmentdock", "isplayerowned")
		menu.contextMenuData.crew.right.isstation = true
		menu.contextMenuData.crew.right.isplayerowned = isplayerowned
		if isshipyard or iswharf or isequipmentdock then
			menu.contextMenuData.crew.right.hasshiptraderpost = true
		end
		menu.contextMenuData.crew.right.canhavetrainees = C.CanControllableHaveAnyTrainees(menu.contextMenuData.rightShip)
	end
	local isrightassignmentrestricted = GetComponentData(menu.contextMenuData.rightShip, "isnpcassignmentrestricted")
	menu.contextMenuData.crew.right.canassignpilot = (not menu.contextMenuData.crew.right.isstation) and (not isrightassignmentrestricted)

	local missionnpcrequirements = {}
	menu.contextMenuData.rightMissionOffers = {}
	local numskills = C.GetNumSkills()
	if menu.contextMenuData.crew.right.isstation and (not menu.contextMenuData.crew.right.isplayerowned) then
		-- mission npc requirements
		local n = C.GetNumRequestedMissionNPCs(menu.contextMenuData.rightShip)
		local buf = ffi.new("MissionNPCInfo[?]", n)
		for i = 0, n - 1 do
			buf[i].numskills = numskills
			buf[i].skills = Helper.ffiNewHelper("SkillInfo[?]", numskills)
		end
		n = C.GetRequestedMissionNPCs(buf, n, menu.contextMenuData.rightShip)
		for i = 0, n - 1 do
			local skills = {}
			for j = 0, buf[i].numskills - 1 do
				table.insert(skills, { id = ffi.string(buf[i].skills[j].id), value = buf[i].skills[j].value })
			end
			local missionid = ConvertStringTo64Bit(tostring(buf[i].missionid))
			local amount = buf[i].amount
			table.insert(missionnpcrequirements, { missionid = missionid, amount = amount, requiredskills = skills })
			menu.contextMenuData.rightMissionOffers[tostring(missionid)] = { amount = amount, transferred = 0 }
		end
	end

	-- virtual crew
	local leftvirtualpeople = {}
	local n = C.GetNumPeopleAfterOrders(menu.contextMenuData.leftShip, 0)
	local buf = ffi.new("NPCInfo[?]", n)
	n = C.GetPeopleAfterOrders(buf, n, menu.contextMenuData.leftShip, 0)
	for i = 0, n - 1 do
		local seed = buf[i].seed
		local role = ffi.string(buf[i].roleid)
		local tier = buf[i].tierid
		local name = ffi.string(buf[i].name)
		local skill = math.floor(buf[i].combinedskill * 15 / 100)
		local arrived = C.HasPersonArrived(menu.contextMenuData.leftShip, seed) and (not C.IsPersonTransferScheduled(menu.contextMenuData.leftShip, seed))
		local missionids = menu.checkMissionNPCRequirement(missionnpcrequirements, menu.contextMenuData.leftShip, seed, numskills)

		if menu.contextMenuData.crew.right.isplayerowned or (#missionids > 0) then
			if leftvirtualpeople[role] then
				if leftvirtualpeople[role][tier] then
					table.insert(leftvirtualpeople[role][tier], { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids })
					if arrived then
						leftvirtualpeople[role][tier].numarrived = leftvirtualpeople[role][tier].numarrived + 1
					end
				else
					leftvirtualpeople[role][tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids } }
				end
			else
				leftvirtualpeople[role] = { [tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids } } }
			end
		end
	end
	local rightvirtualpeople = {}
	local n = C.GetNumPeopleAfterOrders(menu.contextMenuData.rightShip, 0)
	local buf = ffi.new("NPCInfo[?]", n)
	n = C.GetPeopleAfterOrders(buf, n, menu.contextMenuData.rightShip, 0)
	for i = 0, n - 1 do
		local seed = buf[i].seed
		local name = ffi.string(buf[i].name)
		local role = ffi.string(buf[i].roleid)
		local tier = buf[i].tierid
		local skill = math.floor(buf[i].combinedskill * 15 / 100)
		if menu.contextMenuData.crew.right.canhavetrainees and (role == "trainee_group") then
			role = "marine"
			tier = C.GetPersonTier(seed, role, menu.contextMenuData.rightShip)
			skill = math.floor(C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, seed, role, nil) * 15 / 100)
		end
		local arrived = C.HasPersonArrived(menu.contextMenuData.rightShip, seed) and (not C.IsPersonTransferScheduled(menu.contextMenuData.rightShip, seed))

		if rightvirtualpeople[role] then
			if rightvirtualpeople[role][tier] then
				table.insert(rightvirtualpeople[role][tier], { seed = seed, name = name, skill = skill, arrived = arrived })
				if arrived then
					rightvirtualpeople[role][tier].numarrived = rightvirtualpeople[role][tier].numarrived + 1
				end
			else
				rightvirtualpeople[role][tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived } }
			end
		else
			rightvirtualpeople[role] = { [tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived } } }
		end
	end

	-- left crew
	local numroles = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numroles)
	numroles = C.GetPeople2(peopletable, numroles, menu.contextMenuData.leftShip, true)
	local index = 1
	for i = 0, numroles - 1 do
		local numtiers = peopletable[i].numtiers
		if numtiers > 0 then
			local role = ffi.string(peopletable[i].id)
			menu.contextMenuData.crew[index] = { id = role, name = ffi.string(peopletable[i].name), tiers = {} }

			local tiertable = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(tiertable, numtiers, menu.contextMenuData.leftShip, role)
			for j = 0, numtiers - 1 do
				local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][tiertable[j].skilllevel] or { numarrived = 0 }) or { numarrived = 0 }

				menu.contextMenuData.crew[index].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, left = { amount = virtualpeopleentry.numarrived, persons = {}, moved = {} }, right = { amount = 0, persons = {}, moved = {} } }
				menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry

				for k, entry in ipairs(virtualpeopleentry) do
					table.insert(menu.contextMenuData.crew[index].tiers[j + 1].left.persons, entry)
				end
			end

			index = index + 1
		end
	end
	-- right crew
	numroles = C.GetPeople2(peopletable, numroles, menu.contextMenuData.rightShip, true)
	index = 1
	for i = 0, numroles - 1 do
		local numtiers = peopletable[i].numtiers
		if numtiers > 0 then
			local role = menu.contextMenuData.crew[index].id
			local tiertable = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(tiertable, numtiers, menu.contextMenuData.rightShip, role)
			for j = 0, numtiers - 1 do
				local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][tiertable[j].skilllevel] or { numarrived = 0 }) or { numarrived = 0 }

				menu.contextMenuData.crew[index].tiers[j + 1].right.amount = virtualpeopleentry.numarrived
				menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry

				for k, entry in ipairs(virtualpeopleentry) do
					table.insert(menu.contextMenuData.crew[index].tiers[j + 1].right.persons, entry)
				end
			end

			index = index + 1
		end
	end
	-- sorting
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			table.sort(tierentry.left.persons, menu.crewTransferSorter)
			table.sort(tierentry.right.persons, menu.crewTransferSorter)
		end
	end
end

function menu.createCrewTransferContext(frame)
	local numberwidth = 50
	local separatorwidth = 2
	local namewidth = 0.35 * menu.contextMenuData.width - 2 * Helper.scaleY(Helper.standardTextHeight) - Helper.scaleX(numberwidth) - separatorwidth / 2 - 5 * Helper.borderSize
	local numListRows = 8

	local shiptable = frame:addTable(11, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	shiptable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidth(2, namewidth, false)
	shiptable:setColWidth(3, numberwidth)
	shiptable:setColWidthPercent(4, 15)
	shiptable:setColWidth(5, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidth(6, separatorwidth, false)
	shiptable:setColWidth(7, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidthPercent(8, 15)
	shiptable:setColWidth(9, numberwidth)
	shiptable:setColWidth(11, Helper.scaleY(Helper.standardTextHeight), false)

	-- title
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(11):createText(ReadText(1001, 8385), Helper.headerRowCenteredProperties)

	-- ships
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	local leftname, lefticon =  GetComponentData(menu.contextMenuData.leftShip, "name", "icon")
	local leftShipName = "\27[" .. lefticon .. "] " .. leftname .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.leftShip)) .. ")"
	row[1]:setColSpan(5):createText(leftShipName, { halign = "center", color = Helper.color.green, font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety })
	local rightname, righticon =  GetComponentData(menu.contextMenuData.rightShip, "name", "icon")
	local rightShipName = "\27[" .. righticon .. "] " .. rightname .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.rightShip)) .. ")"
	row[7]:setColSpan(5):createText(rightShipName, { halign = "center", color = menu.contextMenuData.crew.right.isplayerowned and Helper.color.green or Helper.color.white, font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety })

	shiptable:addEmptyRow(config.mapRowHeight / 2)

	menu.contextMenuData.crew.left.captain = GetComponentData(menu.contextMenuData.leftShip, "assignedaipilot")
	if menu.contextMenuData.crew.left.captain then
		menu.contextMenuData.crew.left.captain = ConvertIDTo64Bit(menu.contextMenuData.crew.left.captain)
	end

	if menu.contextMenuData.crew.right.isplayerowned then
		-- captain
		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		if menu.contextMenuData.crew.right.isstation then
			row[1]:setColSpan(5):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			row[7]:setColSpan(5):createText(ReadText(20208, 30301), Helper.subHeaderTextProperties)
			row[7].properties.halign = "center"
		else
			row[1]:setColSpan(11):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
		end

		if menu.contextMenuData.crew.right.isstation then
			local tradenpc, shiptrader = GetComponentData(menu.contextMenuData.rightShip, "tradenpc", "shiptrader")
			menu.contextMenuData.crew.right.manager = tradenpc
			if menu.contextMenuData.crew.right.manager then
				menu.contextMenuData.crew.right.manager = ConvertIDTo64Bit(menu.contextMenuData.crew.right.manager)
			end
			if menu.contextMenuData.crew.right.hasshiptraderpost then
				menu.contextMenuData.crew.right.shiptrader = shiptrader
				if menu.contextMenuData.crew.right.shiptrader then
					menu.contextMenuData.crew.right.shiptrader = ConvertIDTo64Bit(menu.contextMenuData.crew.right.shiptrader)
				end
			end
		else
			menu.contextMenuData.crew.right.captain = GetComponentData(menu.contextMenuData.rightShip, "assignedaipilot")
			if menu.contextMenuData.crew.right.captain then
				menu.contextMenuData.crew.right.captain = ConvertIDTo64Bit(menu.contextMenuData.crew.right.captain)
			end
		end

		-- current captains
		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		if menu.contextMenuData.crew.left.captain then
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { color = Helper.color.grey })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Helper.color.grey })
		else
			row[1]:setColSpan(3):createText(ReadText(1001, 11232), { color = Helper.color.grey })
		end

		row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })

		if menu.contextMenuData.crew.right.isstation then
			if menu.contextMenuData.crew.right.manager then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.manager, nil, "manager") * 15 / 100), { color = Helper.color.grey })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.manager)), { halign = "right", color = Helper.color.grey })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11255), { halign = "right", color = Helper.color.grey })
			end
		else
			if menu.contextMenuData.crew.right.captain then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.captain, nil, "aipilot") * 15 / 100), { color = Helper.color.grey })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.captain)), { halign = "right", color = Helper.color.grey })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11232), { halign = "right", color = Helper.color.grey })
			end
		end
		-- reassign captains
		local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		if not menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.canassignpilot then
			row[1]:createCheckBox(function () return menu.contextMenuData.crew.left.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, active = (not menu.contextMenuData.crew.exchangeCaptains) or (not menu.contextMenuData.crew.right.captain) })
			row[1].handlers.onClick = function (id) menu.contextMenuData.crew.left.replaceCaptain = not menu.contextMenuData.crew.left.replaceCaptain; menu.checkForNewCaptains() end
			row[2]:setColSpan(4):createText(menu.contextMenuData.crew.left.captain and ReadText(1001, 11234) or ReadText(1001, 11233))
		end

		row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })

		if menu.contextMenuData.crew.right.isstation then
			if not menu.contextMenuData.crew.right.manager then
				row[7]:setColSpan(4):createText(ReadText(1001, 11256), { halign = "right" })
				row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight })
				row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceCaptain = not menu.contextMenuData.crew.right.replaceCaptain; menu.checkForNewCaptains() end
			end
		elseif menu.contextMenuData.crew.right.canassignpilot then
			row[7]:setColSpan(4):createText(menu.contextMenuData.crew.right.captain and ReadText(1001, 11234) or ReadText(1001, 11233), { halign = "right" })
			row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, active = (not menu.contextMenuData.crew.exchangeCaptains) or (not menu.contextMenuData.crew.left.captain) })
			row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceCaptain = not menu.contextMenuData.crew.right.replaceCaptain; menu.checkForNewCaptains() end
		end
		-- new captain
		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		if menu.contextMenuData.crew.exchangeCaptains and menu.contextMenuData.crew.right.captain then
			-- sic! New captain on the left comes from the right ship!
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.captain)), { color = Helper.color.green })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Helper.color.green })
		elseif menu.contextMenuData.crew.left.newCaptain then
			-- sic! New captain on the left comes from the right ship!
			row[1]:setColSpan(3):createText(function () return menu.contextMenuData.crew.left.replaceCaptain and ffi.string(C.GetPersonName(menu.contextMenuData.crew.left.newCaptain, menu.contextMenuData.rightShip)) or "" end, { color = Helper.color.green })
			row[4]:createText(function () return menu.contextMenuData.crew.left.replaceCaptain and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, menu.contextMenuData.crew.left.newCaptain, nil, "aipilot") * 15 / 100) or "" end, { halign = "right", color = Helper.color.green })
		else
			row[1]:setColSpan(5):createText(function () return menu.contextMenuData.crew.left.replaceCaptain and ReadText(1001, 11235) or "" end, { color = Helper.color.red })
		end

		row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })

		if menu.contextMenuData.crew.exchangeCaptains and menu.contextMenuData.crew.left.captain then
			-- sic! New captain on the right comes from the left ship!
			row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { color = Helper.color.green })
			row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { halign = "right", color = Helper.color.green })
		elseif menu.contextMenuData.crew.right.newCaptain then
			-- sic! New captain on the right comes from the left ship!
			row[8]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newCaptain, nil, menu.contextMenuData.crew.right.isstation and "manager" or "aipilot") * 15 / 100) or "" end, { color = Helper.color.green })
			row[10]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and ffi.string(C.GetPersonName(menu.contextMenuData.crew.right.newCaptain, menu.contextMenuData.leftShip)) or "" end, { halign = "right", color = Helper.color.green })
		else
			row[7]:setColSpan(5):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and ReadText(1001, 11235) or "" end, { halign = "right", color = Helper.color.red })
		end
		if ((menu.contextMenuData.crew.left.captain ~= nil) or (menu.contextMenuData.crew.right.captain ~= nil)) and (not menu.contextMenuData.crew.right.isstation) and menu.contextMenuData.crew.right.canassignpilot then
			-- exchange captains
			local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createCheckBox(menu.contextMenuData.crew.exchangeCaptains, {  })
			row[1].handlers.onClick = menu.checkboxCrewExchangeCaptains
			row[2]:setColSpan(4):createText(ReadText(1001, 11639))
		end

		-- shiptrader
		if menu.contextMenuData.crew.right.hasshiptraderpost then
			local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[7]:setColSpan(5):createText(ReadText(20208, 30501), Helper.subHeaderTextProperties)
			row[7].properties.halign = "center"
			-- current ship trader
			local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })
			if menu.contextMenuData.crew.right.shiptrader then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.shiptrader, nil, "shiptrader") * 15 / 100), { color = Helper.color.grey })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.shiptrader)), { halign = "right", color = Helper.color.grey })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11260), { halign = "right", color = Helper.color.grey })
			end
			-- reassign ship trader
			local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })
			if not menu.contextMenuData.crew.right.shiptrader then
				row[7]:setColSpan(4):createText(ReadText(1001, 11261), { halign = "right" })
				row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceShiptrader or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight })
				row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceShiptrader = not menu.contextMenuData.crew.right.replaceShiptrader; menu.checkForNewCaptains() end
			end
			-- new ship trader
			local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })
			if menu.contextMenuData.crew.right.newShiptrader then
				-- sic! New ship trader on the right comes from the left ship!
				row[8]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newShiptrader, nil, "shiptrader") * 15 / 100) or "" end, { color = Helper.color.green })
				row[10]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and ffi.string(C.GetPersonName(menu.contextMenuData.crew.right.newShiptrader, menu.contextMenuData.leftShip)) or "" end, { halign = "right", color = Helper.color.green })
			else
				row[7]:setColSpan(5):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and ReadText(1001, 11235) or "" end, { halign = "right", color = Helper.color.red })
			end
		end

		-- roles
		if (not menu.contextMenuData.crew.right.isstation) or menu.contextMenuData.crew.right.canhavetrainees then
			for i, roleentry in ipairs(menu.contextMenuData.crew) do
				-- title
				local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
				if menu.contextMenuData.crew.right.canhavetrainees then
					row[1]:setColSpan(5):createText(roleentry.name, Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
					row[7]:setColSpan(5):createText(ReadText(20208, 20503), Helper.subHeaderTextProperties)
					row[7].properties.halign = "center"
				else
					row[1]:setColSpan(11):createText(roleentry.name, Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
				end

				-- tiers
				for j, tierentry in ipairs(roleentry.tiers) do
					local color = Helper.color.white
					if (tierentry.left.amount == 0) and (tierentry.right.amount == 0) then
						color = Helper.color.grey
					end

					local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
					row[1]:setColSpan(2):createText(tierentry.name, { color = color })
					row[3]:createText(function () return tierentry.left.amount - #tierentry.left.moved + #tierentry.right.moved end, { halign = "right", color = function () return menu.crewTransferColorHelper("left", tierentry, color) end })
					row[4]:setColSpan(5):createSliderCell({ start = #tierentry.right.moved - #tierentry.left.moved, min = -tierentry.left.amount, max = tierentry.right.amount, step = 1, fromCenter = true, rightToLeft = true, height = Helper.standardTextHeight })
					row[4].handlers.onSliderCellChanged = function (_, value) return menu.slidercellCrewTransfer(i, j, value) end
					row[4].handlers.onSliderCellConfirm = menu.checkForNewCaptains
					row[9]:createText(function () return tierentry.right.amount - #tierentry.right.moved + #tierentry.left.moved end, { halign = "right", color = function () return menu.crewTransferColorHelper("right", tierentry, color) end })
				end
			end

			shiptable:addEmptyRow(config.mapRowHeight / 2)

			-- total
			local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 2637))
			row[3]:createText(function () return menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved end, { halign = "right", color = function () return menu.crewTransferTotalColor("left") end })
			row[4]:setColSpan(5):createText("/ " .. menu.contextMenuData.crew.left.capacity, { x = 0 })
			row[9]:createText(function () return menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved end, { halign = "right", color = function () return menu.crewTransferTotalColor("right") end })
			row[10]:setColSpan(2):createText("/ " .. menu.contextMenuData.crew.right.capacity, { x = 0 })

			shiptable:addEmptyRow(config.mapRowHeight / 2)

			-- full list toggle
			local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createButton({  }):setText(menu.contextMenuData.fullshown and ReadText(1001, 8387) or ReadText(1001, 8388), { halign = "center" })
			row[1].handlers.onClick = menu.buttonCrewTransferToggleList
		end
	else
		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"

		-- current captain
		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		if menu.contextMenuData.crew.left.captain then
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { color = Helper.color.grey })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Helper.color.grey })
		else
			row[1]:setColSpan(3):createText(ReadText(1001, 11232), { color = Helper.color.grey })
		end

		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 11299), { wordwrap = true })
	end

	if menu.contextMenuData.fullshown or (menu.contextMenuData.crew.right.isstation and (not menu.contextMenuData.crew.right.canhavetrainees)) then
		-- title
		local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(11):createText(ReadText(1001, 8386), Helper.headerRowCenteredProperties)

		local rowcount = 0
		for i, roleentry in ipairs(menu.contextMenuData.crew) do
			-- roles
			local row = shiptable:addRow(nil, { bgColor = Helper.color.transparent })
			if menu.contextMenuData.crew.right.canhavetrainees then
				row[1]:setColSpan(5):createText(roleentry.name, Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
				row[7]:setColSpan(5):createText(ReadText(20208, 20503), Helper.subHeaderTextProperties)
				row[7].properties.halign = "center"
			else
				row[1]:setColSpan(11):createText(roleentry.name, Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
			end
			rowcount = rowcount + 1
			if rowcount == numListRows then
				shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
			end

			-- tiers
			for j, tierentry in ipairs(roleentry.tiers) do
				local isextended = menu.contextMenuData.extendedTier[i .. j]

				local row = shiptable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createButton({ active = function () return #tierentry.left.persons + #tierentry.left.moved + #tierentry.right.persons + #tierentry.right.moved > 0 end }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonCrewTransferExtend(i, j) end
				row[2]:setColSpan(9):createText(tierentry.name, { color = color })
				rowcount = rowcount + 1
				if rowcount == numListRows then
					shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
				end

				if isextended then
					local personpool = {}
					for _, person in ipairs(tierentry.left.persons) do
						table.insert(personpool, person)
					end
					for _, person in ipairs(tierentry.left.moved) do
						table.insert(personpool, person)
					end
					table.sort(personpool, menu.crewTransferSorter)
					for _, person in ipairs(personpool) do
						local row = shiptable:addRow(true, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(2):createText("   " .. person.name, { color = function () return ((not person.arrived) or menu.contextMenuData.crew.left.transferList[person.seed]) and Helper.color.grey or Helper.color.white end, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[4]:createText(Helper.displaySkill(person.skill), { halign = "right", color = function () return menu.contextMenuData.crew.left.transferList[person.seed] and Helper.color.yellow or Helper.color.brightyellow end })
						row[5]:createCheckBox(function () return not menu.contextMenuData.crew.left.transferList[person.seed] end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[5].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "left", person.seed, true) end
						row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })
						row[7]:createCheckBox(function () return menu.contextMenuData.crew.left.transferList[person.seed] or false end, { height = Helper.standardTextHeight, active = menu.isPersonTransferPossible(person), mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[7].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "left", person.seed, false) end
						if menu.contextMenuData.crew.right.isplayerowned then
							row[8]:createText(function () return menu.contextMenuData.crew.left.transferList[person.seed] and Helper.displaySkill(person.skill) or "" end, { color = Helper.color.green })
							row[9]:setColSpan(3):createText(function () return menu.personName(person, "left", "right") end, { halign = "right", color = Helper.color.green })
						elseif menu.contextMenuData.crew.left.transferList[person.seed] then
							if #person.missionids == 1 then
								local mission = menu.getMissionIDInfoHelper(person.missionids[1])
								row[8]:setColSpan(2):createText(mission.name, { color = Helper.color.mission })
							else
								local missions = {}
								for _, missionid in ipairs(person.missionids) do
									local mission = menu.getMissionIDInfoHelper(missionid)
									local active = (person.selectedmissionid == missionid) or (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred)
									table.insert(missions, { id = tostring(missionid), text = mission.name, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ReadText(1026, 3250) })
								end
								row[8]:setColSpan(2):createDropDown(missions, { startOption = tostring(person.selectedmissionid), height = config.mapRowHeight, optionWidth = 2 * row[8]:getColSpanWidth() }):setTextProperties({ color = Helper.color.mission })
								row[8].handlers.onDropDownConfirmed = function (_, missionid) return menu.dropdownCrewTransferSelectMission(person, missionid) end
							end
							row[10]:setColSpan(2):createText(function () return menu.personName(person, "left", "right") end, { halign = "right", color = Helper.color.green })
						end

						rowcount = rowcount + 1
						if rowcount == numListRows then
							shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
						end
					end

					if menu.contextMenuData.crew.right.isplayerowned then
						personpool = {}
						for _, person in ipairs(tierentry.right.persons) do
							table.insert(personpool, person)
						end
						for _, person in ipairs(tierentry.right.moved) do
							table.insert(personpool, person)
						end
						table.sort(personpool, menu.crewTransferSorter)
						for _, person in ipairs(personpool) do
							local row = shiptable:addRow(true, { bgColor = Helper.color.transparent })
							row[2]:setColSpan(2):createText(function () return menu.personName(person, "right", "left") end, { color = Helper.color.green })
							row[4]:createText(function () return menu.contextMenuData.crew.right.transferList[person.seed] and Helper.displaySkill(person.skill) or "" end, { halign = "right", color = Helper.color.green })
							row[5]:createCheckBox(function () return menu.contextMenuData.crew.right.transferList[person.seed] or false end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
							row[5].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "right", person.seed, false) end
							row[6]:createText("", { cellBGColor = Helper.color.white, x = 0 })
							row[7]:createCheckBox(function () return not menu.contextMenuData.crew.right.transferList[person.seed] end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
							row[7].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "right", person.seed, true) end
							row[8]:createText(Helper.displaySkill(person.skill), { color = function () return menu.contextMenuData.crew.right.transferList[person.seed] and Helper.color.yellow or Helper.color.brightyellow end })
							row[9]:setColSpan(3):createText(person.name, { halign = "right", color = function () return ((not person.arrived) or menu.contextMenuData.crew.right.transferList[person.seed]) and Helper.color.grey or Helper.color.white end, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })

							rowcount = rowcount + 1
							if rowcount == numListRows then
								shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
							end
						end
					end
				end
			end
		end
	end

	if menu.contexttoprow then
		shiptable:setTopRow(menu.contexttoprow)
		menu.contexttoprow = nil
	end
	if menu.contextselectedrow then
		shiptable:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end

	-- warnings and buttons
	local buttontable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight(), width = menu.contextMenuData.width })
	buttontable:setColWidthPercent(2, 25)
	buttontable:setColWidthPercent(3, 25)

	local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(function () return menu.crewTransferWarningText(leftname, rightname, 1) end, { halign = "right", color = Helper.color.red })
	local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(function () return menu.crewTransferWarningText(leftname, rightname, 2) end, { halign = "right", color = Helper.color.red })

	local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton({ active = menu.crewTransferAllowed }):setText(ReadText(1001, 2821), { halign = "center" })
	row[2].handlers.onClick = menu.buttonCrewTransferConfirm
	row[3]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[3].handlers.onClick = function () return menu.closeContextMenu("back") end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index

	-- adjust frame position
	local neededheight = buttontable.properties.y + buttontable:getVisibleHeight()
	if frame.properties.y + neededheight > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.isPersonTransferPossible(person)
	if menu.contextMenuData.crew.right.isstation then
		if person.missionids and (#person.missionids > 0) then
			local ispossible = false
			for _, missionid in ipairs(person.missionids) do
				if menu.contextMenuData.rightMissionOffers[tostring(missionid)] and (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred) then
					ispossible = true
					break
				end
			end
			return person.arrived and ispossible
		else
			local missingmanager = false
			if (menu.contextMenuData.crew.right.replaceCaptain == true) and (not menu.contextMenuData.crew.right.newCaptain) then
				missingmanager = true
			end
			local missingshiptrader = false
			if menu.contextMenuData.crew.right.hasshiptraderpost then
				if (menu.contextMenuData.crew.right.replaceShiptrader == true) and (not menu.contextMenuData.crew.right.newShiptrader) then
					missingshiptrader = true
				end
			end
			return person.arrived and ((missingmanager or missingshiptrader) or menu.contextMenuData.crew.right.canhavetrainees)
		end
	else
		return person.arrived
	end
end

function menu.personName(person, origin, target)
	local name = ""
	if menu.contextMenuData.crew[origin].transferList[person.seed] then
		name = person.name
	end
	if menu.contextMenuData.crew[target].replaceCaptain and (menu.contextMenuData.crew[target].newCaptain == person.seed) then
		name = name .. " [" .. (menu.contextMenuData.crew[target].isstation and ReadText(1001, 11258) or ReadText(1001, 11236)) .. "]"
	end
	if menu.contextMenuData.crew[target].replaceShiptrader and (menu.contextMenuData.crew[target].newShiptrader == person.seed) then
		name = name .. " [" .. ReadText(1001, 11263) .. "]"
	end
	return name
end

function menu.checkMissionNPCRequirement(missionnpcrequirements, controllable, seed, numskills)
	local missionids = {}

	local skills = {}
	local buf = ffi.new("SkillInfo[?]", numskills)
	local n = C.GetPersonSkills3(buf, numskills, seed, controllable)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		skills[id] = buf[i].value
	end

	for _, entry in ipairs(missionnpcrequirements) do
		local matchesrequirement = true
		for _, requiredskill in ipairs(entry.requiredskills) do
			if requiredskill.value > skills[requiredskill.id] then
				matchesrequirement = false
				break
			end
		end
		if matchesrequirement then
			table.insert(missionids, entry.missionid)
		end
	end

	return missionids
end

function menu.crewTransferSorter(a, b)
	if a.skill == b.skill then
		return a.name < b.name
	end
	return a.skill > b.skill 
end

function menu.slidercellCrewTransfer(i, j, value)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	local current = #tierentry.right.moved - #tierentry.left.moved
	if value ~= current then
		local change = value - current
		if change > 0 then
			if #tierentry.left.moved > 0 then
				local moveAmount = math.min(change, #tierentry.left.moved)
				for count = 1, moveAmount do
					menu.unmovePerson("left", i, j)
				end
				change = change - moveAmount
			end
			if change > 0 then
				for count = 1, change do
					menu.movePerson("right", i, j)
				end
			end
		elseif change < 0 then
			if #tierentry.right.moved > 0 then
				local moveAmount = math.min(-change, #tierentry.right.moved)
				for count = 1, moveAmount do
					menu.unmovePerson("right", i, j)
				end
				change = change + moveAmount
			end
			if change < 0 then
				for count = 1, -change do
					menu.movePerson("left", i, j)
				end
			end
		end

		table.sort(tierentry.left.persons, menu.crewTransferSorter)
		table.sort(tierentry.right.persons, menu.crewTransferSorter)
	end
end

function menu.checkForNewCaptains()
	local changedcaptain
	if menu.contextMenuData.crew.left.replaceCaptain then
		local currentskill
		-- sic! New captain on the left comes from the right ship!
		if menu.contextMenuData.crew.left.newCaptain then
			if menu.contextMenuData.crew.right.transferList[menu.contextMenuData.crew.left.newCaptain] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, menu.contextMenuData.crew.left.newCaptain, nil, "aipilot")
			else
				menu.contextMenuData.crew.left.newCaptain = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.right.transferList) then
			for seed in pairs(menu.contextMenuData.crew.right.transferList) do
				local skill = C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, seed, nil, "aipilot")
				if (not menu.contextMenuData.crew.left.newCaptain) or (skill > currentskill) then
					menu.contextMenuData.crew.left.newCaptain = seed
					currentskill = skill
					changedcaptain = true
				end
			end
		end
	else
		menu.contextMenuData.crew.left.newCaptain = nil
	end

	if menu.contextMenuData.crew.right.replaceCaptain then
		local currentskill
		-- sic! New captain on the right comes from the left ship!
		if menu.contextMenuData.crew.right.newCaptain then
			if menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newCaptain] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newCaptain, nil, menu.contextMenuData.crew.right.isstation and "manager" and "aipilot")
			else
				menu.contextMenuData.crew.right.newCaptain = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.left.transferList) then
			for seed in pairs(menu.contextMenuData.crew.left.transferList) do
				local skill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, seed, nil, menu.contextMenuData.crew.right.isstation and "manager" and "aipilot")
				if (not menu.contextMenuData.crew.right.newCaptain) or (skill > currentskill) then
					menu.contextMenuData.crew.right.newCaptain = seed
					currentskill = skill
					changedcaptain = true
				end
			end
		end
		if menu.contextMenuData.crew.right.newCaptain == menu.contextMenuData.crew.right.newShiptrader then
			menu.contextMenuData.crew.right.newShiptrader = nil
		end
	else
		if menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.newCaptain then
			menu.unmoveNewPostNPCHelper(menu.contextMenuData.crew.right.newCaptain, "left")
		end
		menu.contextMenuData.crew.right.newCaptain = nil
	end
	if menu.contextMenuData.crew.right.replaceShiptrader then
		local currentskill
		-- sic! New ship trader on the right comes from the left ship!
		if menu.contextMenuData.crew.right.newShiptrader then
			if menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newShiptrader] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newShiptrader, nil, "shiptrader")
			else
				menu.contextMenuData.crew.right.newShiptrader = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.left.transferList) then
			for seed in pairs(menu.contextMenuData.crew.left.transferList) do
				-- choose best npc for captain/manager and skip them for shiptrader
				if seed ~= menu.contextMenuData.crew.right.newCaptain then
					local skill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, seed, nil, "shiptrader")
					if (not menu.contextMenuData.crew.right.newShiptrader) or (skill > currentskill) then
						menu.contextMenuData.crew.right.newShiptrader = seed
						currentskill = skill
						changedcaptain = true
					end
				end
			end
		end
	else
		if menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.newShiptrader then
			menu.unmoveNewPostNPCHelper(menu.contextMenuData.crew.right.newShiptrader, "left")
		end
		menu.contextMenuData.crew.right.newShiptrader = nil
	end

	if changedcaptain or menu.contextMenuData.crew.right.isstation then
		menu.refreshContextFrame()
	end
end

function menu.unmoveNewPostNPCHelper(seed, origin)
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			for k, person in ipairs(tierentry[origin].moved) do
				if person.seed == seed then
					menu.unmovePerson(origin, i, j, person, k)
					return
				end
			end
		end
	end
end

function menu.movePerson(origin, i, j, person, k)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	if person then
		table.remove(tierentry[origin].persons, k)
	else
		for i, possibleperson in ipairs(tierentry[origin].persons) do
			if possibleperson.arrived then
				person = possibleperson
				table.remove(tierentry[origin].persons, i)
				break
			end
		end
	end
	table.insert(tierentry[origin].moved, person)
	menu.contextMenuData.crew[origin].moved = menu.contextMenuData.crew[origin].moved + 1
	menu.contextMenuData.crew[origin].transferList[person.seed] = true
	if person.missionids and (#person.missionids > 0) then
		for _, missionid in ipairs(person.missionids) do
			if menu.contextMenuData.rightMissionOffers[tostring(missionid)] and (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred) then
				person.selectedmissionid = missionid
				break
			end
		end
		if menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)] then
			menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred + 1
		end
	end
end

function menu.unmovePerson(origin, i, j, person, k)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]
	
	if person then
		table.remove(tierentry[origin].moved, k)
	else
		for i = #tierentry[origin].moved, 1, -1 do
			local possibleperson = tierentry[origin].moved[i]
			if possibleperson.arrived then
				person = possibleperson
				table.remove(tierentry[origin].moved, i)
				break
			end
		end
	end
	table.insert(tierentry[origin].persons, person)
	menu.contextMenuData.crew[origin].moved = menu.contextMenuData.crew[origin].moved - 1
	menu.contextMenuData.crew[origin].transferList[person.seed] = nil
	if person.missionids and (#person.missionids > 0) then
		if menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)] then
			menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred - 1
			person.selectedmissionid = nil
		end
	end
end

function menu.crewTransferColorHelper(origin, tierentry, basecolor)
	if (#tierentry.left.moved > 0) or (#tierentry.right.moved > 0) then
		if #tierentry.left.moved == #tierentry.right.moved then
			return Helper.color.brightyellow
		elseif #tierentry.right.moved > #tierentry.left.moved then
			if origin == "left" then
				return Helper.color.green
			else
				return Helper.color.red
			end
		else
			if origin == "left" then
				return Helper.color.red
			else
				return Helper.color.green
			end
		end
	end
	return basecolor
end

function menu.crewTransferWarningText(leftname, rightname, row)
	local count = 0
	local warning = ""
	if menu.contextMenuData.crew.right.isplayerowned then
		if menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved > menu.contextMenuData.crew.left.capacity then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 8389), leftname)
			end
		elseif menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved > menu.contextMenuData.crew.right.capacity then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 8389), rightname)
			end
		end
		if menu.contextMenuData.crew.left.replaceCaptain and (not menu.contextMenuData.crew.left.newCaptain) then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 11237), leftname)
			end
		end
		if menu.contextMenuData.crew.right.replaceCaptain and (not menu.contextMenuData.crew.right.newCaptain) then
			count = count + 1
			if count == row then
				return string.format(menu.contextMenuData.crew.right.isstation and ReadText(1001, 11259) or ReadText(1001, 11237), rightname)
			end
		end
		if menu.contextMenuData.crew.right.replaceShiptrader and (not menu.contextMenuData.crew.right.newShiptrader) then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 11264), rightname)
			end
		end
		local valid, reason = menu.performCrewExchange(true)
		if not valid then
			count = count + 1
			if count == row then
				return menu.hireReasonLookup(reason, true)
			end
		end
	else
		local availablecrew = 0
		for i, roleentry in ipairs(menu.contextMenuData.crew) do
			for j, tierentry in ipairs(roleentry.tiers) do
				availablecrew = availablecrew + #tierentry.left.persons + #tierentry.left.moved
			end
		end
		if availablecrew == 0 then
			count = count + 1
			if count == row then
				return ReadText(1001, 11265)
			end
		end
	end
	return warning
end

function menu.crewTransferTotalColor(origin)
	if menu.contextMenuData.crew[origin].total - menu.contextMenuData.crew[origin].moved + menu.contextMenuData.crew[(origin == "left") and "right" or "left"].moved > menu.contextMenuData.crew[origin].capacity then
		return Helper.color.red
	end
	return Helper.color.white
end

function menu.dropdownCrewTransferSelectMission(person, missionid)
	menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred - 1
	person.selectedmissionid = ConvertStringTo64Bit(missionid)
	menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred + 1

	menu.refreshContextFrame()
end

function menu.crewTransferAllowed()
	if not menu.contextMenuData.crew.right.isplayerowned then
		return menu.contextMenuData.crew.left.moved > 0
	end
	if menu.contextMenuData.crew.left.replaceCaptain and (not menu.contextMenuData.crew.left.newCaptain) then
		return false
	end
	if menu.contextMenuData.crew.right.replaceCaptain and (not menu.contextMenuData.crew.right.newCaptain) then
		return false
	end
	if menu.contextMenuData.crew.right.replaceShiptrader and (not menu.contextMenuData.crew.right.newShiptrader) then
		return false
	end
	if (menu.contextMenuData.crew.left.moved > 0) or (menu.contextMenuData.crew.right.moved > 0) or menu.contextMenuData.crew.exchangeCaptains then
		if (menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved <= menu.contextMenuData.crew.left.capacity) and
			(menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved <= menu.contextMenuData.crew.right.capacity) then
				return menu.performCrewExchange(true)
		end
	end
	return false
end

function menu.getMissionInfoFromPerson(seed, origin)
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			for k, person in ipairs(tierentry[origin].moved) do
				if person.seed == seed then
					return person.selectedmissionid
				end
			end
		end
	end
end

function menu.buttonCrewTransferConfirm()
	if not menu.contextMenuData.crew.right.isplayerowned then
		for seed in pairs(menu.contextMenuData.crew.left.transferList) do
			C.SignalObjectWithNPCSeedAndMissionID(menu.contextMenuData.rightShip, "npctemplate_mission_delivery", menu.getMissionInfoFromPerson(seed, "left"), seed, menu.contextMenuData.leftShip)
		end
	else
		if menu.contextMenuData.crew.right.isstation then
			if menu.contextMenuData.crew.right.replaceCaptain and menu.contextMenuData.crew.right.newCaptain then
				-- sic! New manager on the right comes from the left ship!
				local actor = { entity = nil, personcontrollable = menu.contextMenuData.leftShip, personseed = menu.contextMenuData.crew.right.newCaptain }
				C.AssignHiredActor(actor, menu.contextMenuData.rightShip, "manager", nil, false)
				-- need to clean this up in case we will transfer further npcs as trainees
				menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newCaptain] = nil
				menu.contextMenuData.crew.left.moved = menu.contextMenuData.crew.left.moved - 1
				menu.contextMenuData.crew.right.newCaptain = nil
				menu.contextMenuData.crew.right.replaceCaptain = nil
			end
			if menu.contextMenuData.crew.right.replaceShiptrader and menu.contextMenuData.crew.right.newShiptrader then
				-- sic! New ship trader on the right comes from the left ship!
				local actor = { entity = nil, personcontrollable = menu.contextMenuData.leftShip, personseed = menu.contextMenuData.crew.right.newShiptrader }
				C.AssignHiredActor(actor, menu.contextMenuData.rightShip, "shiptrader", nil, false)
				-- need to clean this up in case we will transfer further npcs as trainees
				menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newShiptrader] = nil
				menu.contextMenuData.crew.left.moved = menu.contextMenuData.crew.left.moved - 1
				menu.contextMenuData.crew.right.newShiptrader = nil
				menu.contextMenuData.crew.right.replaceShiptrader = nil
			end
			if menu.contextMenuData.crew.right.canhavetrainees then
				menu.performCrewExchange(false)
			end
		else
			menu.performCrewExchange(false)
		end
	end
	menu.updatePeopleInfo = getElapsedTime()
	menu.closeContextMenu("back")
end

function menu.performCrewExchange(checkonly)
	local exchangecaptains = menu.contextMenuData.crew.exchangeCaptains
	local captainfromleft = menu.contextMenuData.crew.right.replaceCaptain and menu.contextMenuData.crew.right.newCaptain or 0
	local captainfromright = menu.contextMenuData.crew.left.replaceCaptain and menu.contextMenuData.crew.left.newCaptain or 0
	local hascaptainfromleft, hascaptainfromright

	if menu.contextMenuData.crew.left.moved < 0 then
		DebugError("Invalid amount of moved crew, aborting")
		print(TraceBack())
		return false, "invalid"
	end
	if menu.contextMenuData.crew.right.moved < 0 then
		DebugError("Invalid amount of moved crew, aborting")
		print(TraceBack())
		return false, "invalid"
	end

	if exchangecaptains and ((menu.contextMenuData.crew.left.captain and (captainfromleft ~= 0)) or (menu.contextMenuData.crew.right.captain and (captainfromright ~= 0))) then
		return false, "invalid"
	end

	local i = 0
	local leftnpcs = ffi.new("NPCSeed[?]", menu.contextMenuData.crew.left.moved)
	for seed in pairs(menu.contextMenuData.crew.left.transferList) do
		leftnpcs[i] = seed
		if seed == captainfromleft then
			hascaptainfromleft = true
		end
		i = i + 1
	end
	i = 0
	local rightnpcs = ffi.new("NPCSeed[?]", menu.contextMenuData.crew.right.moved)
	for seed in pairs(menu.contextMenuData.crew.right.transferList) do
		rightnpcs[i] = seed
		if seed == captainfromright then
			hascaptainfromright = true
		end
		i = i + 1
	end

	if (hascaptainfromleft or (captainfromleft == 0)) and (hascaptainfromright or (captainfromright == 0)) then
		local result = C.PerformCrewExchange2(menu.contextMenuData.leftShip, menu.contextMenuData.rightShip, leftnpcs, menu.contextMenuData.crew.left.moved, rightnpcs, menu.contextMenuData.crew.right.moved, captainfromleft, captainfromright, exchangecaptains, checkonly)
		local reason = ffi.string(result.reason)
		return reason == "", reason;
	end
	return false, "invalid"
end

function menu.buttonCrewTransferToggleList()
	menu.contextMenuData.fullshown = not menu.contextMenuData.fullshown
	menu.refreshContextFrame()
end

function menu.buttonCrewTransferExtend(i, j)
	if menu.contextMenuData.extendedTier[i .. j] then
		menu.contextMenuData.extendedTier[i .. j] = nil
	else
		menu.contextMenuData.extendedTier[i .. j] = true
	end
	menu.refreshContextFrame()
end

function menu.checkboxCrewTransfer(id, i, j, origin, seed, isorigin)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	local person, personidx
	if isorigin then
		for k, personentry in ipairs(tierentry[origin].moved) do
			if personentry.seed == seed then
				person = personentry
				personidx = k
				break
			end
		end
	else
		for k, personentry in ipairs(tierentry[origin].persons) do
			if personentry.seed == seed then
				person = personentry
				personidx = k
				break
			end
		end
	end

	if person then
		if menu.contextMenuData.crew[origin].transferList[person.seed] and isorigin then
			menu.unmovePerson(origin, i, j, person, personidx)
		elseif (not menu.contextMenuData.crew[origin].transferList[person.seed]) and (not isorigin) then
			menu.movePerson(origin, i, j, person, personidx)
		end
		table.sort(tierentry[origin].persons, menu.crewTransferSorter)
		if not menu.contextMenuData.crew.right.isstation then
			Helper.setSliderCellValue(menu.contexttable, 4 + 4 * i + j, 4, #tierentry.right.moved - #tierentry.left.moved)
		end
	else
		C.SetCheckBoxChecked2(id, true, true)
	end

	menu.checkForNewCaptains()
end

function menu.checkboxCrewExchangeCaptains()
	menu.contextMenuData.crew.exchangeCaptains = not menu.contextMenuData.crew.exchangeCaptains
	-- If we have a captain on the left ship, we cannot replace the captain on the right ship with another crewmember anymore
	if menu.contextMenuData.crew.left.captain then
		menu.contextMenuData.crew.right.newCaptain = nil
		menu.contextMenuData.crew.right.replaceCaptain = nil
	end
	-- If we have a captain on the right ship, we cannot replace the captain on the left ship with another crewmember anymore
	if menu.contextMenuData.crew.right.captain then
		menu.contextMenuData.crew.left.newCaptain = nil
		menu.contextMenuData.crew.left.replaceCaptain = nil
	end

	menu.refreshContextFrame()
end

function menu.createRenameContext(frame)
	local title = menu.contextMenuData.fleetrename and ReadText(1001, 7895) or ReadText(1001, 1114)
	local startname = menu.contextMenuData.fleetrename and ffi.string(C.GetFleetName(menu.contextMenuData.component)) or ffi.string(C.GetComponentName(menu.contextMenuData.component))

	local shiptable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(title, Helper.headerRowCenteredProperties)

	local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	menu.contextMenuData.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = config.mapRowHeight, description = title }):setText(startname)
	row[1].handlers.onTextChanged = function (_, text, textchanged) menu.contextMenuData.newtext = text end
	row[1].handlers.onEditBoxDeactivated = menu.buttonRenameConfirm

	local row = shiptable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonRenameConfirm
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.closeContextMenu("back") end

	-- adjust frame position
	local neededheight = shiptable.properties.y + shiptable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createChangeLogoContext(frame)
	local title = ReadText(1001, 11133)

	local colwidth = math.floor((menu.contextMenuData.width - 4 * Helper.borderSize) / 5)
	local logotable = frame:addTable(5, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = 5 * (colwidth + Helper.borderSize) - Helper.borderSize, highlightMode = "off" })

	-- title
	local row = logotable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText(title, Helper.headerRowCenteredProperties)

	local logooptiondata = { {{}, ReadText(1001, 9126)}, {{}, ReadText(1001, 9127)} }

	local numlogos = C.GetNumPlayerLogos(true, false)
	local logos = ffi.new("UILogo[?]", numlogos)
	numlogos = C.GetPlayerLogos(logos, numlogos, true, false)
	for i = 0, numlogos - 1 do
		table.insert(logooptiondata[1][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
	end

	numlogos = C.GetNumPlayerLogos(false, true)
	logos = ffi.new("UILogo[?]", numlogos)
	numlogos = C.GetPlayerLogos(logos, numlogos, false, true)
	for i = 0, numlogos - 1 do
		table.insert(logooptiondata[2][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
	end

	local row
	for _, logodata in ipairs(logooptiondata) do
		row = logotable:addRow(nil, { bgColor = Helper.defaultHeaderBackgroundColor })
		row[1]:setColSpan(5):createText(logodata[2], Helper.headerRowCenteredProperties)

		if #logodata[1] > 0 then
			for i, logo in ipairs(logodata[1]) do
				local loccol = i % 5
				if loccol == 0 then
					loccol = 5
				end
				if loccol == 1 then
					row = logotable:addRow("logos", { bgColor = Helper.color.transparent })
				end

				row[loccol]:createButton({ height = colwidth, scaling = false }):setIcon(logo.icon):setIcon2(function() return menu.contextChangeLogoButtonIcon2(logo) end, { color = function() return menu.contextChangeLogoButtonIcon2Color(logo) end })
				row[loccol].handlers.onClick = function() return menu.buttonContextSetLogo(logo) end

				if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
					logotable:setSelectedRow(row.index)
					logotable:setSelectedCol(loccol)
				end
			end
		else
			row = logotable:addRow("logos", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 9132) .. " ---")
		end
	end

	local buttontable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = 5 * (colwidth + Helper.borderSize) - Helper.borderSize, highlightMode = "off" })
	buttontable:addEmptyRow()
	local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () menu.contextMenuData.origlogo = nil; return menu.closeContextMenu("back") end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = menu.buttonChangeLogoCancel
	row[3]:createButton({ active = function () return menu.contextMenuData.currentlogo.file ~= "" end }):setText(ReadText(1001, 11640), { halign = "center" })
	row[3].handlers.onClick = function () menu.contextMenuData.currentlogo = { file = "", icon = "", ispersonal = false}; return C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.currentlogo) end

	local buttonheight = buttontable:getFullHeight()
	if logotable:getFullHeight() + buttonheight + Helper.borderSize > Helper.viewHeight - 2 * Helper.frameBorder then
		logotable.properties.maxVisibleHeight = Helper.viewHeight - 2 * Helper.frameBorder - buttonheight - Helper.borderSize
	end
	buttontable.properties.y = logotable.properties.y + logotable:getVisibleHeight() + Helper.borderSize

	-- adjust frame position
	local neededheight = logotable.properties.y + logotable:getVisibleHeight() + Helper.borderSize + buttonheight
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.contextChangeLogoButtonIcon2(logo)
	if (logo.icon == menu.contextMenuData.currentlogo.icon) and (logo.ispersonal == menu.contextMenuData.currentlogo.ispersonal) then
		return "be_upgrade_installed"
	end
	if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
		return "be_upgrade_uninstalled"
	end
	return "solid"
end

function menu.contextChangeLogoButtonIcon2Color(logo)
	if (logo.icon == menu.contextMenuData.currentlogo.icon) and (logo.ispersonal == menu.contextMenuData.currentlogo.ispersonal) then
		return Helper.color.green
	end
	if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
		return Helper.color.red
	end
	return Helper.color.transparent
end

function menu.createHireContext(frame)
	local isplayerowned = GetComponentData(menu.contextMenuData.hireObject, "isplayerowned")

	local ftable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0

	-- title
	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })

	local name = ffi.string(C.GetComponentName(menu.contextMenuData.hireObject))
	local idcode = " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.hireObject)) .. ")"

	local halign = "center"
	if math.ceil(C.GetTextWidth(name .. idcode, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize))) > menu.contextMenuData.width - 2 * Helper.scaleX(Helper.standardButtonWidth) then
		halign = "left"
		local idcodewidth = math.ceil(C.GetTextWidth(idcode, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)))
		name = TruncateText(name, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), menu.contextMenuData.width - Helper.scaleX(Helper.standardTextOffsetx) - idcodewidth - Helper.scaleX(Helper.standardButtonWidth))
	end

	row[1]:setColSpan(2):createText(name .. idcode, Helper.headerRowCenteredProperties)
	row[1].properties.halign = halign
	if isplayerowned then
		row[1].properties.color = menu.holomapcolor.playercolor
	end

	-- Possible Roles
	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 3259))
	local row = ftable:addRow(true, { fixed = true })
	local actor = { entity = npc, personcontrollable = object, personseed = npcseed }

	local roleOptions = {}
	if isplayerowned then
		-- posts
		local n, buf
		if npc then
			n = C.GetNumSuitableControlPosts(menu.contextMenuData.hireObject, npc, false)
			buf = ffi.new("ControlPostInfo[?]", n)
			n = C.GetSuitableControlPosts(buf, n, menu.contextMenuData.hireObject, npc, false)
		else
			n = C.GetNumPersonSuitableControlPosts(menu.contextMenuData.hireObject, object, npcseed, false)
			buf = ffi.new("ControlPostInfo[?]", n)
			n = C.GetPersonSuitableControlPosts(buf, n, menu.contextMenuData.hireObject, object, npcseed, false)
		end
		for i = 0, n - 1 do
			local postid = ffi.string(buf[i].id)
			local reason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, postid, "", true))
			local active = reason == ""
			local mouseovertext
			if reason ~= "" then
				mouseovertext = menu.hireReasonLookup(reason)
			end

			table.insert(roleOptions, { id = "post:" .. postid, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
		if C.IsComponentClass(menu.contextMenuData.hireObject, "ship") then
			-- service
			local servicereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "service", true))
			local active = servicereason == ""
			local mouseovertext
			if servicereason ~= "" then
				mouseovertext = menu.hireReasonLookup(servicereason)
			end
			table.insert(roleOptions, { id = "role:service", text = ReadText(20208, 20103), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
			-- marines
			local marinereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "marine", true))
			local active = marinereason == ""
			local mouseovertext
			if marinereason ~= "" then
				mouseovertext = menu.hireReasonLookup(marinereason)
			end
			table.insert(roleOptions, { id = "role:marine",  text = ReadText(20208, 20203), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
		if C.CanControllableHaveAnyTrainees(menu.contextMenuData.hireObject) then
			-- group trainee
			local grouptraineereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "trainee_group", true))
			local active = grouptraineereason == ""
			local mouseovertext
			if grouptraineereason ~= "" then
				mouseovertext = menu.hireReasonLookup(grouptraineereason)
			end
			table.insert(roleOptions, { id = "role:trainee_group", text = ReadText(20208, 20503), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
	end

	-- skills
	local numskills = C.GetNumSkills()
	local skills = {}
	if npc then
		local skilltable = GetComponentData(npc, "skills")
		for _, entry in ipairs(skilltable) do
			skills[entry.name] = entry.value
		end
	else
		local buf = ffi.new("SkillInfo[?]", numskills)
		local n = C.GetPersonSkills3(buf, numskills, npcseed, object)
		for i = 0, n - 1 do
			local id = ffi.string(buf[i].id)
			skills[id] = buf[i].value
		end
	end
	-- mission npc requirements
	local n = C.GetNumRequestedMissionNPCs(menu.contextMenuData.hireObject)
	local buf = ffi.new("MissionNPCInfo[?]", n)
	for i = 0, n - 1 do
		buf[i].numskills = numskills
		buf[i].skills = Helper.ffiNewHelper("SkillInfo[?]", numskills)
	end
	n = C.GetRequestedMissionNPCs(buf, n, menu.contextMenuData.hireObject)
	for i = 0, n - 1 do
		if buf[i].amount > 0 then
			local matchesrequirement = true
			for j = 0, buf[i].numskills - 1 do
				local id = ffi.string(buf[i].skills[j].id)
				if buf[i].skills[j].value > skills[id] then
					matchesrequirement = false
					break
				end
			end

			local mission = menu.getMissionIDInfoHelper(buf[i].missionid)
			table.insert(roleOptions, { id = "mission:" .. tostring(buf[i].missionid), text = Helper.convertColorToText(Helper.color.mission) .. mission.name, icon = "", displayremoveoption = false, active = matchesrequirement, mouseovertext = matchesrequirement and "" or ReadText(1026, 3251) })
		end
	end

	table.sort(roleOptions, function (a, b) return a.text < b.text end)

	if #roleOptions > 0 then
		local startOption = ""
		if menu.contextMenuData.hireIsMission then
			startOption = "mission:" .. menu.contextMenuData.hireRole
		elseif menu.contextMenuData.hireRole then
			startOption = (menu.contextMenuData.hireIsPost and "post:" or "role:") .. menu.contextMenuData.hireRole
		end
		row[1]:setColSpan(2):createDropDown(roleOptions, { startOption = startOption, height = config.mapRowHeight, helpOverlayID = "assign_staff_role", helpOverlayText = " " }):setTextProperties({ halign = "center" })
		row[1].handlers.onDropDownConfirmed = menu.dropdownHireRole
		row[1].properties.uiTriggerID = "npcrole"
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
	else
		row[1]:setColSpan(2):createText(string.format(ReadText(1001, 3260), ffi.string(C.GetComponentName(menu.contextMenuData.hireObject))), { halign = "center", color = Helper.color.red })
	end
	-- warnings
	local warningtext = ""
	if npc and GetComponentData(npc, "isplayerowned") then
		if not GetComponentData(menu.contextMenuData.hireObject, "assignedpilot") then
			if menu.contextMenuData.hireRole and (not menu.contextMenuData.hireIsPost) then
				local inventory = GetInventory(npc)
				if next(inventory) then
					warningtext = ReadText(1001, 8384)
				end
			end
		end
	end
	if warningtext ~= "" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(warningtext, { color = Helper.color.red, wordwrap = true })
	end

	menu.hiringdiscounts = GetComponentData(GetContextByClass(npc or object, "container", true), "hiringdiscounts")
	menu.hiringdiscounts.totalfactor = 1
	for _, entry in ipairs(menu.hiringdiscounts) do
		menu.hiringdiscounts.totalfactor = menu.hiringdiscounts.totalfactor - entry.amount / 100
	end

	local fee
	if ishiring and npc then
		fee = GetNPCBlackboard(npc, "$HiringFee")
	end
	local balance = GetPlayerMoney()
	if fee then
		balance = GetPlayerMoney() - fee
	end
	if ishiring then
		-- discounts
		if #menu.hiringdiscounts > 0 then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 3502))
			row[2]:createText(ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
			
			ftable:addEmptyRow(config.mapRowHeight / 4)

			local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 2819))
			for _, entry in ipairs(menu.hiringdiscounts) do
				local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createText("   " .. entry.name)
				row[2]:createText(entry.amount .. " %", { halign = "right" })
			end
			ftable:addEmptyRow(config.mapRowHeight / 4)
		end
		if fee then
			-- Fee
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText((#menu.hiringdiscounts > 0) and ReadText(1001, 3503) or ReadText(1001, 3501))
			row[2]:createText(ConvertMoneyString(fee * menu.hiringdiscounts.totalfactor, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
		end
		-- Final Balance
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 2004))
		row[2]:createText(ConvertMoneyString(balance, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (balance < 0) and Helper.color.red or Helper.color.white })
	end
	-- Buttons
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	local mouseovertext = ""
	if not menu.contextMenuData.hireRole then
		mouseovertext = ReadText(1026, 3221)
	elseif ishiring and (balance < 0) then
		mouseovertext = ReadText(1026, 3222)
	end
	row[1]:createButton({ active = (menu.contextMenuData.hireRole ~= nil) and ((not ishiring) or (balance >= 0)), mouseOverText = mouseovertext, helpOverlayID = "assign_staff_hire_ok", helpOverlayText = " " }):setText(ishiring and ReadText(1001, 3262) or ReadText(1001, 3263), { halign = "center" })
	row[1].handlers.onClick = menu.buttonHire
	row[1].properties.uiTriggerID = "hire_ok"

	row[2]:createButton({helpOverlayID = "assign_staff_hire_cancel", helpOverlayText = " " }):setText(ReadText(1001, 64), { halign = "center"})
	row[2].handlers.onClick = function () return menu.onCloseElement("back") end
	row[2].properties.uiTriggerID = "hire_cancel"

	-- adjust frame position
	local neededheight = ftable.properties.y + ftable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createUserQuestionContext(frame)
	local useSaveOption = false
	if (menu.contextMenuData.mode == "markashostile") then
		useSaveOption = true
	end
	local numCols = useSaveOption and 6 or 5
	local ftable = frame:addTable(numCols, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })
	if useSaveOption then
		ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
		ftable:setColWidthPercent(5, 25, false)
		ftable:setColWidthPercent(6, 25, false)
	end

	if menu.contextMenuData.mode == "fireindividual" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		if menu.contextMenuData.entity then
			row[1]:setColSpan(numCols):createText(string.format(ReadText(1001, 11202), ffi.string(C.GetComponentName(menu.contextMenuData.entity))), Helper.headerRowCenteredProperties)
		else
			row[1]:setColSpan(numCols):createText(string.format(ReadText(1001, 11202), ffi.string(C.GetPersonName(menu.contextMenuData.person, menu.contextMenuData.controllable))), Helper.headerRowCenteredProperties)
		end

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11201))
	elseif menu.contextMenuData.mode == "fireall" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11250), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11249))

		local count = #menu.infoTablePersistentData[menu.contextMenuData.instance].crew.unassigned.persons
		for i, entry in ipairs(menu.infoTablePersistentData[menu.contextMenuData.instance].crew.unassigned.persons) do
			local adjustedskill = math.floor(C.GetPersonCombinedSkill(menu.contextMenuData.controllable, entry.person, entry.oldrole, nil) * 15 / 100)

			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("    · " .. ffi.string(C.GetPersonName(entry.person, menu.contextMenuData.controllable)))
			row[4]:setColSpan(2):createText(Helper.displaySkill(adjustedskill), { halign = "right", color = Helper.color.brightyellow })

			if i == 10 then
				break
			end
		end

		if count > 10 then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("    · ... (+" .. count - 10 .. ")")
		end
	elseif menu.contextMenuData.mode == "markashostile" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11114), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9710), { wordwrap = true })
	elseif menu.contextMenuData.mode == "clearlogbook" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 5722), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 5725), { wordwrap = true })
	elseif menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 8320), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11611), { wordwrap = true })
	end


	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(numCols):createText("")

	if useSaveOption then
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(function () return menu.contextMenuData.saveOption end, { height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function () menu.contextMenuData.saveOption = not menu.contextMenuData.saveOption end
		row[2]:setColSpan(3):createButton({ bgColor = Helper.color.transparent }):setText(ReadText(1001, 9709))
		row[2].handlers.onClick = function () menu.contextMenuData.saveOption = not menu.contextMenuData.saveOption end
		row[5]:createButton({ helpOverlayID = "custom_" .. menu.contextMenuData.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
		row[5].handlers.onClick = menu.buttonConfirmUserQuestion
		row[6]:createButton({ helpOverlayID = "custom_" .. menu.contextMenuData.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		row[6].handlers.onClick = menu.closeContextMenu
		ftable:setSelectedCol(5)
	else
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
		if menu.contextMenuData.mode == "fireindividual" then
			row[2].handlers.onClick = function () return menu.infoSubmenuFireNPC(menu.contextMenuData.controllable, menu.contextMenuData.entity, menu.contextMenuData.person, menu.contextMenuData.instance) end
		elseif menu.contextMenuData.mode == "fireall" then
			row[2].handlers.onClick = function () return menu.buttonFireCrew(menu.contextMenuData.instance, menu.contextMenuData.controllable) end
		elseif menu.contextMenuData.mode == "clearlogbook" then
			row[2].handlers.onClick = function () return menu.buttonInfoLogbookClear(menu.contextMenuData.instance) end
		elseif menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
			row[2].handlers.onClick = menu.contextMenuData.callback
			row[2].handlers.onClick = menu.contextMenuData.callback
		end
		row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
		row[4].handlers.onClick = menu.closeContextMenu
	end
end

function menu.createOnlineModeContext(frame)
	local ftable = frame:addTable(2, { tabOrder = 1, reserveScrollBar = false, highlightMode = "off", x = (Helper.viewWidth - menu.onlineModeHintWidth) / 2, y = Helper.viewHeight / 2 - frame.properties.y, width = menu.onlineModeHintWidth - Helper.borderSize, backgroundID = "solid", backgroundColor = Helper.color.darkgrey })
	ftable:setDefaultColSpan(1, 2)

	local counter = 1

	local hassession = OnlineHasSession()
	local hasdocks = false
	local hasmultipledocksperplatform = false
	for _, entry in ipairs(Helper.ventureplatforms) do
		if #entry.docks > 0 then
			hasdocks = true
			if #entry.docks > 1 then
				hasmultipledocksperplatform = true
			end
		end
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	if menu.contextMenuData.confirmoverwrite then
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11332), Helper.titleTextProperties)

		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11329), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true, color = Helper.color.orange })

		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(1):createButton({ active = function () return IsOnlineSavePossible() end }):setText(ReadText(1001, 14), { fontsize = 10, halign = "center" })
		row[1].handlers.onClick = menu.buttonConvertVentureSave
		
		row[2]:createButton({  }):setText(ReadText(1001, 64), { fontsize = 10, halign = "center" })
		row[2].handlers.onClick = menu.buttonToggleMultiverseMap
	elseif hassession and hasdocks and (not hasmultipledocksperplatform) then
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11332), Helper.titleTextProperties)

		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11328), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		local savegames = GetSaveList(Helper.validSaveFilenames)
		local hasonlinesave = false
		for _, save in ipairs(savegames) do
			if save.isonline and (save.filename == "online_save") then
				hasonlinesave = true
				break
			end
		end
		if hasonlinesave then
			ftable:addEmptyRow()

			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 11361), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true, color = Helper.color.warningorange })
		end

		ftable:addEmptyRow()

		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11362), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		ftable:addEmptyRow()

		while not C.IsSaveListLoadingComplete() do
			-- wait until loading the savegame list is complete
		end
		local savegames = GetSaveList(Helper.validSaveFilenames)
		local onlinesave = false
		for _, save in ipairs(savegames) do
			if save.isonline then
				onlinesave = true
				break
			end
		end

		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11331), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(1):createButton({ active = function () return IsOnlineSavePossible() end }):setText(ReadText(1001, 11333), { fontsize = 10, halign = "center" })
		row[1].handlers.onClick = onlinesave and menu.buttonConfirmConvertVentureSave or menu.buttonConvertVentureSave
		
		row[2]:createButton({  }):setText(ReadText(1001, 64), { fontsize = 10, halign = "center" })
		row[2].handlers.onClick = menu.buttonToggleMultiverseMap
	else
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11306), Helper.titleTextProperties)

		local completed = hassession
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText((completed and "\27G" or "") .. counter .. ". " .. ReadText(1001, 11301) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = C.GetVentureDLCStatus() == 0
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText((completed and "\27G" or "") .. counter .. ". " .. ReadText(1001, 11358) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = true
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText((completed and "\27G" or "") .. counter .. ". " .. ReadText(1001, 11302) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = hasdocks
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText((completed and "\27G" or "") .. counter .. ". " .. ReadText(1001, 11573) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		if hasmultipledocksperplatform then
			completed = false
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:createText((completed and "\27G" or "") .. counter .. ". " .. ReadText(1001, 11597) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
			counter = counter + 1
		end

		completed = false
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText((completed and "\27G" or "") .. counter .. ". " .. ReadText(1001, 11574) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	ftable.properties.y = ftable.properties.y - ftable:getFullHeight() / 2

	return ftable
end

function menu.buttonRenameConfirm()
	if menu.contextMenuData.newtext then
		if menu.contextMenuData.fleetrename then
			C.SetFleetName(menu.contextMenuData.component, menu.contextMenuData.newtext)
		else
			SetComponentName(menu.contextMenuData.component, menu.contextMenuData.newtext)
		end
	end
	menu.noupdate = false
	menu.refreshInfoFrame()
	menu.closeContextMenu("back")
end

function menu.initializeBoardingData(target)
	menu.boardingData = { 
							target = target, ships = {}, shipdata = {}, selectedship = nil,
							marinelevels = {}, casualties = {0, 0, 0},
							currentphase = "setup", phaseindices = {}, phasedata = {}, progresslevels = {},
							risk1 = nil, risk2 = nil, risklevels = {}, riskleveldata = {},
							shipactions = {},
							changed = false, iscapturable = GetComponentData(target, "iscapturable")
						}
	local numtiers = C.GetNumTiersOfRole("marine")
	local tierdata = ffi.new("RoleTierData[?]", numtiers)
	numtiers = C.GetTiersOfRole(tierdata, numtiers, "marine")
	for i = 0, numtiers - 1 do
		table.insert(menu.boardingData.marinelevels, { skilllevel = tierdata[i].skilllevel, text = ffi.string(tierdata[i].name) })
	end

	local numphases = C.GetNumAllBoardingPhases()
	local phases = ffi.new("BoardingPhase[?]", numphases)
	numphases = C.GetAllBoardingPhases(phases, numphases)
	for i = 0, numphases-1 do
		if ffi.string(phases[i].id) ~= "" then
			local phaseid = ffi.string(phases[i].id)
			menu.boardingData.phaseindices[phaseid] = (i+1)
			if phaseid == "approach" or phaseid == "infiltration" or phaseid == "internalfight" then
				table.insert(menu.boardingData.phasedata, { text = ffi.string(phases[i].text), state = "waiting", mouseOverText = "" })
			end
		end
	end
	menu.boardingData.phasedata[1].mouseOverText = ReadText(1026, 8201)		-- Destroy turrets to improve chances of boarding pods arriving safely.
	menu.boardingData.phasedata[2].mouseOverText = ReadText(1026, 8202)		-- Damage hull to reduce the time needed to breach the target.
	menu.boardingData.phasedata[3].mouseOverText = ReadText(1026, 8203)		-- Send more or better marines to improve chances of success.

	menu.boardingData.phasedata[1].helpOverlayID = "boarding_stage1"
	menu.boardingData.phasedata[2].helpOverlayID = "boarding_stage2"
	menu.boardingData.phasedata[3].helpOverlayID = "boarding_stage3"

	menu.boardingData.phasedata[1].helpOverlayText = " "
	menu.boardingData.phasedata[2].helpOverlayText = " "
	menu.boardingData.phasedata[3].helpOverlayText = " "

	menu.boardingData.phasedata[1].helpOverlayHighlightOnly = true
	menu.boardingData.phasedata[2].helpOverlayHighlightOnly = true
	menu.boardingData.phasedata[3].helpOverlayHighlightOnly = true

	menu.boardingData.progresslevels = { waiting = {text = ReadText(1001, 9510), color = Helper.color.red}, started = {text = ReadText(1001, 9511), color = Helper.color.orange}, done = {text = ReadText(1001, 9512), color = Helper.color.green} }		-- Stage not started, Stage in progress, Stage completed

	menu.boardingData.risklevels = { "verylow", "low", "medium", "high", "veryhigh" }
	menu.boardingData.riskleveldata = { verylow = { index = 1, text = ReadText(1037, 3001), textlower = ReadText(1037, 4001), threshold = 20, hulldescription = ReadText(1037, 5001), color = Helper.color.green }, low = { index = 2, text = ReadText(1037, 3002), textlower = ReadText(1037, 4002), threshold = 30, hulldescription = ReadText(1037, 5002), color = Helper.color.yellow }, medium = { index = 3, text = ReadText(1037, 3003), textlower = ReadText(1037, 4003), threshold = 50, hulldescription = ReadText(1037, 5003), color = Helper.color.orange }, high = { index = 4, text = ReadText(1037, 3004), textlower = ReadText(1037, 4004), threshold = 80, hulldescription = ReadText(1037, 5004), color = Helper.color.red }, veryhigh = { index = 5, text = ReadText(1037, 3005), textlower = ReadText(1037, 4005), threshold = 100, hulldescription = ReadText(1037, 5005), color = Helper.color.red }, impossible = { index = 6, text = ReadText(1037, 3006), textlower = ReadText(1037, 4006), threshold = 120, hulldescription = ReadText(1037, 5005), color = Helper.color.red } }
	if not menu.boardingData.risk1 then
		-- Approach risk threshold. default: low
		menu.boardingData.risk1 = menu.boardingData.risklevels[2]
	end
	if not menu.boardingData.risk2 then
		-- Infiltrate risk threshold. default: high (marines don't die while drilling through anymore, but it does increase risk for them in the assault phase since defenders have more time to organize.)
		menu.boardingData.risk2 = menu.boardingData.risklevels[4]
	end

	local numactions = C.GetNumAllBoardingBehaviours()
	local actions = ffi.new("BoardingBehaviour[?]", numactions)
	numactions = C.GetAllBoardingBehaviours(actions, numactions)
	for i = 0, numactions-1 do
		if ffi.string(actions[i].id) ~= "" then
			table.insert(menu.boardingData.shipactions, { id = ffi.string(actions[i].id), text = ffi.string(actions[i].text) })
		end
	end
end

function menu.createBoardingContext(frame, target, boarders)
	if not menu.boardingData or not menu.boardingData.target then
		menu.initializeBoardingData(target)
	end

	local activeop = C.IsDefensibleBeingBoardedBy(target, "player")
	local unknowntext = ReadText(1001, 3210)
	local unknowncolor = Helper.color.red
	local boardingcheatsecrecy = false

	-- if op is already running, add all ships that are already assigned to the boarding operation.
	if activeop then
		menu.boardingData.currentphase = ffi.string(C.GetCurrentBoardingPhase(target, "player"))
		-- get risk thresholds
		local rawriskthresholds = ffi.new("BoardingRiskThresholds")
		rawriskthresholds = C.GetBoardingRiskThresholds(target, "player")
		--print("rawrisk1: " .. tostring(rawriskthresholds[0]) .. ", rawrisk2: " .. tostring(rawriskthresholds[1]))
		local found1, found2 = nil
		for _, risklevel in ipairs(menu.boardingData.risklevels) do
			if not found1 and rawriskthresholds.approach <= menu.boardingData.riskleveldata[risklevel].threshold then
				menu.boardingData.risk1 = risklevel
				found1 = true
			end
			if not found2 and rawriskthresholds.insertion <= menu.boardingData.riskleveldata[risklevel].threshold then
				menu.boardingData.risk2 = risklevel
				found2 = true
			end
			if found1 and found2 then
				break
			end
		end
		--print("retrieved risk levels. approach: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk1].text) .. ", insertion: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk2].text))

		local numattackers = C.GetNumAttackersOfBoardingOperation(target, "player")
		local attackers = ffi.new("UniverseID[?]", numattackers)
		numattackers = C.GetAttackersOfBoardingOperation(attackers, numattackers, target, "player")
		--print("num attackers: " .. tostring(numattackers) .. ". attackers: ")
		for i = 0, numattackers-1 do
			local boarder = ConvertStringTo64Bit(tostring(attackers[i]))
			--print(" " .. ffi.string(C.GetComponentName(boarder)))

			if not menu.boardingData.shipdata[boarder] then
				table.insert(menu.boardingData.ships, boarder)
				menu.boardingData.shipdata[boarder] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = true, issubordinate = false, action = ffi.string(C.GetBoardingActionOfAttacker(target, boarder, "player")) }

				-- only update assignedmarines if shipdata is to be reset.
				local numtiers = #menu.boardingData.marinelevels
				local marinetieramounts = ffi.new("uint32_t[?]", numtiers)
				local marineskilllevellist = ffi.new("uint32_t[?]", numtiers)
				for j, leveldata in ipairs(menu.boardingData.marinelevels) do
					marineskilllevellist[j-1] = leveldata.skilllevel
				end
				C.GetBoardingMarineTierAmountsFromAttacker(marinetieramounts, marineskilllevellist, numtiers, target, boarder, "player")
				for j, leveldata in ipairs(menu.boardingData.marinelevels) do
					menu.boardingData.shipdata[boarder].assignedmarines[leveldata.skilllevel] = marinetieramounts[j-1]
					menu.boardingData.shipdata[boarder].assignedgroupmarines[leveldata.skilllevel] = marinetieramounts[j-1]
					--print("retrieving. index: " .. tostring(j-1) .. ", num marines: " .. tostring(marinetieramounts[j-1]) .. ", skill level: " .. tostring(leveldata.skilllevel))
				end
			end
		end
	end

	-- add all boarders that were passed in and are not yet listed to menu.boardingData.ships and initialize menu.boardingData.shipdata for them.
	for _, ship in ipairs(boarders) do
		if not menu.boardingData.shipdata[ship] then
			--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " to boarding operation.")
			table.insert(menu.boardingData.ships, ship)
			menu.boardingData.shipdata[ship] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = true, issubordinate = false, action = menu.boardingData.shipactions[2].id }
		end
	end

	-- populate marine and subordinate data for menu.boardingData.ships in menu.boardingData.shipdata
	for _, ship in ipairs(menu.boardingData.ships) do
		local numpeople = C.GetNumAllRoles()
		local peopledata = ffi.new("PeopleInfo[?]", numpeople)
		numpeople = C.GetPeople2(peopledata, numpeople, ship, false)
		local numtiers = #menu.boardingData.marinelevels
		local tierdata = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers2(tierdata, numtiers, ship, "marine", false)
		for i = 0, numtiers - 1 do
			menu.boardingData.shipdata[ship].marines[tierdata[i].skilllevel] = tierdata[i].amount
			menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] = tierdata[i].amount
		end

		local subordinates = GetSubordinates(ship, nil, true)
		--print("found " .. tostring(#subordinates) .. " subordinates")
		for _, subordinate in ipairs(subordinates) do
			local subordinate = ConvertIDTo64Bit(subordinate)
			if not C.IsUnit(subordinate) then
				if not menu.boardingData.shipdata[subordinate] then
					menu.boardingData.shipdata[subordinate] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = false, issubordinate = true, action = menu.boardingData.shipactions[2].id }

					local alreadylisted = false
					for _, evalsubordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
						if subordinate == evalsubordinate then
							alreadylisted = true
							break
						end
					end
					if not alreadylisted then
						--print("adding subordinate " .. ffi.string(C.GetComponentName(subordinate)) .. " to boarding operation.")
						table.insert(menu.boardingData.shipdata[ship].subordinates, subordinate)
					end
				else
					menu.boardingData.shipdata[subordinate].issubordinate = true
				end

				if not menu.boardingData.shipdata[subordinate].isprimaryboarder then
					numpeople = C.GetNumAllRoles()
					peopledata = ffi.new("PeopleInfo[?]", numpeople)
					numpeople = C.GetPeople2(peopledata, numpeople, subordinate, false)
					numtiers = #menu.boardingData.marinelevels
					tierdata = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers2(tierdata, numtiers, subordinate, "marine", false)
					for i = 0, numtiers - 1 do
						if tierdata[i].amount > 0 then
							--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. ": adding " .. tierdata[i].amount .. " marines with skill " .. tostring(tierdata[i].skilllevel) .. " to entry of " .. ffi.string(C.GetComponentName(ship)))
							menu.boardingData.shipdata[subordinate].marines[tierdata[i].skilllevel] = tierdata[i].amount
							menu.boardingData.shipdata[subordinate].groupmarines[tierdata[i].skilllevel] = tierdata[i].amount
							menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] = menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] + tierdata[i].amount
						end
					end
				end

				for _, tierdata in ipairs(menu.boardingData.marinelevels) do
					if not menu.boardingData.shipdata[subordinate].assignedmarines[tierdata.skilllevel] then
						menu.boardingData.shipdata[subordinate].assignedmarines[tierdata.skilllevel] = 0
					end
					if not menu.boardingData.shipdata[subordinate].assignedgroupmarines[tierdata.skilllevel] then
						menu.boardingData.shipdata[subordinate].assignedgroupmarines[tierdata.skilllevel] = 0
					end
				end
			end
		end
		for _, tierdata in ipairs(menu.boardingData.marinelevels) do
			if not menu.boardingData.shipdata[ship].assignedmarines[tierdata.skilllevel] then
				menu.boardingData.shipdata[ship].assignedmarines[tierdata.skilllevel] = 0
			end
			if not menu.boardingData.shipdata[ship].assignedgroupmarines[tierdata.skilllevel] then
				menu.boardingData.shipdata[ship].assignedgroupmarines[tierdata.skilllevel] = 0
			end
		end
	end

	local targetname, targetowner, hullpercentage = GetComponentData(target, "name", "ownername", "hullpercent")

	local numoperationalturrets = 0
	local numtotalturrets = 0
	local numpotentialturrets = 0
	local numslots = tonumber(C.GetNumUpgradeSlots(target, "", "turret"))
	for i = 1, numslots do
		numpotentialturrets = numpotentialturrets + 1
		local currentcomponent = ConvertStringTo64Bit(tostring(C.GetUpgradeSlotCurrentComponent(target, "turret", i)))
		if currentcomponent and currentcomponent ~= 0 then
			numtotalturrets = numtotalturrets + 1
			if IsComponentOperational(currentcomponent) then
				numoperationalturrets = numoperationalturrets + 1
			end
		end
	end

	local targetcrewcapacity = C.GetPeopleCapacity(target, "", false)

	local currentboardingresistance = GetComponentData(target, "boardingresistance")
	local numdefendingcrew = menu.getNumDefendingCrew(target)

	-- tally total assigned marines and fill in empty marine tier entries.
	local totalassignedmarines = 0
	if activeop then
		totalassignedmarines = totalassignedmarines + C.GetNumBoardingMarinesFromOperation(target, "player")
	else
		for _, boarder in ipairs(menu.boardingData.ships) do
			for _, tierdata in ipairs(menu.boardingData.marinelevels) do
				if not menu.boardingData.shipdata[boarder].assignedmarines[tierdata.skilllevel] then
					menu.boardingData.shipdata[boarder].assignedmarines[tierdata.skilllevel] = 0
				end
				if not menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] then
					menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] = 0
				end
				totalassignedmarines = totalassignedmarines + menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel]
				--print("assigned marines: adding " .. menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] .. " " .. tostring(tierdata.text) .. " marines from " .. ffi.string(C.GetComponentName(boarder)) .. " " .. tostring(boarder) .. " to total tally.\n total: " .. tostring(totalassignedmarines))
			end
		end
	end

	if not menu.boardingData.selectedship or not menu.boardingData.shipdata[menu.boardingData.selectedship] then
		menu.boardingData.selectedship = menu.boardingData.ships[1]
	end

	local boardingstrength = 0
	if activeop then
		boardingstrength = boardingstrength + C.GetBoardingStrengthFromOperation(target, "player")
	else
		for i, ship in ipairs(menu.boardingData.ships) do
			local locnumtiers = #menu.boardingData.marinelevels
			local locmarinetieramounts = ffi.new("uint32_t[?]", locnumtiers)
			local locmarineskilllevels = ffi.new("uint32_t[?]", locnumtiers)
			for j, level in ipairs(menu.boardingData.marinelevels) do
				locmarinetieramounts[j-1] = menu.boardingData.shipdata[ship].assignedmarines[level.skilllevel]
				locmarineskilllevels[j-1] = level.skilllevel
				--print("tier: " .. j .. " num tiers: " .. locnumtiers .. " tier amount: " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[level.skilllevel]) .. " skill level: " .. level.skilllevel)
			end
			boardingstrength = boardingstrength + C.GetBoardingStrengthOfControllableTierAmounts(ship, locmarinetieramounts, locmarineskilllevels, locnumtiers)
			if #menu.boardingData.shipdata[ship].subordinates > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					for j, level in ipairs(menu.boardingData.marinelevels) do
						locmarinetieramounts[j-1] = menu.boardingData.shipdata[subordinate].assignedmarines[level.skilllevel]
						locmarineskilllevels[j-1] = level.skilllevel
						--print("subordinate. tier: " .. j .. " num tiers: " .. locnumtiers .. " tier amount: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[level.skilllevel]) .. " skill level: " .. level.skilllevel)
					end
					boardingstrength = boardingstrength + C.GetBoardingStrengthOfControllableTierAmounts(subordinate, locmarinetieramounts, locmarineskilllevels, locnumtiers)
				end
			end
			--print("calculating boarding strength. num ships evaluated: " .. i .. " boarding strength: " .. boardingstrength)
		end
	end

	-- max potential boarding resistance: only for comparison with boardingstrength to be expressed as an adjective for crew strength estimate in stage III. always use potential? that would tend to make the approximation safer if very conservative.
	-- we're now using combinedskill to calculate boarding strength, so max potential is max number of crew * maxcombinedskill
	--local maxpotentialboardingresistance = targetcrewcapacity * 100
	local maxpotentialboardingresistance = numdefendingcrew * 100

	-- NB: risk numbers will be updated every time the text widgets that use them are.
	local risk = {}
	-- chance that launched marines will get to target compared to target ship type with maximum loadout
	table.insert(risk, ((numoperationalturrets / math.max(numtotalturrets, 1)) * 100))
	--table.insert(risk, ((numoperationalturrets / numpotentialturrets) * 100))
	-- chance that assaulting marines will survive entry
	table.insert(risk, hullpercentage)
	-- chance that attacking ships will accidentally destroy target
	table.insert(risk, 100 - risk[2])
	-- chance that assaulting marines will defeat opposition within the ship
	table.insert(risk, ((1.0 - math.min((boardingstrength / math.max(currentboardingresistance, 1.0)), 1.0)) * 100))
	--print("risk 1: " .. tostring(risk[1]) .. "\nrisk 2: " .. tostring(risk[2]) .. "\nrisk 3: " .. tostring(risk[3]))

	-- Boarding
	local table_header = frame:addTable(1, { x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

	local row = table_header:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 9500), Helper.headerRowCenteredProperties)		-- Boarding

	-- Boarding Plan
	local table_bottom = frame:addTable(9, { tabOrder = 5, x = Helper.borderSize, y = menu.contextMenuData.height * 3 / 4 + Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "column" })
	table_bottom:setColWidthPercent(2, 5)
	table_bottom:setColWidthPercent(3, 10)
	table_bottom:setColWidthPercent(5, 5)
	table_bottom:setColWidthPercent(6, 10)
	table_bottom:setColWidthPercent(8, 5)
	table_bottom:setColWidthPercent(9, 10)

	row = table_bottom:addRow(false, { fixed = true })
	row[1]:setColSpan(9):createText(ReadText(1001, 9501), Helper.headerRowCenteredProperties)		-- Boarding Plan

	row = table_bottom:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	for i, phase in ipairs(menu.boardingData.phasedata) do
		row[3*i-2]:setColSpan(3):createText(phase.text, { font = Helper.standardFontBold, halign = "center", mouseOverText = phase.mouseOverText,  helpOverlayID = phase.helpOverlayID, helpOverlayText = phase.helpOverlayText, helpOverlayHighlightOnly = phase.helpOverlayHighlightOnly})
	end

	if activeop then
		row = table_bottom:addRow(false, { bgColor = Helper.color.transparent })

		for i, phase in ipairs(menu.boardingData.phasedata) do
			row[3*i-2]:createText((ReadText(1001, 9513) .. ReadText(1001, 120)), { mouseOverText = phase.mouseOverText })		-- Progress, :
			row[3*i-1]:setColSpan(2):createText(function()
					if C.IsDefensibleBeingBoardedBy(target, "player") then
						-- get current phase. updated here to dynamically update the phase for this section of the menu.
						menu.boardingData.currentphase = ffi.string(C.GetCurrentBoardingPhase(target, "player"))
					else
						-- this is for displaying the state of each phase so "succeeded" or "failed" doesn't really matter as long as its index is > that of all of the other phases.
						menu.boardingData.currentphase = "succeeded"
					end

					-- update phase data depending on current phase.
					if i == 1 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] > menu.boardingData.phaseindices.approach and "done") or "started"
					elseif i == 2 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.pre_infiltration and "waiting") or (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.internalfight and "started") or "done"
					elseif i == 3 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.internalfight and "waiting") or (menu.boardingData.phaseindices[menu.boardingData.currentphase] == menu.boardingData.phaseindices.internalfight and "started") or "done"
					end
					return menu.boardingData.progresslevels[phase.state].text
				end, { halign = "right", color = function() return menu.boardingData.progresslevels[phase.state].color end, mouseOverText = phase.mouseOverText })
		end
	end

	row = table_bottom:addRow(false, { bgColor = Helper.color.transparent })

	row[1]:setColSpan(2):createText((ReadText(1001, 9514) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Risk, :
	row[3]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risk1].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[1].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risk1].color or unknowncolor end })

	row[4]:setColSpan(2):createText((ReadText(1001, 9515) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Risk of destroying target, :
	row[6]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[6 - menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[6 - menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].color or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9516) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Defending crew, :
	row[9]:createText(function() 
			local locnumdefendingcrew = menu.getNumDefendingCrew(target)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and (locnumdefendingcrew .. " / " .. targetcrewcapacity) or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Helper.standardColor or unknowncolor end })

	row = table_bottom:addRow(false, { bgColor = Helper.color.transparent })

	row[1]:setColSpan(2):createText((ReadText(1001, 9517) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Target combat effectiveness, :
	row[3]:createText(function()
			local locnumoperationalturrets = menu.getNumOperationalTurrets(target, numtotalturrets)
			risk[1] = ((locnumoperationalturrets / math.max(numtotalturrets, 1)) * 100)
			local risktext = ""
			for i = 1, #menu.boardingData.risklevels do
				if risk[1] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
					risktext = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].hulldescription
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and risktext or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[1].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Helper.standardColor or unknowncolor end })

	row[4]:setColSpan(2):createText((ReadText(1001, 9518) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Risk to marines, :
	row[6]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].color or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9519) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Attacking marines, :
	row[9]:createText(function()
		local loctotalassignedmarines = totalassignedmarines
		if activeop then
			loctotalassignedmarines = C.GetNumBoardingMarinesFromOperation(target, "player")
		end
		return loctotalassignedmarines .. " / " .. targetcrewcapacity end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText })

	row = table_bottom:addRow(false, { bgColor = Helper.color.transparent })

	row[1]:setColSpan(3):createText("", { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })

	row[4]:setColSpan(2):createText((ReadText(1001, 9520) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Target hull, :
	row[6]:createText(function()
			risk[2] = GetComponentData(target, "hullpercent")
			local hulldescription = ""
			for i = 1, #menu.boardingData.risklevels do
				if risk[2] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
					hulldescription = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].hulldescription
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and hulldescription or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Helper.standardColor or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9514) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Risk, :
	row[9]:createText(function()
			local risktext = ""
			local isimpossible = nil
			if menu.boardingData.iscapturable then
				local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
				risk[4] = ((2.0 - math.min((boardingstrength / math.max(loccurrentboardingresistance, 1.0)), 2.0)) * 100) / 2
				for i = 1, #menu.boardingData.risklevels do
					if risk[4] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
						--print("risk: " .. tostring(risk[4]) .. ". strength: " .. tostring(boardingstrength) .. ", resistance: " .. tostring(loccurrentboardingresistance) .. ", current threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold))
						risktext = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].text
						break
					end
				end
			else
				risktext = menu.boardingData.riskleveldata.impossible.text
				isimpossible = true
			end
			return (boardingcheatsecrecy or isimpossible or C.IsInfoUnlockedForPlayer(target, "operator_details")) and risktext or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() 
			local riskcolor = nil
			local isimpossible = nil
			if menu.boardingData.iscapturable then
				local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
				risk[4] = ((2.0 - math.min((boardingstrength / math.max(loccurrentboardingresistance, 1.0)), 2.0)) * 100) / 2
				for i = 1, #menu.boardingData.risklevels do 
					if risk[4] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
						riskcolor = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].color
						break
					end
				end
			else
				riskcolor = menu.boardingData.riskleveldata.impossible.color
				isimpossible = true
			end
			return (boardingcheatsecrecy or isimpossible or C.IsInfoUnlockedForPlayer(target, "operator_details")) and riskcolor or unknowncolor
		end })

	row = table_bottom:addRow(false, { bgColor = Helper.color.transparent })

	row[1]:setColSpan(3):createText((ReadText(1001, 9521) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Launch pods at combat effectiveness, :

	row[4]:setColSpan(3):createText((ReadText(1001, 9522) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Start breaching at hull strength, :

	row[7]:setColSpan(2):createText((ReadText(1001, 1325) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Boarding Attack Strength, :
	row[9]:createText(function()
			local locboardingstrength = boardingstrength
			if activeop then
				locboardingstrength = C.GetBoardingStrengthFromOperation(target, "player")
			end
			return locboardingstrength
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText })

	local dropdowndata = {}
	for _, levelid in ipairs(menu.boardingData.risklevels) do
		table.insert(dropdowndata, {id = levelid, text = menu.boardingData.riskleveldata[levelid].hulldescription, icon = "", displayremoveoption = false})
	end
	row = table_bottom:addRow(true, { bgColor = Helper.color.transparent })

	-- TODO: make dropdown being active dependent on current phase (certainly inactive after phase this applies to is done, but also while the phase is currently active?)
	row[1]:setColSpan(3):createDropDown(dropdowndata, {startOption = menu.boardingData.risk1, height = config.mapRowHeight, mouseOverText = menu.boardingData.phasedata[1].mouseOverText, active = not activeop})
	row[1].handlers.onDropDownConfirmed = function(_, newrisklevel) return menu.dropdownBoardingSetRisk(newrisklevel, 1) end
	row[4]:setColSpan(3):createDropDown(dropdowndata, {startOption = menu.boardingData.risk2, height = config.mapRowHeight, mouseOverText = menu.boardingData.phasedata[2].mouseOverText, active = not activeop})
	row[4].handlers.onDropDownConfirmed = function(_, newrisklevel) return menu.dropdownBoardingSetRisk(newrisklevel, 2) end

	row[7]:setColSpan(2):createText((ReadText(1001, 1324) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Boarding Resistance, :
	row[9]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and tostring(GetComponentData(target, "boardingresistance")) or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Helper.standardColor or unknowncolor end })
	--[[
	row[7]:setColSpan(2):createText((ReadText(1001, 9523) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Crew strength, :
	row[9]:createText(function()
			local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
			local targetcrewstrength = loccurrentboardingresistance / math.max(maxpotentialboardingresistance, 1.0)
			--print("crewstrength: " .. tostring(targetcrewstrength) .. ", currentboardingresistance: " .. tostring(currentboardingresistance) .. ", maxpotentialboardingresistance: " .. tostring(maxpotentialboardingresistance))
			local crewdescription = ""
			for i = 1, #menu.boardingData.risklevels do
				if targetcrewstrength <= menu.boardingData.riskleveldata[ menu.boardingData.risklevels[i] ].threshold then
					crewdescription = menu.boardingData.riskleveldata[ menu.boardingData.risklevels[i] ].text
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and crewdescription or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Helper.standardColor or unknowncolor end })
	--]]

	-- Ship Configuration
	local table_left = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, width = menu.contextMenuData.width / 2 - Helper.borderSize / 2 })

	row = table_left:addRow(false, { fixed = true })
	row[1]:setBackgroundColSpan(2):createText(ReadText(1001, 9502) .. ReadText(1001, 120))		-- Configuring, :
	row[2]:createText(ffi.string(C.GetComponentName(menu.boardingData.selectedship)) .. " (" .. ffi.string(C.GetObjectIDCode(menu.boardingData.selectedship)) .. ")", { halign = "right" })

	row = table_left:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:setColSpan(2):createText((ReadText(1001, 9524) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2 })		-- Ship behaviour while engaging the target, :

	local dropdowndata2 = {}
	for _, actiondata in ipairs(menu.boardingData.shipactions) do
		table.insert(dropdowndata2, {id = actiondata.id, text = actiondata.text, icon = "", displayremoveoption = false})
	end

	-- TODO: make dropdown being active dependent on current phase? disable after op has started?
	row = table_left:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createDropDown(dropdowndata2, {startOption = menu.boardingData.shipdata[menu.boardingData.selectedship].action, height = config.mapRowHeight, active = not activeop})
	row[1].handlers.onDropDownConfirmed = function(_, newaction) return menu.dropdownBoardingSetAction(menu.boardingData.selectedship, newaction) end

	titlerow = table_left:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	titlerow[1]:setColSpan(2):createText((ReadText(1001, 9529) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 3})	-- Select marines to board with, :
	titlerow[1].properties.helpOverlayID = "boarding_selectmarines"
	titlerow[1].properties.helpOverlayText = " "
	titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
	titlerow[1].properties.helpOverlayHighlightOnly = true
	titlerow[1].properties.helpOverlayScaling = false
	for _, leveldata in ipairs(menu.boardingData.marinelevels) do
		row = table_left:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		-- TODO: set slider to readOnly depending on phase? will depend on whether or not we allow sending more marines later in the operation to reinforce.
		--print("assigned: " .. tostring(assignedmarines[menu.boardingData.selectedship][leveldata.skilllevel]) .. ", available: " .. tostring(availablemarines[leveldata.skilllevel]))
		--print("start: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) .. ", maxSelect: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel] > (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) and (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) or menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. "\n poss1: " .. tostring(targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) .. "\n poss2: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. "\ntargetcrewcapacity: " .. tostring(targetcrewcapacity) .. "\ntotalassignedmarines: " .. tostring(totalassignedmarines))
		--print("skilllevel: " .. tostring(leveldata.skilllevel) .. ", groupmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel]) .. ", marines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. ", assignedgroupmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) .. ", assignedmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]))
		row[1]:setColSpan(2):createSliderCell({ start = menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel], max = menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel], maxSelect = menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel] > (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) and (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) or menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel], height = config.mapRowHeight, x = Helper.standardTextOffsetx * 4, readOnly = activeop }):setText(leveldata.text)
		row[1].handlers.onSliderCellChanged = function(_, val) return menu.slidercellBoardingAssignedMarines(menu.boardingData.selectedship, leveldata.skilllevel, val) end
		row[1].handlers.onSliderCellConfirm = function() return menu.refreshContextFrame() end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	row = table_left:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:setBackgroundColSpan(2):createText((ReadText(1001, 9525) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2 })		-- Boarding strength, :
	row[2]:createText(function()
			local locboardingstrength = boardingstrength
			if activeop then
				locboardingstrength = C.GetBoardingStrengthFromOperation(target, "player")
			end
			return locboardingstrength
		end, { halign = "right" })
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	if activeop then
		row = table_left:addRow(false, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 9526), { halign = "center" })		-- Total Casualties

		for lvl, leveldata in ipairs(menu.boardingData.marinelevels) do
			row = table_left:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setBackgroundColSpan(2):createText(leveldata.text)
			-- if boarding op had already started but is now finished, print last saved data.
			row[2]:createText(function()
					local locskilllevel = leveldata.skilllevel
					local loclvl = lvl
					--print("skill level: " .. tostring(locskilllevel) .. " lvl: " .. tostring(loclvl))
					if C.IsDefensibleBeingBoardedBy(target, "player") then
						--local oldcasualties = menu.boardingData.casualties[loclvl]
						menu.boardingData.casualties[loclvl] = C.GetBoardingCasualtiesOfTier(locskilllevel, target, "player")
						--if menu.boardingData.casualties[loclvl] ~= oldcasualties then
						--	print("updating casualties of tier: " .. loclvl .. ". from: " .. oldcasualties .. " to: " .. menu.boardingData.casualties[loclvl])
						--end
					end
					return menu.boardingData.casualties[loclvl]
				end, { halign = "right" })
		end
	end

	table_left.properties.y = table_bottom.properties.y - table_header.properties.y - table_left:getVisibleHeight() - Helper.borderSize

	-- name might be confusing. table containing the button for the topleft table, rather than the button on the top-left.
	local table_button_topleft = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = table_left.properties.width })
	row = table_button_topleft:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	-- TODO: activate button when mode boarding_selectplayerobject is implemented. disable depending on phase?
	--row[1]:createButton({ active = false }):setText(ReadText(1001, 9527), { halign = "center" })		-- Add ship to boarding operation
	--row[1].handlers.onClick = function() return menu.buttonBoardingAddShip() end

	-- Ships assigned to boarding operation. has to be initialized after table_bottom because we need that table's y-offset
	menu.boardingtable_shipselection = frame:addTable(3, { tabOrder = 2, x = Helper.borderSize, y = table_header.properties.y + table_header:getVisibleHeight() + Helper.borderSize, width = table_left.properties.width })
	menu.boardingtable_shipselection:setColWidth(2, config.mapRowHeight * 2)
	menu.boardingtable_shipselection:setColWidth(3, Helper.scaleY(config.mapRowHeight), false)

	row = menu.boardingtable_shipselection:addRow(false, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 9528))		-- Ships assigned to boarding operation

	for _, shipid in ipairs(menu.boardingData.ships) do
		row = menu.boardingtable_shipselection:addRow({"boardingship", shipid}, { bgColor = Helper.color.transparent })
		local nameappendix = ""
		if #menu.boardingData.shipdata[shipid].subordinates > 0 then
			nameappendix = (" + " .. #menu.boardingData.shipdata[shipid].subordinates .. " " .. ReadText(1001, 1504))		-- subordinates
		end
		row[1]:setBackgroundColSpan(3):createText((ffi.string(C.GetComponentName(shipid)) .. " (" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")" .. nameappendix))
		--row[1]:setBackgroundColSpan(3):createText((ffi.string(C.GetComponentName(shipid)) .. nameappendix), { x = menu.boardingData.shipdata[shipid].issubordinate and (Helper.standardTextOffsetx + Helper.standardIndentStep) or nil })

		local nummarines = 0
		for _, leveldata in ipairs(menu.boardingData.marinelevels) do
			nummarines = nummarines + menu.boardingData.shipdata[shipid].groupmarines[leveldata.skilllevel]
		end
		row[2]:createText(nummarines, { halign = "right" })
		if not menu.boardingData.shipdata[shipid].issubordinate then
			row[3]:createButton({ height = row[3]:getWidth(), scaling = false }):setText("x", { halign = "center", font = Helper.standardFontBold })
			row[3].handlers.onClick = function() return menu.buttonBoardingRemoveShip(shipid) end
		end

		if menu.boardingData.selectedship == shipid then
			menu.boardingtable_shipselection:setSelectedRow(row.index)
		end
	end

	menu.boardingtable_shipselection.properties.maxVisibleHeight = table_left.properties.y - Helper.scaleY(table_button_topleft:getVisibleHeight()) - Helper.scaleY(table_header:getVisibleHeight()) - Helper.borderSize * 3
	table_button_topleft.properties.y = menu.boardingtable_shipselection.properties.y + menu.boardingtable_shipselection:getVisibleHeight() + Helper.borderSize
	--print("topleft maxvisibleheight: " .. tostring(menu.boardingtable_shipselection.properties.maxVisibleHeight) .. "\n left y offset: " .. tostring(table_left.properties.y) .. "\n buttontopleft height: " .. tostring(table_button_topleft:getVisibleHeight()) .. "\n header height: " .. tostring(table_header:getVisibleHeight()) .. "\n 3 borders: " .. tostring(Helper.borderSize * 3))

	-- Boarding Target
	local table_right = frame:addTable(2, { x = table_left.properties.x + table_left.properties.width + Helper.borderSize, y = menu.boardingtable_shipselection.properties.y, width = table_left.properties.width, height = table_bottom.properties.y - Helper.scaleY(table_header:getVisibleHeight())  - Helper.borderSize * 2 })
	table_right:setColWidthPercent(1, 20)

	row = table_right:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 9503), { halign = "center" })	-- Boarding Target

	row = table_right:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 5) .. ReadText(1001, 120))		-- Ship, :
	row[2]:createText(targetname, { halign = "right" })

	row = table_right:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 43) .. ReadText(1001, 120))		-- Faction, :
	row[2]:createText(targetowner, { halign = "right" })

	row = table_right:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText("")

	row = table_right:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 1319) .. ReadText(1001, 120))		-- Turrets, :
	row[2]:createText(function()
			local locnumoperationalturrets = menu.getNumOperationalTurrets(target, numtotalturrets)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and (locnumoperationalturrets .. " / " .. numtotalturrets) or unknowntext
		end, { halign = "right", color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Helper.standardColor or unknowncolor end })

	row = table_right:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 1) .. ReadText(1001, 120))		-- Hull, :
	row[2]:createText(function()
			local lochullpercentage = GetComponentData(target, "hullpercent")
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and (lochullpercentage .. "%") or unknowntext
		end, { halign = "right", color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Helper.standardColor or unknowncolor end })

	row = table_right:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 80) .. ReadText(1001, 120))		-- Crew, :
	row[2]:createText(function()
			local locnumdefendingcrew = menu.getNumDefendingCrew(target)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and (locnumdefendingcrew .. " / " .. targetcrewcapacity) or unknowntext
		end, { halign = "right", color = (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Helper.standardColor or unknowncolor })

	local table_button = frame:addTable(3, { tabOrder = 6, x = Helper.borderSize, y = table_bottom.properties.y + table_bottom:getVisibleHeight() + Helper.borderSize, width = menu.contextMenuData.width })
	table_button:setColWidthPercent(2, 15)
	table_button:setColWidthPercent(3, 15)

	row = table_button:addRow(true, { bgColor = Helper.color.transparent, fixed = true })
	-- handler: if no boarding op, create a boarding op with defined specifications. (and refresh menu?)
	-- if op already created, update boarding op data. (changes in ship and marine assignments.)
	-- approachthreshold == menu.boardingData.risk1
	-- insertionthreshold == menu.boardingData.risk2
	-- activate button only if anything was changed (number of marines, thresholds, actions)
	row[2]:createButton({ active = function() return menu.boardingData.iscapturable and menu.boardingData.changed and totalassignedmarines > 0 end, helpOverlayID = "boarding_operation_start", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(activeop and ReadText(1001, 9531) or ReadText(1001, 9530), { halign = "center" })		-- Update Operation, Start Operation
	row[2].handlers.onClick = function() return menu.buttonUpdateBoardingOperation(activeop) end
	row[2].properties.uiTriggerID = "startboarding"
	row[3]:createButton({ active = true, helpOverlayID = "boarding_operation_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(activeop and ReadText(1001, 8035) or ReadText(1001, 64), { halign = "center" })		-- "Close Menu", "Cancel"
	row[3].handlers.onClick = function() return menu.closeContextMenu() end
	row[3].properties.uiTriggerID = "cancelboarding"

	if menu.contexttoprow then
		menu.boardingtable_shipselection:setTopRow(menu.contexttoprow)
		menu.contexttoprow = nil
	end
	if menu.contextselectedrow then
		menu.boardingtable_shipselection:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end
end

function menu.createMissionContext(frame)
	AddUITriggeredEvent(menu.name, "mission_context", ConvertStringToLuaID(menu.contextMenuData.missionid))

	local tablespacing = Helper.standardTextHeight
	local maxObjectiveLines = 10

	-- description table
	local desctable = frame:addTable(3, { tabOrder = 3, highlightMode = "off", maxVisibleHeight = menu.contextMenuData.descriptionHeight, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	desctable:setColWidth(1, Helper.headerRowCenteredProperties.height)
	desctable:setColWidth(3, Helper.headerRowCenteredProperties.height)
	desctable:setDefaultColSpan(1, 3)

	-- kuertee start: callback
	if callbacks ["createMissionContext_startDescriptionTable"] then
		for _, callback in ipairs (callbacks ["createMissionContext_startDescriptionTable"]) do
			callback (desctable)
		end
	end
	-- kuertee end: callback

	-- title
	local visibleHeight

	if menu.contextMenuData.onlinechapter ~= "" then
		local row = desctable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 11363), Helper.titleTextProperties)
	end

	local row = desctable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	if menu.contextMenuData.onlinechapter ~= "" then
		local icon = "vt_type_" .. menu.contextMenuData.subtype .. "_mission"
		if not C.IsIconValid(icon) then
			DebugError("Unknown online mission type icon '" .. icon .. "'. [Florian]")
			icon = "solid"
		end
		row[1]:setColSpan(1):createIcon(icon, { width = Helper.headerRowCenteredProperties.height, height = Helper.headerRowCenteredProperties.height })
		row[2]:setBackgroundColSpan(2):createText(menu.contextMenuData.name, Helper.headerRowCenteredProperties)
		row[3]:createText(" ", Helper.headerRowCenteredProperties)
	else
		row[1]:createText(menu.contextMenuData.name, Helper.headerRowCenteredProperties)
	end

	-- briefing icon if any
	local icontable
	if menu.contextMenuData.briefingicon then
		icontable = frame:addTable(1, { tabOrder = 0, highlightMode = "off", maxVisibleHeight = menu.contextMenuData.descriptionHeight, x = Helper.borderSize, y = desctable.properties.y + desctable:getFullHeight() + Helper.borderSize, width = menu.contextMenuData.briefingiconwidth })

		local row = icontable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createIcon(menu.contextMenuData.briefingicon, { scaling = false, height = menu.contextMenuData.briefingiconwidth })
		
		local row = icontable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(menu.contextMenuData.briefingiconcaption, { wordwrap = true })
	end

	-- description
	for linenum, descline in ipairs(menu.contextMenuData.description) do
		local row = desctable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:createText(descline, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = menu.contextMenuData.briefingiconwidth and (menu.contextMenuData.briefingiconwidth + Helper.borderSize + Helper.scaleX(Helper.standardTextOffsetx)) or nil, minRowHeight = Helper.scaleY(Helper.standardTextHeight) })
		if linenum == menu.contextMenuData.descriptionLines then
			visibleHeight = desctable:getFullHeight()
		end
	end
	if visibleHeight then
		desctable.properties.maxVisibleHeight = visibleHeight
	else
		desctable.properties.maxVisibleHeight = desctable:getFullHeight()
	end

	local objectiveOffsetY = desctable.properties.y + desctable:getVisibleHeight()
	if icontable then
		objectiveOffsetY = math.max(objectiveOffsetY, menu.contextMenuData.descriptionHeight)
	end
	objectiveOffsetY = objectiveOffsetY + tablespacing + Helper.borderSize

	-- objectives table
	local objectivetable = frame:addTable(2, { tabOrder = 4, highlightMode = "off", x = Helper.borderSize, y = objectiveOffsetY, maxVisibleHeight = menu.contextMenuData.objectiveHeight, width = menu.contextMenuData.width })
	objectivetable:setColWidthPercent(2, 25)
	objectivetable:setDefaultColSpan(1, 2)

	-- objectives
	local visibleHeight
	if menu.contextMenuData.threadtype ~= "" then
		-- title
		local row = objectivetable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 3418), Helper.headerRowCenteredProperties)
		if menu.contextMenuData.isoffer then
			if #menu.contextMenuData.briefingmissions > 0 then
				for i, details in ipairs(menu.contextMenuData.briefingmissions) do
					local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(1):createText(((menu.contextMenuData.threadtype == "sequential") and (i .. ReadText(1001, 120)) or "·") .. " " .. details.name, textProperties)
					local timeouttext = ((details.duration and (details.duration > 0)) and ConvertTimeString(details.duration, (details.duration >= 3600) and "%h:%M:%S" or "%M:%S") or "")
					row[2]:createText(timeouttext .. "  \27[missiontype_" .. details.type .. "]", { halign = "right" })

					if i == maxObjectiveLines then
						visibleHeight = objectivetable:getFullHeight()
					end
				end
			else
				local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
			end
		else
			if #menu.contextMenuData.subMissions > 0 then
				for i, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
					local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(1):createText(((menu.contextMenuData.threadtype == "sequential") and (i .. ReadText(1001, 120)) or "·") .. " " .. submissionEntry.name, textProperties)
					row[2]:createText(function () return menu.getSubMissionTimer(submissionEntry) end, { halign = "right" })
					if i == maxObjectiveLines then
						visibleHeight = objectivetable:getFullHeight()
					end
				end
			else
				local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
			end
		end
	else
		-- title
		local row = objectivetable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 3402), Helper.headerRowCenteredProperties)
		if #menu.contextMenuData.briefingobjectives > 0 then
			for linenum, briefingobjective in ipairs(menu.contextMenuData.briefingobjectives) do
				local infotext = ""
				local textProperties = {}
				if linenum < menu.contextMenuData.activebriefingstep then
					infotext = " - " .. (briefingobjective.failed and ReadText(1001, 3422) or ReadText(1001, 3416))
					textProperties.color = Helper.color.grey
				elseif linenum == menu.contextMenuData.activebriefingstep then
					if (not menu.isOffer) and (menu.contextMenuData.missionid == C.GetActiveMissionID()) then
						textProperties.color = Helper.color.mission
					end
				else
					if briefingobjective.completedoutofsequence then
						infotext = " - " .. ReadText(1001, 3416)
						textProperties.color = Helper.color.grey
					end
				end
				local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(briefingobjective.encyclopedia and 1 or 2):createText(briefingobjective.step .. ReadText(1001, 120) .. " " .. briefingobjective.text .. infotext, textProperties)

				if menu.infoTableMode == "mission" and linenum == menu.contextMenuData.activebriefingstep then
					if menu.contextMenuData.curProgress and menu.contextMenuData.maxProgress then
						if menu.contextMenuData.curProgress > 0 or menu.contextMenuData.maxProgress > 0 then
							if not string.find(briefingobjective.text, tostring(menu.contextMenuData.curprogress) .. " / ") then
								local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
								local progressText
								if menu.contextMenuData.progressname ~= nil then
									progressText = "    " .. menu.contextMenuData.progressname .. ReadText(1001, 120) .. " "
								else
									progressText = "    " .. ReadText(1001, 9513) .. ReadText(1001, 120) .. " "
								end
								progressText = progressText .. tostring(menu.contextMenuData.curProgress) .. " / " .. tostring(menu.contextMenuData.maxProgress)
								row [1]:setColSpan(2):createText(progressText, textProperties)
							end
						end
					end
				end

				if briefingobjective.encyclopedia then
					local buttonsize = Helper.scaleY(Helper.standardTextHeight)
					row[2]:createButton({ scaling = false, active = briefingobjective.encyclopedia.known, height = buttonsize, width = buttonsize, x = row[2]:getWidth() - buttonsize, mouseOverText = briefingobjective.encyclopedia.known and ReadText(1001, 2416) or ReadText(1026, 3259) }):setIcon("mm_externallink")
					row[2].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, briefingobjective.encyclopedia.mode, briefingobjective.encyclopedia.library, briefingobjective.encyclopedia.id, briefingobjective.encyclopedia.object }); menu.cleanup() end
				end
				if linenum == maxObjectiveLines then
					visibleHeight = objectivetable:getFullHeight()
				end
			end
		else
			local row = objectivetable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
		end
	end
	if visibleHeight then
		objectivetable.properties.maxVisibleHeight = visibleHeight
	else
		objectivetable.properties.maxVisibleHeight = objectivetable:getFullHeight()
	end

	-- bottom table (info and buttons)
	local bottomtable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = objectivetable.properties.y + objectivetable:getVisibleHeight() + tablespacing, width = menu.contextMenuData.width, highlightMode = "off" })

	-- faction
	if menu.contextMenuData.factionName then
		local row = bottomtable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 43) .. ReadText(1001, 120))
		row[2]:createText(menu.contextMenuData.factionName, { halign = "right" })
	end
	-- reward
	local rewardtext
	if menu.contextMenuData.rewardmoney ~= 0 then
		rewardtext = ConvertMoneyString(menu.contextMenuData.rewardmoney, false, true, 0, true) .. " " .. ReadText(1001, 101)
		if menu.contextMenuData.rewardtext ~= "" then
			rewardtext = rewardtext .. " \n" .. menu.contextMenuData.rewardtext
		end
	else
		rewardtext = menu.contextMenuData.rewardtext
	end
	local row = bottomtable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 3301) .. ReadText(1001, 120))
	row[2]:createText(rewardtext, { halign = "right", wordwrap = true })
	-- difficulty
	if menu.contextMenuData.difficulty ~= 0 then
		local row = bottomtable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 3403) .. ReadText(1001, 120))
		row[2]:createText(ConvertMissionLevelString(menu.contextMenuData.difficulty), { halign = "right" })
	end
	-- time left
	local row = bottomtable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 3404) .. ReadText(1001, 120))
	row[2]:createText(menu.getMissionContextTime, { halign = "right" })

	-- buttons
	if menu.contextMenuData.isoffer then
		-- Accept & Briefing
		local row = bottomtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		local active = true
		local mouseovertext
		if C.IsMissionLimitReached(false, false, false) then
			active = false
			mouseovertext = ReadText(1026, 3242)
		elseif menu.contextMenuData.onlinechapter ~= "" then
			if C.HasAcceptedOnlineMission() then
				mouseovertext = "\27R" .. ReadText(1026, 11301)
			end
		end

		-- kuertee start: callback
		if active then
			if callbacks ["createMissionContext_getIsMissionAcceptable"] then
				for _, callback in ipairs (callbacks ["createMissionContext_getIsMissionAcceptable"]) do
					active = callback (menu.contextMenuData.missionid)
					if active == 0 or active == false then
						break
					end
				end
			end
		end
		-- kuertee end: callback

		row[1]:createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "map_acceptmission", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 57), { halign = "center" })
		row[1].handlers.onClick = menu.buttonMissionOfferAccept
		row[1].properties.uiTriggerID = "missionofferaccept"

		-- kuertee start: callback
		local kEM_isBriefingAvailable = nil
		if callbacks ["createMissionContext_getIsMissionBriefingAvailable"] then
			for _, callback in ipairs (callbacks ["createMissionContext_getIsMissionBriefingAvailable"]) do
				kEM_isBriefingAvailable = callback (menu.contextMenuData.missionid)
				if kEM_isBriefingAvailable == 0 or kEM_isBriefingAvailable == false then
					break
				end
			end
		end
				
		if kEM_isBriefingAvailable == nil then
			-- Vanilla do original logic
			row[2]:createButton({  }):setText(ReadText(1001, 3326), { halign = "center" })
		else
			-- Emergent Missions is installed do modified logic
			row[2]:createButton({active = kEM_isBriefingAvailable}):setText(ReadText(1001, 3326), { halign = "center" })
		end
		-- kuertee end: callback

		row[2].handlers.onClick = menu.buttonMissionOfferBriefing
		row[2].properties.uiTriggerID = "missionofferbriefing"


		-- kuertee start: callback
		if callbacks ["createMissionContext_addMissionOfferButtons"] then
			for _, callback in ipairs (callbacks ["createMissionContext_addMissionOfferButtons"]) do
				active = callback (bottomtable, menu.contextMenuData.missionid)
			end
		end
		-- kuertee end: callback

	else
		-- Abort & Briefing
		local active = menu.contextMenuData.abortable
		local mouseovertext = ""
		if menu.contextMenuData.threadMissionID ~= 0 then
			local details = menu.getMissionIDInfoHelper(menu.contextMenuData.threadMissionID)
			active = active and (details.threadtype ~= "sequential")
			if details.threadtype == "sequential" then
				mouseovertext = ReadText(1026, 3405)
			end
		end
		local row = bottomtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "map_abortmission", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(ReadText(1001, 3407), { halign = "center" })
		row[1].handlers.onClick = menu.buttonMissionAbort
		row[1].properties.uiTriggerID = "missionabort"
		row[2]:createButton({  }):setText(ReadText(1001, 3326), { halign = "center" })
		row[2].handlers.onClick = menu.buttonMissionBriefing
		row[2].properties.uiTriggerID = "missionbriefing"
		local row

		-- kuertee start: allow buttons in guidance missions
		-- if menu.contextMenuData.type ~= "guidance" then
		-- kuertee end: allow buttons in guidance missions

			-- Set active
			local active = menu.contextMenuData.missionid == C.GetActiveMissionID()
			for _, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
				if submissionEntry.active then
					active = true
				end
			end
			row = bottomtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ helpOverlayID = "map_activatemission", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(active and ReadText(1001, 3413) or ReadText(1001, 3406), { halign = "center" })
			row[1].handlers.onClick = menu.buttonMissionActivate
			row[1].properties.uiTriggerID = "missionactivate"

		-- kuertee start: allow buttons in guidance missions
		-- end
		-- kuertee end: allow buttons in guidance missions

		-- deliver wares
		if #menu.contextMenuData.deliveryWares > 0 then
			if not row then
				row = bottomtable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			end

			row[2]:createButton({ active = menu.checkDeliverWaresCargo, mouseOverText = function () return menu.checkDeliverWaresCargo() and "" or ("\27R" .. ReadText(1026, 3406)) end }):setText(ReadText(1001, 3423), { halign = "center" })
			row[2].handlers.onClick = menu.buttonMissionDeliverWares
			row[2].properties.uiTriggerID = "missiondeliverwares"
		end

		-- kuertee start: callback
		if callbacks ["createMissionContext_addMissionAcceptedButtons"] then
			for _, callback in ipairs (callbacks ["createMissionContext_addMissionAcceptedButtons"]) do
				active = callback (bottomtable, menu.contextMenuData.missionid)
			end
		end
		-- kuertee end: callback
	end
	local neededheight = bottomtable.properties.y + bottomtable:getFullHeight() + Helper.frameBorder
	if frame.properties.y + neededheight > Helper.viewHeight then
		frame.properties.y = Helper.viewHeight - neededheight
	end

	desctable.properties.nextTable = objectivetable.index
	objectivetable.properties.prevTable = desctable.index

	objectivetable.properties.nextTable = bottomtable.index
	bottomtable.properties.prevTable = objectivetable.index

	-- kuertee start: callback
	if callbacks ["createMissionContext_on_end"] then
		for _, callback in ipairs (callbacks ["createMissionContext_on_end"]) do
			callback (frame)
		end
	end
	-- kuertee end: callback
end

function menu.checkDeliverWaresCargo()
	local hascargo = true
	local cargo = GetComponentData(ConvertStringTo64Bit(tostring(menu.contextMenuData.deliveryWares.target)), "cargo") or {}
	for _, entry in ipairs(menu.contextMenuData.deliveryWares) do
		if (cargo[entry.ware] or 0) == 0 then
			hascargo = false
			break
		end
	end
	return hascargo
end

function menu.getMissionContextTime()
	if not menu.contextMenuData.expired then
		if (not menu.contextMenuData.isoffer) and menu.contextMenuData.missionid then
			local missiondetails = C.GetMissionIDDetails(menu.contextMenuData.missionid)
			local timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)

			return (timeout > 0 and ConvertTimeString(timeout, (timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "-")
		else
			return (menu.contextMenuData.timeout > 0 and ConvertTimeString(menu.contextMenuData.timeout, (menu.contextMenuData.timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "-")
		end
	else
		return "-"
	end
end

function menu.getSubMissionTimer(submissionentry)
	local text
	if not submissionentry.expired then
		if not menu.isOffer then
			local missiondetails = C.GetMissionIDDetails(ConvertStringTo64Bit(submissionentry.ID))
			local timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)

			text = (timeout > 0 and ConvertTimeString(timeout, (timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "")
		else
			text = (submissionentry.timeout > 0 and ConvertTimeString(submissionentry.timeout, (submissionentry.timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "")
		end
	else
		text = ""
	end

	return text .. "  \27[missiontype_" .. submissionentry.type .. "]"
end

function menu.createInfoContext(frame)
	local instance = menu.contextMenuData.instance

	local controllable = menu.contextMenuData.component
	local entity = menu.contextMenuData.entity
	local person = menu.contextMenuData.person
	local inv_ware = menu.contextMenuData.inv_ware
	local weaponmacro = menu.contextMenuData.weaponmacro
	local equipmentmacro = menu.contextMenuData.equipmentmacro
	local software = menu.contextMenuData.software
	local personrole = ""
	if not (controllable and (person or entity or inv_ware or weaponmacro or equipmentmacro or software)) then
		DebugError(string.format("menu.createInfoContext called with invalid controllable or invalid actor, invalid ware and invalid macro. controllable: %s, person: %s, entity: %s, inv_ware: %s, software: %s, weaponmacro: %s, equipmentmacro: %s", tostring(controllable), tostring(person), tostring(entity), tostring(inv_ware), tostring(software), tostring(weaponmacro), tostring(equipmentmacro)))
		return
	end
	if person then
		--print("person: " .. ffi.string(C.GetPersonName(person, controllable)) .. ", combinedskill: " .. C.GetPersonCombinedSkill(controllable, person, nil, nil))
		-- get real NPC if instantiated
		local instance = C.GetInstantiatedPerson(person, controllable)
		entity = (instance ~= 0 and instance or nil)
		personrole = ffi.string(C.GetPersonRole(person, controllable))
	end
	entity = entity and ConvertStringTo64Bit(tostring(entity)) or nil

	local loctable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local title = ""
	if entity then
		title = ffi.string(C.GetComponentName(entity))
	elseif person then
		title = ffi.string(C.GetPersonName(person, controllable))
	elseif inv_ware or software then
		title = GetWareData(inv_ware or software, "name")
	elseif weaponmacro or equipmentmacro then
		title = GetMacroData(weaponmacro or equipmentmacro, "name")
	end

	-- title
	local row = loctable:addRow(false, { fixed = true })
	row[1]:createText(title, Helper.headerRowCenteredProperties)

	local oldpilot = GetComponentData(controllable, "assignedaipilot")
	if oldpilot then
		oldpilot = ConvertStringTo64Bit(tostring(oldpilot))
	end

	local transferscheduled = false
	local hasarrived = true
	if person then
		transferscheduled = C.IsPersonTransferScheduled(controllable, person)
		hasarrived = C.HasPersonArrived(controllable, person)
	end
	
	local player = C.GetPlayerID()
	if person then
		if GetComponentData(controllable, "isplayerowned") then
			if transferscheduled then
				local row = loctable:addRow("info_person_cancel_transfer", { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1001, 9435))	-- Cancel all scheduled transfers
				row[1].handlers.onClick = function () return menu.infoSubmenuCancelTransfer(controllable, person) end
			elseif hasarrived then
				if (personrole == "service") or (personrole == "marine") then
					local printedtitle = C.IsComponentClass(controllable, "ship_s") and ReadText(1001, 4847) or ReadText(1001, 4848)	-- Pilot, Captain
					local row = loctable:addRow("info_person_promote", { fixed = true, bgColor = Helper.color.transparent })
					row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight, active = function () return menu.infoSubmenuReplacePilot(controllable, oldpilot, person, true, true, instance) end }):setText(ReadText(1001, 9433) .. " " .. printedtitle)	-- Promote to(followed by "captain" or "pilot")
					row[1].handlers.onClick = function () return menu.infoSubmenuReplacePilot(controllable, oldpilot, person, false, true, instance) end
				end
			end
		end
	end
	if person or (entity and (entity ~= player)) then
		if GetComponentData(controllable, "isplayerowned") then
			if (person and ((personrole == "service") or (personrole == "marine") or (personrole == "trainee_group"))) or (entity and GetComponentData(entity, "isplayerowned") and GetComponentData(entity, "caninitiatecomm")) then
				if hasarrived then
					-- work somewhere else
					local row = loctable:addRow("info_person_worksomewhere", { fixed = true, bgColor = Helper.color.transparent })
					row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1002, 3008))
					if entity then
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", entity, 0 } }); menu.cleanup() end
					else
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", controllable, 0, person} }); menu.cleanup() end
					end
				end
				-- fire
				local row = loctable:addRow("info_person_fire", { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1002, 15800))
				row[1].handlers.onClick = function () return menu.infoSubmenuFireNPCConfirm(controllable, entity, person, instance) end
			end
		end
	elseif inv_ware or weaponmacro or equipmentmacro or software then
		local row = loctable:addRow("info_inv_ware", { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1001, 2416))	-- Show Encyclopedia Entry
		if inv_ware then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "inventory_wares", inv_ware }); menu.cleanup() end
		elseif weaponmacro then
			local library = GetMacroData(weaponmacro, "infolibrary")
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Weapons", library, weaponmacro }); menu.cleanup() end
		elseif equipmentmacro then
			local library = GetMacroData(equipmentmacro, "infolibrary")
			local mode = "Equipment"
			if library == "mines" then
				mode = "Weapons"
			end
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, mode, library, equipmentmacro }); menu.cleanup() end
		elseif software then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Equipment", "software", software }); menu.cleanup() end
		end
	end
	local conversationactor = entity
	if person and (not entity or C.GetContextByClass(entity, "container", false) ~= C.GetContextByClass(player, "container", false)) then
		-- Talking to person - either not instantiated as a real entity, or the instance is far away.
		-- Note: Only start comms with instantiated NPCs if they are on the player container, otherwise they are likely to get despawned during the conversation.
		conversationactor = { context = ConvertStringToLuaID(tostring(controllable)), person = ConvertStringToLuaID(tostring(person)) }
	end
	if person or entity then
		if (not transferscheduled) and hasarrived then
			row = loctable:addRow("info_actor_comm", { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight, active = (not entity) or (entity ~= player) }):setText(ReadText(1001, 3216))	-- (initiate comm)Comm
			row[1].handlers.onClick = function () menu.openCommWithActor(conversationactor) end
		end
	end

	-- adjust frame position
	local neededheight = loctable.properties.y + loctable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createSellShipsContext(frame)
	-- description table
	local ftable = frame:addTable(2, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })
	ftable:setColWidthPercent(1, 60)

	-- title
	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 7857), Helper.headerRowCenteredProperties)
	-- ships
	local issellingpossible = false
	menu.contextMenuData.totalprice = 0
	for i, data in ipairs(menu.contextMenuData.ships) do
		local errors, warnings = {}, {}
		local n = C.GetNumOrders(data)
		local buf = ffi.new("Order[?]", n)
		n = C.GetOrders(buf, n, data)
		for i = 0, n - 1 do
			if ffi.string(buf[i].orderdef) == "Equip" then
				errors[1] = ReadText(1001, 3267)
				break
			end
		end
		local hasanymod = GetComponentData(data, "hasanymod")
		if hasanymod then
			warnings[1] = ReadText(1001, 3268)
		end
		menu.contextMenuData.ships[i] = { data, errors }
		local ship = menu.contextMenuData.ships[i][1]
		local price = GetTotalValue(ship, true, menu.contextMenuData.shipyard)

		local color = Helper.color.white
		if #errors > 0 then
			color = Helper.color.grey
		else
			issellingpossible = true
			menu.contextMenuData.totalprice = menu.contextMenuData.totalprice + price
		end

		-- keep these selectable to support scrolling when selling a lot of ships
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
		row[1]:createText(ffi.string(C.GetComponentName(ship)) .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")", { color = color })
		row[2]:createText(ConvertMoneyString(price, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = color })

		for _, error in ipairs(errors) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
			row[1]:setColSpan(2):createText(error, { halign = "right", color = Helper.color.red })
		end
		for _, warning in ipairs(warnings) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
			row[1]:setColSpan(2):createText(warning, { halign = "right", color = Helper.color.orange })
		end
	end
	-- button
	local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
	row[2]:createButton({ active = issellingpossible, height = Helper.standardTextHeight }):setText(ReadText(1001, 2917), { halign = "center" })
	row[2].handlers.onClick = menu.buttonSellShips

	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - config.contextBorder
	end
	local height = frame:getUsedHeight()
	if frame.properties.y + height > Helper.viewHeight then
		local newypos = Helper.viewHeight - height - config.contextBorder
		frame.properties.y = math.max(config.contextBorder, newypos)
	end
end

function menu.createSelectContext(frame)
	-- description table
	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(Helper.unlockInfo(IsInfoUnlockedForPlayer(menu.contextMenuData.component, "name"), ffi.string(C.GetComponentName(menu.contextMenuData.component))), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	local active = true
	local mouseovertext = ""
	if menu.mode == "selectCV" then
		local assignedpilot, isplayerowned, isenemy = GetComponentData(menu.contextMenuData.component, "assignedpilot", "isplayerowned", "isenemy")
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.contextMenuData.component, hasloop)

		if isenemy then
			active = false
			mouseovertext = "\27R" .. ReadText(1026, 8014)
		elseif hasloop[0] then
			active = false
			mouseovertext = "\27R" .. ReadText(1026, 7852)
		elseif menu.contextMenuData.component == C.GetPlayerOccupiedShipID() then
			active = false
			mouseovertext = "\27R" .. ReadText(1026, 3224)
		elseif C.IsBuilderBusy(menu.contextMenuData.component) then
			active = false
			mouseovertext = "\27R" .. ReadText(1026, 7820)
		elseif not assignedpilot then
			active = false
			mouseovertext = "\27R" .. ReadText(1026, 7801)
		elseif not isplayerowned then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney < fee then
				active = false
				mouseovertext = "\27R" .. ReadText(1026, 3222)
			end
		end
	elseif menu.mode == "selectComponent" then
		active = menu.checkForSelectComponent(menu.contextMenuData.component)
	end
	row[1]:createButton({ active = active, height = Helper.standardTextHeight, mouseOverText = mouseovertext }):setText(ReadText(1001, 3102))
	row[1].handlers.onClick = menu.buttonSelectHandler
	row[1].properties.uiTriggerID = "selectactive"

	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - config.contextBorder
	end
	local height = frame:getUsedHeight()
	if frame.properties.y + height > Helper.viewHeight then
		frame.properties.y = Helper.viewHeight - height - config.contextBorder
	end
end

function menu.createWeaponConfigContext(frame, instance)
	local ftable = frame:addTable(2, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, Helper.standardTextHeight)

	-- title
	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 1105), Helper.headerRowCenteredProperties)

	if not menu.contextMenuData.usedefault then
		for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
			if entry.id == "default" then
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createCheckBox(entry.active, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[1].handlers.onClick = function () return menu.checkboxSetWeaponConfig(entry.id, not entry.active) end
				row[2]:createText(entry.name)
				break
			end
		end
	end

	ftable:addEmptyRow(1)

	if menu.contextMenuData.default then
		menu.contextMenuData.weaponsystems = {}
		local n = C.GetNumAllowedWeaponSystems()
		local buf = ffi.new("WeaponSystemInfo[?]", n)
		n = C.GetAllowedWeaponSystems(buf, n, menu.contextMenuData.component, 0, true)
		for i = 0, n - 1 do
			table.insert(menu.contextMenuData.weaponsystems, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), active = buf[i].active })
		end
	end

	for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
		if entry.id ~= "default" then
			local color = Helper.color.white
			if menu.contextMenuData.default then
				color = Helper.color.grey
			end
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(entry.active, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function () return menu.checkboxSetWeaponConfig(entry.id, not entry.active) end
			row[2]:createText(entry.name, { color = color })
		end
	end

	local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createButton({ active = not menu.contextMenuData.default }):setText(ReadText(1001, 5706), { halign = "center" })
	row[1].handlers.onClick = menu.buttonClearWeaponConfig

	local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText("")

	local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createButton():setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonConfirmWeaponConfig

	local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[1].handlers.onClick = menu.buttonCancelWeaponConfig
end

-- update
menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.updatePeopleInfo and (menu.updatePeopleInfo <= curtime) then
		menu.refreshCrewInfo()
		menu.updatePeopleInfo = nil
	end

	if menu.mainFrame then
		menu.mainFrame:update()
	end
	if menu.infoFrame then
		menu.infoFrame:update()
	end
	if menu.infoFrame2 then
		menu.infoFrame2:update()
	end
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if menu.map and menu.holomap ~= 0 then
		local x, y = GetRenderTargetMousePosition(menu.map)
		C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
	end
	
	local refreshing = false
	if menu.refreshIF and (menu.refreshIF < curtime) then
		refreshing = true
		menu.refreshIF = nil
	end

	if menu.refreshMissionContext and (menu.refreshMissionContext.time < curtime) then
		menu.showMissionContext(menu.refreshMissionContext.id, false)
		menu.refreshMissionContext = nil
	end
	
	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainFrameLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.rendertargetWidth / menu.rendertargetHeight, 1)
			if menu.holomap ~= 0 then
				C.ClearSelectedMapComponents(menu.holomap)
				if menu.showMultiverse then
					C.ShowMultiverseMap(menu.holomap)
				elseif menu.mode == "selectbuildlocation" then
					C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
				else
					if menu.focuscomponent and menu.focusoffset then
						C.ShowUniverseMap2(menu.holomap, true, menu.showzone, menu.mode == "selectCV", menu.focuscomponent, menu.focusoffset)
						menu.focuscomponent = nil
					else
						local startpos = ffi.new("UIPosRot")
						C.ShowUniverseMap2(menu.holomap, true, menu.showzone, menu.mode == "selectCV", 0, startpos)
					end
					menu.focusoffset = nil
				end
			end

			if menu.focuscomponent then
				C.SetFocusMapComponent(menu.holomap, menu.focuscomponent, true)
			end

			if menu.mapstate then
				C.SetMapState(menu.holomap, menu.mapstate)
				menu.mapstate = nil
			end

			if menu.mode == "hire" then
				local classes = ffi.new("const char*[?]", 2)
				classes[0] = Helper.ffiNewString("ship")
				classes[1] = Helper.ffiNewString("station")
				C.SetMapObjectFilter(menu.holomap, classes, 2, 1, true)
				Helper.ffiClearNewHelper()
				C.ClearMapOrderParamObjectFilter(menu.holomap)
			elseif menu.mode == "selectComponent" then
				local numclasses = menu.modeparam[2] and #menu.modeparam[2] or 0
				local classes = ffi.new("const char*[?]", numclasses)
				if numclasses > 0 then
					for i, class in ipairs(menu.modeparam[2]) do
						classes[i - 1] = Helper.ffiNewString(class)
					end
				end
				C.SetMapObjectFilter(menu.holomap, classes, numclasses, menu.modeparam[4] or -1, false)
				Helper.ffiClearNewHelper()
				C.ClearMapOrderParamObjectFilter(menu.holomap)
			elseif menu.mode == "orderparam_object" then
				if type(menu.modeparam[5]) == "string" then
					C.SetMapDefaultOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
				else
					C.SetMapOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
				end
				C.ClearMapObjectFilter(menu.holomap)
			else
				C.ClearMapOrderParamObjectFilter(menu.holomap)
				C.ClearMapObjectFilter(menu.holomap)
			end
			Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
			menu.applyFilterSettings()

			menu.activatemap = false
			if menu.infoTableMode == "objectlist" then
				menu.refreshIF = getElapsedTime()
			end
		end
	end

	if not menu.refreshed then
		if menu.holomap and (menu.holomap ~= 0) then
			if menu.picking ~= menu.pickstate then
				menu.pickstate = menu.picking
				C.SetMapPicking(menu.holomap, menu.pickstate)
			end
		end
	end
	menu.refreshed = nil
	
	if menu.lock and curtime > menu.lock + 0.01 then
		menu.lock = nil
	end
	if menu.over then
		menu.refreshInfoFrame()
		menu.over = nil
		return
	end

	-- evaluate mouse cursor overrides
	if menu.holomap and (menu.holomap ~= 0) then
		menu.updateMouseCursor()
		if menu.plotData.active then
			local offset = ffi.new("UIPosRot")
			local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
			if offsetsector ~= 0 then
				if C.IsCurrentBuildMapPlotPositionDiscovered(offsetsector, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000) then
					local price = tonumber(C.GetBuildPlotPrice(offsetsector, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000, "player"))
					SetMouseOverOverride(menu.map, ReadText(1001, 2808) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tostring(price), false, true, 0, true) .. " " .. ReadText(1001, 101))
				else
					SetMouseOverOverride(menu.map, nil)
				end
			end
		end
	end

	local range = 100
	if menu.contextMenuData and menu.contextMenuData.mouseOutPos then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] > menu.contextMenuData.mouseOutPos[1] + range) or (curpos[1] < menu.contextMenuData.mouseOutPos[1] - range)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.contextMenuData.mouseOutPos[2] + range) or (curpos[2] < menu.contextMenuData.mouseOutPos[2] - range)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.lastHighlightCheck + 1.0 < curtime then
		menu.lastHighlightCheck = curtime
		if menu.highlightLeftBar["mission"] then
			if C.GetActiveMissionID() == 0 then
				menu.highlightLeftBar["mission"] = nil
				menu.refreshMainFrame = true
			end
		end
		if menu.showMultiverse then
			local outcomes = GetVentureOutcomes()
			if (next(outcomes) ~= nil) ~= menu.highlightLeftBar["ventureoperation"] then
				menu.highlightLeftBar["ventureoperation"] = next(outcomes) ~= nil
				menu.refreshMainFrame = true
			end
		end
	end

	if ((menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders"))) or
	   ((menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders"))) then
		if menu.infoSubmenuObject and (menu.infoSubmenuObject ~= 0) then
			local orders = {}
			if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
				local n = C.GetNumOrders(menu.infoSubmenuObject)
				local buf = ffi.new("Order[?]", n)
				n = C.GetOrders(buf, n, menu.infoSubmenuObject)
				for i = 0, n - 1 do
					local entry = {}
					entry.state = ffi.string(buf[i].state)
					entry.orderdef = ffi.string(buf[i].orderdef)
					entry.actualparams = tonumber(buf[i].actualparams)
					table.insert(orders, entry)
				end
			end

			if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders")) then
				if menu.infoTableData.left.orders then
					if #orders ~= #menu.infoTableData.left.orders then
						refreshing = true
					else
						for i, order in ipairs(orders) do
							local oldorder = menu.infoTableData.left.orders[i]
							if (order.state ~= oldorder.state) or (order.orderdef ~= oldorder.orderdef) then
								refreshing = true
								break
							end
						end
					end
				end
			end
			if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders")) then
				if menu.infoTableData.right.orders then
					if #orders ~= #menu.infoTableData.right.orders then
						refreshing = true
					else
						for i, order in ipairs(orders) do
							local oldorder = menu.infoTableData.right.orders[i]
							if (order.state ~= oldorder.state) or (order.orderdef ~= oldorder.orderdef) then
								refreshing = true
								break
							end
						end
					end
				end
			end
		end
	end

	if menu.orderdrag and menu.orderdrag.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if menu.leftdown and ((menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5)) then
			menu.orderdrag.isclick = false
			if menu.orderdrag.isintermediate then
				if menu.orderdrag.component ~= C.GetPlayerOccupiedShipID() then
					local posrot = ffi.new("UIPosRot")
					local eclipticoffset = ffi.new("UIPosRot")
					local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)
					if posrotcomponent ~= 0 then
						local hasloop = ffi.new("bool[1]", 0)
						C.GetOrderQueueFirstLoopIdx(menu.orderdrag.component, hasloop)
						if C.IsOrderSelectableFor("MoveWait", menu.orderdrag.component) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
							local orderidx = C.CreateOrder(menu.orderdrag.component, "MoveWait", false)
							if orderidx > 0 then
								SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, 1, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
								SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, 5, nil, true)
								-- If we added the new move order in front of a default order, menu.orderdrag.order.queueidx == 0 -> change it to length of the queue for the new order now on the queue
								if menu.orderdrag.order.queueidx == 0 then
									menu.orderdrag.order.queueidx = C.GetNumOrders(menu.orderdrag.component)
								end
								C.AdjustOrder(menu.orderdrag.component, orderidx, menu.orderdrag.order.queueidx, menu.orderdrag.order.enabled, false, false)
							end
							if menu.infoTableMode == "mission" then
								menu.refreshIF = curtime
							end
						end
					else
						-- we should create a new order, but there is no valid position here (e.g. between clusters), store the need to create a new order for later
						menu.orderdrag.createneworder = true
					end
				end
			end
		end
	end
	if menu.orderdrag and (not menu.orderdrag.isclick) then
		if (menu.orderdrag.component ~= C.GetPlayerOccupiedShipID()) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") then
			if menu.orderdrag.createneworder then
				local posrot = ffi.new("UIPosRot")
				local eclipticoffset = ffi.new("UIPosRot")
				local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)
				
				if posrotcomponent ~= 0 then
					local hasloop = ffi.new("bool[1]", 0)
					C.GetOrderQueueFirstLoopIdx(menu.orderdrag.component, hasloop)
					if C.IsOrderSelectableFor("MoveWait", menu.orderdrag.component) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
						local neworderidx = C.CreateOrder(menu.orderdrag.component, "MoveWait", false)
						if neworderidx > 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), neworderidx, 1, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), neworderidx, 5, nil, true)
							-- If we added the new move order in front of a default order, menu.orderdrag.order.queueidx == 0 -> change it to length of the queue for the new order now on the queue
							if menu.orderdrag.order.queueidx == 0 then
								menu.orderdrag.order.queueidx = C.GetNumOrders(menu.orderdrag.component)
							end
							C.AdjustOrder(menu.orderdrag.component, neworderidx, menu.orderdrag.order.queueidx, menu.orderdrag.order.enabled, false, false)
						end
						if menu.infoTableMode == "mission" then
							menu.refreshIF = curtime
						end
					end
					menu.orderdrag.createneworder = nil
				end
			end

			if not menu.orderdrag.createneworder then
				local posrot = ffi.new("UIPosRot")

				local paramidx = config.orderDragSupport[ffi.string(menu.orderdrag.orderdefid)]
				-- the order queue can change while we are dragging the new order (previous order stops because it was only waiting)
				-- recheck the pickedorder on the map and adjust the queueidx if there is a picked non-intermediate order (during dragging this must be the order we are dragging)
				local pickedorder = ffi.new("Order")
				local isintermediate = ffi.new("bool[1]", 0)
				local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
				if (pickedordercomponent == menu.orderdrag.component) and (not isintermediate[0]) then
					menu.orderdrag.order.queueidx = pickedorder.queueidx
				end

				local orderidx = (tonumber(menu.orderdrag.order.queueidx) == 0) and "default" or tonumber(menu.orderdrag.order.queueidx)
				local orderparams = GetOrderParams(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx)
				if next(orderparams) then
					if (orderparams[paramidx].type == "position") and (type(orderparams[paramidx].value[2]) == "table") then
						local eclipticoffset = ffi.new("UIPosRot", orderparams[paramidx].value[2])
			
						local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, ConvertIDTo64Bit(orderparams[paramidx].value[1]), eclipticoffset)
						if posrotcomponent ~= 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, paramidx, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
						end
					else
						DebugError("menu.onUpdate(): Invalid order parameter used for orderdrag: " .. menu.orderdrag.orderdefid .. ", param '" .. paramidx .. "' of type '" .. orderparams[paramidx].type .. "'")
					end
				end
			end
		end
	end

	if menu.intersectordrag and menu.intersectordrag.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if menu.leftdown and ((menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5)) then
			menu.intersectordrag.isclick = false
		end
	end
	if menu.intersectordrag and (not menu.intersectordrag.isclick) then
		local posrot = ffi.new("UIPosRot")
		local currentsector = C.GetSubordinateGroupProtectedSector(menu.intersectordrag.component, menu.intersectordrag.group)
		local eclipticoffset = C.GetSubordinateGroupProtectedPosition(menu.intersectordrag.component, menu.intersectordrag.group)
			
		local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, currentsector, eclipticoffset)
		if posrotcomponent ~= 0 then
			C.SetSubordinateGroupProtectedLocation(menu.intersectordrag.component, menu.intersectordrag.group, posrotcomponent, posrot)
		end
	end

	if menu.panningmap and menu.panningmap.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if (menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5) then
			menu.panningmap.isclick = false
		end
	end

	if menu.lastzoom then
		if not menu.zoom_newdir or menu.zoom_newdir ~= menu.lastzoom.dir then
			if menu.zoom_newdir then
				if menu.sound_zoom then
					StopPlayingSound(menu.sound_zoom)
				end
				menu.sound_zoom = nil
			end

			if menu.lastzoom.dir == "in" then
				menu.sound_zoom = StartPlayingSound("ui_scroll_zoomin")
				menu.zoom_newdir = "in"
			elseif menu.lastzoom.dir == "out" then
				menu.sound_zoom = StartPlayingSound("ui_scroll_zoomout")
				menu.zoom_newdir = "out"
			end
		elseif menu.sound_zoom and menu.lastzoom.time + 0.3 < curtime then
			StopPlayingSound(menu.sound_zoom)
			menu.sound_zoom = nil
			menu.zoom_newdir = nil
			menu.lastzoom = nil
		end
	end

	if menu.leftdown then
		if not menu.leftdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.leftdown.position, offset, 5) then
				menu.leftdown.wasmoved = true
			end
		end
		if menu.leftdown.wasmoved and menu.leftdown.time + 0.1 < curtime and not C.IsComponentClass(C.GetPickedMapComponent(menu.holomap), "object") then
			local currentmousepos = table.pack(GetLocalMousePosition())
			if menu.panningmap and Helper.comparePositions(menu.leftdown.dynpos, currentmousepos, 5) then
				if not menu.sound_panmap then
					menu.sound_panmap = StartPlayingSound("ui_scroll_wasd")
				end
				menu.leftdown.dynpos = currentmousepos
			elseif menu.sound_panmap then
				StopPlayingSound(menu.sound_panmap)
				menu.sound_panmap = nil
			end
		end
	end

	if menu.rightdown then
		if not menu.rightdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.rightdown.position, offset, 5) then
				menu.rightdown.wasmoved = true
			end
		end
		if menu.rightdown.wasmoved and menu.rightdown.time + 0.1 < curtime and not C.IsComponentClass(C.GetPickedMapComponent(menu.holomap), "object") then
			local currentmousepos = table.pack(GetLocalMousePosition())
			if menu.rotatingmap then
				if currentmousepos[2] > menu.rightdown.dynpos[2] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "down" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_down"), dir = "down"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_down"), dir = "down"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif currentmousepos[2] < menu.rightdown.dynpos[2] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "up" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_up"), dir = "up"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_up"), dir = "up"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif menu.rightdown.dynpos[1] ~= currentmousepos[1] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "up" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_cirle"), dir = "rot"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_cirle"), dir = "rot"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif menu.sound_rotatemap then
					if menu.sound_rotatemap.sound then
						StopPlayingSound(menu.sound_rotatemap.sound)
					end
					menu.sound_rotatemap = nil
				end
			end
		end
	end

	if (menu.infoTableMode == "objectlist") then
		if menu.lastrefresh + 2.0 < curtime then
			refreshing = true
		end
	end

	if Helper.hasExtension("multiverse") then
		if Helper.callExtensionFunction("multiverse", "updateVentures", menu) then
			refreshing = true
		end
	end

	if menu.infoSubmenuObject and (menu.infoSubmenuObject ~= 0) and (not IsValidComponent(menu.infoSubmenuObject)) then
		menu.infoSubmenuObject = 0
		refreshing = true
	end

	if refreshing and (not menu.noupdate) then
		menu.lastrefresh = curtime
		menu.refreshInfoFrame()
	end

	if menu.refreshFilterSettings then
		menu.applyFilterSettings()
		menu.refreshMainFrame = true
		menu.refreshFilterSettings = nil
	end

	if menu.inputModeHasChanged then
		if not menu.noupdate then
			menu.refreshMainFrame = true
			menu.inputModeHasChanged = nil
		end
	end

	if not menu.panningmap then
		if menu.refreshMainFrame then
			if not menu.createMainFrameRunning then
				if not menu.disregardFilterTable then
					menu.topRows.filterTable = GetTopRow(menu.searchField)
					menu.selectedRows.filterTable = Helper.currentTableRow[menu.searchField]
					menu.selectedCols.filterTable = Helper.currentTableCol[menu.searchField]
				end

				menu.selectedRows.sideBar = Helper.currentTableRow[menu.sideBar]
				menu.selectedRows.rightBar = Helper.currentTableRow[menu.rightBar]

				menu.createMainFrame(nil, (menu.contextMenuMode == "trade") and menu.contextMenuData.tradeModeHeight or nil, true)
				menu.disregardFilterTable = nil
				menu.refreshMainFrame = nil
			end
		end
	end

	if menu.contextMenuMode == "trade" then
		if (not menu.tradeSliderLock) then
			local playermoney = GetPlayerMoney()
			if playermoney ~= menu.contextMenuData.playerMoney then
				menu.contextMenuData.playerMoney = playermoney
				menu.queuetradecontextrefresh = true
			end
		end
	elseif menu.contextMenuMode == "rename" then
		if menu.contextMenuData.nameEditBox then
			ActivateEditBox(menu.contextMenuData.nameEditBox.id)
			menu.contextMenuData.nameEditBox = nil
		end
	end

	if menu.queuecontextrefresh and (menu.queuecontextrefresh < curtime) then
		menu.refreshContextFrame()
		menu.queuecontextrefresh = nil
	end

	if menu.queuetradecontextrefresh then
		menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
		menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
		menu.createContextFrame()
		menu.queuetradecontextrefresh = nil
	end
end

-- row changes
function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	-- Lock button over updates
	menu.lock = getElapsedTime()

	-- handle map modes without a holomap first
	if (menu.mode == "boardingcontext") and menu.boardingtable_shipselection and (uitable == menu.boardingtable_shipselection.id) and (type(rowdata) == "table") and (rowdata[1] == "boardingship") and C.IsComponentClass(rowdata[2], "defensible") and (menu.boardingData.selectedship ~= rowdata[2]) then
		--print("queueing refresh on next frame. ship: " .. ffi.string(C.GetComponentName(rowdata[2])) .. " " .. tostring(rowdata[2]))
		menu.boardingData.selectedship = rowdata[2]
		menu.queuecontextrefresh = menu.lock
	elseif menu.contextMenuMode == "trade" then
		if uitable == menu.contextshiptable then
			if rowdata then
				if (type(rowdata) == "table") and next(rowdata) then
					menu.selectedTradeWare = rowdata
				else
					menu.selectedTradeWare = nil
				end
				if (not menu.skipTradeRowChange) and (not menu.tradeSliderLock) then
					menu.queuetradecontextrefresh = true
				end
				menu.skipTradeRowChange = nil
			end
		end
	end

	if menu.holomap == 0 then
		return
	end

	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureseason") then
			if uitable == menu.infoTable then
				Helper.callExtensionFunction("multiverse", "onRowChanged", menu, menu.ventureMode, row, rowdata, uitable, modified, input, source)
			end
		end
	else
		
		-- start Forleyor_infoCenter Callback:
		if callbacks ["ic_onRowChanged"] then
			for _, callback in ipairs (callbacks ["ic_onRowChanged"]) do
				callback (row, rowdata, uitable, modified, input, source)
			end
		end
		-- end Forleyor_infoCenter:

		if (menu.infoTableMode == "info") then
			if uitable == menu.infoTable then
				if (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") or (menu.infoMode.left == "objectloadout") then
					menu.selectedRows.infotableleft = row
					if menu.infoMode.left == "objectloadout" then
						local infomacrostolaunch = menu.infoTablePersistentData.left.macrostolaunch
						if (type(rowdata) == "table") and (rowdata[1] == "info_deploy") then
							if GetMacroData(rowdata[2], "islasertower") and (infomacrostolaunch.lasertower ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { lasertower = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "mine") and (infomacrostolaunch.mine ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { mine = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "navbeacon") and (infomacrostolaunch.navbeacon ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { navbeacon = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "resourceprobe") and (infomacrostolaunch.resourceprobe ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { resourceprobe = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "satellite") and (infomacrostolaunch.satellite ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { satellite = rowdata[2] }
							end
						else
							menu.infoTablePersistentData.left.macrostolaunch = {}
						end
					end
				elseif (menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders") then
					if type(rowdata) == "table" then
						menu.infoTablePersistentData.left.selectedorder = rowdata
						menu.infoTablePersistentData.left.selectedorder.object = menu.infoSubmenuObject
					else
						menu.infoTablePersistentData.left.selectedorder = nil
					end
				end
			end

		-- kuertee start:
		-- elseif (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
		elseif (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
			-- kuertee end:

			if uitable == menu.infoTable then
				if type(rowdata) == "table" then
					local convertedComponent = ConvertIDTo64Bit(rowdata[2])
					if (source ~= "auto") and convertedComponent then
						local convertedcomponentclass = ffi.string(C.GetComponentClass(convertedComponent))
						if convertedcomponentclass  == "station" then
							AddUITriggeredEvent(menu.name, "selection_station", convertedComponent)
						end
						if (convertedcomponentclass  == "ship_s") or (convertedcomponentclass  == "ship_m") or (convertedcomponentclass  == "ship_l") or (convertedcomponentclass  == "ship_xl") then
							AddUITriggeredEvent(menu.name, "selection_ship", convertedComponent)
						end
						if (convertedcomponentclass == "resourceprobe") then
							AddUITriggeredEvent(menu.name, "selection_resourceprobe", convertedComponent)
						end

						if (menu.mode ~= "orderparam_object") and (input ~= "rightmouse") then
							menu.setInfoSubmenuObjectAndRefresh(convertedComponent)
						end
					end
					menu.updateSelectedComponents(modified, source == "auto", convertedComponent, row)
					menu.setSelectedMapComponents()
				end
			end
		elseif menu.infoTableMode == "plots" then
			if menu.plotDoNotUpdate then
				menu.plotDoNotUpdate = nil
			elseif menu.table_plotlist and (uitable == menu.table_plotlist.id) then
				menu.settoprow = GetTopRow(menu.table_plotlist)
				menu.setrow = Helper.currentTableRow[menu.table_plotlist]
				if not rowdata then
					print("rowdata empty. table id: " .. tostring(uitable) .. ", row: " .. tostring(row) .. ", rowdata: " .. tostring(rowdata))
				elseif input == "mouse" then
					--print("table id: " .. tostring(uitable) .. ", row: " .. tostring(row) .. ", rowdata: " .. tostring(rowdata) .. ", menu.table_plotlist.id: " .. tostring(menu.table_plotlist.id) .. ", uitable == menu.table_plotlist.id? " .. tostring(uitable == menu.table_plotlist.id))
					if rowdata == "plots_new" then
						menu.updatePlotData("plots_new", true)
					else
						C.SetFocusMapComponent(menu.holomap, rowdata, true)
					end
					menu.updatePlotData(rowdata)
				end
			end
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if uitable == menu.infoTable then
				if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
					Helper.callExtensionFunction("multiverse", "onRowChanged", menu, "ventureoperation", row, rowdata, uitable, modified, input, source)
				else
					local oldmission = menu.missionModeCurrent
					if type(rowdata) == "table" then
						local missionid = ConvertStringTo64Bit(rowdata[1])
						menu.missionModeCurrent = rowdata[1]
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						elseif input == "mouse" then
							if menu.contextMenuData and menu.contextMenuData.missionid and (menu.contextMenuData.missionid == missionid) then
								menu.closeContextMenu()
								menu.missionModeContext = nil
							else
								menu.closeContextMenu()
								menu.showMissionContext(missionid)
								menu.missionModeContext = true
							end
						end
					elseif type(rowdata) == "string" then
						menu.missionModeCurrent = rowdata
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						elseif input == "mouse" then
							menu.closeContextMenu()
							menu.missionModeContext = nil
						end
					end
					if menu.missionDoNotUpdate then
						menu.missionDoNotUpdate = nil
					elseif menu.missionModeCurrent ~= oldmission then
						if source ~= "auto" then
							menu.refreshInfoFrame()
						end
					end
				end
			end
		end
	end

	if (menu.searchTableMode == "info") then
		if uitable == menu.infoTableRight then
			if (menu.infoMode.right == "objectinfo") or (menu.infoMode.right == "objectcrew") or (menu.infoMode.right == "objectloadout") then
				menu.selectedRows.infotableright = row
				if menu.infoMode.right == "objectloadout" then
					local infomacrostolaunch = menu.infoTablePersistentData.right.macrostolaunch
					if (type(rowdata) == "table") and (rowdata[1] == "info_deploy") then
						if GetMacroData(rowdata[2], "islasertower") and (infomacrostolaunch.lasertower ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { lasertower = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "mine") and (infomacrostolaunch.mine ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { mine = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "navbeacon") and (infomacrostolaunch.navbeacon ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { navbeacon = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "resourceprobe") and (infomacrostolaunch.resourceprobe ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { resourceprobe = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "satellite") and (infomacrostolaunch.satellite ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { satellite = rowdata[2] }
						end
					else
						menu.infoTablePersistentData.right.macrostolaunch = {}
					end
				end
			elseif (menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders") then
				if type(rowdata) == "table" then
					menu.infoTablePersistentData.right.selectedorder = rowdata
					menu.infoTablePersistentData.right.selectedorder.object = menu.infoSubmenuObject
				else
					menu.infoTablePersistentData.right.selectedorder = nil
				end
			end
		end
	end
end

function menu.onRowChangedSound(row, rowdata, uitable, layer, modified, input)
	if (menu.frames[layer] == GetActiveFrame()) and (uitable == GetInteractiveObject(menu.frames[layer])) then
		local playsound = false
		if uitable == menu.infoTable then
			if (not menu.sound_rowChangedRowLeft) or (menu.sound_rowChangedRowLeft ~= row) then
				playsound = true
			end
		elseif uitable ~= menu.infoTableRight then
			if (not menu.sound_rowChangedRowRight) or (menu.sound_rowChangedRowRight ~= row) then
				playsound = true
			end
		else
			playsound = true
		end
		if playsound then
			PlaySound((uitable == menu.sideBar) and "ui_positive_hover_side" or "ui_positive_hover_normal")
		end
	end
	if uitable == menu.infoTable then
		menu.sound_rowChangedRowLeft = row
	elseif uitable == menu.infoTableRight then
		menu.sound_rowChangedRowRight = row
	end
end

function menu.setSelectedMapComponents()
	if menu.holomap and (menu.holomap ~= 0) then
		local numcomponents = 0
		for _, _ in pairs(menu.selectedcomponents) do
			numcomponents = numcomponents + 1
		end
		local components = ffi.new("UniverseID[?]", numcomponents)
		local i = 0
		for id, _ in pairs(menu.selectedcomponents) do
			components[i] = ConvertStringTo64Bit(id)
			i = i + 1
		end
		C.SetSelectedMapComponents(menu.holomap, components, numcomponents)
	end
end

function menu.onSelectElement(uitable, modified, row, isdblclick, input)
	local rowdata = Helper.getCurrentRowData(menu, uitable)
	if menu.showMultiverse then
		if menu.ventureMode == "ventureoperation" then
			if uitable == menu.infoTable then
				Helper.callExtensionFunction("multiverse", "onSelectRow", menu, menu.ventureMode, uitable, modified, row, isdblclick, input)
			elseif uitable == menu.contextinfotable then
				Helper.callExtensionFunction("multiverse", "onSelectRow", menu, menu.ventureMode, uitable, modified, row, isdblclick, input)
			end
		end
	else

		-- start Forleyor_infoCenter Callback:
		if callbacks ["ic_onSelectElement"] then
			for _, callback in ipairs (callbacks ["ic_onSelectElement"]) do
				callback (uitable, modified, row, isdblclick, input)
			end
		end
		-- end Forleyor_infoCenter:

		-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
		-- kuertee start: callback
		if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
			-- kuertee end: callback

			if uitable == menu.infoTable then
				if type(rowdata) == "table" then
					local convertedRowComponent = ConvertIDTo64Bit(rowdata[2])
					menu.setSelectedMapComponents()

					if convertedRowComponent and (convertedRowComponent ~= 0) then
						local isonlineobject, isplayerowned = GetComponentData(rowdata[2], "isonlineobject", "isplayerowned")
						if (isdblclick or (input ~= "mouse")) and (ffi.string(C.GetComponentClass(convertedRowComponent)) ~= "sector") then
							if string.find(rowdata[1], "subordinates") then
								local subordinates = menu.infoTableData.left.subordinates[tostring(rowdata[2])] or {}
								local groups = {}
								for _, subordinate in ipairs(subordinates) do
									local group = GetComponentData(subordinate, "subordinategroup")
									if group and group > 0 then
										if groups[group] then
											table.insert(groups[group].subordinates, subordinate)
										else
											groups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(convertedRowComponent, group)), subordinates = { subordinate } }
										end
									end
								end

								if groups[rowdata[3]] then
									C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(groups[rowdata[3]].subordinates[1]), true)
									menu.addSelectedComponents(groups[rowdata[3]].subordinates, modified ~= "shift")
								end
							elseif isplayerowned and isonlineobject then
								local assigneddock = ConvertIDTo64Bit(GetComponentData(convertedRowComponent, "assigneddock"))
								if assigneddock then
									local container = C.GetContextByClass(assigneddock, "container", false)
									if container then
										C.SetFocusMapComponent(menu.holomap, container, true)
									end
								end
							else
								C.SetFocusMapComponent(menu.holomap, convertedRowComponent, true)
							end
						end
					end
				end
			end
		elseif menu.infoTableMode == "plots" then
			if menu.plotDoNotUpdate then
				menu.plotDoNotUpdate = nil
			elseif menu.table_plotlist and (uitable == menu.table_plotlist.id) then
				if rowdata == "plots_new" then
					menu.updatePlotData("plots_new", true)
				else
					C.SetFocusMapComponent(menu.holomap, rowdata, true)
				end
				menu.updatePlotData(rowdata)
			end
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if uitable == menu.infoTable then
				if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
					Helper.callExtensionFunction("multiverse", "onSelectRow", menu, "ventureoperation", uitable, modified, row, isdblclick, input)
				else
					if type(rowdata) == "table" then
						menu.missionModeCurrent = rowdata[1]
						local missionid = ConvertStringTo64Bit(rowdata[1])
						if menu.contextMenuData and menu.contextMenuData.missionid and (menu.contextMenuData.missionid == missionid) then
							menu.closeContextMenu()
							menu.missionModeContext = nil
						else
							menu.closeContextMenu()
							menu.showMissionContext(missionid)
							menu.missionModeContext = true
						end
					elseif type(rowdata) == "string" then
						menu.missionModeCurrent = rowdata
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						else
							menu.closeContextMenu()
							menu.missionModeContext = nil
						end
					end
				end
			end
		elseif (menu.infoTableMode == "info") then
			if (isdblclick or (input ~= "mouse")) then
				if (rowdata == "info_focus") or ((type(rowdata) == "table") and (rowdata[1] == "info_focus")) then
					C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true)
				end
				if (menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") then
					if (type(rowdata) == "table") and (type(rowdata[1]) == "number") then
						C.SetFocusMapOrder(menu.holomap, menu.infoSubmenuObject, rowdata[1], true)
					end
				end
			end
		end
	end

	if (menu.searchTableMode == "info") then
		if (isdblclick or (input ~= "mouse")) then
			if (rowdata == "info_focus") or ((type(rowdata) == "table") and (rowdata[1] == "info_focus")) then
				C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true)
			end
			if (menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") then
				if (type(rowdata) == "table") and (type(rowdata[1]) == "number") then
					C.SetFocusMapOrder(menu.holomap, menu.infoSubmenuObject, rowdata[1], true)
				end
			end
		end
	end
end

-- rendertarget selections
function menu.onRenderTargetSelect(modified)
	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.5 seconds and the mouse was moved more than a distance of 5px
	if (not menu.leftdown) or ((menu.leftdown.time + 0.5 > getElapsedTime()) and not Helper.comparePositions(menu.leftdown.position, offset, 5)) then
		if menu.showMultiverse then
			local pickedplayer = C.GetPickedMultiverseMapPlayer(menu.holomap)
			-- TODO
		elseif menu.mode == "selectbuildlocation" then
			local station = 0
			if menu.plotData.active then
				local offset = ffi.new("UIPosRot")
				local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
				if offsetsector ~= 0 then
					if C.IsCurrentBuildMapPlotValid(menu.holomap) then
						AddUITriggeredEvent(menu.name, "plotplaced")
						menu.plotData.sector = offsetsector
						station = C.ReserveBuildPlot(offsetsector, "player", menu.plotData.set, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
						if GetComponentData(ConvertStringTo64Bit(tostring(offsetsector)), "isplayerowned") then
							local size = { x = menu.plotData.size.x * 1000, y = menu.plotData.size.y * 1000, z = menu.plotData.size.z * 1000 }
							local plotcenter = { x = offset.x, y = offset.y, z = offset.z }
							C.PayBuildPlotSize(station, size, plotcenter)
						end
						C.ClearMapBuildPlot(menu.holomap)
						menu.plotData.active = nil
						SetMouseOverOverride(menu.map, nil)
					else
						PlaySound("ui_target_set_fail")
					end
				end
			else
				local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
				local pickedcomponentclass = ffi.string(C.GetRealComponentClass(pickedcomponent))
				if (pickedcomponentclass == "station") and GetComponentData(ConvertStringToLuaID(tostring(pickedcomponent)), "isplayerowned") then
					station = pickedcomponent
				end
			end

			if station ~= 0 then
				for _, row in ipairs(menu.table_plotlist.rows) do
					if row.rowdata == station then
						menu.setplotrow = row.index
						menu.setplottoprow = (row.index - config.plots.maxPlotRows + 1) > 1 and (row.index - config.plots.maxPlotRows + 1) or 1
						break
					end
				end

				menu.updatePlotData(station, true)
				menu.refreshInfoFrame()
			end
		elseif menu.mode == "orderparam_position" then
			local offset = ffi.new("UIPosRot")
			local eclipticoffset = ffi.new("UIPosRot")
			local offsetcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, offset, false, 0, eclipticoffset)
			if offsetcomponent ~= 0 then
				local class = ffi.string(C.GetComponentClass(offsetcomponent))
				if (not menu.modeparam[2].inputparams.class) or (class == menu.modeparam[2].inputparams.class) then
					menu.modeparam[1]({ConvertStringToLuaID(tostring(offsetcomponent)), {offset.x, offset.y, offset.z}})
				elseif (menu.modeparam[2].inputparams.class == "zone") and (class == "sector") then
					offsetcomponent = C.GetZoneAt(offsetcomponent, offset)
					menu.modeparam[1]({ConvertStringToLuaID(tostring(offsetcomponent)), {offset.x, offset.y, offset.z}})
				end
			end
		elseif (menu.mode == "orderparam_selectenemies") or (menu.mode == "orderparam_selectplayerdeployables") then
			menu.mode = nil
			menu.modeparam = {}
			SetMouseCursorOverride("default")
			menu.removeMouseCursorOverride(3)
		elseif menu.mode == "boardingcontext" then

		else
			if menu.searchField then
				Helper.confirmEditBoxInput(menu.searchField, 1, 7)
			end
			local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
			local pickedorder = ffi.new("Order")
			local isintermediate = ffi.new("bool[1]", 0)
			local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
			local pickedcomponentclass = ffi.string(C.GetComponentClass(pickedcomponent))
			local ispickedcomponentship = C.IsComponentClass(pickedcomponent, "ship") and not C.IsUnit(pickedcomponent)
			local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
			if pickedordercomponent ~= 0 then
				local sectorcontext = C.GetContextByClass(pickedordercomponent, "sector", false)
				if sectorcontext ~= menu.currentsector then
					menu.currentsector = sectorcontext
				end

				menu.createInfoFrame()
			elseif pickedtradeoffer ~= 0 then
				local tradeid = ConvertStringToLuaID(tostring(pickedtradeoffer))
				local tradedata = GetTradeData(tradeid)
				if tradedata.ware then
					local setting, rawwarelist = menu.getTradeWareFilter()
					local found = false
					for i, ware in ipairs(rawwarelist) do
						if ware == tradedata.ware then
							found = i
							break
						end
					end
					AddUITriggeredEvent(menu.name, "filterwareselected", tradedata.isbuyoffer and "buyoffer" or "selloffer")
					if found then
						menu.removeFilterOption(setting, setting.id, found)
					else
						menu.setFilterOption("layer_trade", setting, setting.id, tradedata.ware)
					end
				end
			elseif pickedcomponent ~= 0 then
				local pickedcomponent64 = ConvertStringTo64Bit(tostring(pickedcomponent))
				if (not menu.sound_selectedelement) or (menu.sound_selectedelement ~= pickedcomponent) or (modified == "ctrl") or (modified == "shift") then
					local isselected = menu.isSelectedComponent(pickedcomponent)
					if (not isselected) and (modified == "shift") then
						PlaySound("ui_positive_multiselect")
					elseif modified == "ctrl" then
						if isselected then
							PlaySound("ui_positive_deselect")
						else
							PlaySound("ui_positive_multiselect")
						end
					elseif (pickedcomponentclass == "sector") then
						PlaySound("ui_positive_deselect")
					else
						PlaySound("ui_positive_select")
					end
				end
				menu.sound_selectedelement = pickedcomponent
				if menu.mode ~= "orderparam_object" then
					if not menu.handlePlannedDefaultOrderRendertargetSelect(false) then
						return
					end

					menu.setInfoSubmenuObjectAndRefresh(pickedcomponent64)
				end

				if pickedcomponentclass == "sector" then
					AddUITriggeredEvent(menu.name, "selection_reset")
					menu.clearSelectedComponents()
					if pickedcomponent ~= menu.currentsector then
						menu.currentsector = pickedcomponent
						menu.updateMapAndInfoFrame()
					end
				elseif (#menu.searchtext == 0) or Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(pickedcomponent, numtexts, texts, true) end) then
					local isconstruction = IsComponentConstruction(pickedcomponent64)
					if (C.IsComponentOperational(pickedcomponent) and (pickedcomponentclass ~= "player") and (pickedcomponentclass ~= "collectablewares") and (not menu.createInfoFrameRunning)) or
						(pickedcomponentclass == "gate") or (pickedcomponentclass == "asteroid") or isconstruction
					then
						local sectorcontext = C.GetContextByClass(pickedcomponent, "sector", false)
						if sectorcontext ~= menu.currentsector then
							menu.currentsector = sectorcontext
						end
						
						if modified == "ctrl" then
							menu.toggleSelectedComponent(pickedcomponent)
						else
							if pickedcomponentclass == "station" then
								AddUITriggeredEvent(menu.name, "selection_station", pickedcomponent64)
							end
							if (pickedcomponentclass == "ship_s") or (pickedcomponentclass == "ship_m") or (pickedcomponentclass == "ship_l") or (pickedcomponentclass == "ship_xl") then
								AddUITriggeredEvent(menu.name, "selection_ship", pickedcomponent64)
							end
							if (pickedcomponentclass == "resourceprobe") then
								AddUITriggeredEvent(menu.name, "selection_resourceprobe", pickedcomponent64)
							end

							local newmode
							if (menu.mode ~= "selectComponent") or (menu.modeparam[3] ~= "deployables") then

								-- kuertee start:
								-- if menu.infoTableMode == "objectlist" then
								if string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
									-- kuertee end:

									local isdeployable = GetComponentData(pickedcomponent64, "isdeployable")
									if isdeployable or (pickedcomponentclass == "lockbox") then
										newmode = "deployables"
									elseif menu.objectMode ~= "objectall" then
										if C.IsRealComponentClass(pickedcomponent, "station") then
											newmode = "stations"
										elseif ispickedcomponentship then
											local found = false
											local commanderlist = GetAllCommanders(pickedcomponent64)
											for i, entry in ipairs(commanderlist) do
												if IsComponentClass(entry, "station") then
													found = true
													break
												end
											end
											if found then
												newmode = "stations"
											else
												newmode = "ships"
											end
										end
									end

									-- kuertee start:
									-- elseif menu.infoTableMode == "propertyowned" then
								elseif string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
									-- kuertee end:

									local isplayerowned, isdeployable = GetComponentData(pickedcomponent64, "isplayerowned", "isdeployable")
									if isplayerowned then
										if isdeployable or (pickedcomponentclass == "lockbox") then
											newmode = "deployables"
										elseif menu.propertyMode ~= "propertyall" then
											if C.IsRealComponentClass(pickedcomponent, "station") then
												newmode = "stations"
											elseif ispickedcomponentship then
												local found = false
												local commanderlist = GetAllCommanders(pickedcomponent64)
												for i, entry in ipairs(commanderlist) do
													if IsComponentClass(entry, "station") then
														found = true
														break
													end
												end
												local subordinates = GetSubordinates(pickedcomponent64)
												if found then
													newmode = "stations"
												else
													if (#commanderlist > 0) or (#subordinates > 0) then
														newmode = "fleets"
													else
														newmode = "unassignedships"
													end
												end
											end
										end
									end

									-- start: mycu call-back
									if callbacks ["onRenderTargetSelect_on_propertyowned_newmode"] then
										for _, callback in ipairs (callbacks ["onRenderTargetSelect_on_propertyowned_newmode"]) do
											result = callback (pickedcomponent64, newmode)
											if result then
												newmode = result.newmode
											end
										end
									end
									-- end: mycu call-back

								end
							end
							menu.addSelectedComponent(pickedcomponent, not modified)
							if newmode then

								-- kuertee start:
								-- if menu.infoTableMode == "objectlist" then
								if string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
									-- kuertee end:

									if newmode ~= menu.objectMode then
										menu.objectMode = newmode
										menu.refreshInfoFrame()
									end

									-- kuertee start:
									-- elseif menu.infoTableMode == "propertyowned" then
								elseif string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
									-- kuertee end:

									if newmode ~= menu.propertyMode then
										menu.propertyMode = newmode
										menu.refreshInfoFrame()
									end
								end
							end
						end
					end
				end
			else
				if (menu.mode ~= "info") or (not menu.infoMode.left) or (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") or (menu.infoMode.left == "objectloadout") or (menu.infoMode.left == "objectlogbook") then
					AddUITriggeredEvent(menu.name, "selection_reset")
					menu.clearSelectedComponents()
				end
			end
		end
	end
	menu.leftdown = nil
end

-- rendertarget doubleclick
function menu.onRenderTargetDoubleClick(modified)
	local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
	if pickedcomponent ~= 0 then
		if not C.IsComponentClass(pickedcomponent, "sector") then
			if modified == "shift" then 
				C.AddSimilarMapComponentsToSelection(menu.holomap, pickedcomponent)
			elseif modified ~= "ctrl" then 
				C.SetFocusMapComponent(menu.holomap, pickedcomponent, true)
			end

			local components = {}
			Helper.ffiVLA(components, "UniverseID", C.GetNumMapSelectedComponents, C.GetMapSelectedComponents, menu.holomap)
			if #components > 0 then
				menu.addSelectedComponents(components)
			else
				menu.clearSelectedComponents()
			end
		end
	end
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown(modified)
	menu.leftdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }

	local pickedorder = ffi.new("Order")
	local buf = ffi.new("bool[1]", 0)
	local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, buf)
	local isintermediate = buf[0]
	local pickedintersectordefense = C.GetPickedMapInterSectorDefence(menu.holomap)
	if pickedordercomponent ~= 0 then
		if (menu.mode ~= "orderparam_object") and (menu.mode ~= "orderparam_position") then
			if not modified then
				if not menu.handlePlannedDefaultOrderRendertargetSelect(false) then
					return
				end

				menu.setInfoSubmenuObjectAndRefresh(ConvertStringTo64Bit(tostring(pickedordercomponent)))
			end

			menu.addSelectedComponent(pickedordercomponent, true)

			if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
				local orderdef = ffi.new("OrderDefinition")
				if C.GetOrderDefinition(orderdef, pickedorder.orderdef) then
					local orderdefid = ffi.string(orderdef.id)
					if isintermediate or config.orderDragSupport[orderdefid] then
						menu.orderdrag = { component = pickedordercomponent, order = pickedorder, orderdefid = isintermediate and "MoveWait" or orderdefid, isintermediate = isintermediate, isclick = true }
					end
				end
			end
		end
	elseif pickedintersectordefense.controllableid ~= 0 then
		if (menu.mode ~= "orderparam_object") and (menu.mode ~= "orderparam_position") then
			if GetComponentData(ConvertStringTo64Bit(tostring(pickedintersectordefense.controllableid)), "isplayerowned") then
				menu.intersectordrag = { component = pickedintersectordefense.controllableid, group = pickedintersectordefense.group, isclick = true }
			end
		end
	else
		if modified == "shift" then
			C.StartMapBoxSelect(menu.holomap, menu.mode == "orderparam_selectenemies")
		else
			C.StartPanMap(menu.holomap)
			menu.panningmap = { isclick = true }
			menu.noupdate = true
		end
	end

	-- kuertee start: distance tool
	distanceTool_from_posRot = ffi.new("UIPosRot")
	local eclipticoffset = ffi.new("UIPosRot")
	distanceTool_from_component = C.GetMapPositionOnEcliptic2(menu.holomap, distanceTool_from_posRot, false, 0, eclipticoffset)
    -- kuertee end
end

function menu.onRenderTargetMouseUp(modified)
	if menu.orderdrag then
		if not menu.orderdrag.isclick then
			if (menu.orderdrag.component ~= C.GetPlayerOccupiedShipID()) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") then
				local posrot = ffi.new("UIPosRot")

				local paramidx = config.orderDragSupport[ffi.string(menu.orderdrag.orderdefid)]
				local orderidx = (tonumber(menu.orderdrag.order.queueidx) == 0) and "default" or tonumber(menu.orderdrag.order.queueidx)
				local orderparams = GetOrderParams(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx)
				if next(orderparams) then
					if (orderparams[paramidx].type == "position") and (type(orderparams[paramidx].value[2]) == "table") then
						local eclipticoffset = ffi.new("UIPosRot", orderparams[paramidx].value[2])

						local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, ConvertIDTo64Bit(orderparams[paramidx].value[1]), eclipticoffset)
						if posrotcomponent ~= 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, paramidx, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
						end
					else
						DebugError("menu.onRenderTargetMouseUp(): Invalid order parameter used for orderdrag: " .. menu.orderdrag.orderdefid .. ", param '" .. paramidx .. "' of type '" .. orderparams[paramidx].type .. "'")
					end
				end
			end
		end
		menu.orderdrag = nil
	elseif menu.intersectordrag then
		if not menu.intersectordrag.isclick then
			local posrot = ffi.new("UIPosRot")
			local currentsector = C.GetSubordinateGroupProtectedSector(menu.intersectordrag.component, menu.intersectordrag.group)
			local eclipticoffset = C.GetSubordinateGroupProtectedPosition(menu.intersectordrag.component, menu.intersectordrag.group)
			
			local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, currentsector, eclipticoffset)
			if posrotcomponent ~= 0 then
				C.SetSubordinateGroupProtectedLocation(menu.intersectordrag.component, menu.intersectordrag.group, posrotcomponent, posrot)
			end
		end
		menu.intersectordrag = nil
	elseif menu.panningmap then
		C.StopPanMap(menu.holomap)
		menu.noupdate = false
		if menu.sound_panmap then
			StopPlayingSound(menu.sound_panmap)
			menu.sound_panmap = nil
		end
		if menu.infoTableMode == "objectlist" then
			if not menu.panningmap.isclick then
				menu.refreshInfoFrame()
			end
		elseif menu.infoTableMode == "plots" and menu.plotData.component then
			if not menu.panningmap.isclick then
				-- update plot position and price
				menu.updatePlotData()
			end
		end
		menu.panningmap = nil
	else
		C.StopMapBoxSelect(menu.holomap)
		local components = {}
		Helper.ffiVLA(components, "UniverseID", C.GetNumMapSelectedComponents, C.GetMapSelectedComponents, menu.holomap)
		if #components > 0 then
			menu.setInfoSubmenuObjectAndRefresh(ConvertStringTo64Bit(tostring(components[1])))
			menu.sound_selectedelement = components[i]
			PlaySound("ui_positive_multiselect")
		end
		if menu.mode == "orderparam_selectenemies" then
			for i = #components, 1, -1 do
				local component = components[i]
				if component == menu.modeparam[1] then
					table.remove(components, i)
				elseif (not C.IsComponentClass(component, "ship")) and (not C.IsComponentClass(component, "station")) then
					table.remove(components, i)
				end
			end
			for id, _ in pairs(menu.selectedcomponents) do
				local selectedcomponent = ConvertStringTo64Bit(id)
				local hasloop = ffi.new("bool[1]", 0)
				C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
				if (selectedcomponent ~= C.GetPlayerOccupiedShipID()) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["Attack"].loopable) then
					if GetComponentData(selectedcomponent, "isplayerowned") then
						menu.orderAttackMultiple(selectedcomponent, menu.modeparam[1], components, menu.modeparam[2])
					end
				end
			end
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
			menu.refreshInfoFrame()
		elseif menu.mode == "orderparam_selectplayerdeployables" then
			for i = #components, 1, -1 do
				local component = ConvertStringTo64Bit(tostring(components[i]))
				if not GetComponentData(component, "isdeployable") then
					table.remove(components, i)
				end
			end
			menu.orderCollectDeployables(menu.modeparam[1], components, menu.modeparam[2])
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
			menu.refreshInfoFrame()
		else
			if #components > 0 then
				menu.addSelectedComponents(components, false)
			end
		end
	end
end

function menu.onRenderTargetMiddleMouseDown()
	-- nothing yet
end

function menu.onRenderTargetMiddleMouseUp()

end

function menu.onRenderTargetRightMouseDown()
	if (menu.mode ~= "boardingcontext") and (menu.contextMenuMode ~= "onlinemode") and (menu.contextMenuMode ~= "onlinereward") then
		menu.closeContextMenu()
	end
	menu.rightdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()) , dynpos = table.pack(GetLocalMousePosition()) }

	C.StartRotateMap(menu.holomap)
	menu.rotatingmap = true
	menu.noupdate = true
end

function menu.onRenderTargetRightMouseUp(modified)
	local offset = table.pack(GetLocalMousePosition())

	-- Check if the mouse was moved more than a distance of 5px
	if menu.rightdown and (not Helper.comparePositions(menu.rightdown.position, offset, 5)) and (not menu.rightdown.wasmoved) and (menu.mode ~= "boardingcontext") then
		if (menu.mode == "orderparam_position") then
			menu.resetOrderParamMode()
		elseif menu.mode == "selectbuildlocation" then
			if menu.plotData.active then
				C.ClearMapBuildPlot(menu.holomap)
				menu.plotData.active = nil
				SetMouseOverOverride(menu.map, nil)
			end
		elseif menu.mode == "orderparam_selectenemies" then
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
		else
			local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
			local pickedorder = ffi.new("Order")
			local isintermediate = ffi.new("bool[1]", 0)
			local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
			local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
			local pickedmissionoffer = C.GetPickedMapMissionOffer(menu.holomap)
			local pickedmission = C.GetPickedMapMission(menu.holomap)
			local pickedsyncpoint = C.GetPickedMapSyncPoint(menu.holomap)
			local pickedsyncpointorder = ffi.new("Order")
			local pickedsyncpointordercomponent = C.GetPickedMapSyncPointOwningOrder(menu.holomap, pickedsyncpointorder)
			local pickedintersectordefense = C.GetPickedMapInterSectorDefence(menu.holomap)

			local posrot = ffi.new("UIPosRot")
			local eclipticoffset = ffi.new("UIPosRot")
			local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)

			-- kuertee start: distance tool
			distanceTool_to_posRot = posrot
			distanceTool_to_component = posrotcomponent
    
    		Helper.distanceTool_distance = nil
			if distanceTool_from_component and distanceTool_from_posRot then
				local posFrom, sectorFrom, posTo, sectorTo
				if C.IsComponentClass (distanceTool_from_component, "sector") then
					posFrom = distanceTool_from_posRot
					sectorFrom = distanceTool_from_component
				else
					posFrom = C.GetObjectPositionInSector (distanceTool_from_component)
					sectorFrom = ConvertIDTo64Bit(GetComponentData(distanceTool_from_component, "sectorid"))
				end
				if C.IsComponentClass (distanceTool_to_component, "sector") then
					posTo = distanceTool_to_posRot
					sectorTo = distanceTool_to_component
				else
					posTo = C.GetObjectPositionInSector (distanceTool_to_component)
					sectorTo = ConvertIDTo64Bit(GetComponentData(distanceTool_to_component, "sectorid"))
				end
				if sectorFrom == sectorTo then
					local x_delta = math.abs (posTo.x - posFrom.x)
					local y_delta = math.abs (posTo.y - posFrom.y)
					local z_delta = math.abs (posTo.z - posFrom.z)
					Helper.distanceTool_distance = math.pow (math.pow (x_delta, 2) + math.pow (y_delta, 2) + math.pow (z_delta, 2), 0.5)
				end
			end
			distanceTool_from_posRot = distanceTool_to_posRot
			distanceTool_from_component = distanceTool_to_component
		    -- kuertee end

			local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
			if pickedordercomponent ~= 0 then
				if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
					if menu.mode ~= nil then
						PlaySound("ui_menu_interact_btn_selectinvalid_core")
					else
						menu.interactMenuComponent = pickedcomponent

						Helper.openInteractMenu(menu, { component = pickedordercomponent, order = pickedorder, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
					end
				end
			elseif pickedsyncpoint ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { syncpoint = pickedsyncpoint, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedsyncpointordercomponent ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { component = pickedsyncpointordercomponent, syncpointorder = pickedsyncpointorder, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedintersectordefense.controllableid ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { component = pickedintersectordefense.controllableid, intersectordefencegroup = pickedintersectordefense.group, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedmission ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { mission = ConvertStringTo64Bit(tostring(pickedmission)), playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
				end
			elseif pickedtradeoffer ~= 0 then
				if menu.mode == nil then
					local tradeid = ConvertStringToLuaID(tostring(pickedtradeoffer))
					local tradedata = GetTradeData(tradeid)

					local issingleloopship, selectedcomponent
					if menu.getNumSelectedComponents() == 1 then
						local component = next(menu.selectedcomponents)
						selectedcomponent = ConvertStringTo64Bit(component)
						local hasloop = ffi.new("bool[1]", 0)
						C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
						issingleloopship = hasloop[0]
					end

					if issingleloopship then
						menu.contextMenuMode = "tradeloop"
						menu.contextMenuData = { component = ConvertIDTo64Bit(tradedata.station), currentShip = selectedcomponent, orders = {}, loop = tradedata.isbuyoffer and "SingleSell" or "SingleBuy", ware = tradedata.ware, reservecargo = true }

						local offsetx = offset[1] + Helper.viewWidth / 2
						local offsety = Helper.viewHeight / 2 - offset[2]

						menu.createContextFrame(config.tradeLoopWidth, nil, offsetx, offsety)
					else
						local tradesubscription = GetComponentData(tradedata.station, "tradesubscription")
						if tradesubscription and (tradedata.amount > 0) then
							menu.contextMenuMode = "trade"
							menu.contextMenuData = { component = ConvertIDTo64Bit(tradedata.station), orders = {}, tradeid = tradeid }

							local numwarerows, numinforows = menu.initTradeContextData()
							menu.updateTradeContextDimensions(numwarerows, numinforows)
							AddUITriggeredEvent(menu.name, "pickedtradeoffer", tradedata.isbuyoffer and "buyoffer" or "selloffer")

							local width = menu.tradeContext.width
							local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize

							local offsetx = offset[1] + Helper.viewWidth / 2
							if offsetx + width > Helper.viewWidth - Helper.frameBorder then
								offsetx = Helper.viewWidth - width - Helper.frameBorder
							end
							local offsety = Helper.viewHeight / 2 - offset[2]
							if offsety + height > Helper.viewHeight - Helper.frameBorder then
								offsety = Helper.viewHeight - height - Helper.frameBorder
							end

							menu.createContextFrame(width, height, offsetx, offsety)
						else
							menu.interactMenuComponent = tradedata.station

							local missions = {}
							Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, ConvertIDTo64Bit(tradedata.station))

							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { component = tradedata.station, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, componentmissions = missions })
						end
					end
				else
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				end
			elseif pickedmissionoffer ~= 0 then
				if menu.mode == nil then
					menu.contextMenuMode = "mission"
					local width = Helper.scaleX(config.missionContextWidth)
					local height = menu.prepareMissionContextData(nil, tostring(pickedmissionoffer), width)

					local offsetx = offset[1] + Helper.viewWidth / 2
					local offsety = Helper.viewHeight / 2 - offset[2]

					if offsetx + width > Helper.viewWidth then
						offsetx = Helper.viewWidth - width - config.contextBorder
					end
					if offsety + height > Helper.viewHeight then
						offsety = Helper.viewHeight - height - config.contextBorder
					end

					menu.createContextFrame(width, height, offsetx, offsety)
					if menu.holomap ~= 0 then
						C.SetMapRenderMissionGuidance(menu.holomap, pickedmissionoffer)
					end
				else
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				end
			elseif pickedcomponent ~= 0 then
				local convertedComponent = ConvertStringTo64Bit(tostring(pickedcomponent))
				if modified ~= "ctrl" then
					if menu.mode == "hire" then
						if C.IsComponentClass(convertedComponent, "controllable") and (not C.IsComponentClass(convertedComponent, "spacesuit")) then
							local isplayerowned, isdock, isonlineobject = GetComponentData(convertedComponent, "isplayerowned", "isdock", "isonlineobject")
							if (isplayerowned or (isdock and C.IsComponentClass(convertedComponent, "station"))) and (not isonlineobject) then
								menu.contextMenuMode = "hire"
								menu.contextMenuData = { hireObject = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }

								local width = Helper.scaleX(config.hireContextWidth)
								if menu.contextMenuData.xoffset + width > Helper.viewWidth then
									menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
								end

								menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
							end
						end
					elseif menu.mode == "selectCV" then
						if C.IsComponentClass(pickedcomponent, "ship") and GetComponentData(convertedComponent, "primarypurpose") == "build" then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					elseif menu.mode == "orderparam_object" then
						if menu.checkForOrderParamObject(convertedComponent) then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2]  }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					elseif menu.mode == "selectComponent" then
						if menu.checkForSelectComponent(pickedcomponent) then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					else
						menu.interactMenuComponent = pickedcomponent

						local missions = {}
						Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, pickedcomponent)

						local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
						Helper.openInteractMenu(menu, { component = pickedcomponent, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, componentmissions = missions })
					end
				else
					local offsetx = offset[1] + Helper.viewWidth / 2
					local offsety = Helper.viewHeight / 2 - offset[2]

					menu.defaultInteraction(pickedcomponent, posrot, posrotcomponent ~= 0, offsetx, offsety)
				end
			end
		end
	end
	menu.rightdown = nil
	if menu.rotatingmap then
		C.StopRotateMap(menu.holomap)
		menu.noupdate = false
		if menu.sound_rotatemap and menu.sound_rotatemap.sound then
			StopPlayingSound(menu.sound_rotatemap.sound)
			menu.sound_rotatemap = nil
		end
		menu.rotatingmap = nil
		if menu.infoTableMode == "objectlist" then
			menu.refreshInfoFrame()
		end
	end
end

function menu.prepareMissionContextData(missionid, missionofferid, width)
	if missionid then
		local missionid64 = ConvertStringTo64Bit(missionid)
		local missiondetails = C.GetMissionIDDetails(missionid64)
		local onlineinfo = C.GetMissionOnlineInfo(missionid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		menu.contextMenuData = {
			isoffer = false,
			missionid = missionid64,
			name = ffi.string(missiondetails.missionName),
			rawdescription = ffi.string(missiondetails.missionDescription),
			difficulty = missiondetails.difficulty,
			rewardmoney = tonumber(missiondetails.reward) / 100,
			rewardtext = ffi.string(missiondetails.rewardText),
			activebriefingstep = missiondetails.activeBriefingStep,
			briefingmissions = {},
			timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1),
			abortable = missiondetails.abortable,
			offeractor = nil,
			expired = false,
			threadtype = ffi.string(missiondetails.threadType),
			threadMissionID = ConvertStringTo64Bit(tostring(missiondetails.threadMissionID)),
			type = ffi.string(missiondetails.mainType),
			subtype = ffi.string(missiondetails.subType),
			onlinechapter = onlinechapter,
			onlineID = onlineid
		}
		if menu.contextMenuData.threadtype == "" then
			local objectivedata = C.GetMissionIDObjective2(missionid64)
			menu.contextMenuData.objectiveText = ffi.string(objectivedata.objectiveText)
			menu.contextMenuData.progressname = ffi.string(objectivedata.progressname)
			menu.contextMenuData.curProgress = objectivedata.curProgress
			menu.contextMenuData.maxProgress = objectivedata.maxProgress
		end

		local briefingicon = C.GetMissionBriefingIcon(missionid64)
		if ffi.string(briefingicon.icon) ~= "" then
			menu.contextMenuData.briefingicon = ffi.string(briefingicon.icon)
			menu.contextMenuData.briefingiconcaption = ffi.string(briefingicon.caption)
			menu.contextMenuData.briefingiconwidth = math.floor(config.missionContextIconWidthFactor * width)
		end

		menu.contextMenuData.briefingobjectives = {}
		for i = 1, tonumber(missiondetails.numBriefingObjectives) do
			local objective = C.GetMissionObjectiveStep3(missionid64, i)
			table.insert(menu.contextMenuData.briefingobjectives, { step = objective.step, text = ffi.string(objective.text), failed = objective.failed, completedoutofsequence = objective.completedoutofsequence })
		end
		menu.contextMenuData.subMissions = {}
		local buf = {}
		Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionid64)
		for _, submission in ipairs(buf) do
			local submissionEntry = menu.getMissionIDInfoHelper(submission)
			table.insert(menu.contextMenuData.subMissions, submissionEntry)
		end

		menu.contextMenuData.deliveryWares = {}
		local n = C.GetNumMissionDeliveryWares(missionid64)
		if n > 0 then
			local buf = ffi.new("MissionWareDeliveryInfo[1]")
			buf[0].numwares = n
			buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", n)
			C.GetMissionDeliveryWares(buf, missionid64)
			menu.contextMenuData.deliveryWares.target = buf[0].target
			for i = 0, buf[0].numwares - 1 do
				table.insert(menu.contextMenuData.deliveryWares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
			end
		end

		local descriptionwidth = width
		if menu.contextMenuData.briefingicon then
			descriptionwidth = descriptionwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
		end
		descriptionwidth = descriptionwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionwidth)
		menu.contextMenuData.descriptionWidth = descriptionwidth

		local faction = ffi.string(missiondetails.faction)
		if faction ~= "" then
			local factionDetails = C.GetFactionDetails(faction)
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.factionName = factionName
			end
		end
	elseif missionofferid then
		local missionofferid64 = ConvertStringTo64Bit(missionofferid)
		local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, rewardmoney, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, abortable, guidancedisabled, associatedcomponent, alertLevel, offeractor, offercomponent = GetMissionOfferDetails(ConvertStringToLuaID(missionofferid))
		local onlineinfo = C.GetMissionOnlineInfo(missionofferid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		menu.contextMenuData = {
			isoffer = true,
			missionid = missionofferid64,
			name = name,
			rawdescription = description,
			difficulty = difficulty,
			rewardmoney = rewardmoney,
			rewardtext = rewardtext,
			briefingobjectives = briefingobjectives,
			activebriefingstep = activebriefingstep,
			briefingmissions = briefingmissions,
			timeout = duration or -1,
			abortable = nil,
			offeractor = offeractor,
			expired = false,
			threadtype = threadtype,
			subMissions = {},
			type = maintype,
			subtype = subtype,
			onlinechapter = onlinechapter,
			onlineID = onlineid,
		}
		local briefingicon = C.GetMissionBriefingIcon(missionofferid64)
		if ffi.string(briefingicon.icon) ~= "" then
			menu.contextMenuData.briefingicon = ffi.string(briefingicon.icon)
			menu.contextMenuData.briefingiconcaption = ffi.string(briefingicon.caption)
			menu.contextMenuData.briefingiconwidth = math.floor(config.missionContextIconWidthFactor * width)
		end

		menu.contextMenuData.deliveryWares = {}
		local n = C.GetNumMissionDeliveryWares(missionofferid64)
		if n > 0 then
			local buf = ffi.new("MissionWareDeliveryInfo[1]")
			buf[0].numwares = n
			buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", n)
			C.GetMissionDeliveryWares(buf, missionofferid64)
			menu.contextMenuData.deliveryWares.target = buf[0].target
			for i = 0, buf[0].numwares - 1 do
				table.insert(menu.contextMenuData.deliveryWares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
			end
		end

		local descriptionwidth = width
		if menu.contextMenuData.briefingicon then
			descriptionwidth = descriptionwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
		end
		descriptionwidth = descriptionwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionwidth)
		menu.contextMenuData.descriptionWidth = descriptionwidth

		if faction then
			local factionDetails = C.GetFactionDetails(faction)
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.factionName = factionName
			end
		end
	end
	if menu.contextMenuData and menu.contextMenuData.briefingobjectives then
		for i, entry in ipairs(menu.contextMenuData.briefingobjectives) do
			local mode, object
			local library, item, item2 = GetMissionObjectiveEncyclopediaReference(menu.contextMenuData.missionid, i)
			local known = true
			if library then
				if library == "Galaxy" then
					mode = library
					object = item
					known = C.IsKnownToPlayer(ConvertIDTo64Bit(object))
				elseif library == "Blueprints" then
					mode = library
					library = item
					item = item2

					local macro = GetWareData(item2, "component")
					local macrolibrary = GetMacroData(macro, "infolibrary")
					AddKnownItem(macrolibrary, macro)
				else
					AddKnownItem(library, item)
				end
				entry.encyclopedia = { mode = mode, library = library, id = item, object = object, known = known }
			end
		end
	end

	local textHeight = math.ceil(C.GetTextHeight(" ", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), 0))

	local descriptionminwidth = width - Helper.scrollbarWidth
	if menu.contextMenuData.briefingicon then
		descriptionminwidth = descriptionminwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
	end
	descriptionminwidth = descriptionminwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)

	-- restrict number of visible lines for both description table and objectives table - if there are more lines, we need a scrollbar
	menu.contextMenuData.descriptionLines = #menu.contextMenuData.description
	local maxdescriptionlines = 10
	local briefingiconheight = 0
	if menu.contextMenuData.briefingicon then
		local iconwidth = menu.contextMenuData.briefingiconwidth
		local captionheight = math.ceil(C.GetTextHeight(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)))
		-- cap the captionheight at 5 lines
		if captionheight > 5 * (textHeight + Helper.borderSize) then
			local lines = GetTextLines(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
			menu.contextMenuData.briefingiconcaption = ""
			for i = 1, 5 do
				if i > 1 then
					menu.contextMenuData.briefingiconcaption = menu.contextMenuData.briefingiconcaption .. " "
				end
				menu.contextMenuData.briefingiconcaption = menu.contextMenuData.briefingiconcaption .. lines[i]
			end
			menu.contextMenuData.briefingiconcaption = utf8.sub(menu.contextMenuData.briefingiconcaption, 1, -3) .. "..."
			captionheight = math.ceil(C.GetTextHeight(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)))
		end

		briefingiconheight = iconwidth + captionheight + Helper.borderSize
		maxdescriptionlines = math.ceil(1.5 * briefingiconheight / (textHeight + Helper.borderSize))
	end
	if menu.contextMenuData.descriptionLines > maxdescriptionlines then
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionminwidth)
		menu.contextMenuData.descriptionLines = maxdescriptionlines
		menu.contextMenuData.descriptionWidth = descriptionminwidth
	end

	if menu.contextMenuData.threadtype ~= "" then
		if menu.contextMenuData.isoffer then
			menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.briefingmissions, 1)
		else
			menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.subMissions, 1)
		end
	else
		menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.briefingobjectives, 1)
	end

	local minwidth = width - Helper.scrollbarWidth
	menu.contextMenuData.objectiveWidth = width
	if menu.contextMenuData.objectiveLines > 10 then
		menu.contextMenuData.objectiveLines = 10
		menu.contextMenuData.objectiveWidth = minwidth
	end
	menu.contextMenuData.bottomLines = 3 + (menu.contextMenuData.factionName and 1 or 0) + ((menu.contextMenuData.difficulty ~= 0) and 1 or 0) + (menu.contextMenuData.isoffer and 0 or 1)

	local tablespacing = Helper.standardTextHeight
	local headerHeight = Helper.scaleY(Helper.headerRow1Offsety) + Helper.scaleY(Helper.headerRow1Height - Helper.headerRow1Offsety)
	menu.contextMenuData.descriptionYOffset = Helper.borderSize
	menu.contextMenuData.descriptionHeight = headerHeight + math.max(menu.contextMenuData.descriptionLines * (textHeight + Helper.borderSize), briefingiconheight)
	menu.contextMenuData.objectiveYOffset = menu.contextMenuData.descriptionYOffset + menu.contextMenuData.descriptionHeight + tablespacing
	menu.contextMenuData.objectiveHeight = headerHeight + menu.contextMenuData.objectiveLines * (textHeight + Helper.borderSize)
	menu.contextMenuData.bottomYOffset = menu.contextMenuData.objectiveYOffset + menu.contextMenuData.objectiveHeight + tablespacing
	menu.contextMenuData.bottomHeight = menu.contextMenuData.bottomLines * (textHeight + Helper.borderSize)

	return menu.contextMenuData.bottomYOffset + menu.contextMenuData.bottomHeight + Helper.borderSize
end

function menu.showMissionContext(missionid, isoffer)
	menu.contextMenuMode = "mission"
	local width = Helper.scaleX(config.missionContextWidth)
	local height
	if ((not menu.showMultiverse) and (menu.infoTableMode == "mission")) or (isoffer == false) then
		height = menu.prepareMissionContextData(missionid, nil, width)
	else
		height = menu.prepareMissionContextData(nil, missionid, width)
	end

	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + Helper.borderSize + config.contextBorder
	local offsety = menu.infoTableOffsetY

	menu.createContextFrame(width, height, offsetx, offsety)
	if menu.holomap ~= 0 then
		C.SetMapRenderMissionGuidance(menu.holomap, ConvertStringTo64Bit(missionid))
	end
end

function menu.getSelectedComponentCategories()
	local playerships, otherobjects, playerdeployables = {}, {}, {}, {}

	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		local isplayerowned, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isdeployable")
		if isdeployable then
			if isplayerowned then
				table.insert(playerdeployables, selectedcomponent)
			end
		elseif C.IsComponentClass(selectedcomponent, "ship") then
			if isplayerowned then
				table.insert(playerships, selectedcomponent)
			else
				table.insert(otherobjects, selectedcomponent)
			end
		elseif C.IsRealComponentClass(selectedcomponent, "station") or C.IsRealComponentClass(selectedcomponent, "ship") then
			table.insert(otherobjects, selectedcomponent)
		end
	end

	return playerships, otherobjects, playerdeployables
end

function menu.onRenderTargetCombinedScrollDown(step)
	local curtime = getElapsedTime()
	C.ZoomMap(menu.holomap, step)
	if not menu.lastzoom or menu.lastzoom.dir ~= "out" or menu.lastzoom.time + 1.0 < curtime then
		menu.lastzoom = { time = curtime, dir = "out" }
	end
end

function menu.onRenderTargetCombinedScrollUp(step)
	local curtime = getElapsedTime()
	C.ZoomMap(menu.holomap, -step)
	if not menu.lastzoom or menu.lastzoom.dir ~= "in" or menu.lastzoom.time + 1.0 < curtime then
		menu.lastzoom = { time = curtime, dir = "in" }
	end
end

-- button mouse helper

function menu.onButtonOverSound(uitable, row, col, button, input)
	if not menu.sound_selectedelement or button ~= menu.sound_selectedelement then
		if input == "mouse" then
			if (not menu.sound_buttonOverLock) then
				PlaySound((uitable == menu.sideBar) and "ui_positive_hover_side" or "ui_positive_hover_normal")
				menu.sound_buttonOverLock = true
			end
		end
	end
	menu.sound_selectedelement = button
end

function menu.onButtonDown()
	menu.noupdate = true
	PlaySound("ui_positive_click")
end

function menu.onButtonUp()
	menu.noupdate = false
	--PlaySound("ui_positive_click")
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableScrollBarDown()
	menu.noupdate = true
	PlaySound("ui_sbar_table_down")
end

function menu.onTableScrollBarUp()
	menu.noupdate = false
end

function menu.onEditboxRightMouseClick()
	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	-- start Forleyor_infoCenter Callback:
	if callbacks ["ic_onTableRightMouseClick"] then
		for _, callback in ipairs (callbacks ["ic_onTableRightMouseClick"]) do
			callback (uitable, row, posx, posy)
		end
	end
	-- end Forleyor_infoCenter:

	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	else
		if row > (menu.numFixedRows or 0) then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if not menu.showMultiverse then

				-- kuertee start:
				-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
				if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
					-- kuertee end:

					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							local convertedRowComponent = ConvertIDTo64Bit(rowdata[2])
							if convertedRowComponent and (convertedRowComponent ~= 0) then
								local x, y = GetLocalMousePosition()
								if x == nil then
									-- gamepad case
									if posx ~= nil then
										x = posx + Helper.viewWidth / 2
										y = posy + Helper.viewHeight / 2
									end
								else
									x = x + Helper.viewWidth / 2
									y = Helper.viewHeight / 2 - y
								end

								if menu.mode == "hire" then
									local isplayerowned, isonlineobject = GetComponentData(convertedRowComponent, "isplayerowned", "isonlineobject")
									if isplayerowned and C.IsComponentClass(convertedRowComponent, "controllable") and (not C.IsComponentClass(convertedRowComponent, "spacesuit")) and (not isonlineobject) then
										menu.contextMenuMode = "hire"
										menu.contextMenuData = { hireObject = convertedRowComponent, xoffset = x, yoffset = y }

										local width = Helper.scaleX(config.hireContextWidth)
										if menu.contextMenuData.xoffset + width > Helper.viewWidth then
											menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
										end

										menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
									end
								elseif menu.mode == "selectCV" then
									menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
									menu.contextMenuMode = "select"
									menu.createContextFrame(menu.selectWidth)
								elseif menu.mode == "orderparam_object" then
									if menu.checkForOrderParamObject(convertedRowComponent) then
										menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
										menu.contextMenuMode = "select"
										menu.createContextFrame(menu.selectWidth)
									end
								elseif menu.mode == "selectComponent" then
									if menu.checkForSelectComponent(convertedRowComponent) then
										menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
										menu.contextMenuMode = "select"
										menu.createContextFrame(menu.selectWidth)
									end
								else
									local missions = {}
									Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, convertedRowComponent)
								
									local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
									if rowdata[1] == "construction" then
										menu.interactMenuComponent = convertedRowComponent
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, construction = rowdata[3], componentmissions = missions })
									elseif string.find(rowdata[1], "subordinates") then
										menu.interactMenuComponent = convertedRowComponent
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, subordinategroup = rowdata[3], componentmissions = missions })
									else
										menu.interactMenuComponent = convertedRowComponent
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, componentmissions = missions })
									end
								end
							end
						end
					end
				elseif menu.infoTableMode == "info" then
					if uitable == menu.infoTable then
						menu.prepareInfoContext(rowdata, "left")
					end
				elseif menu.infoTableMode == "missionoffer" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local missionid = ConvertStringTo64Bit(rowdata[1])
							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { missionoffer = missionid, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
						end
					end
				elseif menu.infoTableMode == "mission" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local missionid = ConvertStringTo64Bit(rowdata[1])
							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { mission = missionid, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables })
						end
					end
				end
			
			else
				if menu.ventureMode == "ventureseason" then
					if menu.seasonMode.left == "ventureteam" then
						if uitable == menu.infoTable then
							if type(rowdata) == "table" then
								if not rowdata.isplayer then
									menu.closeContextMenu()

									local x, y = GetLocalMousePosition()

									menu.contextMenuMode = "ventureteammembercontext"
									menu.contextMenuData = { teammember = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

									local width = Helper.scaleX(config.ventureTeamContextWidth)
									if menu.contextMenuData.xoffset + width > Helper.viewWidth then
										menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
									end

									menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
								end
							end
						end
					end
				elseif menu.ventureMode == "venturecontacts" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local x, y = GetLocalMousePosition()

							menu.contextMenuMode = "venturecontactcontext"
							menu.contextMenuData = { contact = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

							local width = Helper.scaleX(config.ventureContactContextWidth)
							if menu.contextMenuData.xoffset + width > Helper.viewWidth then
								menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
							end

							menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
						end
					end
				end
			end

			if menu.searchTableMode == "info" then
				if uitable == menu.infoTableRight then
					menu.prepareInfoContext(rowdata, "right")
				end
			end
		else
			menu.closeContextMenu()
		end
	end
end

function menu.prepareInfoContext(rowdata, instance)
	-- controllable: rowdata[3], actor: rowdata[2]
	-- actor may be a member of a ship's crew (person) or a ship's pilot, depending on rowdata[1]. actor should never be the player.
	if (type(rowdata) == "table") and (type(rowdata[3]) == "number") and C.IsComponentClass(rowdata[3], "controllable") then
		local controllable = rowdata[3]
		local person, entity, inv_ware, weaponmacro, equipmentmacro, software
		local isplayerowned, assignedpilot, assignedaipilot, tradenpc, shiptrader, individualtrainee = GetComponentData(rowdata[3], "isplayerowned", "assignedpilot", "assignedaipilot", "tradenpc", "shiptrader", "individualtrainee")
		if rowdata[1] == "info_crewperson" then
			if isplayerowned and C.IsPerson(rowdata[2], controllable) then
				person = rowdata[2]
			end
		elseif rowdata[1] == "info_crewnpc" then
			if GetComponentData(rowdata[2], "isplayerowned") then
				entity = rowdata[2]
			end
		elseif (rowdata[1] == "info_manager") or (rowdata[1] == "info_pilot") or (rowdata[1] == "info_shiptrader") or (rowdata[1] == "info_individualtrainee") then
			if isplayerowned or C.CanPlayerCommTarget(rowdata[2]) then
				-- ship captain
				if C.IsComponentClass(controllable, "ship") and ((ConvertStringTo64Bit(tostring(assignedpilot)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(assignedaipilot)) == rowdata[2])) then
					entity = rowdata[2]
				-- station manager or shiptrader
				elseif C.IsComponentClass(controllable, "station") and ((ConvertStringTo64Bit(tostring(tradenpc)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(shiptrader)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(individualtrainee)) == rowdata[2])) then
					entity = rowdata[2]
				end
			end
		elseif rowdata[1] == "info_inventory" then
			inv_ware = rowdata[2]
		elseif rowdata[1] == "info_weapon" then
			weaponmacro = rowdata[2]
		elseif (rowdata[1] == "info_equipment") or (rowdata[1] == "info_deploy") then
			equipmentmacro = rowdata[2]
		elseif rowdata[1] == "info_software" then
			software = rowdata[2]
		end

		if person or entity or inv_ware or weaponmacro or equipmentmacro or software then
			--print("person: " .. ffi.string(C.GetPersonName(rowdata[2], rowdata[3])) .. ", combinedskill: " .. C.GetPersonCombinedSkill(rowdata[3], rowdata[2], nil, nil))
			local x, y = GetLocalMousePosition()
			menu.contextMenuData = { component = controllable, person = person, entity = entity, inv_ware = inv_ware, weaponmacro = weaponmacro, equipmentmacro = equipmentmacro, software = software, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y, instance = instance }
			menu.contextMenuMode = "info_context"
			menu.createContextFrame(menu.selectWidth)
		end
	end
end

function menu.onButtonRightMouseClick()
	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	end
end

function menu.onInteractiveElementChanged(element)
	menu.lastactivetable = element
end

-- close menu handler
function menu.onCloseElement(dueToClose, layer)
	PlaySound("ui_negative_back")
	if (menu.contextMenuMode == "onlinemode") or ((menu.contextMenuMode == "onlinereward") and (not menu.contextMenuData.allowClose)) then
		Helper.closeMenu(menu, dueToClose)
		menu.cleanup()
		return
	end

	if menu.closeContextMenu(dueToClose) then
		return
	end

	if (menu.mode == "orderparam_object") or (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
		return
	end

	if (menu.mode ~= "hire") and (not menu.minimized) and (dueToClose == "back") then
		if menu.showMultiverse then
			if menu.ventureMode then
				menu.deactivateObjectList()
				return
			end
		else
			if menu.infoTableMode then
				menu.deactivateObjectList()
				return
			end
		end
	end

	if (layer == nil) or (layer == config.mainFrameLayer) or (layer == config.infoFrameLayer) or (layer == config.infoFrameLayer2) then
		if dueToClose == "minimize" then
			if not menu.minimized then
				menu.closeContextMenu()
				Helper.minimizeMenu(menu, ReadText(1001, 3245))
			else
				Helper.restoreMenu(menu)
			end
		else
			Helper.closeMenu(menu, dueToClose)
			menu.cleanup()
		end
	elseif layer == config.contextFrameLayer then
		Helper.clearFrame(menu, layer)
	end
end

-- helper functions

function menu.initPlotList()
	if not menu.plots then
		menu.plots = {}
	end

	local playerobjects = GetContainedStationsByOwner("player", nil, true)
	for _, object in ipairs(playerobjects) do
		--print(GetComponentData(object, "name") .. " " .. tostring(object) .. " has " .. tostring(numstationmodules) .. " modules.")
		local object64 = ConvertIDTo64Bit(object)
		local sector64 = ConvertIDTo64Bit(GetComponentData(object, "sectorid"))
		local owner = GetComponentData(sector64, "owner")
		local inownedspace = (owner ~= "ownerless") and (owner ~= "xenon")
		local size = C.GetBuildPlotSize(object64)
		local boughtrawsize = C.GetPaidBuildPlotSize(object64)
		local paid = (not inownedspace) or (boughtrawsize.x > 0) or (boughtrawsize.y > 0) or (boughtrawsize.z > 0)
		local fullprice = tonumber(C.GetBuildPlotPrice(sector64, C.GetObjectPositionInSector(object64), size.x, size.y, size.z, "player"))
		local buf = ffi.new("bool[1]", 0)
		local plotpayment = tonumber(C.GetBuildPlotPayment(object64, buf))
		local haspositionchanged = buf[0]
		local fullypaid = ((not inownedspace) or ((boughtrawsize.x >= size.x) and (boughtrawsize.y >= size.y) and (boughtrawsize.z >= size.z))) and ((not haspositionchanged) or (plotpayment >= fullprice))

		local found = false
		for j, plot in ipairs(menu.plots) do
			if plot.station == object64 then
				found = true
				if plot.removed then
					table.remove(menu.plots, j)
				else
					plot.paid = paid
					plot.fullypaid = fullypaid
					plot.permanent = (C.GetNumStationModules(object64, true, true) > 0) and true or false
					-- plot.boughtrawcenteroffset is set at menu.buttonBuyPlot() when a plot is bought.
				end
				break
			end
		end
		if not found then
			table.insert(menu.plots, { station = object64, paid = paid, fullypaid = fullypaid, permanent = C.GetNumStationModules(object64, true, true) > 0, boughtrawcenteroffset = C.GetPaidBuildPlotCenterOffset(object64), removed = nil })
		end
	end
end

function menu.isInfoModeValidFor(object, mode)
	if object == nil or object == 0 then
		print(TraceBack())
	end
	local isonlineobject, isplayerowned, macro = GetComponentData(object, "isonlineobject", "isplayerowned", "macro")
	if isplayerowned and isonlineobject then
		return false
	end

	if mode == "objectinfo" or mode == "objectlogbook" then
		local isdatavault, islandmark = GetComponentData(object, "isdatavault", "islandmark")
		if	C.IsComponentClass(object, "ship") or
			C.IsRealComponentClass(object, "station") or
			C.IsComponentClass(object, "sector") or
			C.IsComponentClass(object, "gate") or
			C.IsComponentClass(object, "mine") or
			C.IsComponentClass(object, "navbeacon") or
			C.IsComponentClass(object, "resourceprobe") or
			C.IsComponentClass(object, "satellite") or
			C.IsComponentClass(object, "asteroid") or
			(C.IsComponentClass(object, "object") and (isdatavault or islandmark))
		then
			return true
		end
	elseif (mode == "objectcrew") or (mode == "objectloadout") then
		if C.IsRealComponentClass(object, "ship_xs") then
			return false
		elseif GetMacroData(macro, "islasertower") then
			return false
		elseif C.IsComponentClass(object, "ship") or C.IsComponentClass(object, "station") then
			return true
		end
	elseif mode == "orderqueue" then
		if isplayerowned and C.IsComponentClass(object, "ship") and (not C.IsUnit(object)) then
			return true
		end
	elseif mode == "standingorders" then
		if isplayerowned and (C.IsComponentClass(object, "ship") or C.IsComponentClass(object, "station")) and (not C.IsUnit(object)) then
			return true
		end
	elseif mode == "orderqueue_advanced" then
		if isplayerowned and C.IsComponentClass(object, "ship") and (not C.IsUnit(object)) then
			return true
		end
	else
		local text = ""
		for i, entry in ipairs(config.infoCategories) do
			if not entry.empty then
				if i == #config.infoCategories then
					text = text .. " and "
				elseif i > 1 then
					text = text .. ", "
				end
				text = text .. "'" .. entry.category .. "'"
			end
		end
		DebugError("menu.isInfoModeValidFor called with invalid mode: " .. tostring(mode) .. ". valid modes are " .. text)
	end

	return false
end

function menu.getNumDefendingCrew(objectid)
	local numdefendingcrew = 0
	local numpeople = C.GetNumAllRoles()
	local peopledata = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopledata, numpeople, objectid, true)
	local loccounter = 0
	for i = 0, numpeople - 1 do
		if ffi.string(peopledata[i].id) == "marine" or ffi.string(peopledata[i].id) == "service" then
			numdefendingcrew = numdefendingcrew + peopledata[i].amount
			loccounter = loccounter + 1
			if loccounter == 2 then
				loccounter = nil
				break
			end
		end
	end
	return numdefendingcrew
end

function menu.getNumOperationalTurrets(objectid, numtotalturrets)
	numoperationalturrets = 0
	for i = 1, numtotalturrets do
		local currentcomponent = ConvertStringTo64Bit(tostring(C.GetUpgradeSlotCurrentComponent(objectid, "turret", i)))
		if currentcomponent and currentcomponent ~= 0 and IsComponentOperational(currentcomponent) then
			numoperationalturrets = numoperationalturrets + 1
		end
	end
	return numoperationalturrets
end

function menu.infoChangeObjectName(objectid, text, textchanged)
	if textchanged then
		SetComponentName(objectid, text)
	end

	menu.noupdate = false
	menu.refreshInfoFrame()
end

function menu.infoCombineLoadoutComponents(components)
	local locmacros = {}
	for _, val in ipairs(components) do
		local val64 = ConvertStringTo64Bit(tostring(val))
		local locmacro, hullpercent, shieldpercent, hull, shield = GetComponentData(val64, "macro", "hullpercent", "shieldpercent")
		local isoperational = IsComponentOperational(val64)
		local isconstruction = IsComponentConstruction(val64)
		if not locmacros[locmacro] then
			if isoperational then
				locmacros[locmacro] = { count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent, construction = 0 }
			elseif isconstruction then
				locmacros[locmacro] = { count = 0, hullpercent = 0, shieldpercent = 0, construction = 1 }
			end
		else
			if isoperational then
				locmacros[locmacro].count = locmacros[locmacro].count + 1
				locmacros[locmacro].hullpercent = locmacros[locmacro].hullpercent + hullpercent
				locmacros[locmacro].shieldpercent = locmacros[locmacro].shieldpercent + shieldpercent
			elseif isconstruction then
				locmacros[locmacro].construction = locmacros[locmacro].construction + 1
			end
		end
	end
	return locmacros
end

function menu.infoSetWeaponGroup(objectid, weaponid, primary, group, active)
	--print("setting weapon " .. ffi.string(C.GetComponentName(weaponid)) .. " of object " .. ffi.string(C.GetComponentName(objectid)) .. " for group " .. tostring(group) .. " of set primary? " .. tostring(primary) .. " to " .. tostring(active))
	C.SetWeaponGroup(objectid, weaponid, primary, group, active)
	menu.refreshInfoFrame()
end

function menu.infoWeaponGroupCheckBoxColor(objectid, groupidx, primary)
	return (C.GetDefensibleActiveWeaponGroup(objectid, primary) == groupidx) and Helper.color.checkboxgroup or Helper.defaultCheckBoxBackgroundColor
end

function menu.infoUpdatePeople()
	menu.updatePeopleInfo = menu.updatePeopleInfo or getElapsedTime()
end

function menu.refreshCrewInfo()
	if (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") then
		if menu.infoSubmenuObject and C.IsComponentClass(menu.infoSubmenuObject, "ship") then
			menu.infoSubmenuPrepareCrewInfo("left")
		end
		menu.refreshInfoFrame()
	end
	if (menu.infoMode.right == "objectinfo") or (menu.infoMode.right == "objectcrew") then
		if menu.infoSubmenuObject and C.IsComponentClass(menu.infoSubmenuObject, "ship") then
			menu.infoSubmenuPrepareCrewInfo("right")
		end
		menu.refreshInfoFrame2()
	end
end

function menu.isModuleTypeExtended(station, type)
	for i, entry in ipairs(menu.extendedmoduletypes) do
		if IsSameComponent(entry.id, station) then
			return entry.moduletypes[type]
		end
	end
	return false
end

function menu.isSubordinateExtended(name, group)
	return menu.extendedsubordinates[name .. group] ~= false
end

function menu.isDockedShipsExtended(name, isstation)
	if isstation then
		return menu.extendeddockedships[name] ~= nil
	else
		return menu.extendeddockedships[name] ~= false
	end
end

function menu.isConstructionExtended(name)
	return menu.extendedconstruction[name] ~= nil
end

function menu.isPropertyExtended(name)
	return menu.extendedproperty[name] ~= nil
end

function menu.isOrderExtended(controllable, orderidx, instance, default)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			return entry.orders[orderidx .. instance]
		end
	end
	if default ~= nil then
		table.insert(menu.extendedorders, { id = controllable, orders = { [orderidx .. instance] = default } })
		return default
	end
	return false
end

function menu.isCommander(component, group)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if C.IsComponentClass(selectedcomponent, "controllable") then
			local directcommander = GetCommander(selectedcomponent)
			local commanderlist = GetAllCommanders(selectedcomponent)
			local prevcommander
			for i, entry in ipairs(commanderlist) do
				if IsSameComponent(entry, component) then
					if group then
						if IsSameComponent(entry, directcommander) then
							-- This is the direct commander, check if the group matches
							local selectedgroup = GetComponentData(selectedcomponent, "subordinategroup")
							return group == selectedgroup
						elseif prevcommander then
							-- This is a commander in the chain, get the previous commander's group and check if it matches
							local selectedgroup = GetComponentData(prevcommander, "subordinategroup")
							return group == selectedgroup
						else
							-- This is a commander in the chain, but not the direct commander and there was no previous commander?
							DebugError("menu.isCommander() found a commander, but could not reconstruct the chain of command!")
							return false
						end
					else
						return true
					end
				end
				prevcommander = entry
			end
		end
	end
	return false
end

function menu.isDockContext(component)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if GetComponentData(selectedcomponent, "isdocked") then
			local containercontext = C.GetContextByClass(selectedcomponent, "container", false)
			while containercontext ~= 0 do
				if containercontext == component then
					return true
				end
				containercontext = C.GetContextByClass(containercontext, "container", false)
			end
		end
	end
	return false
end

function menu.isConstructionContext(component)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsComponentConstruction(selectedcomponent) then
			local containercontext = C.GetContextByClass(selectedcomponent, "container", false)
			while containercontext ~= 0 do
				if containercontext == component then
					return true
				end
				containercontext = C.GetContextByClass(containercontext, "container", false)
			end
		end
	end
	return false
end

function menu.extendModuleType(station, type, notoggle)
	local found = false
	for i, entry in ipairs(menu.extendedmoduletypes) do
		if IsSameComponent(entry.id, station) then
			found = true
			if (not notoggle) and entry.moduletypes[type] then
				entry.moduletypes[type] = nil
				menu.clearSelectedComponents()
				menu.highlightedbordercomponent = station
				menu.highlightedbordermoduletype = type
			else
				entry.moduletypes[type] = true
			end
		end
	end
	if not found then
		table.insert(menu.extendedmoduletypes, {id = station, moduletypes = { [type] = true } })
	end
end

function menu.extendOrder(controllable, orderidx, instance)
	local found = false
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			found = true
			if entry.orders[orderidx .. instance] then
				entry.orders[orderidx .. instance] = nil
			else
				entry.orders[orderidx .. instance] = true
			end
			break
		end
	end
	if not found then
		table.insert(menu.extendedorders, {id = controllable, orders = { [orderidx .. instance] = true } })
	end
end

function menu.swapExtendedOrder(controllable, oldorderidx, neworderidx, instance)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			local temp = entry.orders[neworderidx .. instance]
			entry.orders[neworderidx .. instance] = entry.orders[oldorderidx .. instance]
			entry.orders[oldorderidx .. instance] = temp
			break
		end
	end
end

function menu.setOrderParamFromMode(controllable, order, param, index, value, instance)
	SetOrderParam(controllable, order, param, index, value)

	menu.resetOrderParamMode()
end

function menu.resetOrderParamMode()
	if menu.currentInfoMode then
		menu.infoTableMode = menu.currentInfoMode[1]
		menu.infoMode.left = menu.currentInfoMode[2]
		menu.currentInfoMode = nil
	end
	menu.settoprow = menu.modeparam[3]
	menu.mode = nil
	menu.modeparam = {}

	C.ClearMapOrderParamObjectFilter(menu.holomap)
	C.ClearMapObjectFilter(menu.holomap)

	menu.removeMouseCursorOverride(3)

	menu.refreshMainFrame = true
	menu.refreshInfoFrame(0, 0)
end

function menu.onEditBoxActivated(widget)
	menu.noupdate = true
end

function menu.searchTextConfirmed(_, text, textchanged)
	if textchanged then
		AddUITriggeredEvent(menu.name, "searchconfirmed")

		local ware = menu.economyWares[utf8.lower(text)]
		if ware then
			local setting, list = menu.getTradeWareFilter(true)
			local found = false
			for _, filterware in ipairs(list) do
				if filterware == ware then
					found = true
				end
			end

			if not found then
				menu.setFilterOption("layer_trade", setting, setting.id, ware)
			else
				if not __CORE_DETAILMONITOR_MAPFILTER["layer_trade"] then
					__CORE_DETAILMONITOR_MAPFILTER["layer_trade"] = true
					menu.applyFilterSettings()
				end
			end
		else
			table.insert(menu.searchtext, { text = text })
			Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
		end
		menu.refreshMainFrame = true
	end
	menu.noupdate = false

	menu.refreshInfoFrame()
end

function menu.getTradeWareFilter(force)
	local setting = config.layersettings["layer_trade"][1]
	local list = {}
	-- only return the values if the filter is active
	if force or menu.getFilterOption("layer_trade") then
		list = menu.getFilterOption(setting.id) or {}
	end
	return setting, list
end

function menu.removeExtendedOrder(controllable, orderidx, instance)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			entry.orders[orderidx .. instance] = nil
			for i = orderidx + 1, #menu.infoTableData[instance].orders do
				entry.orders[(i - 1) .. instance] = entry.orders[i]
			end
			entry.orders[#menu.infoTableData[instance].orders .. instance] = nil
			break
		end
	end
end

function menu.addShipToBoardingOperation(shipid, shipdata)
	--print("ship: " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. ", actionid: " .. tostring(shipdata.action))
	-- NB: actionid also applies to subordinates. explicitly assigned ships that are all subordinates should be in menu.boardingData.shipdata and not in subordinates. assignedmarines are distributed among shipid and all subordinates. assignedmarines starts from shipid, overflow among subordinates in no particular order.
	local actionid = shipdata.action
	local assignedmarines = {}
	local remainingmarines = {}
	local subordinates = shipdata.subordinates

	--print("ship: " .. ffi.string(C.GetComponentName(shipid)) .. ", actionid: " .. tostring(actionid) .. ", num subordinates: " .. tostring(#subordinates))
	for _, leveldata in ipairs(menu.boardingData.marinelevels) do
		if not menu.boardingData.shipdata[shipid].assignedgroupmarines[leveldata.skilllevel] then
			table.insert(assignedmarines, 0)
		else
			table.insert(assignedmarines, menu.boardingData.shipdata[shipid].assignedgroupmarines[leveldata.skilllevel])
		end
	end

	-- get number of marines per tier on shipid
	local numtiers = #menu.boardingData.marinelevels
	local tierdata = ffi.new("RoleTierData[?]", numtiers)
	numtiers = C.GetRoleTiers2(tierdata, numtiers, shipid, "marine", false)

	-- add each ship and subordinate to the boarding operation.
	local marinelist = ffi.new("uint32_t[?]", numtiers)
	local marineskilllevellist = ffi.new("uint32_t[?]", numtiers)
	for i = 0, numtiers - 1 do
		marinelist[i] = math.min(assignedmarines[i+1], tierdata[i].amount)
		marineskilllevellist[i] = menu.boardingData.marinelevels[i+1].skilllevel
		table.insert(remainingmarines, assignedmarines[i+1] - marinelist[i])
		--print("primary attacker. index: " .. tostring(i) .. ", num marines: " .. tostring(marinelist[i]) .. ", skill level: " .. tostring(marineskilllevellist[i]))
	end

	if menu.isShipAlreadyBoarding(shipid) then
		if not C.UpdateAttackerOfBoardingOperation(menu.boardingData.target, shipid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
			DebugError("Failed updating boarding ship " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid))
		end
	else
		if not C.AddAttackerToBoardingOperation(menu.boardingData.target, shipid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
			DebugError("Failed adding " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. " to boarding operation attacking " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	end

	for _, subordinateid in ipairs(subordinates) do
		if not menu.boardingData.shipdata[subordinateid].isprimaryboarder then
			-- get number of marines per tier in subordinateid
			numtiers = C.GetRoleTiers2(tierdata, numtiers, subordinateid, "marine", false)
			for i = 0, numtiers - 1 do
				marinelist[i] = math.min(remainingmarines[i+1], tierdata[i].amount)
				marineskilllevellist[i] = menu.boardingData.marinelevels[i+1].skilllevel
				remainingmarines[i+1] = remainingmarines[i+1] - marinelist[i]
				--print("subordinate. index: " .. tostring(i) .. ", num marines: " .. tostring(marinelist[i]) .. ", skill level: " .. tostring(marineskilllevellist[i]))
			end

			if menu.isShipAlreadyBoarding(subordinateid) then
				if not C.UpdateAttackerOfBoardingOperation(menu.boardingData.target, subordinateid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
					DebugError("Failed updating boarding ship " .. ffi.string(C.GetComponentName(subordinateid)) .. " " .. tostring(subordinateid))
				end
			else
				--print("adding " .. ffi.string(C.GetComponentName(subordinateid)) .. " to boarding operation")
				if not C.AddAttackerToBoardingOperation(menu.boardingData.target, subordinateid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
					DebugError("Failed adding " .. ffi.string(C.GetComponentName(subordinateid)) .. " " .. tostring(subordinateid) .. " to boarding operation attacking " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
				end
			end
		end
	end
end

function menu.isShipAlreadyBoarding(shipid)
	local numattackers = C.GetNumAttackersOfBoardingOperation(menu.boardingData.target, "player")
	local attackers = ffi.new("UniverseID[?]", numattackers)
	numattackers = C.GetAttackersOfBoardingOperation(attackers, numattackers, menu.boardingData.target, "player")
	local alreadyboarding = false
	for i = 0, numattackers do
		if shipid == ConvertStringTo64Bit(tostring(attackers[i])) then
			alreadyboarding = true
			break
		end
	end

	return alreadyboarding
end

function menu.updateHolomap()
	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	elseif (menu.infoMode.left == "objectlogbook") or (menu.infoMode.right == "objectlogbook")  then
		return
	end

	if not menu.lastUpdateHolomapTime then
		menu.lastUpdateHolomapTime = 0
	end
	local curTime = getElapsedTime()
	if menu.lastUpdateHolomapTime < curTime - 5 and not menu.noupdate then
		menu.lastUpdateHolomapTime = curTime
		menu.refreshInfoFrame()
	end
end

function menu.syncMapFilterWithConfig()
	__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"] = C.GetConfigSetting("highlightvisitors") ~= 0
end

function menu.importMenuParameters()
	menu.showzone = menu.param[3] ~= 0

	menu.focuscomponent = ConvertIDTo64Bit(menu.param[4])
	menu.selectfocuscomponent = true
	if not menu.focuscomponent then
		local softtargetinfo = C.GetSofttarget()
		if softtargetinfo.softtargetID ~= 0 then
			if C.IsComponentClass(softtargetinfo.softtargetID, "space") or C.IsComponentClass(softtargetinfo.softtargetID, "object") then
				menu.focuscomponent = softtargetinfo.softtargetID
				if C.IsComponentClass(menu.focuscomponent, "zone") and (ffi.string(softtargetinfo.softtargetConnectionName) == "") then
					menu.focuscomponent = C.GetContextByClass(menu.focuscomponent, "sector", false)
					menu.focusoffset = C.GetPlayerTargetOffset()
				end
			else
				menu.focuscomponent = C.GetPlayerObjectID()
				menu.selectfocuscomponent = nil
			end
		else
			menu.focuscomponent = C.GetPlayerObjectID()
			menu.selectfocuscomponent = nil
		end
	end

	if C.IsComponentClass(menu.focuscomponent, "highway") then
		menu.currentsector = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.focuscomponent)), "sourcesector")) or 0
	else
		menu.currentsector = C.GetContextByClass(menu.focuscomponent, "sector", true)
	end
	menu.mode = menu.param[6]
	menu.modeparam = menu.param[7] or {}
	menu.initMultiverse = menu.param[8]
	menu.focusoffset = menu.param[9]
end

function menu.prepareEconomyWares()
	if not menu.economyWares then
		menu.economyWares = {}
		local n = C.GetNumWares("economy", false, "", "")
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, "economy", false, "", "")
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			local name = GetWareData(ware, "name")
			
			-- strip color code from temp strings
			if utf8.find(name, "^\027M") then
				name = utf8.sub(name, 3)
			end
			if utf8.find(name, "\027X$") then
				name = utf8.sub(name, 1, -3)
			end

			menu.economyWares[utf8.lower(name)] = ware
		end
	end
end

function menu.checkForOrderParamObject(component)
	if type(menu.modeparam[5]) == "string" then
		return C.FilterComponentForDefaultOrderParamObjectMode(ConvertStringTo64Bit(tostring(component)), ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
	else
		return C.FilterComponentForOrderParamObjectMode(ConvertStringTo64Bit(tostring(component)), ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
	end
end

function menu.checkForSelectComponent(component)
	local numclasses = menu.modeparam[2] and #menu.modeparam[2] or 0
	local classes = ffi.new("const char*[?]", numclasses)
	if numclasses > 0 then
		for i, class in ipairs(menu.modeparam[2]) do
			classes[i - 1] = Helper.ffiNewString(class)
		end
	end
	local result = C.FilterComponentForMapMode(component, classes, numclasses, menu.modeparam[4] or -1, false)
	Helper.ffiClearNewHelper()

	return result
end

function menu.plotCourse(object, offset)
	local convertedObject = ConvertStringToLuaID(tostring(object))
	if menu.mode or (object == C.GetPlayerControlledShipID()) then
		PlaySound("ui_target_set_fail")
		return -- no plot course to playership or when menu.mode is set
	end

	if IsSameComponent(GetActiveGuidanceMissionComponent(), convertedObject) then
		C.EndGuidance()
	else
		if offset == nil then
			offset = ffi.new("UIPosRot", 0)
		elseif C.IsComponentClass(object, "sector") then
			object = C.GetZoneAt(object, offset)
		end
		C.SetGuidance(object, offset)
	end

	menu.settoprow = GetTopRow(menu.selecttable)
	menu.setrow = Helper.currentTableRow[menu.selecttable]
	if not menu.createInfoFrameRunning then
		menu.createInfoFrame()
	end
end

function menu.getParamValue(type, value, inputparams)
	local result

	if type == "bool" then
		result = (value ~= 0) and ReadText(1001, 2617) or ReadText(1001, 2618)
	elseif type == "length" then
		if inputparams and inputparams.step and (inputparams.step >= 1000) then
			result = tostring(math.floor(value / 1000)) .. " " .. ReadText(1001, 107)
		else
			result = tostring(value) .. " " .. ReadText(1001, 107)
		end
	elseif type == "time" then
		result = tostring(value) .. " " .. ReadText(1001, 100)
	elseif type == "money" then
		result = ConvertMoneyString(value, false, true, 0, true) .. " " .. ReadText(1001, 101)
	elseif type == "object" then
		if IsComponentClass(value, "space") then
			local name, sector, cluster = GetComponentData(value, "name", "sector", "cluster")
			result = ((cluster ~= "") and (cluster .. " / ") or "") .. ((sector ~= "") and (sector .. " / ") or "") .. name
		else
			result = GetComponentData(value, "name")
		end
	elseif type == "sector" then
		local name, sector, cluster = "", "", ""
		if value then
			name, sector, cluster = GetComponentData(value, "name", "sector", "cluster")
		end
		result = ((cluster ~= "") and (cluster .. " / ") or "") .. ((sector ~= "") and (sector .. " / ") or "") .. name
	elseif type == "ware" then
		result = GetWareData(value, "name")
	elseif type == "macro" then
		result = GetMacroData(value, "name")
	elseif type == "trade_ware" then
		result = (value[1] and ReadText(1001, 2917) or ReadText(1001, 2916)) .. " " .. GetWareData(value[2], "name")
	elseif type == "trade_amount" then
		result = value[1] and (tostring(value[1]) .. " (" .. string.format(ReadText(1001, 3246), tostring(value[2])) .. ")") or ""
	elseif type == "position" then
		local name, sectorid, clusterid = GetComponentData(value[1], "name", "sectorid", "clusterid")
		result = ""
		if clusterid then
			local sectors = GetSectors(clusterid)
			local clustername, systemid = GetComponentData(clusterid, "name", "systemid")
			if (#sectors > 1) or (systemid ~= 0) then
				result = clustername .. "\n"
			end
		end
		result = result .. (sectorid and (GetComponentData(sectorid, "name") .. "\n") or "") .. name
	else
		result = tostring(value)
	end

	return result
end

function menu.closeContextMenu(dueToClose)
	AddUITriggeredEvent(menu.name, "contextmenu_close")

	if Helper.closeInteractMenu() then
		return true
	end
	if menu.contextMenuMode then
		if menu.contextMenuMode == "trade" then
			if C.IsComponentOperational(menu.contextMenuData.currentShip) then
				SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
			end
			if menu.contextMenuData.wareexchange then
				if C.IsComponentOperational(menu.contextMenuData.component) then
					SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), false)
				end
			end
			menu.selectedTradeWare = nil
		elseif menu.contextMenuMode == "mission" then
			if menu.holomap ~= 0 then
				C.SetMapRenderMissionGuidance(menu.holomap, 0)
			end
			if menu.contextMenuData.isoffer then
				UnregisterEvent("missionofferremoved", menu.onMissionOfferRemoved)
			else
				UnregisterEvent("missionremoved", menu.onMissionRemoved)
			end
		elseif menu.contextMenuMode == "boardingcontext" then
			-- restore old mode and old info table mode
			menu.mode = menu.oldmode
			menu.oldmode = nil
			menu.infoTableMode = menu.oldInfoTableMode
			menu.refreshMainFrame = true
			menu.oldInfoTableMode = nil
			menu.boardingData = {}
			menu.contexttoprow = nil
			menu.contextselectedrow = nil
		elseif (menu.contextMenuMode == "onlinemode") then
			if dueToClose == "back" then
				return false
			end
		elseif (menu.contextMenuMode == "onlinereward") then
			OnlineClearLogbookRewards()
		elseif (menu.contextMenuMode == "ventureconfig") or (menu.contextMenuMode == "venturecreateparty") or (menu.contextMenuMode == "ventureoutcome") or (menu.contextMenuMode == "venturefriendlist") then
			if not Helper.callExtensionFunction("multiverse", "closeContextMenu", menu, menu.contextMenuMode, dueToClose) then
				return true
			end
		elseif menu.contextMenuMode == "changelogo" then
			if menu.contextMenuData.origlogo ~= nil then
				C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.origlogo)
			end
		elseif menu.contextMenuMode == "venturereport" then
			Helper.sendChatWindowCallback("unlock")
		end
		-- REMOVE this block once the mouse out/over event order is correct -> This should be unnessecary due to the global tablemouseout event reseting the picking
		if menu.currentMouseOverTable and (
			(menu.currentMouseOverTable == menu.contexttable)
			or (menu.currentMouseOverTable == menu.contextshiptable)
			or (menu.currentMouseOverTable == menu.contextbuttontable)
			or (menu.currentMouseOverTable == menu.contextdesctable)
			or (menu.currentMouseOverTable == menu.contextobjectivetable)
			or (menu.currentMouseOverTable == menu.contextbottomtable)
			or (menu.currentMouseOverTable == contextobjectivetable)
			or (menu.contextMenuMode == "boardingcontext")
			or (menu.contextMenuMode == "dropwares")
			or (menu.contextMenuMode == "crewtransfer")
			or (menu.contextMenuMode == "rename")
			or (menu.contextMenuMode == "changelogo")
			or (menu.contextMenuMode == "userquestion")
			or (menu.contextMenuMode == "venturepatron")
			or (menu.contextMenuMode == "venturereport")
			or (menu.contextMenuMode == "ventureteammembercontext")
			or (menu.contextMenuMode == "venturecontactcontext")
			or (menu.contextMenuMode == "filter_multiselectlist")
			or (menu.contextMenuMode == "hire")
		) then
			menu.picking = true
			menu.currentMouseOverTable = nil
		end
		-- END
		menu.contextFrame = nil
		Helper.clearFrame(menu, config.contextFrameLayer)
		menu.contextMenuData = {}
		menu.contextMenuMode = nil
		if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or(menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") or menu.closemapwithmenu then
			Helper.closeMenu(menu, dueToClose)
			menu.cleanup()
		end
		return true
	end
	return false
end

function menu.onInteractMenuCallback(type, param)
	if type == "attackmultiple" then
		menu.mode = "orderparam_selectenemies"
		menu.modeparam = param
		menu.setMouseCursorOverride("targetred", 3)
	elseif type == "collectdeployables" then
		menu.mode = "orderparam_selectplayerdeployables"
		menu.modeparam = param
		menu.setMouseCursorOverride("target", 3)
	elseif type == "boardingcontext" then
		-- accessing boarding menu from within the map
		local width = Helper.viewWidth * 0.6
		local height = Helper.viewHeight * 0.7
		local xoffset = Helper.viewWidth * 0.2
		local yoffset = Helper.viewHeight * 0.15
		menu.contextMenuMode = "boardingcontext"
		menu.contextMenuData = { target = param[1], boarders = param[2] }
		menu.createContextFrame(width, height, xoffset, yoffset)
	elseif type == "comm" then
		menu.openComm(param)
	elseif type == "close" then
		menu.onCloseElement("close")
	elseif type == "info" then
		if param[2] then
			menu.extendedinfo = {}
			for _, loccategory in ipairs(param[2]) do
				menu.extendedinfo[loccategory] = true
			end
		end
		menu.openDetails(param[1])
	elseif type == "mission" then
		menu.infoTableMode = "mission"
		menu.missionMode = param[1]
		menu.missionModeCurrent = tostring(param[2])
		if param[3] then
			menu.expandedMissionGroups[param[2]] = true
		end
		menu.refreshMainFrame = true
		menu.refreshInfoFrame()
		if not param[3] then
			menu.showMissionContext(param[2])
			menu.missionModeContext = true
		end
	elseif type == "missionaccepted" then
		if menu.missionOfferList then
			local found = false
			for i, entry in ipairs(menu.missionOfferList["plot"] or {}) do
				if ConvertStringTo64Bit(entry.ID) == param[1] then
					found = true
					entry.accepted = true
					menu.highlightLeftBar["mission"] = true
					menu.refreshMainFrame = true
					break
				end
			end
			if not found then
				for _, data in ipairs(menu.missionOfferList["guild"] or {}) do
					for _, entry in ipairs(data.missions) do
						if ConvertStringTo64Bit(entry.ID) == param[1] then
							found = true
							entry.accepted = true
							menu.highlightLeftBar["mission"] = true
							menu.refreshMainFrame = true
							break
						end
					end
					if found then
						break
					end
				end
			end
			if not found then
				for i, entry in ipairs(menu.missionOfferList["other"] or {}) do
					if ConvertStringTo64Bit(entry.ID) == param[1] then
						found = true
						entry.accepted = true
						menu.highlightLeftBar["mission"] = true
						menu.refreshMainFrame = true
						break
					end
				end
			end
		end
		menu.refreshIF = getElapsedTime()
	elseif type == "newconversation" then
		Helper.closeMenuForNewConversation(menu, param[1], param[2], param[3])
		menu.cleanup()
	elseif type == "newmenu" then
		Helper.closeMenuAndOpenNewMenu(menu, param[1], param[2])
		menu.cleanup()
	elseif type == "refresh" then
		menu.refreshInfoFrame()
	elseif type == "sellships" then
		menu.contextMenuData = { shipyard = param[1], ships = param[2], xoffset = param[3], yoffset = param[4] }
		menu.contextMenuMode = "sellships"
		menu.createContextFrame(menu.sellShipsWidth)
	elseif type == "tradecontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuData = { component = param[1], currentShip = param[5], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2, loop = param[4] }
		if menu.contextMenuData.loop then
			menu.buttonContextTradeLoop()
		else
			menu.buttonContextTrade(param[3])
		end
	elseif type == "dropwarescontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "dropwares"
		menu.contextMenuData = { mode = param[1], entity = param[2], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2, wares = {} }

		if menu.contextMenuData.mode == "inventory" then
			local inventory = GetInventory(menu.contextMenuData.entity)
			local onlineitems = OnlineGetUserItems()

			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(menu.contextMenuData.wares, { ware = ware, name = entry.name, amount = entry.amount })
				end
			end
			table.sort(menu.contextMenuData.wares, Helper.sortName)
		end

		local height = (#menu.contextMenuData.wares + 5) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		if menu.contextMenuData.yoffset + height > Helper.viewHeight then
			menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
		end
		if menu.contextMenuData.xoffset + config.dropInventoryWidth > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - config.dropInventoryWidth - Helper.frameBorder
		end

		menu.createContextFrame(config.dropInventoryWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "crewtransfercontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "crewtransfer"
		menu.contextMenuData = { leftShip = param[1], rightShip = param[2], extendedTier = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.crewTransferWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "renamecontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "rename"
		menu.contextMenuData = { component = param[1], fleetrename = param[2], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.renameWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "changelogocontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "changelogo"
		menu.contextMenuData = { component = param[1], origlogo = {}, currentlogo = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local buf = C.GetCurrentFleetLogo(menu.contextMenuData.component)
		menu.contextMenuData.origlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }
		menu.contextMenuData.currentlogo = menu.contextMenuData.origlogo

		local width = Helper.scaleX(config.changeLogoWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "selectsubordinates" then
		local subordinates = GetSubordinates(param[1])
		local groupShips = {}
		for _, subordinate in ipairs(subordinates) do
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if group == param[2] then
					table.insert(groupShips, subordinate)
				end
			end
		end

		if #groupShips > 0 then
			C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(groupShips[1]), true)
			menu.addSelectedComponents(groupShips)
		end
	elseif type == "venturepatroninfo" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "venturepatron"
		menu.contextMenuData = { component = param[1], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "venturereport" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "venturereport"
		menu.contextMenuData = { mode = "venturereport", submode = param[1], reason = param[2], timestamp = param[3], author = param[4], transactionid = param[5], userid = param[6], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "markashostile" then
		menu.contextMenuMode = "userquestion"
		menu.contextMenuData = { mode = "markashostile", controllable = param[1], xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, saveOption = false }

		if __CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] then
			-- continue immediately
			menu.buttonConfirmUserQuestion()
		else
			menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
		end
	elseif type == "refreshcrew" then
		if menu.infoTableMode == "info" then
			if menu.infoMode.left == "objectcrew" then
				menu.infoTablePersistentData["left"].resetcrew = true
			end
		end
		if menu.searchTableMode == "info" then
			if menu.infoMode.right == "objectcrew" then
				menu.infoTablePersistentData["right"].resetcrew = true
			end
		end
		menu.refreshInfoFrame()
	end
end

function menu.updateSelectedComponents(modified, keepselection, changedComponent, changedrow)
	local components = {}
	local rows, highlightedborderrow = GetSelectedRows(menu.infoTable)

	-- determine whether the component we are changing is now selected or unselected
	local ischangedselected = false
	for _, row in ipairs(rows) do
		if row == changedrow then
			ischangedselected = true
			break
		end
	end

	for _, row in ipairs(rows) do
		local rowdata = menu.rowDataMap[menu.infoTable][row]
		if type(rowdata) == "table" then
			if (rowdata[1] ~= "moduletype") and (not string.find(rowdata[1], "subordinates")) and (rowdata[1] ~= "dockedships") and (rowdata[1] ~= "constructions") then
				-- for docked ships in the PO the ship can be listed twice in the menu, do not keep the component due to the selection in the other line if the changed line is now unselected
				if rowdata[1] == "construction" then
					if rowdata[3].component ~= 0 then
						if ischangedselected or (rowdata[3].component ~= changedComponent) then
							table.insert(components, ConvertStringTo64Bit(tostring(rowdata[3].component)))
						end
					end
				elseif ischangedselected or (C.ConvertStringTo64Bit(tostring(rowdata[2])) ~= changedComponent) then
					table.insert(components, rowdata[2])
				end
			end
		end
	end

	if modified or keepselection then
		for id in pairs(menu.selectedcomponents) do
			local component = ConvertStringTo64Bit(id)
			-- keep gates, satellites, etc. selected even if they don't have their own list entries
			if C.IsComponentClass(component, "gate") or C.IsComponentClass(component, "asteroid") or C.IsComponentClass(component, "buildstorage") or C.IsComponentClass(component, "highwayentrygate") or C.IsComponentClass(component, "highway") then
				table.insert(components, component)
			end

			-- kuertee start:
			-- if menu.infoTableMode == "propertyowned" then
			if string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
				-- kuertee end:

				local isplayerowned, isdeployable = GetComponentData(component, "isplayerowned", "isdeployable")
				if not isplayerowned then
					-- keep npc ships selected
					table.insert(components, component)
				elseif menu.propertyMode ~= "propertyall" then
					-- keep other property selected that is currently not displayed
					if (menu.propertyMode ~= "stations") and C.IsRealComponentClass(component, "station") then
						table.insert(components, component)
					end
					if (modified ~= "ctrl") or (component ~= changedComponent) then
						if C.IsComponentClass(component, "ship") then
							table.insert(components, component)
						end
					end
				end
				if (menu.propertyMode ~= "deployables") and (isdeployable or C.IsComponentClass(component, "lockbox")) then
					table.insert(components, component)
				end

				-- kuertee start:
				-- elseif menu.infoTableMode == "objectlist" then
			elseif string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
				-- kuertee end:

				local isdeployable = GetComponentData(component, "isdeployable")
				if menu.objectMode ~= "objectall" then
					-- keep other property selected that is currently not displayed
					if (menu.objectMode ~= "stations") and C.IsRealComponentClass(component, "station") then
						table.insert(components, component)
					end
					if (modified ~= "ctrl") or (component ~= changedComponent) then
						if C.IsComponentClass(component, "ship") then
							table.insert(components, component)
						end
					end
				end
				if (menu.objectMode ~= "deployables") and (isdeployable or C.IsComponentClass(component, "lockbox")) then
					table.insert(components, component)
				end
			end
		end
	end

	local rowdata = menu.rowDataMap[menu.infoTable][highlightedborderrow]
	if type(rowdata) == "table" then
		menu.highlightedbordercomponent = rowdata[2]
		if rowdata[1] == "construction" then
			if rowdata[3].component ~= 0 then
				menu.highlightedbordercomponent = ConvertStringTo64Bit(tostring(rowdata[3].component))
			end
		end
		local oldselectedstationcategory = menu.selectedstationcategory
		menu.highlightedbordermoduletype = nil
		menu.highlightedborderstationcategory = nil
		menu.selectedstationcategory = nil
		menu.highlightedplannedmodule = nil
		menu.highlightedconstruction = nil
		menu.selectedconstruction = nil
		menu.selectedfleetcommander = nil
		if rowdata[1] == "moduletype" then
			menu.highlightedbordermoduletype = rowdata[3]
		elseif rowdata[1] == "module" then
			menu.highlightedbordermoduletype = rowdata[3]
			if rowdata[6] then
				menu.highlightedbordercomponent = rowdata[5]
				menu.highlightedplannedmodule = rowdata[6]
			end
		elseif string.find(rowdata[1], "subordinates") then
			menu.highlightedborderstationcategory = rowdata[1]
			if (keepselection and (oldselectedstationcategory == rowdata[1])) or (modified ~= "ctrl") then
				menu.selectedstationcategory = rowdata[1]
			end
			menu.selectedfleetcommander = ConvertIDTo64Bit(rowdata[2])
		elseif rowdata[1] == "dockedships" then
			menu.highlightedborderstationcategory = "dockedships"
		elseif rowdata[1] == "constructions" then
			menu.highlightedborderstationcategory = "constructions"
		elseif rowdata[1] == "construction" then
			menu.highlightedconstruction = rowdata[3]
			if (modified ~= "ctrl") then
				menu.selectedconstruction = rowdata[3]
			end
		end
		menu.highlightedbordersection = nil
	elseif type(rowdata) == "string" then
		menu.highlightedbordercomponent = nil
		menu.highlightedbordermoduletype = nil
		menu.highlightedborderstationcategory = nil
		menu.selectedstationcategory = nil
		menu.highlightedconstruction = nil
		menu.selectedconstruction = nil
		menu.selectedfleetcommander = nil
		menu.highlightedbordersection = rowdata
	end

	C.SetMapSelectedFleetCommander(menu.holomap, menu.selectedfleetcommander or 0)
	menu.addSelectedComponents(components, modified)
end

function menu.updateTableSelection(lastcomponent)
	menu.refreshMainFrame = true

	-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
	-- kuertee start:
	if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
		-- kuertee end:

		-- check if sections need to be extended - if so we need a refresh
		local refresh = false
		for id in pairs(menu.selectedcomponents) do
			local component = ConvertStringTo64Bit(id)
			-- build queues contain components that are not connected to the universe yet
			if IsValidComponent(component) then
				local commanderlist = C.IsComponentClass(component, "controllable") and GetAllCommanders(component) or {}
				for i, entry in ipairs(commanderlist) do
					if (not menu.isPropertyExtended(tostring(entry))) then
						menu.extendedproperty[tostring(entry)] = true
						refresh = true
					end
				end
			end
		end
		if refresh then
			menu.refreshInfoFrame()
			return
		end

		if menu.rowDataMap[menu.infoTable] then
			local rows = {}
			local curRow
			for row, rowdata in pairs(menu.rowDataMap[menu.infoTable]) do
				if type(rowdata) == "table" then
					if rowdata[1] == nil then
						print(TraceBack())
					end
					if (rowdata[1] ~= "moduletype") and (not string.find(rowdata[1], "subordinates")) and (rowdata[1] ~= "dockedships") and (rowdata[1] ~= "constructions") and (rowdata[1] ~= "construction") and menu.isSelectedComponent(rowdata[2]) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "construction") and (rowdata[3].component ~= 0) and menu.isSelectedComponent(rowdata[3].component) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[3].component)) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "construction") and rowdata[2] and menu.selectedconstruction and (menu.selectedconstruction.id == rowdata[3].id) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif string.find(rowdata[1], "subordinates") and (rowdata[1] == menu.selectedstationcategory) then
						table.insert(rows, row)
					end
				end
			end
			SetSelectedRows(menu.infoTable, rows, curRow or (Helper.currentTableRow[menu.infoTable] or 0))
		end
	end
	menu.setSelectedMapComponents()
end

function menu.addSelectedComponent(component, clear, noupdate)
	component = ConvertStringTo64Bit(tostring(component))
	if clear ~= false then
		menu.selectedcomponents = {}
	end

	local add = true
	local hasonlynpcs = true
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if GetComponentData(selectedcomponent, "isplayerowned") then
			hasonlynpcs = false
			break
		end
	end
	-- build queues contain components that are not connected to the universe yet
	if (not IsValidComponent(component)) or (not GetComponentData(component, "isplayerowned")) then
		if hasonlynpcs then
			-- replace
			menu.selectedcomponents = {}
		else
			-- don't add
			add = false
		end
	else
		if hasonlynpcs then
			-- replace
			menu.selectedcomponents = {}
		else
			-- add -> nothing to do
		end
	end

	if add then
		menu.selectedcomponents[tostring(component)] = {}
	end
	if not noupdate then
		menu.updateTableSelection(component)
	end
end

function menu.addSelectedComponents(components, clear)
	if clear ~= false then
		menu.selectedcomponents = {}
	end
	for _, component in ipairs(components) do
		menu.addSelectedComponent(component, false, true)
	end
	menu.updateTableSelection()
end

function menu.removeSelectedComponent(component)
	component = ConvertStringTo64Bit(tostring(component))
	menu.selectedcomponents[tostring(component)] = nil
	menu.updateTableSelection()
end

function menu.toggleSelectedComponent(component)
	if menu.isSelectedComponent(component) then
		menu.removeSelectedComponent(component)
	else
		menu.addSelectedComponent(component, false)
	end
end

function menu.isSelectedComponent(component)
	component = ConvertStringTo64Bit(tostring(component))
	return menu.selectedcomponents[tostring(component)] ~= nil
end

function menu.clearSelectedComponents()
	menu.selectedcomponents = {}
	menu.updateTableSelection()
end

function menu.getNumSelectedComponents()
	local count = 0
	for _, _ in pairs(menu.selectedcomponents) do
		count = count + 1
	end
	return count
end

function menu.getShipList(includePlayerOccupiedShip, includeShipsWithOrderLoops)
	local ships = GetTradeShipList()
	local playeroccupiedship = ConvertStringToLuaID(tostring(C.GetPlayerOccupiedShipID()))
	for i = #ships, 1, -1 do
		local ship = ships[i]
		local commander = GetCommander(ship.shipid)
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ConvertIDTo64Bit(ship.shipid), hasloop)
		local isplayeroccupiedship = IsSameComponent(ship.shipid, playeroccupiedship)

		if commander and not IsSameComponent(commander, playeroccupiedship) then
			table.remove(ships, i)
		elseif GetComponentData(ship.shipid, "isdeployable") then
			table.remove(ships, i)
		elseif #GetTransportUnitMacros(GetComponentData(ship.shipid, "macro")) == 0 then
			table.remove(ships, i)
		elseif (not includePlayerOccupiedShip) and isplayeroccupiedship then
			-- remove the player occupied ship
			table.remove(ships, i)
		elseif (not includeShipsWithOrderLoops) and hasloop[0] and ((not includePlayerOccupiedShip) or (not isplayeroccupiedship)) then
			-- remove loop ship unless it is the player occupied ship and we keep the player occupied ship
			table.remove(ships, i)
		end
	end

	return ships
end

function menu.updateTradeContextDimensions(numwarerows, numinforows)
	local warescrollwindowsize = 6
	local numwarningrows = 2

	local textheight = math.ceil(C.GetTextHeight("", Helper.standardFont, math.floor(Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)), 0))
	local rowHeight = math.max(Helper.slidercellMinHeight, textheight)

	menu.tradeContext = {
		width = config.tradeContextMenuWidth,			-- ca 800 px in 1920x1080
		warescrollwindowsize = warescrollwindowsize,
		numwarerows = numwarerows,
		shipheight = Helper.scaleY(Helper.headerRow1Height) + Helper.borderSize + 1 + (math.min(warescrollwindowsize, numwarerows) + 1) * (Helper.borderSize + rowHeight),
		numinforows = numinforows,
		numwarningrows = numwarningrows,
		buttonheight = 1 + (numinforows + numwarningrows + 2) * (Helper.borderSize + rowHeight),
	}
end

function menu.getFilterTradeWaresOptions()
	local result = {}
	for name, ware in pairs(menu.economyWares) do
		table.insert(result, ware)
	end
	return result
end

function menu.getFilterTradeVolumeOptions()
	local params = C.GetMapTradeVolumeParameter()
	local icon = "\27[" .. ffi.string(params.icon) .."]"
	local color = { r = params.color.red, g = params.color.green, b = params.color.blue, a = params.color.alpha }

	local result = {
		{ id = 0,				text = ReadText(1001, 8359), text2 = "",														icon = "", displayremoveoption = false }, -- None
		{ id = params.volume_s,	text = ReadText(1001, 2853), text2 = Helper.convertColorToText(color) .. icon,					icon = "", displayremoveoption = false }, -- Small
		{ id = params.volume_m,	text = ReadText(1001, 2854), text2 = Helper.convertColorToText(color) .. icon .. icon,			icon = "", displayremoveoption = false }, -- Medium
		{ id = params.volume_l,	text = ReadText(1001, 2855), text2 = Helper.convertColorToText(color) .. icon .. icon .. icon,	icon = "", displayremoveoption = false }, -- Large
	}
	return result
end

function menu.getFilterTradePlayerOfferOptions(buysellswitch)
	local result = {
		{ id = 0,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11206),	icon = "", displayremoveoption = false }, -- All
		{ id = 1,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11207),	icon = "", displayremoveoption = false }, -- Player only
		{ id = 2,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11208),	icon = "", displayremoveoption = false }, -- Non-Player only
	}
	return result
end

function menu.getFilterThinkAlertOptions()
	local result = {
		{ id = 0, text = ReadText(1001, 4054), icon = "", displayremoveoption = false }, -- none
		{ id = 3, text = ReadText(1001, 4053), icon = "", displayremoveoption = false }, -- high
		{ id = 2, text = ReadText(1001, 4052), icon = "", displayremoveoption = false }, -- medium
		{ id = 1, text = ReadText(1001, 4051), icon = "", displayremoveoption = false }, -- low
	}
	return result
end

function menu.getFilterOption(id)
	return __CORE_DETAILMONITOR_MAPFILTER[id]
end

function menu.setFilterOption(mode, setting, id, value, index)
	if setting.type == "multiselectlist" then
		__CORE_DETAILMONITOR_MAPFILTER[id] = __CORE_DETAILMONITOR_MAPFILTER[id] or {}
		if value then
			if index then
				__CORE_DETAILMONITOR_MAPFILTER[id][index] = value
			else
				if type(value) == "table" then
					local sorted = {}
					for ware in pairs(value) do
						table.insert(sorted, ware)
					end
					table.sort(sorted, Helper.sortWareName)
					__CORE_DETAILMONITOR_MAPFILTER[id] = {}
					for _, ware in ipairs(sorted) do
						table.insert(__CORE_DETAILMONITOR_MAPFILTER[id], ware)
					end
					menu.closeContextMenu()
				else
					table.insert(__CORE_DETAILMONITOR_MAPFILTER[id], value)
				end
			end
		else
			if menu.contextMenuMode == "filter_multiselectlist" then
				menu.setFilterOption(menu.displayedFilterLayer, menu.contextMenuData.setting, menu.contextMenuData.setting.id, menu.contextMenuData.selectedWares)
			else
				menu.contextMenuMode = "filter_multiselectlist"
				menu.contextMenuData = { setting = setting, id = id, value = value }
				menu.createContextFrame(280, Helper.viewHeight - 100, Helper.viewWidth - menu.infoTableOffsetX - menu.infoTableWidth - config.contextBorder - 280, 100)
			end
		end
	elseif setting.type == "checkbox" then
		__CORE_DETAILMONITOR_MAPFILTER[id] = not __CORE_DETAILMONITOR_MAPFILTER[id]
	elseif setting.type == "slidercell" then
		__CORE_DETAILMONITOR_MAPFILTER[id] = value
	elseif setting.type == "dropdown" then
		__CORE_DETAILMONITOR_MAPFILTER[id] = tonumber(value)
	end

	if not __CORE_DETAILMONITOR_MAPFILTER[mode] then
		__CORE_DETAILMONITOR_MAPFILTER[mode] = true
		menu.applyFilterSettings()
	else
		setting.callback(setting)
	end
end

function menu.removeFilterOption(setting, id, index)
	if setting.type == "multiselectlist" then
		__CORE_DETAILMONITOR_MAPFILTER[id] = __CORE_DETAILMONITOR_MAPFILTER[id] or {}
		table.remove(__CORE_DETAILMONITOR_MAPFILTER[id], index)
		setting.callback(setting)
	end
end

function menu.upgradeMapFilterVersion()
	local oldversion = __CORE_DETAILMONITOR_MAPFILTER.version

	if oldversion < 3 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_ecliptic"] = true
	end
	if oldversion < 5 then
		__CORE_DETAILMONITOR_MAPFILTER["layer_think"] = true
	end
	if oldversion < 6 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_storage_container"] = true
	end
	if oldversion < 7 then
		__CORE_DETAILMONITOR_MAPFILTER["think_alert"] = 3
	end
	if oldversion < 8 then
		__CORE_DETAILMONITOR_MAPFILTER["mining_resource_display"] = true
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_civilian"] = true
	end
	if oldversion < 9 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_offer_number"] = 3
	end
	if oldversion < 10 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_volume"] = 0
	end
	if oldversion < 11 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_allyorderqueue"] = true
	end
	if oldversion < 12 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_wrecks"] = true
	end
	if oldversion < 13 then
		__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_factioncolor"] = false
		__CORE_DETAILMONITOR_MAPFILTER["trade_playeroffer_buy"] = 0
		__CORE_DETAILMONITOR_MAPFILTER["trade_playeroffer_sell"] = 0
	end
	if oldversion < 14 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_selection_lines"] = true
	end
	if oldversion < 15 then
		__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"] = true
	end
	if oldversion < 16 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_relation_enemy"] = true
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_opacity"] = false
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_gate_connections"] = true
	end
	if oldversion < 17 then
		if __CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] == 5000 then
			__CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] = 10000
		end
	end
	if oldversion < 18 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false
	end
	if oldversion < 19 then
		if __CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] == 10000 then
			__CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] = 0
		end
	end
	if oldversion < 20 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_rendersatelliteradarrange"] = true
	end

	__CORE_DETAILMONITOR_MAPFILTER.version = config.mapfilterversion
end

function menu.applyFilterSettings()
	for mode, settings in pairs(config.layersettings) do
		local active = menu.getFilterOption(mode) or false
		if settings.callback then
			settings.callback(active)
		end
		if active then
			for _, setting in ipairs(settings) do
				setting.callback(setting)
			end
		end
	end
end

function menu.setMouseCursorOverride(cursor, priority)
	menu.mouseCursorOverrides[priority] = cursor
	menu.setMouseCursor()
end

function menu.removeMouseCursorOverride(priority)
	menu.mouseCursorOverrides[priority] = nil
	menu.setMouseCursor()
end

function menu.clearMouseCursorOverrides()
	menu.mouseCursorOverrides = { [1] = "default" }
	menu.setMouseCursor()
end

function menu.setMouseCursor()
	local highestPriority = table.maxn(menu.mouseCursorOverrides)
	if menu.mouseCursorOverrides[highestPriority] ~= menu.currentMouseCursor then
		menu.currentMouseCursor = menu.mouseCursorOverrides[highestPriority]
		SetMouseCursorOverride(menu.currentMouseCursor)
	end
end

function menu.updateMouseCursor()
	local occupiedship = C.GetPlayerOccupiedShipID()

	local hasplayerselectedship = false
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsValidComponent(selectedcomponent) then
			if C.IsComponentClass(selectedcomponent, "ship") and GetComponentData(selectedcomponent, "isplayerowned") then
				if selectedcomponent ~= occupiedship then
					hasplayerselectedship = true
				end
			end
		else
			menu.removeSelectedComponent(selectedcomponent)
		end
	end

	local cursor
	if menu.showMultiverse then
		local pickedplayer = C.GetPickedMultiverseMapPlayer(menu.holomap)
		if pickedplayer.id ~= 0 then
			cursor = "cursor"
		elseif menu.picking then
			cursor = "crossarrows"
		end
	elseif menu.plotData and menu.plotData.active then
		-- plot mode
		local offset = ffi.new("UIPosRot")
		local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
		if offsetsector ~= 0 then
			cursor = "cursorplus"
		else
			cursor = "unavailable"
		end
	else
		local shiftpressed = C.IsShiftPressed()
		local controlpressed = C.IsControlPressed()
		local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
		local pickedcomponentclass = ffi.string(C.GetComponentClass(pickedcomponent))
		local pickedorder = ffi.new("Order")
		local buf = ffi.new("bool[1]", 0)
		local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, buf)
		local isintermediate = buf[0]
		local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
		local pickedmission = C.GetPickedMapMission(menu.holomap)
		local pickedsyncpoint = C.GetPickedMapSyncPoint(menu.holomap)
		local pickedsyncpointorder = ffi.new("Order")
		local pickedsyncpointordercomponent = C.GetPickedMapSyncPointOwningOrder(menu.holomap, pickedsyncpointorder)

		if pickedordercomponent ~= 0 then
			if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
				-- orders
				if pickedordercomponent ~= occupiedship then
					if isintermediate then
						cursor = "cursorplus"
					else
						cursor = "cursormove"
					end
				else
					cursor = "cursor"
				end
			end
		elseif pickedmission ~= 0 then
			-- guidance
			cursor = "cursor"
		elseif pickedsyncpoint ~= 0 then
			-- sync point
			cursor = "cursor"
		elseif pickedsyncpointordercomponent ~= 0 then
			-- order sync point
			cursor = "cursor"
		elseif pickedtradeoffer ~= 0 then
			-- trade offers
			cursor = "trade"
		elseif pickedcomponent ~= 0 then
			if menu.picking then
				if shiftpressed then
					-- changing selection
					if (pickedcomponentclass ~= "player") and (pickedcomponentclass ~= "ship_xs") and (pickedcomponentclass ~= "highwayentrygate") and (pickedcomponentclass ~= "collectablewares") and (pickedcomponentclass ~= "gate") and (pickedcomponentclass ~= "asteroid") and (pickedcomponentclass ~= "sector") then
						if C.IsComponentOperational(pickedcomponent) and GetComponentData(ConvertStringTo64Bit(tostring(pickedcomponent)), "isplayerowned") then
							cursor = "cursorplus"
						end
					end
				elseif controlpressed then
					-- default interactions
					if C.IsComponentClass(pickedcomponent, "sector") then
						if hasplayerselectedship then
							cursor = "movehere"
						end
					elseif GetComponentData(ConvertStringTo64Bit(tostring(pickedcomponent)), "isenemy") then
						if hasplayerselectedship then
							cursor = "targetred"
						end
					elseif C.IsComponentClass(pickedcomponent, "station") then
						local issingleloopship
						if menu.getNumSelectedComponents() == 1 then
							local component = next(menu.selectedcomponents)
							local selectedcomponent = ConvertStringTo64Bit(component)
							local hasloop = ffi.new("bool[1]", 0)
							C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
							issingleloopship = hasloop[0]
						end

						if not issingleloopship then
							cursor = "trade"
						end
					end
				elseif pickedcomponentclass ~= "player" then
					local playerships = menu.getSelectedComponentCategories()
					for i = #playerships, 1, -1 do
						local ship = playerships[i]
						if ship == pickedcomponent then
							table.remove(playerships, i)
						end
					end
					if #playerships > 0 then
						if C.IsComponentClass(pickedcomponent, "sector") then
							cursor = "crossarrowsorder"
						else
							cursor = "cursororder"
						end
					end
				end
			end
		end
		-- map pan & rot
		if menu.picking then
			if not cursor then
				if (pickedcomponent == 0) or (not C.IsComponentClass(pickedcomponent, "object")) then
					if shiftpressed then
						cursor = "boxselect"
					else
						cursor = "crossarrows"
					end
				end
			end
		end
	end
	if cursor then
		menu.setMouseCursorOverride(cursor, 2)
	else
		menu.removeMouseCursorOverride(2)
	end
end

function menu.getDropDownTurretModeOption(defensibleorturret, context, path, group)
	if (context == nil) and (path == nil) and (group == nil) then
		return ffi.string(C.GetWeaponMode(defensibleorturret))
	elseif context == "all" then
		local allmode
		for i, turret in ipairs(menu.turrets) do
			if (path == nil) or (path == C.IsComponentClass(turret, "missileturret")) then
				local mode = ffi.string(C.GetWeaponMode(turret))
				if allmode == nil then
					allmode = mode
				elseif allmode ~= mode then
					allmode = ""
					break
				end
			end
		end
		for i, group in ipairs(menu.turretgroups) do
			if group.operational > 0 then
				if (path == nil) or (path == IsMacroClass(group.currentmacro, "missileturret")) then
					local mode = ffi.string(C.GetTurretGroupMode2(defensibleorturret, group.context, group.path, group.group))
					if allmode == nil then
						allmode = mode
					elseif allmode ~= mode then
						allmode = ""
						break
					end
				end
			end
		end
		return allmode or ""
	end
	return ffi.string(C.GetTurretGroupMode2(defensibleorturret, context, path, group))
end

function menu.areTurretsArmed(defensibleorturret, ismissile)
	local alldisarmed = true
	for i, turret in ipairs(menu.turrets) do
		if (ismissile == nil) or (ismissile == C.IsComponentClass(turret, "missileturret")) then
			if C.IsWeaponArmed(turret) then
				alldisarmed = false
				break
			end
		end
	end
	for i, group in ipairs(menu.turretgroups) do
		if group.operational > 0 then
			if (ismissile == nil) or (ismissile == IsMacroClass(group.currentmacro, "missileturret")) then
				if C.IsTurretGroupArmed(defensibleorturret, group.context, group.path, group.group) then
					alldisarmed = false
					break
				end
			end
		end
	end
	return not alldisarmed
end

function menu.updateSubordinateGroupInfo(controllable)
	local curtime = getElapsedTime()
	if (not menu.lastSubordinateGroupUpdate) or (curtime > menu.lastSubordinateGroupUpdate) then
		menu.lastSubordinateGroupUpdate = curtime
		local subordinates = GetSubordinates(controllable)
		menu.subordinategroups = {}
		for _, subordinate in ipairs(subordinates) do
			local subordinate64 = ConvertIDTo64Bit(subordinate)
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if menu.subordinategroups[group] then
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == controllable
					if isdocked then
						menu.subordinategroups[group].numdockedatcommander = menu.subordinategroups[group].numdockedatcommander + 1
					end
					table.insert(menu.subordinategroups[group].subordinates, subordinate)
				else
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == controllable
					menu.subordinategroups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(controllable, group)), subordinates = { subordinate }, numdockedatcommander = isdocked and 1 or 0 }
				end
			end
		end
	end
end

function menu.etaSorter(a, b)
	if (a.eta < 0) then
		return false
	elseif (b.eta < 0) then
		return true
	end
	return a.eta < b.eta
end

-- sums up all ware reservation amounts and returns the total (single integer)
function menu.getReservationsAmountTotal(contextcomponent)
	local total = 0
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then			
			if buyflag == "buyoffer" then
				total = total + reservations[i].amount
			else
				total = total - reservations[i].amount
			end
		end
	end

	return total
end

-- sums up all ware reservation amounts sorted by transport type and returns the result as a list
function menu.getReservationsVolumeByTransportType(contextcomponent)
	local amounts = {}
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local storagetype, volume = GetWareData(ffi.string(reservations[i].ware), "transport", "volume")
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if not amounts[storagetype] then
				amounts[storagetype] = 0
			end

			if buyflag == "buyoffer" then
				amounts[storagetype] = amounts[storagetype] + reservations[i].amount * volume
			else
				amounts[storagetype] = amounts[storagetype] - reservations[i].amount * volume
			end
		end
	end

	return amounts
end

-- sums up all ware reservation amounts sorted by ware type and returns the result as a list
function menu.getReservationsAmountByWareType(contextcomponent)
	local amounts = {}
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local ware = ffi.string(reservations[i].ware)
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if not amounts[ware] then
				amounts[ware] = 0
			end

			if buyflag == "buyoffer" then
				amounts[ware] = amounts[ware] + reservations[i].amount
			else
				amounts[ware] = amounts[ware] - reservations[i].amount
			end
		end
	end

	return amounts
end

-- Returns the color and function needed to initiate a ware button for the ObjectInfoTab and the SelectedObjectInfo
-- NOTE: this function is designed to run in a loop, therefore filteroptionlist and setting is not part of the function
--
-- filteroptionlist needs to be the return of menu.getFilterOption
-- setting needs to be the return of config.layersettings["layer_trade"][1]
-- contextware is the ware to do all the checks against
--
-- returns color white if the contextware can be found in filteroptionlist or if filteroptionlist is empty, returns grey otherwise
-- returns function to remove the ware from the tradefilter if the contextware can be found in filteroptionlist, returns function to add the ware otherwise
function menu.getWareButtonColorAndScript(filteroptionlist, setting, contextware)
	local index
	for i, entry in ipairs(filteroptionlist) do
		if (entry == contextware) then
			index = i
			break
		end
	end

	local color = ((#filteroptionlist == 0) or index) and Helper.color.white or Helper.color.grey64
	local script
	if index then
		script = function () menu.removeFilterOption(setting, setting.id, index) end
	else
		script = function () menu.setFilterOption("layer_trade", setting, setting.id, contextware) end
	end

	return color, script
end

-- Takes in storage level, capacity and reservation amount and returns a formatted string like "4,928 k (+5,184) / 5,000 k m3"
-- NOTE: maxcapacity is optional in which case the return is like: "1,295 k (+425)"
function menu.formatWareAmount(currentamount, futureamount, maxcapacity)
	local formattedstring = ConvertIntegerString(futureamount, true, 2, true) .. ((futureamount ~= currentamount) and (" (" .. string.format("%s%s", ((futureamount - currentamount) > 0) and "+" or "", ConvertIntegerString(futureamount - currentamount, true, 2, true)) .. ")") or "")
	if maxcapacity ~= nil then
		formattedstring = formattedstring  .. " / " .. ConvertIntegerString(maxcapacity, true, 2, true) .. " " .. ReadText(1001, 110)
	end
	return formattedstring
end

function menu.getAmountTextWidth(amounttext)
	return math.ceil(C.GetTextWidth(amounttext, Helper.standardFont, menu.selectedShipsTableData.fontsize)) + 2 * Helper.standardTextOffsetx
end

-- Adds a row into a table that shows the name of a transporttype and its fillinglevel expressed with a bar and in numbers
-- Function takes in a table with the following attributes
--	inputtable: the table to add the row to
--	barcolumn: the column the bar should exist in
--	textcolumn: the column the text should exist in
--	textcolspan: the column span of the text
--	currentamount: storage's current filling level
--	futureamount: storage's filling level after all reserved ware exchanges have happened
--	maxcapacity: storage's maximum capacity
--	transporttypename: the displayed text
function menu.addCapacityRow(data)
	row = data.inputtable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
	row[data.textcolumn]:setColSpan(data.textcolspan)

	local mouseovertext
	local amounttext = menu.formatWareAmount(data.currentamount, data.futureamount, data.maxcapacity)
	local text = ReadText(1001, 1402) .. " (" .. data.transporttypename .. ")" .. ReadText(1001, 120)
	local truncatedtext = TruncateText(text, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[data.textcolumn]:getWidth() - menu.getAmountTextWidth(amounttext))
	if truncatedtext ~= text then
		mouseovertext = text .. " " .. amounttext
	end

	local textxoffset = 1 + Helper.borderSize
	local barxoffset = textxoffset + row[data.barcolumn]:getColSpanWidth()
	local width = row[data.textcolumn]:getColSpanWidth()
	row[data.barcolumn]:createStatusBar({ current = data.futureamount, start = data.currentamount, max = data.maxcapacity, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultFlowchartDiff2Color, negChangeColor = Helper.defaultFlowchartDiff1Color, markerColor = Helper.color.transparent, width = width, x = barxoffset, scaling = false })
	row[data.textcolumn]:createIcon("solid", { color = { r = 0, g = 0, b = 0, a = 1 }, height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
	row[data.textcolumn]:setText(truncatedtext, {x = textxoffset})
	row[data.textcolumn]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
end

-- Adds a row into a table that shows a button labled with the ware's name and its amount expressed with a bar and in numbers
-- Function takes in a table with the following attributes
--	inputtable: the table to add the row to
--	barcolumn: the column the bar should exist in
--	buttoncolumn: the column the button should exist in
--	buttoncolspan: the column span of the button
--	currentamount: ware's current amount
--	futureamount: ware's amount after all reserved exchanges have happened
--	maxcapacity: ware's maximum capacity
--	warename: name of the ware
--	textcolor: the color to display the text in
--	buttonscript: the function to execute when clicking the button
function menu.addWareInfoButtonRow(data)
	row = data.inputtable:addRow(true, { bgColor = Helper.color.transparent })
	row[data.buttoncolumn]:setColSpan(data.buttoncolspan)

	local mouseovertext
	local amounttext = menu.formatWareAmount(data.currentamount, data.futureamount)
	local truncatedtext = TruncateText(data.warename, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[data.buttoncolumn]:getWidth() - menu.getAmountTextWidth(amounttext))
	if truncatedtext ~= data.warename then
		mouseovertext = data.warename .. " " .. amounttext
	end

	local barxoffset = 1 + Helper.borderSize + row[data.barcolumn]:getColSpanWidth()
	local width = row[data.buttoncolumn]:getColSpanWidth()
	row[data.barcolumn]:createStatusBar({ current = data.futureamount, start = data.currentamount, max = data.maxcapacity, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultFlowchartDiff2Color, negChangeColor = Helper.defaultFlowchartDiff1Color, markerColor = Helper.color.transparent, width = width, x = barxoffset, scaling = false })
	row[data.buttoncolumn]:createButton({ bgColor = Helper.color.transparent, height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
	row[data.buttoncolumn]:setText(truncatedtext, { color = data.textcolor, x = Helper.standardIndentStep })
	row[data.buttoncolumn]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx, color = data.textcolor })
	row[data.buttoncolumn].handlers.onClick = data.buttonscript
end

function menu.setInfoSubmenuObjectAndRefresh(component)
	menu.infoSubmenuObject = component
	if menu.infoTableMode == "info" then
		menu.refreshInfoFrame(nil, 0)
	elseif menu.searchTableMode == "info" then
		menu.refreshInfoFrame2(nil, 0)
	end
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	--
	-- (true | false) = createInfoFrame_on_menu_infoTableMode (menu.infoFrame)
	-- buttonMissionActivate_on_activate (missionid)
	-- buttonToggleObjectList_on_start (objectlistparam, config)
	-- createPropertyOwned_on_start (config)
	-- createPropertyOwned_on_init_infoTableData (infoTableData)
	-- createPropertyOwned_on_add_ship_infoTableData (infoTableData, object)
	-- createPropertyOwned_on_add_other_objects_infoTableData (infoTableData)
	-- {numdisplayed = numdisplayed} = createPropertyOwned_on_createPropertySection_unassignedships (numdisplayed, instance, ftable, infoTableData)
	-- {maxicons = maxicons, subordinates = subordinates, dockedships = dockedships, constructions = constructions, convertedComponent = convertedComponent} = createPropertyRow_on_init_vars (maxicons, subordinates, dockedships, constructions, convertedComponent)
	-- {locationtext = locationtext} = createPropertyRow_on_set_locationtext (locationtext, component)
	-- {shipname = shipname, properties = createTextProperties} = createPropertyRow_override_row_shipname_createText (shipname, createTextProperties, component)
	-- {locationtext = locationtext, properties = createTextProperties} = createPropertyRow_override_row_location_createText (locationtext, createTextProperties, component)
	-- createSideBar_on_start (config)
	-- createMissionMode_on_missionoffer_guild_start (ftable)
	-- replacement ConvertStringTo64Bit (missionId) = createMissionMode_replaceMissionModeCurrent (current missionId)
	-- createMissionContext_startDescriptionTable (ftable)
	-- (true | false) = createMissionContext_getIsMissionAcceptable (missionid)
	-- (true | false) = createMissionContext_getIsMissionBriefingAvailable (missionid)
	-- createMissionContext_addMissionOfferButtons (ftable, missionid)
	-- createMissionContext_addMissionAcceptedButtons (ftable, missionid)
	-- refreshInfoFrame2_on_start ()
	-- createInfoFrame2_on_menu_infoModeRight (menu.infoFrame2)
	-- createRightBar_on_start (config)
	-- getPropertyOwnedFleetDataInternal_addToFleetIcons (component, shiptyperanks, shiptypedata)
	-- createMissionContext_on_end(frame)
	-- displayDefaultBehaviour_change_param_behaviouractive (behaviouractive)
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end

function menu.setSelectComponentMode (returnsection, classlist, category, playerowned, customheading, screenname)
	menu.old_mode = menu.mode
	menu.old_modeparam = menu.modeparam
	menu.old_infoTableMode = menu.infoTableMode

	menu.mode = "selectComponent"
	menu.modeparam = {
		returnsection,
		classlist,
		category,
		playerowned,
		customheading,
		screenname
	}
	menu.infoTableMode = "propertyowned"
	menu.closeContextMenu()
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.sortDistanceFromPlayer (a, b, invert)
	local distance_a = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (a.id)), ConvertStringTo64Bit (tostring (C.GetPlayerID ())))
	local distance_b = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (b.id)), ConvertStringTo64Bit (tostring (C.GetPlayerID ())))
	if invert then
		return distance_a > distance_b
	else
		return distance_a < distance_b
	end
end
function menu.sortDistanceFromObject (a, b, invert)
	local distance_a = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (a.id)), ConvertStringTo64Bit (tostring (menu.infoSubmenuObject)))
	local distance_b = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (b.id)), ConvertStringTo64Bit (tostring (menu.infoSubmenuObject)))
	if invert then
		return distance_a > distance_b
	else
		return distance_a < distance_b
	end
end
-- kuertee end

init()
﻿
-- param == { 0, 0, mode }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef int32_t BlacklistID;
	typedef int32_t FightRuleID;
	typedef uint64_t MessageID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;
	typedef struct {
		const char* factionid;
		const char* civiliansetting;
		const char* militarysetting;
	} UIFightRuleSetting;

	typedef struct {
		uint32_t id;
		const char* type;
		const char* name;
		bool usemacrowhitelist;
		uint32_t nummacros;
		const char** macros;
		bool usefactionwhitelist;
		uint32_t numfactions;
		const char** factions;
		const char* relation;
		bool hazardous;
	} BlacklistInfo2;
	typedef struct {
		FightRuleID id;
		const char* name;
		uint32_t numfactions;
		UIFightRuleSetting* factions;
	} FightRuleInfo;
	typedef struct {
		MessageID id;
		double time;
		const char* category;
		const char* title;
		const char* text;
		const char* source;
		UniverseID sourcecomponent;
		const char* interaction;
		UniverseID interactioncomponent;
		const char* interactiontext;
		const char* interactionshorttext;
		const char* cutscenekey;
		const char* entityname;
		const char* factionname;
		int64_t money;
		int64_t bonus;
		bool highlighted;
		bool isread;
	} MessageInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		uint32_t numspaces;
	} PlayerAlertCounts;
	typedef struct {
		size_t index;
		double interval;
		bool repeats;
		bool muted;
		uint32_t numspaces;
		UniverseID* spaceids;
		const char* objectclass;
		const char* objectpurpose;
		const char* objectidcode;
		const char* objectowner;
		const char* name;
		const char* message;
		const char* soundid;
	} PlayerAlertInfo2;
	typedef struct {
		const char* id;
		const char* name;
	} ProductionMethodInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
	} Skill2;
	typedef struct {
		const char* id;
		const char* name;
	} SoundInfo;
	typedef struct {
		uint32_t numfactions;
	} TradeRuleCounts;
	typedef struct {
		uint32_t id;
		const char* name;
		uint32_t numfactions;
		const char** factions;
		bool iswhitelist;
	} TradeRuleInfo;
	typedef struct {
		const char* ID;
		const char* Name;
		const char* RawName;
	} UIClothingTheme;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
	} UIEquipmentMod;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		const char* macro;
		uint32_t amount;
	} UIMacroCount;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		const char* category;
		bool enabled;
	} UINotificationType;
	typedef struct {
		const char* ID;
		const char* Name;
		const char* RawName;
		const char* Icon;
	} UIPaintTheme;
	typedef struct {
		const float x;
		const float y;
		const float z;
		const float yaw;
		const float pitch;
		const float roll;
	} UIPosRot;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	void AddPlayerAlert2(PlayerAlertInfo2 alert);
	bool AreVenturesCompatible(void);
	BlacklistID CreateBlacklist2(BlacklistInfo2 info);
	FightRuleID CreateFightRule(FightRuleInfo info);
	UniverseID CreateNPCFromPerson(NPCSeed person, UniverseID controllableid);
	TradeRuleID CreateTradeRule(TradeRuleInfo info);
	bool DropInventory(UniverseID entityid, const char* lockboxid, UIWareAmount* wares, uint32_t numwares);
	const char* GenerateFactionRelationText(const char* factionid);
	uint32_t GetAllFactionShips(UniverseID* result, uint32_t resultlen, const char* factionid);
	uint32_t GetAllFactionStations(UniverseID* result, uint32_t resultlen, const char* factionid);
	uint32_t GetAllTradeRules(TradeRuleID* result, uint32_t resultlen);
	uint32_t GetAvailableClothingThemes(UIClothingTheme* result, uint32_t resultlen);
	uint32_t GetAvailableEquipmentMods(UIEquipmentMod* result, uint32_t resultlen);
	uint32_t GetAvailableLockboxes(const char** result, uint32_t resultlen, UniverseID entityid);
	uint32_t GetAvailablePaintThemes(UIPaintTheme* result, uint32_t resultlen);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	double GetCurrentGameTime(void);
	UILogo GetCurrentPlayerLogo(void);
	int32_t GetEntityCombinedSkill(UniverseID entityid, const char* role, const char* postid);
	uint32_t GetEntitySkillsForAssignment(Skill2* result, UniverseID entityid, const char* role, const char* postid);
	const char* GetFactionDefaultWeaponMode(const char* factionid);
	UniverseID GetLastPlayerControlledShipID(void);
	UIPosRot GetMessageInteractPosition(MessageID messageid);
	uint32_t GetMessages(MessageInfo* result, uint32_t resultlen, size_t start, size_t count, const char* categoryname);
	uint32_t GetNotificationTypes(UINotificationType* result, uint32_t resultlen);
	uint32_t GetNumAllFactionShips(const char* factionid);
	uint32_t GetNumAllFactionStations(const char* factionid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllTradeRules(void);
	uint32_t GetNumAvailableClothingThemes();
	uint32_t GetNumAvailableEquipmentMods();
	uint32_t GetNumAvailableLockboxes(UniverseID entityid);
	uint32_t GetNumAvailablePaintThemes();
	uint32_t GetNumMessages(const char* categoryname, bool );
	uint32_t GetNumNotificationTypes(void);
	uint32_t GetNumPlayerAlerts(void);
	uint32_t GetNumPlayerAlertSounds2(const char* tags);
	uint32_t GetNumPlayerBuildMethods(void);
	uint32_t GetNumPlayerLogos(bool includestandard, bool includecustom);
	uint32_t GetNumSkills(void);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumTransactionLog(UniverseID componentid, double starttime, double endtime);
	int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
	const char* GetPersonName(NPCSeed person, UniverseID controllableid);
	const char* GetPersonRoleName(NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkills3(SkillInfo* result, uint32_t resultlen, NPCSeed person, UniverseID controllableid);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPlayerAlertCounts(PlayerAlertCounts* result, uint32_t resultlen);
	uint32_t GetPlayerAlerts2(PlayerAlertInfo2* result, uint32_t resultlen);
	uint32_t GetPlayerAlertSounds2(SoundInfo* result, uint32_t resultlen, const char* tags);
	const char* GetPlayerBuildMethod(void);
	uint32_t GetPlayerBuildMethods(ProductionMethodInfo* result, uint32_t resultlen);
	const char* GetPlayerClothingTheme(void);
	const char* GetPlayerFactionName(bool userawname);
	float GetPlayerGlobalLoadoutLevel(void);
	UniverseID GetPlayerID(void);
	uint32_t GetPlayerLogos(UILogo* result, uint32_t resultlen, bool includestandard, bool includecustom);
	const char* GetPlayerPaintTheme(void);
	const char* GetPlayerName(void);
	UniverseID GetPlayerOccupiedShipID(void);
	bool GetPlayerGlobalTradeLoopCargoReservationSetting(void);
	UniverseID GetPlayerZoneID(void);
	const char* GetPurposeName(const char* purposeid);
	int32_t GetRelationRangeUIMaxValue(const char* relationrangeid);
	uint32_t GetRoleTierNPCs(NPCSeed* result, uint32_t resultlen, UniverseID controllableid, const char* role, int32_t skilllevel);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	int64_t GetSupplyBudget(UniverseID containerid);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	bool GetTradeRuleInfo(TradeRuleInfo* info, TradeRuleID id);
	TradeRuleCounts GetTradeRuleInfoCounts(TradeRuleID id);
	int64_t GetTradeWareBudget(UniverseID containerid);
	bool HasPersonArrived(UniverseID controllableid, NPCSeed person);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsComponentOperational(UniverseID componentid);
	bool IsMouseEmulationActive(void);
	bool IsPersonTransferScheduled(UniverseID controllableid, NPCSeed person);
	bool IsPlayerTradeRuleDefault(TradeRuleID id, const char* ruletype);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsUnit(UniverseID controllableid);
	void MutePlayerAlert(size_t index);
	void ReadAllInventoryWares(void);
	void ReadInventoryWare(const char* wareid);
	void ReleasePersonFromCrewTransfer(UniverseID controllableid, NPCSeed person);
	void RemoveBlacklist(BlacklistID id);
	void RemoveFightRule(FightRuleID id);
	void RemovePerson(UniverseID controllableid, NPCSeed person);
	void RemovePlayerAlert(size_t index);
	void RemoveTradeRule(TradeRuleID id);
	void SetEditBoxText(const int editboxid, const char* text);
	void SetFactionBuildMethod(const char* factionid, const char* buildmethodid);
	void SetFactionRelationToPlayerFaction(const char* factionid, const char* reasonid, float boostvalue);
	void SetFactionDefaultWeaponMode(const char* factionid, const char* weaponmode);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetMessageRead(MessageID messageid, const char* categoryname);
	void SetNotificationTypeEnabled(const char* id, bool value);
	void SetPlayerBlacklistDefault(BlacklistID id, const char* listtype, const char* defaultgroup, bool value);
	void SetPlayerClothingTheme(const char* theme);
	void SetPlayerFactionName(const char* name);
	void SetPlayerFightRuleDefault(FightRuleID id, const char* listtype, bool value);
	void SetPlayerGlobalLoadoutLevel(float value);
	void SetPlayerIllegalWare(const char* wareid, bool illegal);
	void SetPlayerLogo(UILogo logo);
	void SetPlayerPaintTheme(const char* theme);
	void SetPlayerShipsWaitForPlayer(bool value);
	void SetPlayerTaxiWaitsForPlayer(bool value);
	void SetPlayerTradeLoopCargoReservationSetting(bool value);
	void SetPlayerTradeRuleDefault(TradeRuleID id, const char* ruletype, bool value);
	bool ShouldPlayerShipsWaitForPlayer(void);
	bool ShouldPlayerTaxiWaitForPlayer(void);
	void SignalObjectWithNPCSeed(UniverseID objecttosignalid, const char* param, NPCSeed person, UniverseID controllableid);
	void UnmutePlayerAlert(size_t index, bool silent);
	void UpdateBlacklist2(BlacklistInfo2 info);
	void UpdateFightRule(FightRuleInfo info);
	void UpdatePlayerAlert2(PlayerAlertInfo2 uialert);
	void UpdateTradeRule(TradeRuleInfo info);
]]

local utf8 = require("utf8")

local menu = {
	name = "PlayerInfoMenu",
	inventoryData = {
		craftingHistory = {},
		selectedWares = {},
		curEntry = {},
		mode = "normal",
	},
	logbookData = {
		name = ReadText(1001, 2963),
		category = "all",
		curPage = 1,
		searchtext = "",
	},
	messageData = {
		name = ReadText(1001, 7741),
		category = "highprio",
		searchtext = "",
		curEntry = {},
	},
	equipmentModsData = {
		expandedProperties = {}
	},
	accountData = {
		transactions = {}
	},
	empireData = {
	},
	personnelData = {
		sort = "name",
		role = "current",
		curPage = 1,
		searchtext = "",
		expandedEntities = {},
		curEntry = {},
	},
	editedBlacklist = {},
	factionData = {
		curEntry = {},
	},
	editedFightRule = {},
}

local config = {
	mode = "empire",
	mainLayer = 5,
	infoLayer = 4,
	contextLayer = 2,
	rowHeight = 17,
	leftBar = {
		{ name = ReadText(1001, 7717),		icon = "pi_empire",					mode = "empire",			active = true, helpOverlayID = "playerinfo_sidebar_empire",			helpOverlayText = ReadText(1028, 7701) },
		{ name = ReadText(1001, 7703),		icon = "pi_diplomacy",				mode = "factions",			active = true, helpOverlayID = "playerinfo_sidebar_factions",		helpOverlayText = ReadText(1028, 7715) },
		{ name = ReadText(1001, 2500),		icon = "pi_statistics",				mode = "stats",				active = true, helpOverlayID = "playerinfo_sidebar_stats",			helpOverlayText = ReadText(1028, 7717) },
		{ spacing = true },
		{ name = ReadText(1001, 2202),		icon = "pi_inventory",				mode = "inventory",			active = true, helpOverlayID = "playerinfo_sidebar_inventory",		helpOverlayText = ReadText(1028, 7703) },
		--{ name = ReadText(1001, 7701),		icon = "pi_crafting",				mode = "crafting",			active = true },
		{ name = ReadText(1001, 8031),		icon = "pi_equipmentmods",			mode = "equipmentmods",		active = true, helpOverlayID = "playerinfo_sidebar_equipmentmods",	helpOverlayText = ReadText(1028, 7705) },
		{ name = ReadText(1001, 7716),		icon = "pi_spacesuit",				mode = "spacesuit",			active = true, helpOverlayID = "playerinfo_sidebar_spacesuit",		helpOverlayText = ReadText(1028, 7707) },
		{ spacing = true },
		{ name = ReadText(1001, 9171),		icon = "mapst_ao_default_global",	mode = "globalorders",		active = true, helpOverlayID = "playerinfo_sidebar_globalorders",	helpOverlayText = ReadText(1028, 7709) },
		{ name = ReadText(1001, 7708),		icon = "pi_accountmanagement",		mode = "accounts",			active = true, helpOverlayID = "playerinfo_sidebar_accounts",		helpOverlayText = ReadText(1028, 7713) },
		{ name = ReadText(1001, 11034),		icon = "pi_personnelmanagement",	mode = "personnel",			active = true, helpOverlayID = "playerinfo_sidebar_personnel",		helpOverlayText = ReadText(1028, 7718) },
		{ spacing = true },
		{ name = ReadText(1001, 7730),		icon = function () return menu.messageSidebarIcon() end,		mode = "messages",			active = true, helpOverlayID = "playerinfo_sidebar_messages",		helpOverlayText = ReadText(1028, 7712),		iconcolor = function () return menu.messageSidebarIconColor() end },
		{ name = ReadText(1001, 7702),		icon = "pi_transactionlog",			mode = "transactionlog",	active = true, helpOverlayID = "playerinfo_sidebar_transactions",	helpOverlayText = ReadText(1028, 7719) },
		{ name = ReadText(1001, 5700),		icon = "pi_logbook",				mode = "logbook",			active = true, helpOverlayID = "playerinfo_sidebar_logbook",		helpOverlayText = ReadText(1028, 7711) },
	},
	rightAlignTextProperties = {
		halign = "right"
	},
	rightAlignBoldTextProperties = {
		font = Helper.standardFontBold,
		halign = "right"
	},
	logbookCategories = {
		{ name = ReadText(1001, 2963),	icon = "pi_logbook",		mode = "all" },
		{ empty = true },
		{ name = ReadText(1001, 5701),	icon = "logbook_general",	mode = "general" },
		{ name = ReadText(1001, 5702),	icon = "logbook_missions",	mode = "missions" },
		{ name = ReadText(1001, 5721),	icon = "logbook_news",		mode = "news" },
		{ name = ReadText(1001, 5714),	icon = "logbook_alerts",	mode = "alerts" },
		{ name = ReadText(1001, 5704),	icon = "logbook_upkeep",	mode = "upkeep" },
		{ name = ReadText(1001, 5708),	icon = "logbook_tips",		mode = "tips" },
	},
	logbookPage = 100,
	logbookQueryLimit = 1000,
	messageCategories = {
		{ name = ReadText(1001, 7741),	icon = "pi_message_read_high",	icon_unread = "pi_message_unread_high",	mode = "highprio" },
		{ name = ReadText(1001, 7742),	icon = "pi_message_read_low",	icon_unread = "pi_message_unread_low",	mode = "lowprio" },
	},
	messageCutscenes = {
		["OrbitIndefinitely"] = true,
		["terraforming_scaleplate_green"] = true,
		["terraforming_black_hole_sun"] = true,
		["terraforming_getsu_fune"] = true,
		["terraforming_frontier_edge"] = true,
		["terraforming_atiyas_misfortune"] = true,
		["terraforming_18billion"] = true,
		["terraforming_memory_of_profit"] = true,
		["terraforming_tharkas_cascade"] = true,
		["terraforming_ocean_of_fantasy"] = true
	},
	mouseOutRange = 100,
	modCountColumnWidth = 60,
	equipmentModClasses = {
		{ name = ReadText(1001, 8008), modclass = "ship" },
		{ name = ReadText(1001, 1301), modclass = "weapon" },
		{ name = ReadText(1001, 1317), modclass = "shield" },
		{ name = ReadText(1001, 1103), modclass = "engine" },
	},
	inventoryCategories = {
		{ id = "crafting",		name = ReadText(1001, 2827) },
		{ id = "upgrade",		name = ReadText(1001, 7716) },
		{ id = "paintmod",		name = ReadText(1001, 8510) },
		{ id = "useful",		name = ReadText(1001, 2828) },
		{ id = "tradeonly",		name = ReadText(1001, 2829) },
	},
	inventoryTabs = {
		{ category = "normal",	name = ReadText(1001, 2202),	icon = "pi_inventory",			helpOverlayID = "playerinfo_inventory_normal",		helpOverlayText = ReadText(1028, 7703) },
	},
	blacklistTypes = {
		[1] = { id = "sectortravel",	text = ReadText(1001, 9165), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 9101), shorttext = ReadText(1001, 9162) },
		[2] = { id = "sectoractivity",	text = ReadText(1001, 9166), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 9102), shorttext = ReadText(1001, 9163) },
		[3] = { id = "objectactivity",	text = ReadText(1001, 9167), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 9103), shorttext = ReadText(1001, 9164) },
	},
	classDefinitions = {
		["object"]	= ReadText(1001, 9198),
		["station"]	= ReadText(1001, 3),
		["ship_xl"]	= ReadText(1001, 11003),
		["ship_l"]	= ReadText(1001, 11002),
		["ship_m"]	= ReadText(1001, 11001),
		["ship_s"]	= ReadText(1001, 11000),
	},
	personnelPage = 100,
}

if C.AreVenturesCompatible() then
	table.insert(config.inventoryTabs, { category = "online",	name = ReadText(1001, 7720),	icon = "vt_inventory_player",	helpOverlayID = "playerinfo_inventory_online",		helpOverlayText = ReadText(1028, 3269) })

	table.insert(config.logbookCategories, { empty = true,		online = true })
	table.insert(config.logbookCategories, { name = ReadText(1001, 11319),	icon = "vt_logbook",		mode = "online",	online = true })
end

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_playerinfo.xpl.init - kuertee")
end
-- kuertee end

function menu.cleanup()
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	menu.mainFrame = nil
	menu.infoFrame = nil
	menu.contextFrame = nil

	menu.mainTable = nil
	menu.topLevelTable = nil
	menu.infoTable = nil
	menu.buttonTable = nil

	menu.contextMenuMode = nil
	menu.mouseOutBox = nil

	menu.expandedTransactionEntry = nil
	menu.transactionSearchString = nil

	menu.inventoryData.selectedWares = {}
	menu.accountData.transactions = {}
	menu.personnelData.curEntry = {}
	menu.messageData.showFullscreen = nil

	menu.blacklists = {}
	menu.blacklist = {}
	menu.editedBlacklist = {}

	menu.fightrules = {}
	menu.fightrule = {}
	menu.editedFightRule = {}

	menu.settoprow = nil
	menu.setselectedrow = nil
	menu.setselectedrow2 = nil
	menu.setselectedcol2 = nil
	menu.logbookPageEditBox = nil
	menu.personnelPageEditBox = nil
	menu.transactionLogEditBox = nil
	menu.noupdate = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	menu.cleanupCutsceneRenderTarget()

	if (menu.mode == "inventory") or (menu.mode == "spacesuit") or (menu.empireData.mode and (menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
		C.ReadAllInventoryWares()
	end
	menu.empireData = {}

	if Helper.hasExtension("multiverse") then
		Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
	end

	C.SetUICoverOverride(false)
end

-- Menu member functions

function menu.refreshInfoFrame(toprow, selectedrow, mode, selectedrow2)
	menu.settoprow = toprow or GetTopRow(menu.infoTable)
	menu.setselectedrow = selectedrow or Helper.currentTableRow[menu.infoTable]
	if mode == "accounts" then
		menu.setselectedrow2 = selectedrow2 or Helper.currentTableRow[menu.infoTable]
	end
	menu.logbookPageEditBox = nil
	menu.personnelPageEditBox = nil
	menu.transactionLogEditBox = nil
	if menu.inventoryHeaderTable and menu.lastactivetable == menu.inventoryHeaderTable.id then
		menu.selectedRows.inventoryHeaderTable = menu.selectedRows.inventoryHeaderTable or Helper.currentTableRow[menu.inventoryHeaderTable.id] or 1
		menu.selectedCols.inventoryHeaderTable = menu.selectedCols.inventoryHeaderTable or Helper.currentTableCol[menu.inventoryHeaderTable.id]
	end
	menu.createInfoFrame()
end

function menu.buttonSetPlayerLogo(logo, row, col)
	C.SetPlayerLogo(logo)
	menu.empireData.currentlogo = logo

	menu.setselectedrow2 = row
	menu.setselectedcol2 = col
	menu.over = true
	--print("row: " .. tostring(row) .. ", col: " .. tostring(col))
end

function menu.buttonSetDefaultTheme(mode, themeid, row, col)
	--print("mode: " .. tostring(mode) .. ". applying theme: " .. tostring(themeid))
	if mode == "painttheme" then
		C.SetPlayerPaintTheme(themeid)
	elseif mode == "uniform" then
		C.SetPlayerClothingTheme(themeid)
	end

	menu.setselectedrow2 = row
	menu.setselectedcol2 = col
	menu.over = true
	--print("row: " .. tostring(row) .. ", col: " .. tostring(col))
end

function menu.buttonTogglePlayerInfo(mode)
	-- kuertee start: callback
	if callbacks ["buttonTogglePlayerInfo_on_start"] then
		for _, callback in ipairs (callbacks ["buttonTogglePlayerInfo_on_start"]) do
			callback (mode, config)
		end
	end
	-- kuertee end: callback

	local oldidx, newidx
	for i, entry in ipairs(config.leftBar) do
		if entry.mode then
			if entry.mode == menu.mode then
				oldidx = i
			end
			if entry.mode == mode then
				newidx = i
			end
		end
		if oldidx and newidx then
			break
		end
	end
	if newidx then
		Helper.updateButtonColor(menu.mainTable, newidx + 2, 1, Helper.defaultArrowRowBackgroundColor)
	end
	if oldidx then
		Helper.updateButtonColor(menu.mainTable, oldidx + 2, 1, Helper.defaultButtonBackgroundColor)
	end

	-- Mark items as read when hiding them
	if (menu.mode == "inventory") or (menu.mode == "spacesuit") or (menu.empireData.mode and (menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
		menu.inventoryData.selectedWares = {}
		C.ReadAllInventoryWares()
		if menu.inventoryData.mode == "online" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureinventory", mode)
			end
		end
	elseif menu.mode == "messages" then
		if next(menu.messageData.curEntry) then
			C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
			AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
		end
		menu.messageData.showFullscreen = nil
		menu.cleanupCutsceneRenderTarget()
	end

	AddUITriggeredEvent(menu.name, mode, menu.mode == mode and "off" or "on")
	if mode == menu.mode then
		PlaySound("ui_negative_back")
		menu.mode = nil
		menu.personnelData.curEntry = {}
		if oldidx then
			SelectRow(menu.mainTable, oldidx + 2)
		end
	else
		menu.setdefaulttable = true
		PlaySound("ui_positive_select")
		menu.mode = mode
		if mode == "personnel" then
			menu.empireData.init = true
		end
		if newidx then
			SelectRow(menu.mainTable, newidx + 2)
		end
	end

	menu.refreshInfoFrame(1, 1)
end

function menu.deactivatePlayerInfo()
	local oldidx
	for i, entry in ipairs(config.leftBar) do
		if entry.mode then
			if entry.mode == menu.mode then
				oldidx = i
			end
		end
		if oldidx then
			break
		end
	end

	if oldidx then
		Helper.updateButtonColor(menu.mainTable, oldidx + 2, 1, Helper.defaultButtonBackgroundColor)
	end

	-- Mark items as read when hiding them
	if (menu.mode == "inventory") or (menu.mode == "spacesuit") or (menu.empireData.mode and (menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
		menu.inventoryData.selectedWares = {}
		C.ReadAllInventoryWares()
		if menu.inventoryData.mode == "online" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureinventory", "ventureinventory")
			end
		end
	elseif menu.mode == "messages" then
		if next(menu.messageData.curEntry) then
			C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
			AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
		end
		menu.messageData.showFullscreen = nil
		menu.cleanupCutsceneRenderTarget()
	end
	menu.personnelData.curEntry = {}

	PlaySound("ui_negative_back")
	menu.mode = nil
	if oldidx then
		SelectRow(menu.mainTable, oldidx + 2)
	end

	menu.refreshInfoFrame(1, 1)
end

function menu.buttonInventoryDrop()
	if menu.inventoryData.mode == "drop" then
		local wares = ffi.new("UIWareAmount[?]", #menu.inventoryData.dropWares)

		for i, entry in ipairs(menu.inventoryData.dropWares) do
			wares[i - 1].wareid = Helper.ffiNewString(entry.ware)
			wares[i - 1].amount = entry.amount
		end

		local lockbox = menu.inventoryData.dropLockbox
		if lockbox == "none" then
			lockbox = nil
		end
		C.DropInventory(C.GetPlayerID(), lockbox, wares, #menu.inventoryData.dropWares)

		menu.inventoryData.mode = "normal"
		menu.inventoryData.dropWares = {}
	else
		local rowdata = Helper.getCurrentRowData(menu, menu.infoTable)
		if type(rowdata) == "table" then
			menu.inventoryData.mode = "drop"

			menu.inventoryData.dropWares = {}
			for ware in pairs(menu.inventoryData.selectedWares) do
				if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
					if menu.inventory[ware] and menu.inventory[ware].amount > 0 then
						table.insert(menu.inventoryData.dropWares, { ware = ware, amount = menu.inventory[ware].amount })
					end
				end
			end
		end
	end
	menu.refreshInfoFrame()
end

function menu.buttonInventoryCraft()
	if menu.inventoryData.mode == "craft" then
		if menu.inventoryData.craftAmount and menu.inventoryData.craftAmount > 0 then
			for _, entry in ipairs(menu.craftable) do
				if entry.ware == menu.inventoryData.craftWare[1] then
					if HasAllResourcesToCraft(nil, menu.inventoryData.craftWare[1], menu.inventoryData.craftAmount) then
						local isunbundleammo, component = GetWareData(menu.inventoryData.craftWare[1], "isunbundleammo", "component")
						if isunbundleammo then
							local playership = C.GetPlayerOccupiedShipID()
							if playership ~= 0 then
								if AddAmmo(ConvertStringToLuaID(tostring(playership)), component, menu.inventoryData.craftAmount, true) ~= menu.inventoryData.craftAmount then
									-- We're out of ammo space abort
									break
								end
							end
						end
						for _, resource in ipairs(entry.resources) do
							RemoveInventory(nil, resource.ware, menu.inventoryData.craftAmount * resource.data.needed)
						end
						AddInventory(nil, menu.inventoryData.craftWare[1], menu.inventoryData.craftAmount, true)
						table.insert(menu.inventoryData.craftingHistory, 1, { ware = menu.inventoryData.craftWare, amount = menu.inventoryData.craftAmount, time = C.GetCurrentGameTime() })
						PlaySound("ui_crafting_success")
					end
					break
				end
			end
		end
		menu.inventoryData.mode = nil
		menu.inventoryData.craftWare = nil
		menu.inventoryData.craftAmount = nil
	else
		local rowdata = Helper.getCurrentRowData(menu, menu.defaulttable)
		if type(rowdata) == "table" then
			menu.inventoryData.mode = "craft"
			menu.inventoryData.craftWare = Helper.getCurrentRowData(menu, menu.defaulttable)
			menu.inventoryData.craftAmount = 1
		end
	end
	menu.refreshInfoFrame()
end

function menu.buttonInventoryCancel()
	menu.inventoryData.mode = "normal"
	menu.inventoryData.dropWares = {}
	menu.inventoryData.craftWare = nil
	menu.inventoryData.craftAmount = nil
	menu.refreshInfoFrame()
end

function menu.buttonInventoryEncyclopedia(ware)
	local ispaintmod = GetWareData(ware, "ispaintmod")
	if ispaintmod then
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "paintmods", ware })
	else
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "inventory_wares", ware })
	end
	menu.cleanup()
end

function menu.buttonInventoryDropAll(illegalonly)
	local count = 0
	for ware in pairs(illegalonly and menu.inventory or menu.inventoryData.selectedWares) do
		if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
			if (not illegalonly) or (menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction)) then
				if menu.inventory[ware] and menu.inventory[ware].amount > 0 then
					count = count + 1
				end
			end
		end
	end

	local wares = ffi.new("UIWareAmount[?]", count)
	local i = 0
	for ware in pairs(illegalonly and menu.inventory or menu.inventoryData.selectedWares) do
		if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
			if (not illegalonly) or (menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction)) then
				if menu.inventory[ware] and menu.inventory[ware].amount > 0 then
					wares[i].wareid = Helper.ffiNewString(ware)
					wares[i].amount = menu.inventory[ware].amount
					i = i + 1
				end
			end
		end
	end

	C.DropInventory(C.GetPlayerID(), menu.inventoryData.defaultLockbox, wares, count)
	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.buttonInventorySubMode(mode, col)
	if mode ~= menu.inventoryData.mode then
		menu.inventoryData.mode = mode
		if menu.inventoryData.mode ~= "online" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
			end
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonLogbookCategory(name, category, col)
	menu.logbookData.name = name
	menu.logbookData.category = category
	menu.logbookData.curPage = 1
	menu.setselectedcol = col
	menu.refreshInfoFrame()
end

function menu.buttonLogbookClearQuestion()
	menu.closeContextMenu()

	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "clearlogbook", category = menu.logbookData.category, width = Helper.scaleX(400), xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

	menu.createUserQuestionFrame()
end

function menu.buttonLogbookClear(category)
	ClearLogbook(0, category)
	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.buttonLogbookInteraction(entry)
	if IsValidComponent(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, entry.interactioncomponent })
			menu.cleanup()
		elseif entry.interaction == "showlocationonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, entry.interactioncomponent, nil, nil, nil, nil, entry.interactionposition })
			menu.cleanup()
		elseif entry.interaction == "guidance" then
			local convertedInteractionComponent = ConvertIDTo64Bit(entry.interactioncomponent)
			if convertedInteractionComponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(convertedInteractionComponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.editboxLogbookPage(_, text, textchanged)
	menu.noupdate = nil
	local newpage = tonumber(text)
	if newpage and (newpage ~= menu.logbookData.curPage) then
		menu.logbookData.curPage = math.max(1, math.min(newpage, menu.logbookData.numPages))
		menu.refreshInfoFrame()
	else
		C.SetEditBoxText(menu.logbookPageEditBox.id, menu.logbookData.curPage .. " / " .. menu.logbookData.numPages)
	end
end

function menu.editboxPersonnelPage(_, text, textchanged)
	menu.noupdate = nil
	local newpage = tonumber(text)
	if newpage and (newpage ~= menu.personnelData.curPage) then
		menu.personnelData.curPage = math.max(1, math.min(newpage, menu.personnelData.numPages))
		menu.personnelData.curEntry = {}
		menu.refreshInfoFrame(1, 1)
	else
		C.SetEditBoxText(menu.personnelPageEditBox.id, menu.personnelData.curPage .. " / " .. menu.personnelData.numPages)
	end
end

function menu.buttonMessageCategory(name, category, col)
	menu.messageData.name = name
	menu.messageData.category = category
	if next(menu.messageData.curEntry) then
		C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
		AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
	end
	menu.messageData.curEntry = {}
	menu.messageData.showFullscreen = nil
	menu.cleanupCutsceneRenderTarget()
	menu.setselectedcol = col
	menu.refreshInfoFrame()
end

function menu.buttonMessagesRead()
	for _, entry in ipairs(menu.messages) do
		C.SetMessageRead(entry.id, entry.category)
		AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(entry.id)))
	end
	menu.refreshInfoFrame()
end

function menu.buttonMessagesInteraction(entry)
	if (entry.interactioncomponent > 0) and C.IsComponentOperational(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, ConvertStringToLuaID(tostring(entry.interactioncomponent)) })
			menu.cleanup()
		elseif entry.interaction == "showlocationonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, ConvertStringToLuaID(tostring(entry.interactioncomponent)), nil, nil, nil, nil, entry.interactionposition })
			menu.cleanup()
		elseif entry.interaction == "guidance" then
			if entry.interactioncomponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(entry.interactioncomponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.buttonMessagesToggleCutsceneFullscreen()
	menu.messageData.showFullscreen = not menu.messageData.showFullscreen
	menu.refreshInfoFrame()
end

function menu.buttonAccountCancel()
	menu.accountData.transactions = {}
	menu.refreshInfoFrame()
end

function menu.buttonAccountConfirm()
	for _, transaction in ipairs(menu.accountData.transactions) do
		if transaction.amount > 0 then
			local newstationcash = (GetAccountData(transaction.station, "money") or 0) - transaction.amount
			SetMaxBudget(transaction.station, (newstationcash * 3) / 2)
			SetMinBudget(transaction.station, newstationcash)
			TransferMoneyToPlayer(transaction.amount, transaction.station)
		end
	end
	for _, transaction in ipairs(menu.accountData.transactions) do
		if transaction.amount < 0 then
			-- NB: transaction.amount is always with respect to the player's account! so transaction.amount in this case is negative since money is taken away from the player's account.
			local newstationcash = (GetAccountData(transaction.station, "money") or 0) - transaction.amount
			SetMaxBudget(transaction.station, (newstationcash * 3) / 2)
			SetMinBudget(transaction.station, newstationcash)
			TransferPlayerMoneyTo(-transaction.amount, transaction.station)
		end
	end
	menu.accountData.transactions = {}
	menu.refreshInfoFrame()
end

function menu.accountSetEstimate(container, isbuildstorage)
	local container64 = ConvertIDTo64Bit(container)
	local containernmoney, productionmoney, wantedmoney = GetComponentData(container, "money", "productionmoney", "wantedmoney")
	local estimate = 0
	if isbuildstorage then
		estimate = wantedmoney
	else
		local supplymoney = tonumber(C.GetSupplyBudget(container64)) / 100
		local tradewaremoney = tonumber(C.GetTradeWareBudget(container64)) / 100
		estimate = productionmoney + supplymoney + tradewaremoney
	end
	local amount = -estimate + containernmoney

	local _, index = menu.findAccountTransaction(container)
	if amount ~= 0 then
		if index then
			if menu.accountData.transactions[index].amount ~= amount then
				menu.accountData.transactions[index].amount = amount
			end
		else
			table.insert(menu.accountData.transactions, { station = container, amount = amount })
		end
	else
		if index then
			table.remove(menu.accountData.transactions, index)
		end
	end
end

function menu.buttonAccountToEstimate(container, isbuildstorage)
	menu.accountSetEstimate(container, isbuildstorage)

	menu.refreshInfoFrame()
end

function menu.buttonAccountAllEstimates()
	for i, station in ipairs(menu.accountData.stations) do
		menu.accountSetEstimate(station)
		local buildstorage = GetComponentData(station, "buildstorage")
		menu.accountSetEstimate(buildstorage, true)
	end

	menu.refreshInfoFrame()
end

function menu.editboxChangePlayerName(_, text, textchanged)
	menu.noupdate = nil
	if textchanged and (text ~= "") then
		local player = ConvertStringTo64Bit(tostring(C.GetPlayerID()))
		SetComponentName(player, text)
		menu.empireData.name = text
	end

	menu.refreshInfoFrame()
end

function menu.editboxChangePlayerFactionName(_, text, textchanged)
	menu.noupdate = nil
	if textchanged then
		C.SetPlayerFactionName(text)
		menu.empireData.factionname = text
	end

	menu.refreshInfoFrame()
end

function menu.editboxUpdateTransactionSearchString(_, text, textchanged)
	if textchanged then
		menu.transactionSearchString = text
	end

	menu.refreshInfoFrame()
end

function menu.dropdownInventoryLockbox(_, id)
	menu.inventoryData.dropLockbox = id
end

function menu.slidercellInventoryDrop(ware, value)
	for _, entry in ipairs(menu.inventoryData.dropWares) do
		if entry.ware == ware then
			entry.amount = value
		end
	end
end

function menu.slidercellInventoryCraft(_, value)
	menu.inventoryData.craftAmount = value
end

function menu.slidercellAccountChanged(station, row, value, functable)
	if not functable then
		functable = menu.infoTable
	end

	local changed = false
	if value ~= 0 then
		local _, index = menu.findAccountTransaction(station)
		if index then
			if menu.accountData.transactions[index].amount ~= value then
				menu.accountData.transactions[index].amount = value
				changed = true
			end
		else
			table.insert(menu.accountData.transactions, { station = station, amount = value })
		end
	else
		local _, index = menu.findAccountTransaction(station)
		if index then
			table.remove(menu.accountData.transactions, index)
			changed = true
		end
	end

	if changed then
		local playermoney = ConvertMoneyString(menu.getAccountPlayerMoney(), false, true, nil, true) .. " " .. ReadText(1001, 101)
		for i in ipairs(menu.accountData.stations) do
			Helper.updateCellText(functable, i * 7 - 3, 5, playermoney)
			Helper.updateCellText(functable, i * 7, 5, playermoney)
			if (i * 7 - 3) == row then
				Helper.updateCellText(functable, i * 7 - 3, 2, ConvertMoneyString(GetComponentData(station, "money") - value, false, true, nil, true) .. " " .. ReadText(1001, 101))
			elseif (i * 7) == row then
				Helper.updateCellText(functable, i * 7, 2, ConvertMoneyString(GetComponentData(station, "money") - value, false, true, nil, true) .. " " .. ReadText(1001, 101))
			end
		end
	end
end

function menu.onSliderCellActivated()
	menu.refresh = nil
	menu.refreshdata = nil
end

-- mode: "factionresponses", "controllableresponses"
function menu.checkboxOrdersSetAsk(factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetAsk called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.checkboxOrdersSetAsk called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetAsk called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	local ask
	local response
	if mode == "controllableresponses" then
		ask = not C.GetAskToSignalForControllable(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForControllable(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForControllable(response, ask, signalid, factionorcontrollable)
	else
		ask = not C.GetAskToSignalForFaction(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForFaction(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForFaction(response, ask, signalid, factionorcontrollable)
	end
	menu.refreshInfoFrame()
end

function menu.toggleAllNotificationSettings(notificationgroupdata, checked)
	for _, type in ipairs(notificationgroupdata.types) do
		menu.checkboxNotification(notificationgroupdata, type.id, checked)
	end
end

function menu.checkboxNotification(notificationgroupdata, id, checked)
	C.SetNotificationTypeEnabled(id, checked)
	notificationgroupdata.checkedcounts = 0
	for _, type in ipairs(notificationgroupdata.types) do
		if type.id == id then
			type.enabled = checked
		end
		if type.enabled then
			notificationgroupdata.checkedcounts = notificationgroupdata.checkedcounts + 1
		end
	end
end

-- mode: "factionresponses", "controllableresponses"
function menu.dropdownOrdersSetResponse(_, newresponseid, factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.dropdownOrdersSetResponse called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.dropdownOrdersSetResponse called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.dropdownOrdersSetResponse called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if newresponseid == "reset" then
		if mode == "controllableresponses" then
			if not C.ResetResponseToSignalForControllable(signalid, factionorcontrollable) then
				DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(factionorcontrollable)) .. " " .. tostring(factionorcontrollable))
			end
		else
			local factionobjects = GetContainedObjectsByOwner(factionorcontrollable)
			for _, object in ipairs(factionobjects) do
				local object64 = ConvertIDTo64Bit(object)
				if C.IsComponentClass(object64, "controllable") then
					if not C.ResetResponseToSignalForControllable(signalid, object64) then
						DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(object64)) .. " " .. tostring(object64))
					end
				end
			end
		end
	else
		local ask
		if mode == "controllableresponses" then
			ask = C.GetAskToSignalForControllable(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForControllable(newresponseid, ask, signalid, factionorcontrollable)
		else
			ask = C.GetAskToSignalForFaction(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForFaction(newresponseid, ask, signalid, factionorcontrollable)
		end
	end
end

function menu.dropdownOrdersResupply(_, id)
	C.SetPlayerGlobalLoadoutLevel(tonumber(id))
end

function menu.dropdownOrdersCargoReservations(_, id)
	C.SetPlayerTradeLoopCargoReservationSetting(id == "on")
end

function menu.dropdownOrdersBuildRule(_, id)
	C.SetFactionBuildMethod("player", id)
end

function menu.onShowMenu(state)
	-- reset settings
	C.SetUICoverOverride(false)
	menu.noupdate = nil
	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	-- Init
	menu.playerInfoFullWidth = Helper.viewWidth - (Helper.playerInfoConfig.offsetX + Helper.frameBorder + Helper.borderSize)
	menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	local availableLeftBarHeight = Helper.viewHeight - (Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + Helper.borderSize + menu.sideBarWidth + Helper.scaleY(Helper.titleTextProperties.height) + 2 * Helper.borderSize)
	if 14 * menu.sideBarWidth > availableLeftBarHeight then
		menu.sideBarWidth = Helper.round(availableLeftBarHeight / 14)
	end
	menu.contextMenuWidth = Helper.scaleX(200)

	menu.mode = menu.param[3] or menu.mode or config.mode
	-- cleanup parameter, so we are not returned automatically to the original mode when opening another menu/conversation from this menu (but a different mode)
	menu.param[3] = nil

	menu.expandedTransactionEntry = {}
	menu.transactionSearchString = ""

	menu.initEmpireData()

	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	if state then
		menu.onRestoreState(state)
	end

	menu.holomapcolor = Helper.getHoloMapColors()

	-- display main frame
	menu.createMainFrame()

	AddUITriggeredEvent(menu.name, menu.mode)

	-- display info
	menu.createInfoFrame()
end

function menu.onSaveState()
	local state = {}

	state.settoprow = GetTopRow(menu.infoTable)
	state.setselectedrow = Helper.currentTableRow[menu.infoTable]

	return state
end

function menu.onRestoreState(state)
	menu.settoprow = state.settoprow
	menu.setselectedrow = state.setselectedrow
end

function menu.createMainFrame()
	local frameProperties = {
		standardButtons = { back = true, close = true },
		standardButtonX = Helper.playerInfoConfig.offsetX,
		standardButtonY = Helper.playerInfoConfig.offsetY,
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
		layer = config.mainLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { back = true, close = true, help = true  },
	}

	menu.mainFrame = Helper.createFrameHandle(menu, frameProperties)

	menu.createPlayerInfo(menu.mainFrame, Helper.playerInfoConfig.width, Helper.playerInfoConfig.height, Helper.playerInfoConfig.offsetX, Helper.playerInfoConfig.offsetY)

	menu.mainFrame:display()
end

function menu.createPlayerInfo(frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if callbacks ["createPlayerInfo_on_start"] then
		for _, callback in ipairs (callbacks ["createPlayerInfo_on_start"]) do
			callback (config)
		end
	end
	-- kuertee end: callback

	local ftable = frame:addTable(2, { tabOrder = 3, scaling = false, borderEnabled = false, x = offsetx, y = offsety, reserveScrollBar = false })
	ftable:setColWidth(1, menu.sideBarWidth, false)
	ftable:setColWidth(2, width - menu.sideBarWidth - Helper.borderSize, false)

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent60 })
	local icon = row[1]:setColSpan(2):createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = height, height = height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, width - height - Helper.borderSize))
	icon:setText(Helper.playerInfoConfigTextLeft,		{ fontsize = Helper.playerInfoConfig.fontsize, halign = "left",  x = height + Helper.borderSize, y = (height - textheight) / 2 })
	icon:setText2(Helper.playerInfoConfigTextRight,	{ fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize,          y = (height - textheight) / 2 })

	local spacingHeight = menu.sideBarWidth / 4
	row = ftable:addRow(false, { fixed = true })
	row[1]:createText(" ", { minRowHeight = menu.sideBarWidth + Helper.scaleY(Helper.titleTextProperties.height) + 2 * Helper.borderSize })
	for _, entry in ipairs(config.leftBar) do
		if entry.spacing then
			row = ftable:addRow(false, { fixed = true })
			row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
		else
			row = ftable:addRow(true, { fixed = true })
			row[1]:createButton({ active = entry.active, height = menu.sideBarWidth, bgColor = (menu.mode == entry.mode) and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = entry.iconcolor })
			row[1].handlers.onClick = function () return menu.buttonTogglePlayerInfo(entry.mode) end
		end
	end

	ftable:addConnection(1, 1, true)
end

function menu.createTopLevel(frame)
	Helper.createTopLevelTab(menu, "playerinfo", frame, "", nil, true)
end

function menu.onTabScroll(direction)
	if direction == "right" then
		Helper.scrollTopLevel(menu, "playerinfo", 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, "playerinfo", -1)
	end
end

function menu.onInputModeChanged(_, mode)
	if not menu.noupdate then
		menu.refreshInfoFrame()
	else
		menu.inputModeHasChanged = true
	end
end

function menu.createInfoFrame()
	-- kuertee start: callback
	if callbacks ["createInfoFrame_on_start"] then
		for _, callback in ipairs (callbacks ["createInfoFrame_on_start"]) do
			callback (menu.infoFrame, tableProperties)
		end
	end
	-- kuertee end: callback

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	local width = Helper.playerInfoConfig.width
	if (menu.mode == "empire") or (menu.mode == "globalorders") or (menu.mode == "messages") or (menu.mode == "factions") then
		width = menu.playerInfoFullWidth
	end

	local frameProperties = {
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
		layer = config.infoLayer,
	}

	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)

	if not menu.messageData.showFullscreen then
		menu.createTopLevel(menu.infoFrame)
	end

	local tableProperties = {
		width = width - menu.sideBarWidth - Helper.borderSize,
		x = Helper.playerInfoConfig.offsetX + menu.sideBarWidth + Helper.borderSize,
		y = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + Helper.borderSize,
	}
	tableProperties.height = Helper.viewHeight - tableProperties.y

	Helper.clearTableConnectionColumn(menu, 2)
	Helper.clearTableConnectionColumn(menu, 3)

	if menu.mode == "inventory" then
		menu.createInventory(menu.infoFrame, tableProperties)
	elseif menu.mode == "crafting" then
		menu.createCrafting(menu.infoFrame, tableProperties)
	elseif menu.mode == "equipmentmods" then
		menu.createEquipmentMods(menu.infoFrame, tableProperties)
	elseif menu.mode == "spacesuit" then
		menu.createInventory(menu.infoFrame, tableProperties, "personalupgrade")
	elseif menu.mode == "globalorders" then
		menu.createEmpire(menu.infoFrame, tableProperties)
	elseif menu.mode == "factions" then
		menu.createFactions(menu.infoFrame, tableProperties)
	elseif menu.mode == "transactionlog" then
		tableProperties.width = tableProperties.width * 5 / 4
		tableProperties.x2 = Helper.frameBorder
		Helper.createTransactionLog(menu.infoFrame, C.GetPlayerID(), tableProperties, menu.refreshInfoFrame, { toprow = menu.settoprow, selectedrow = menu.setselectedrow })
		menu.lastTransactionLogRefreshTime = getElapsedTime()
	elseif menu.mode == "empire" then
		menu.createEmpire(menu.infoFrame, tableProperties)
	elseif menu.mode == "accounts" then
		tableProperties.width = tableProperties.width * 3 / 2
		menu.createAccounts(menu.infoFrame, tableProperties)
	elseif menu.mode == "stats" then
		menu.createStats(menu.infoFrame, tableProperties)
	elseif menu.mode == "logbook" then
		tableProperties.width = tableProperties.width * 5 / 4
		menu.createLogbook(menu.infoFrame, tableProperties)
	elseif menu.mode == "messages" then
		menu.createMessages(menu.infoFrame, tableProperties)
	elseif menu.mode == "personnel" then
		menu.createPersonnelInfo(menu.infoFrame, tableProperties)
	end

	-- kuertee start: callback
	if callbacks ["createInfoFrame_on_info_frame_mode"] then
		for _, callback in ipairs (callbacks ["createInfoFrame_on_info_frame_mode"]) do
			callback (menu.infoFrame, tableProperties)
		end
	end
	-- kuertee end: callback

	menu.infoFrame:display()
end

function menu.createInventory(frame, tableProperties, mode, tabOrderOffset)
	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize

	if not tabOrderOffset then
		tabOrderOffset = 0
	end
	menu.skipread = true

	local isonline = Helper.isOnlineGame()
	-- show venture inventory partially if we have permanent online items
	local onlineitems = OnlineGetUserItems()
	for ware, waredata in pairs(onlineitems) do
		local isoperationvolatile, isseasonvolatile = GetWareData(ware, "isoperationvolatile", "isseasonvolatile")
		if (not isoperationvolatile) and (not isseasonvolatile) then
			isonline = true
			break
		end
	end

	if menu.inventoryData.mode == "online" then
		if not isonline then
			menu.inventoryData.mode = "normal"
		end
	end

	if (menu.inventoryData.mode == "normal") or (menu.inventoryData.mode == "drop") or (mode == "personalupgrade") then
		local infotable = frame:addTable(4, { tabOrder = 1 + tabOrderOffset, borderEnabled = true, width = tableProperties.width, maxVisibleHeight = tableProperties.height, multiSelect = true, x = tableProperties.x, y = tableProperties.y })
		menu.inventoryInfoTable = infotable
		if menu.setdefaulttable then
			infotable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		infotable:setColWidth(2, tableProperties.width / 8, false)
		infotable:setColWidth(3, tableProperties.width / 5, false)
		infotable:setColWidth(4, tableProperties.width / 5, false)
		infotable:setDefaultBackgroundColSpan(1, 4)

		-- title
		local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(4):createText((mode == "personalupgrade") and ReadText(1001, 7716) or ReadText(1001, 2202), Helper.titleTextProperties)

		local wareCategories = {}
		local wareCategoryIdx = {}
		for i, entry in ipairs(config.inventoryCategories) do
			wareCategoryIdx[entry.id] = i
			table.insert(wareCategories, { id = entry.id, name = entry.name, data = {} })
		end

		menu.inventory = GetPlayerInventory()
		menu.onlineitems = OnlineGetUserItems()
		for ware, waredata in Helper.orderedPairs(menu.inventory) do
			local iscraftingresource, ismodpart, isprimarymodpart, ispersonalupgrade, tradeonly, ispaintmod, isbraneitem = GetWareData(ware, "iscraftingresource", "ismodpart", "isprimarymodpart", "ispersonalupgrade", "tradeonly", "ispaintmod", "isbraneitem")
			if iscraftingresource or ismodpart or isprimarymodpart then
				table.insert(wareCategories[wareCategoryIdx["crafting"]].data, ware)
			elseif ispersonalupgrade then
				table.insert(wareCategories[wareCategoryIdx["upgrade"]].data, ware)
			elseif tradeonly then
				table.insert(wareCategories[wareCategoryIdx["tradeonly"]].data, ware)
			elseif ispaintmod then
				table.insert(wareCategories[wareCategoryIdx["paintmod"]].data, ware)
			elseif (not menu.onlineitems[ware]) and (not isbraneitem) then
				table.insert(wareCategories[wareCategoryIdx["useful"]].data, ware)
			end
		end
		for i, entry in ipairs(config.inventoryCategories) do
			table.sort(wareCategories[i].data, Helper.sortWareName)
		end

		menu.inventoryData.policefaction = GetComponentData(ConvertStringToLuaID(tostring(C.GetPlayerZoneID())), "policefaction")

		menu.inventoryData.lockboxes = {}
		local player = C.GetPlayerID()
		local n = C.GetNumAvailableLockboxes(player)
		local buf = ffi.new("const char*[?]", n)
		n = C.GetAvailableLockboxes(buf, n, player)
		for i = 0, n - 1 do
			table.insert(menu.inventoryData.lockboxes, GetWareData(ffi.string(buf[i]), "component"))
		end

		local totalprice = 0
		local totalonlineprice = 0
		local found = false
		if next(menu.inventory) then
			-- header
			row = infotable:addRow(ware, { fixed = true, bgColor = Helper.color.unselectable })
			row[1]:setBackgroundColSpan(4):createText(ReadText(1001, 95), { font = Helper.standardFontBold })
			row[2]:createText(ReadText(1001, 1202), config.rightAlignBoldTextProperties)
			row[3]:createText(ReadText(1001, 2413), config.rightAlignBoldTextProperties)
			row[4]:createText(ReadText(1001, 2927), config.rightAlignBoldTextProperties)

			row = infotable:addRow(false, { fixed = true, bgColor = Helper.color.grey })
			row[1]:setColSpan(4):createText("", {height = 1})

			-- entries
			for _, entry in ipairs(wareCategories) do
				if #entry.data > 0 then
					if (mode == "personalupgrade") == (entry.id == "upgrade") then
						found = true
						if mode ~= "personalupgrade" then
							row = infotable:addRow(nil, { bgColor = Helper.color.transparent })
							row[1]:setColSpan(4):createText(entry.name, Helper.subHeaderTextProperties)
							row[1].properties.halign = "center"
						end
						for _, ware in ipairs(entry.data) do
							local waredata = menu.inventory[ware]
							local isequipment, avgprice = GetWareData(ware, "isequipment", "avgprice")
							if not next(menu.inventoryData.selectedWares) then
								menu.inventoryData.selectedWares[ware] = true
							end
							menu.addInventoryWareEntry(infotable, ware, waredata, nil, nil, isequipment, entry.id == "online")
							totalprice = totalprice + avgprice * waredata.amount
						end
					end
				end
			end
		end
		if not found then
			row = infotable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
			row[1]:setColSpan(4):createText("-- " .. ReadText(1001, 32) .. " --", { halign = "center" })
		end

		infotable:setTopRow(menu.settoprow)
		if not menu.setselectedrow2 then
			infotable:setSelectedRow(menu.setselectedrow)
		else
			infotable:setSelectedRow(menu.setselectedrow2)
		end
		menu.settoprow = nil
		menu.setselectedrow = nil
		menu.setselectedrow2 = nil

		-- buttons
		local buttontable = frame:addTable(3, { tabOrder = 2 + tabOrderOffset, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
		menu.inventoryButtonTable = buttontable

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")

		if mode ~= "personalupgrade" then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(" ", { titleColor = Helper.defaultSimpleBackgroundColor })
			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.unselectable })
			row[1]:setBackgroundColSpan(3):setColSpan(2):createText(ReadText(1001, 2442), {  })
			row[3]:createText(ConvertMoneyString(totalprice, false, true, 0, true) .. " " .. ReadText(1001, 101), config.rightAlignTextProperties)

			buttontable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 7735), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"

		local curOption = menu.inventoryData.dropLockbox or "none"
		local options = {
			{ id = "none", text = ReadText(1001, 7731), icon = "", displayremoveoption = false }
		}
		for _, box in ipairs(menu.inventoryData.lockboxes) do
			if (menu.inventoryData.dropLockbox == nil) and (curOption == "none") then
				menu.inventoryData.dropLockbox = box
				menu.inventoryData.defaultLockbox = box
				curOption = box
			end
			table.insert(options, { id = box, text = GetMacroData(box, "name"), icon = "", displayremoveoption = false })
		end

		local row
		if menu.inventoryData.mode == "drop" then
			for _, entry in ipairs(menu.inventoryData.dropWares) do
				local slidermax = entry.amount
				row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createSliderCell({ height = Helper.standardButtonHeight, valueColor = Helper.color.slidervalue, min = 0, minSelect = 1, max = slidermax, start = slidermax }):setText(GetWareData(entry.ware, "name"))
				row[1].handlers.onSliderCellChanged = function (_, value) return menu.slidercellInventoryDrop(entry.ware, value) end
			end

			row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("")

			row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 7732))
			row[2]:setColSpan(2):createDropDown(options, { startOption = curOption })
			row[2].handlers.onDropDownConfirmed = menu.dropdownInventoryLockbox

			row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			-- cancel button
			row[3]:createButton():setText(ReadText(1001, 64), { halign = "center" })
			row[3].handlers.onClick = menu.buttonInventoryCancel
		else
			row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		end
		-- drop item button
		row[1]:createButton({ active = menu.inventoryData.mode == "drop" }):setText((menu.inventoryData.dropWares and (#menu.inventoryData.dropWares > 1)) and ReadText(1001, 7733) or ReadText(1001, 7705), { halign = "center" })
		row[1].handlers.onClick = menu.buttonInventoryDrop

		if menu.inventoryData.mode ~= "drop" then
			local hasillegalwares = false
			for ware in pairs(menu.inventory) do
				if menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction) then
					hasillegalwares = true
					break
				end
			end

			row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ active = hasillegalwares }):setText(ReadText(1001, 7734), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonInventoryDropAll(true) end
		end

		if isonline and (mode ~= "personalupgrade") then
			local headertable = menu.createInventoryHeader(frame, tableProperties)

			local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - headertable:getFullHeight() - Helper.borderSize - Helper.frameBorder
			infotable.properties.y = headertable.properties.y + headertable:getFullHeight() + Helper.borderSize
			buttontable.properties.y = infotable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
			infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

			headertable:addConnection(1, 2, true)
			infotable:addConnection(2, 2)
			buttontable:addConnection(3, 2)
		else
			local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
			buttontable.properties.y = infotable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
			infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

			infotable:addConnection(1, 2, true)
			buttontable:addConnection(2, 2)
		end

		-- media & description
		if menu.inventoryData.curEntry and next(menu.inventoryData.curEntry) then
			local width = narrowtablewidth
			local height = width
			if height > Helper.viewHeight / 2 then
				height = Helper.viewHeight / 2
				width = height
			end
			local mediaProperties = { width = width, x = Helper.viewWidth - width - Helper.frameBorder, height = height, y = tableProperties.y }

			menu.rendertarget = frame:addRenderTarget(mediaProperties)
			menu.inventoryData.activatecutscene = true

			local descriptiontable = frame:addTable(1, { tabOrder = 0, width = width, x = Helper.viewWidth - width - Helper.frameBorder, y = tableProperties.y + height + Helper.borderSize })
			local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:createText(ReadText(1001, 2404), Helper.titleTextProperties)

			local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(GetWareData(menu.inventoryData.curEntry[1], "description"), { wordwrap = true })
		end
	elseif menu.inventoryData.mode == "online" then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
			Helper.callExtensionFunction("multiverse", "createVenturePlayerInventory", menu, menu.infoFrame, "left", "playerinfo", tableProperties)
		end
	end
end

function menu.createInventoryHeader(frame, tableProperties)
	local categories = config.inventoryTabs

	menu.inventoryHeaderTable = frame:addTable(#categories + 1, { tabOrder = 1, x = tableProperties.x, y = tableProperties.y, width = tableProperties.width })
	local ftable = menu.inventoryHeaderTable

	local count = 1
	for i, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if entry.empty then
				ftable:setColWidth(count, menu.sideBarWidth / 2, false)
			else
				ftable:setColWidth(count, menu.sideBarWidth, false)
			end
			count = count + 1
		end
	end

	local row = ftable:addRow("tabs", { fixed = true, bgColor = Helper.color.transparent })
	local count = 1
	for _, entry in ipairs(categories) do
		if not entry.empty then
			local bgcolor = Helper.defaultTitleBackgroundColor
			local color = Helper.color.white
			if entry.category == menu.inventoryData.mode then
				bgcolor = Helper.defaultArrowRowBackgroundColor
			end

			local loccount = count
			row[loccount]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
			row[loccount].handlers.onClick = function () return menu.buttonInventorySubMode(entry.category, loccount) end
			count = count + 1
		end
	end

	if menu.selectedRows["inventoryHeaderTable"] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["inventoryHeaderTable"])
		ftable:setSelectedCol(menu.selectedCols["inventoryHeaderTable"] or 0)
		menu.selectedRows["inventoryHeaderTable"] = nil
		menu.selectedCols["inventoryHeaderTable"] = nil
	end

	return ftable
end

function menu.createCrafting(frame, tableProperties)
	local infotable = frame:addTable(4, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(2, tableProperties.width / 8, false)
	infotable:setColWidth(3, tableProperties.width / 5, false)
	infotable:setColWidth(4, tableProperties.width / 5, false)
	infotable:setDefaultBackgroundColSpan(1, 4)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(4):createText(ReadText(1001, 7701), Helper.titleTextProperties)

	menu.inventory = GetPlayerInventory()
	menu.inventoryData.policefaction = GetComponentData(ConvertStringToLuaID(tostring(C.GetPlayerZoneID())), "policefaction")

	menu.craftable = {}
	if next(menu.inventory) then
		for ware, waredata in pairs(menu.inventory) do
			local ismodpart, isequipment = GetWareData(ware, "ismodpart", "isequipment")
			if (not ismodpart) and (not isequipment) then
				local hasproduction, products, issinglecraft, iscrafting = GetWareData(ware, "hasproductionmethod", "products", "issinglecraft", "iscrafting")
				if (not issinglecraft) or (waredata.amount < 1) then
					if iscrafting and hasproduction then
						menu.createCraftableEntry(ware)
					elseif next(products) then
						for _, product in ipairs(products) do
							menu.createCraftableEntry(product)
						end
					end
				end
			end
		end

		table.sort(menu.craftable, function (a, b) return a.data.name < b.data.name end)
	end

	if next(menu.craftable) then
		-- header
		row = infotable:addRow(ware, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 45))
		row[2]:createText(ReadText(1001, 1202), config.rightAlignTextProperties)
		row[3]:createText(ReadText(1001, 2413), config.rightAlignTextProperties)
		row[4]:createText(ReadText(1001, 2927), config.rightAlignTextProperties)

		-- entries
		for i, product in ipairs(menu.craftable) do
			AddKnownItem("productionmethods", GetWareData(product.ware, "productionmethod"))
			if product.resources.count > 0 then
				menu.addInventoryWareEntry(infotable, product.ware, product.data, true)
				for _, resource in ipairs(product.resources) do
					menu.addInventoryWareEntry(infotable, resource.ware, resource.data, true, true)
				end
			end
		end
	else
		row = infotable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText("-- " .. ReadText(1001, 32) .. " --", { halign = "center" })
	end

	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	-- history & buttons
	local buttontable = frame:addTable(3, { tabOrder = 2, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
	local row
	if menu.inventoryData.craftingHistory[1] then
		row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 7707), Helper.titleTextProperties)

		for i = 1, math.min(3, #menu.inventoryData.craftingHistory) do
			local entry = menu.inventoryData.craftingHistory[i]

			row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(entry.amount .. ReadText(1001, 42) .. " " .. entry.ware[2].name)
			row[3]:createText(Helper.convertGameTimeToXTimeString(entry.time), config.rightAlignTextProperties)
		end

		row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")
	end
	if menu.inventoryData.mode == "craft" then
		row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })

		local slidermax = menu.inventoryData.craftWare[2].craftable
		row[1]:setColSpan(3):createSliderCell({ height = Helper.standardButtonHeight, valueColor = Helper.color.slidervalue, min = 0, minSelect = 1, max = slidermax, start = 1 }):setText(menu.inventoryData.craftWare[2].name)
		row[1].handlers.onSliderCellChanged = menu.slidercellInventoryCraft

		row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		-- cancel button
		row[3]:createButton():setText(ReadText(1001, 64), { halign = "center" })
		row[3].handlers.onClick = menu.buttonInventoryCancel
	else
		row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	end
	-- craft item button
	row[1]:createButton({ active = true }):setText(ReadText(1001, 7706), { halign = "center" })
	row[1].handlers.onClick = menu.buttonInventoryCraft

	infotable.properties.maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
	buttontable.properties.y = buttontable.properties.y + infotable:getMaxVisibleHeight()

	infotable:addConnection(1, 2, true)
	buttontable:addConnection(2, 2)
end

function menu.createEquipmentMods(frame, tableProperties)
	-- STATUS
	local statustable = frame:addTable(1, { tabOrder = 0, width = tableProperties.width, x = tableProperties.x, y = 0 })

	local row = statustable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:createText(ReadText(1001, 2427), Helper.titleTextProperties)

	local row = statustable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 7715), { wordwrap = true })

	statustable.properties.maxVisibleHeight = statustable:getFullHeight()
	statustable.properties.y = tableProperties.y + tableProperties.height - statustable:getVisibleHeight() - Helper.frameBorder

	-- MOD LIST
	local infotable = frame:addTable(6, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = statustable.properties.y - tableProperties.y - Helper.borderSize })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, config.rowHeight, true)
	infotable:setColWidth(2, config.rowHeight, true)
	infotable:setColWidth(4, config.modCountColumnWidth)
	infotable:setColWidth(5, config.modCountColumnWidth)
	infotable:setColWidth(6, config.modCountColumnWidth)
	infotable:setDefaultBackgroundColSpan(2, 5)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(6):createText(ReadText(1001, 8031), Helper.titleTextProperties)

	menu.inventory = GetPlayerInventory()
	menu.modwares = {}
	local n = C.GetNumAvailableEquipmentMods()
	local buf = ffi.new("UIEquipmentMod[?]", n)
	n = C.GetAvailableEquipmentMods(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.ware = ffi.string(buf[i].Ware)

		local modclass, modquality, rawresources = GetWareData(entry.ware, "modclass", "modquality", "resources")
		entry.quality = modquality

		entry.resources = {}
		for _, resource in ipairs(rawresources or {}) do
			local resourcedata = menu.inventory[resource.ware]
			if resourcedata then
				local isprimarymodpart = GetWareData(resource.ware, "isprimarymodpart")
				local maxcraftable = math.floor(resourcedata.amount / resource.amount)
				entry.craftableamount = entry.craftableamount and math.min(maxcraftable, entry.craftableamount) or maxcraftable
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcedata.name, amount = resourcedata.amount, price = resourcedata.price, needed = resource.amount } })
			else
				local resourcename, resourcebuyprice, isprimarymodpart = GetWareData(resource.ware, "name", "buyprice", "isprimarymodpart")
				entry.craftableamount = 0
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcename, amount = 0, price = resourcebuyprice, needed = resource.amount } })
			end
		end

		if menu.modwares[modclass] then
			table.insert(menu.modwares[modclass], entry)
		else
			menu.modwares[modclass] = { entry }
		end
	end

	for _, entry in ipairs(config.equipmentModClasses) do
		local isclassexpanded = menu.isEquipmentModExpanded(entry.modclass, "")

		local qualitycounts = {
			[0] = 0, -- default value in ModDB, handle but don't use
			[1] = 0,
			[2] = 0,
			[3] = 0,
		}
		for _, modware in ipairs(menu.modwares[entry.modclass] or {}) do
			if modware.craftableamount > 0 then
				expandable = true
				qualitycounts[modware.quality] = qualitycounts[modware.quality] + 1
			end
		end

		local row = infotable:addRow(true, {  })
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(isclassexpanded and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function () return menu.expandWeaponMod(entry.modclass, "", row.index) end
		row[2]:setColSpan(2):createText(entry.name)
		for quality, entry2 in ipairs(Helper.modQualities) do
			row[quality + 3]:createText(qualitycounts[quality] .. " \27[" .. entry2.icon2 .. "]", config.rightAlignTextProperties)
		end

		if isclassexpanded then
			for _, property in ipairs(Helper.modProperties[entry.modclass]) do
				menu.createEquipmentPropertyEntry(infotable, entry.modclass, property)
			end
		end
	end

	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	infotable:addConnection(1, 2, true)
end

function menu.createEquipmentPropertyEntry(ftable, modclass, property)
	local isexpanded = menu.isEquipmentModExpanded(modclass, property.key)

	local expandable = false
	local modwares = {
		[0] = {}, -- default value in ModDB, handle but don't use
		[1] = {},
		[2] = {},
		[3] = {},
	}
	for _, modware in ipairs(menu.modwares[modclass] or {}) do
		local moddef = C.GetEquipmentModInfo(modware.ware)
		local propertytype = ffi.string(moddef.PropertyType)
		if propertytype == property.key then
			expandable = true
			table.insert(modwares[modware.quality], modware)
			if modware.craftableamount > 0 then
				modwares[modware.quality].iscraftable = true
			end
		end
	end
	table.sort(modwares[1], function (a, b) return GetWareData(a.ware, "name") < GetWareData(b.ware, "name") end)
	table.sort(modwares[2], function (a, b) return GetWareData(a.ware, "name") < GetWareData(b.ware, "name") end)
	table.sort(modwares[3], function (a, b) return GetWareData(a.ware, "name") < GetWareData(b.ware, "name") end)
	local color = Helper.color.white
	if not expandable then
		color = Helper.color.grey
	end

	local row = ftable:addRow(true, {  })
	row[1].properties.cellBGColor = Helper.color.transparent
	row[2]:setBackgroundColSpan(1):createButton({ active = expandable, height = Helper.standardTextHeight }):setText(isexpanded and "-" or "+", { halign = "center" })
	row[2].handlers.onClick = function () return menu.expandWeaponMod(modclass, property.key, row.index) end
	row[3]:setBackgroundColSpan(4):createText(property.text, { color = color })
	for quality, entry2 in ipairs(Helper.modQualities) do
		if modwares[quality].iscraftable then
			row[quality + 3]:createText("\27[" .. entry2.icon2 .. "]", { halign = "right", color = color })
		end
	end

	if isexpanded then
		local first = true
		for quality, entry2 in ipairs(Helper.modQualities) do
			if not first then
				ftable:addEmptyRow(config.rowHeight / 2)
			end
			first = false
			for i, modware in ipairs(modwares[quality]) do
				if i ~= 1 then
					ftable:addEmptyRow(config.rowHeight / 2)
				end
				menu.createEquipmentModEntry(ftable, modclass, modware)
			end
		end
	end
end

function menu.createEquipmentModEntry(ftable, modclass, moddata)
	-- mod name
	local row = ftable:addRow(true, { bgColor = Helper.defaultTitleBackgroundColor, interactive = false })
	row[1].properties.cellBGColor = Helper.color.transparent
	row[2].properties.cellBGColor = Helper.color.transparent
	row[3]:setColSpan(4):createText("    " .. "\27[" .. Helper.modQualities[moddata.quality].icon2 .. "]" .. GetWareData(moddata.ware, "shortname"), { color = Helper.modQualities[moddata.quality].color })
	-- Resources
	for _, resource in ipairs(moddata.resources) do
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
		local color = (resource.data.amount < resource.data.needed) and Helper.color.grey or Helper.color.white
		-- name
		row[3]:setColSpan(2):createText("       " .. resource.data.name, { color = color })
		-- amount
		row[5]:setColSpan(2):createText(resource.data.amount .. " / " .. resource.data.needed, { halign = "right", color = color })
	end
	-- Effects
	local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
	row[3]:setColSpan(4):createText("     " .. ReadText(1001, 8034) .. ReadText(1001, 120))
	-- Property
	local moddef = C.GetEquipmentModInfo(moddata.ware)
	local propertytype = ffi.string(moddef.PropertyType)
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key == propertytype then
			local minvalue = moddef["MinValue" .. property.type]
			local mineffectcolor = Helper.color.white
			if minvalue > property.basevalue then
				mineffectcolor = property.pos_effect and Helper.color.green or Helper.color.red
			elseif minvalue < property.basevalue then
				mineffectcolor = property.pos_effect and Helper.color.red or Helper.color.green
			end

			local maxvalue = moddef["MaxValue" .. property.type]
			local maxeffectcolor = Helper.color.white
			if maxvalue > property.basevalue then
				maxeffectcolor = property.pos_effect and Helper.color.green or Helper.color.red
			elseif maxvalue < property.basevalue then
				maxeffectcolor = property.pos_effect and Helper.color.red or Helper.color.green
			end

			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
			row[3]:createText("       " .. property.text, { font = Helper.standardFontBold })
			if property.pos_effect and (minvalue < maxvalue) or (minvalue > maxvalue) then
				row[5]:setColSpan(2):createText(property.eval2(minvalue, mineffectcolor, maxvalue, maxeffectcolor), { font = Helper.standardFontBold, halign = "right" })
			else
				row[5]:setColSpan(2):createText(property.eval2(maxvalue, maxeffectcolor, minvalue, mineffectcolor), { font = Helper.standardFontBold, halign = "right" })
			end
			break
		end
	end
	-- Bonus properties
	if moddef.BonusMax > 0 then
		local mouseovertext = ReadText(1026, 8005) .. ReadText(1001, 120)
		for n = 1, moddef.BonusMax do
			-- n < n_max:
			-- p_n = p^n * (1-p)
			-- n == n_max:
			-- p_n_max = p^n_max
			local probability = ((moddef.BonusChance ^ n) * ((n ~= moddef.BonusMax) and (1 - moddef.BonusChance) or 1))
			mouseovertext = mouseovertext .. "\n" .. string.format("%+d %s%s %4.1f%%", n, ReadText(1001, 6602), ReadText(1001, 120), probability * 100)
		end

		local row = ftable:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
		row[3]:setColSpan(2):createText("       " .. ((moddef.BonusMax == 1) and ReadText(1001, 8039) or string.format(ReadText(1001, 8040), moddef.BonusMax)), { mouseOverText = mouseovertext })
		row[5]:setColSpan(2):createText("???", { halign = "right" })
	end
end

function menu.isEquipmentModExpanded(class, property)
	return menu.equipmentModsData.expandedProperties[class .. property]
end

function menu.expandWeaponMod(class, property, row)
	if menu.equipmentModsData.expandedProperties[class .. property] then
		menu.equipmentModsData.expandedProperties[class .. property] = nil
	else
		menu.equipmentModsData.expandedProperties[class .. property] = true
	end

	menu.refreshInfoFrame(nil, row)
end

function menu.isPersonnelExpanded(id)
	return menu.equipmentModsData.expandedProperties[tostring(id)]
end

function menu.expandPersonnel(id, row)
	if menu.equipmentModsData.expandedProperties[tostring(id)] then
		menu.equipmentModsData.expandedProperties[tostring(id)] = nil
	else
		menu.equipmentModsData.expandedProperties[tostring(id)] = true
	end

	if menu.personnelData.curEntry.id ~= id then
		menu.personnelData.curEntry = {}
	end
	menu.refreshInfoFrame(nil, row)
end

function menu.createFactions(frame, tableProperties)
	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize
	local iconheight = math.ceil(config.rowHeight * 1.5)
	local iconoffset = 2

	local infotable = frame:addTable(3, { tabOrder = 1, borderEnabled = true, width = narrowtablewidth, x = tableProperties.x, y = tableProperties.y })

	-- kuertee start: callback
	infotable:setDefaultCellProperties("text", {minRowHeight = config.rowHeight, fontsize = Helper.standardFontSize})
	infotable:setDefaultCellProperties("button", {height = config.rowHeight})
	-- kuertee end: callback

	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, Helper.scaleX(iconheight) + 2 * iconoffset, false)
	infotable:setColWidthPercent(3, 33)
	infotable:setDefaultBackgroundColSpan(1, 3)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(3):createText(ReadText(1001, 7703), Helper.titleTextProperties)
	row[1].properties.height = row[1].properties.height + Helper.borderSize

	-- cover override
	if Helper.isPlayerCovered() then
		local row = infotable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(C.IsUICoverOverridden(), { width = Helper.standardTextHeight, height = Helper.standardTextHeight, mouseOverText = ReadText(1026, 7713) })
		row[1].handlers.onClick = function(_, checked) C.SetUICoverOverride(checked); menu.refreshInfoFrame() end
		row[2]:setColSpan(2):createText(ReadText(1001, 11604), { mouseOverText = ReadText(1026, 7713) })
	end

	menu.relations = GetLibrary("factions")
	for i, relation in ipairs(menu.relations) do
		if relation.id == "player" then
			table.remove(menu.relations, i)
			break
		end
	end
	table.sort(menu.relations, Helper.sortName)
	menu.licences = {}
	for i, relation in ipairs(menu.relations) do
		menu.licences[relation.id] = GetOwnLicences(relation.id)
		table.sort(menu.licences[relation.id], menu.sortLicences)
	end

	if #menu.relations == 0 then
		row = infotable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 38) .. " ---", { halign = "center" })
	else
		for i, relation in ipairs(menu.relations) do
			local shortname = GetFactionData(relation.id, "shortname")
			row = infotable:addRow({ "faction", relation }, { bgColor = Helper.color.transparent })
			row[1]:createIcon((relation.icon ~= "") and relation.icon or "solid", { height = iconheight, x = iconoffset, color = function () return menu.relationColor(relation.id) end, mouseOverText = function () local prioritizedrelationrangename = GetFactionData(relation.id, "prioritizedrelationrangename"); return prioritizedrelationrangename end })
			row[2]:createText("[" .. shortname .. "] " .. relation.name, { fontsize = 14, color = function () return menu.relationColor(relation.id) end, y = 2 * iconoffset, minRowHeight = iconheight + 2 * iconoffset, mouseOverText = function () local prioritizedrelationrangename = GetFactionData(relation.id, "prioritizedrelationrangename"); return prioritizedrelationrangename end })
			row[3]:createText(
				function () return string.format("%+d", GetUIRelation(relation.id)) end,
				{ font = Helper.standardFontMono, color = function () return menu.relationColor(relation.id) end, fontsize = 14, halign = "right", y = 2 * iconoffset, mouseOverText = function () local prioritizedrelationrangename = GetFactionData(relation.id, "prioritizedrelationrangename"); return prioritizedrelationrangename end })
		end
	end
	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	-- faction details
	local detailtable = frame:addTable(3, { tabOrder = 2, width = tableProperties.width - 2 * (narrowtablewidth + Helper.borderSize), x = tableProperties.x + infotable.properties.width + Helper.borderSize, y = infotable.properties.y, highlightMode = "grey" })
	detailtable:setColWidth(1, 2 * Helper.titleHeight)

	local relation = menu.factionData.curEntry

	local row = detailtable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setBackgroundColSpan(3):createText(next(relation) and ("\27[" .. relation.icon .. "]") or "", Helper.titleTextProperties)
	local name
	if next(relation) then
		local shortname = GetFactionData(relation.id, "shortname")
		name = "[" .. shortname .. "] " .. relation.name
	end
	row[2]:setColSpan(2):createText(name, Helper.titleTextProperties)
	row[2].properties.height = row[2].properties.height + Helper.borderSize

	if next(relation) then
		local isrelationlocked, relationlockreason, willclaimspace = GetFactionData(relation.id, "isrelationlocked", "relationlockreason", "willclaimspace")
		-- sector ownership
		if not willclaimspace then
			local row = detailtable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7784))

			detailtable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		-- kuertee start: callback
		if callbacks ["createFactions_on_before_render_licences"] then
			for _, callback in ipairs (callbacks ["createFactions_on_before_render_licences"]) do
				callback (frame, tableProperties, relation.id, detailtable)
			end
		end
		-- kuertee end: callback

		-- licences
		if menu.licences[relation.id] and #menu.licences[relation.id] > 0 then
			local row = detailtable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setBackgroundColSpan(3):setColSpan(2):createText(ReadText(1001, 62), Helper.subHeaderTextProperties)
			row[3]:createText(ReadText(1001, 7748), Helper.subHeaderTextProperties)
			row[3].properties.halign = "right"

			for i, licence in ipairs(menu.licences[relation.id]) do
				local row = detailtable:addRow({ "licence", licence.id }, { bgColor = Helper.color.transparent })
				local color = Helper.color.grey
				if HasLicence("player", licence.type, relation.id) then
					color = Helper.color.white
				end
				local name = licence.name
				if licence.precursor then
					name = "    " .. name
				end
				local info
				if licence.price > 0 then
					info = ConvertMoneyString(licence.price, false, true, 0, true) .. " " .. ReadText(1001, 101)
				elseif not licence.precursor then
					info = string.format("%+d", licence.minrelation)
				end
				row[2]:createText(name, { color = color, mouseOverText = licence.desc })
				row[3]:createText(info, { halign = "right", color = color })
				AddKnownItem("licences", licence.id)
			end

			detailtable:addEmptyRow(Helper.standardTextHeight / 2)
		end
		-- relation
		local row = detailtable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 7749), Helper.subHeaderTextProperties)

		local row = detailtable:addRow(true, { bgColor = Helper.color.transparent })
		row[2]:setColSpan(2):createText(ffi.string(C.GenerateFactionRelationText(relation.id)))

		detailtable:addEmptyRow(Helper.standardTextHeight / 2)
		-- war declaration
		local row = detailtable:addRow(true, { bgColor = Helper.color.transparent })
		local active = true
		local mouseovertext
		if GetUIRelation(relation.id) <= -25 then
			active = false
			mouseovertext = ReadText(1026, 7702)
		elseif isrelationlocked then
			active = false
			mouseovertext = (relationlockreason ~= "") and relationlockreason or ReadText(20229, 100)
		end
		row[3]:createButton({ active = active, mouseOverText = mouseovertext }):setText(ReadText(1001, 7750), { halign = "center" })
		row[3].handlers.onClick = function () return menu.buttonWarDeclarationConfirm(relation.id) end

		-- kuertee start: callback
		if callbacks ["createFactions_on_after_declare_war_button"] then
			for _, callback in ipairs (callbacks ["createFactions_on_after_declare_war_button"]) do
				callback (frame, tableProperties, relation.id, detailtable)
			end
		end
		-- kuertee end: callback
	end

	infotable:addConnection(1, 2, true)
	detailtable:addConnection(1, 3, true)
end

function menu.sortLicences(a, b)
	if a.minrelation == b.minrelation then
		if a.precursor == b.precursor then
			if a.price == b.price then
				return a.name < b.name
			end
			return a.price < b.price
		end
		return (not a.precursor) and b.precursor
	end
	return a.minrelation < b.minrelation
end

function menu.relationColor(faction)
	if GetFactionData(faction, "ishostile") then
		return menu.holomapcolor.hostilecolor
	elseif GetFactionData(faction, "isenemy") then
		return menu.holomapcolor.enemycolor
	else
		return Helper.color.white
	end
end

function menu.createStats(frame, tableProperties)
	local infotable = frame:addTable(2, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, highlightMode = "grey" })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, 2 * tableProperties.width / 3, false)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(2):createText(ReadText(1001, 2500), Helper.titleTextProperties)

	local stats = GetAllStatIDs()
	for i = 1, #stats do
		local hidden, displayname = GetStatData(stats[i], "hidden", "displayname")
		if not hidden then
			row = infotable:addRow(stats[i], {bgColor = Helper.color.transparent})
			row[1]:createText(displayname)
			row[2]:createText(function () return GetStatData(stats[i], "displayvalue") end, { halign = "right", font = Helper.standardFontMono })
		end
	end
	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	infotable:addConnection(1, 2, true)
end

function menu.findAccountTransaction(station)
	for i, transaction in ipairs(menu.accountData.transactions) do
		if IsSameComponent(transaction.station, station) then
			return transaction.amount, i
		end
	end

	return 0
end

function menu.getAccountPlayerMoney()
	local playermoney = GetPlayerMoney()
	for _, transaction in ipairs(menu.accountData.transactions) do
		playermoney = playermoney + transaction.amount
	end
	return playermoney
end

function menu.createAccounts(frame, tableProperties, tabOrderOffset)
	if not tabOrderOffset then
		tabOrderOffset = 0
	end
	local infotable = frame:addTable(5, { tabOrder = 1 + tabOrderOffset, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidthPercent(1, 25)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(5):createText(ReadText(1001, 7708), Helper.titleTextProperties)

	row = infotable:addRow(nil, { fixed = true, bgColor = Helper.color.unselectable })
	row[1]:setBackgroundColSpan(5)
	row[2]:createText(ReadText(1001, 7773), { font = Helper.standardFontBold })
	row[5]:createText(ReadText(1001, 6509), { font = Helper.standardFontBold })

	local playermoney = menu.getAccountPlayerMoney()

	menu.accountData.stations = GetContainedStationsByOwner("player")
	table.sort(menu.accountData.stations, Helper.sortComponentName)
	if #menu.accountData.stations > 0 then
		for i, station in ipairs(menu.accountData.stations) do
			local name, sector, stationmoney, productionmoney, buildstorage = GetComponentData(station, "name", "sector", "money", "productionmoney", "buildstorage")
			local station64 = ConvertIDTo64Bit(station)
			-- station name
			local mouseovertext = ReadText(20001, 201) .. ReadText(1001, 120) .. " " .. sector
			local row = infotable:addRow(false, {  })
			row[1]:setColSpan(5):createText(name .. " (" .. ffi.string(C.GetObjectIDCode(station64)) .. ")", Helper.subHeaderTextProperties)
			row[1].properties.color = menu.holomapcolor.playercolor
			row[1].properties.mouseOverText = mouseovertext

			-- station account
			local transaction = menu.findAccountTransaction(station)
			local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 7710) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
			row[2]:createText(ConvertMoneyString(stationmoney - transaction, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
			row[3]:setColSpan(2):createSliderCell({ min = math.min((-playermoney + transaction), transaction), max = math.max(stationmoney, transaction), start = transaction, fromCenter = true, suffix = ReadText(1001, 101), height = config.rowHeight })
			row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellAccountChanged(station, row.index, value, infotable.id) end
			row[3].handlers.onSliderCellConfirm = function () menu.refreshdata = { nil, nil, "accounts", row.index } menu.refresh = getElapsedTime() + 0.1 end
			row[5]:createText(ConvertMoneyString(playermoney, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "left" })

			-- station estimated budget
			local supplymoney = tonumber(C.GetSupplyBudget(station64)) / 100
			local tradewaremoney = tonumber(C.GetTradeWareBudget(station64)) / 100
			local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9434) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
			local mouseovertext =	ReadText(1001, 8420) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(productionmoney, false, true, 0, true)	.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8423) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(supplymoney, false, true, 0, true)		.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8447) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tradewaremoney, false, true, 0, true)	.. " " .. ReadText(1001, 101)
			row[2]:createText(ConvertMoneyString(productionmoney + supplymoney + tradewaremoney, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })
			row[5]:createButton({ active = function () local money, estimate = GetComponentData(station64, "money", "productionmoney"); estimate = estimate + tonumber(C.GetSupplyBudget(station64)) / 100 + tonumber(C.GetTradeWareBudget(station64)) / 100; return (money + GetPlayerMoney()) > estimate end }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })
			row[5].handlers.onClick = function () return menu.buttonAccountToEstimate(station) end

			infotable:addEmptyRow(Helper.standardTextHeight / 2)

			-- buildstorage account
			if buildstorage then
				local buildstorage64 = ConvertIDTo64Bit(buildstorage)
				local buildstoragemoney, wantedmoney = GetComponentData(buildstorage64, "money", "wantedmoney")

				local transaction = menu.findAccountTransaction(buildstorage)
				local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9429) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
				row[2]:createText(ConvertMoneyString(buildstoragemoney - transaction, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				row[3]:setColSpan(2):createSliderCell({ min = math.min((-playermoney + transaction), transaction), max = math.max(buildstoragemoney, transaction), start = transaction, fromCenter = true, suffix = ReadText(1001, 101), height = config.rowHeight })
				row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellAccountChanged(buildstorage, row.index, value, infotable.id) end
				row[3].handlers.onSliderCellConfirm = function () menu.refreshdata = { nil, nil, "accounts", row.index } menu.refresh = getElapsedTime() + 0.1 end
				row[5]:createText(ConvertMoneyString(playermoney, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "left" })

				-- buildstorage estimated budget
				local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9436) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
				row[2]:createText(ConvertMoneyString(wantedmoney, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				row[5]:createButton({ active = function () local money, estimate = GetComponentData(buildstorage64, "money", "wantedmoney"); return (money + GetPlayerMoney()) > estimate end }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })
				row[5].handlers.onClick = function () return menu.buttonAccountToEstimate(buildstorage, true) end
			end

			if i ~= #menu.accountData.stations then
				infotable:addEmptyRow()
			end
		end
	else
		local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 33) .. " ---", { halign = "center" })
	end

	infotable:setTopRow(menu.settoprow)
	if not menu.setselectedrow2 then
		infotable:setSelectedRow(menu.setselectedrow)
	else
		infotable:setSelectedRow(menu.setselectedrow2)
	end
	menu.settoprow = nil
	menu.setselectedrow = nil
	menu.setselectedrow2 = nil

	local buttontable = frame:addTable(3, { tabOrder = 2 + tabOrderOffset, borderEnabled = false, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })

	local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText("")

	local row = buttontable:addRow(true, { fixed = true })
	row[1]:createButton({ active = #menu.accountData.transactions > 0 }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonAccountConfirm
	row[2]:createButton():setText(ReadText(1001, 3318), { halign = "center" })
	row[2].handlers.onClick = menu.buttonAccountCancel
	row[3]:createButton():setText(ReadText(1001, 7779), { halign = "center" })
	row[3].handlers.onClick = menu.buttonAccountAllEstimates

	local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
	buttontable.properties.y = buttontable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
	infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

	infotable:addConnection(1, 2, true)
	buttontable:addConnection(2, 2)

	return infotable, buttontable
end

function menu.logbookSearchHelper(entry, text)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.title), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.text), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.entityname), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.factionname), text, 1, true) then
		return true
	end

	return false
end

function menu.createLogbookHeader(frame, tableProperties)
	local isonline = C.AreVenturesCompatible()

	local count = 0
	for i, entry in ipairs(config.logbookCategories) do
		if (entry.online == nil) or (entry.online == isonline) then
			count = count + 1
		end
	end

	local numcols = count + 1
	local titletable = frame:addTable(numcols, { tabOrder = 2, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
	for i, entry in ipairs(config.logbookCategories) do
		if (entry.online == nil) or (entry.online == isonline) then
			if entry.empty then
				titletable:setColWidth(i, menu.sideBarWidth / 2, false)
			else
				titletable:setColWidth(i, menu.sideBarWidth, false)
			end
		end
	end

	-- title
	local row = titletable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numcols):createText(ReadText(1001, 5700), Helper.titleTextProperties)
	-- categories
	local row = titletable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	for i, entry in ipairs(config.logbookCategories) do
		if (entry.online == nil) or (entry.online == isonline) then
			if not entry.empty then
				local bgcolor = Helper.defaultTitleBackgroundColor
				local color = Helper.color.white
				if entry.mode == menu.logbookData.category then
					bgcolor = Helper.defaultArrowRowBackgroundColor
				end

				row[i]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false }):setIcon(entry.icon, { color = color})
				row[i].handlers.onClick = function () return menu.buttonLogbookCategory(entry.name, entry.mode, i) end
			end
		end
	end

	if menu.setselectedcol then
		titletable:setSelectedCol(menu.setselectedcol)
		menu.setselectedcol = nil
	end

	return titletable
end

function menu.createLogbook(frame, tableProperties)
	local isonline = Helper.isOnlineGame()
	if not isonline then
		if menu.logbookData.category == "online" then
			menu.logbookData.hasExtension = "all"
		end
	end

	if menu.logbookData.category == "online" then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "createVentureLogbook", menu, menu.infoFrame, "left", "playerinfo", tableProperties)
		end
	else
		local titletable = menu.createLogbookHeader(frame, tableProperties)

		-- entries
		local buttonsize = Helper.scaleY(config.rowHeight)
		local infotable = frame:addTable(10, { tabOrder = 1, width = tableProperties.width, x = tableProperties.x, y = titletable.properties.y + titletable:getFullHeight() + 2 * Helper.borderSize, maxVisibleHeight = tableProperties.height - titletable:getFullHeight() - Helper.borderSize })
		if menu.setdefaulttable then
			infotable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		infotable:setColWidth(1, tableProperties.width / 3, false)
		infotable:setColWidth(4, config.rowHeight)
		infotable:setColWidth(5, config.rowHeight)
		infotable:setColWidth(6, config.rowHeight)
		infotable:setColWidth(7, config.rowHeight)
		infotable:setColWidth(8, tableProperties.width / 3 - 4 * (buttonsize + Helper.borderSize), false)
		infotable:setColWidth(9, config.rowHeight)
		infotable:setColWidth(10, config.rowHeight)

		-- entries
		menu.logbookData.numEntries = GetNumLogbook(menu.logbookData.category)
		if menu.logbookData.searchtext ~= "" then
			menu.logbook = {}
			for i = 1, math.ceil(menu.logbookData.numEntries / config.logbookQueryLimit) do
				local numQuery = math.min(config.logbookQueryLimit, menu.logbookData.numEntries - (i - 1) * config.logbookQueryLimit)
				local logbook = GetLogbook((i - 1) * config.logbookQueryLimit + 1, numQuery, menu.logbookData.category) or {}
				if #logbook > 0 then
					for _, entry in ipairs(logbook) do
						if menu.logbookSearchHelper(entry, menu.logbookData.searchtext) then
							table.insert(menu.logbook, entry)
						end
					end
				end
			end

			menu.logbookData.numEntries = #menu.logbook
			if menu.logbookData.numEntries <= config.logbookPage then
				menu.logbookData.curPage = 1
			else
				local startIndex = menu.logbookData.numEntries - config.logbookPage * menu.logbookData.curPage + 1
				local endIndex = config.logbookPage + startIndex - 1
				if startIndex < 1 then
					startIndex = 1
				end
				menu.logbook = { table.unpack(menu.logbook, startIndex, endIndex) }
			end
		else
			local startIndex = 1
			local numQuery = math.min(config.logbookPage, menu.logbookData.numEntries)
			if menu.logbookData.numEntries <= config.logbookPage then
				menu.logbookData.curPage = 1
			else
				startIndex = menu.logbookData.numEntries - config.logbookPage * menu.logbookData.curPage + 1
				if startIndex < 1 then
					numQuery = config.logbookPage + startIndex - 1
					startIndex = 1
				end
			end
			menu.logbook = GetLogbook(startIndex, numQuery, menu.logbookData.category) or {}
		end
		menu.logbookData.numPages = math.max(1, math.ceil(menu.logbookData.numEntries / config.logbookPage))

		-- category title / pages
		local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(10):createText(menu.logbookData.name, {
			scaling = false,
			font = Helper.titleFont,
			fontsize = Helper.scaleFont(Helper.titleFont, Helper.standardFontSize),
			height = Helper.scaleY(Helper.subHeaderHeight),
			cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
			titleColor = Helper.defaultSimpleBackgroundColor,
		})
		row[1].properties.x = (tableProperties.width - math.ceil(C.GetTextWidth(menu.logbookData.name, Helper.titleFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))) / 2
		row = infotable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250) }):setText(menu.logbookData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= menu.logbookData.searchtext then menu.logbookData.searchtext = text; menu.noupdate = nil; menu.refreshInfoFrame() end end

		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[4]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[4].handlers.onClick = function () menu.logbookData.searchtext = ""; menu.refreshInfoFrame() end

		row[5]:createButton({ scaling = false, active = menu.logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[5].handlers.onClick = function () menu.logbookData.curPage = 1; menu.refreshInfoFrame() end
		row[6]:createButton({ scaling = false, active = menu.logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[6].handlers.onClick = function () menu.logbookData.curPage = menu.logbookData.curPage - 1; menu.refreshInfoFrame() end
		menu.logbookPageEditBox = row[7]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(menu.logbookData.curPage .. " / " .. menu.logbookData.numPages, { halign = "center" })
		row[7].handlers.onEditBoxDeactivated = menu.editboxLogbookPage
		row[9]:createButton({ scaling = false, active = menu.logbookData.curPage < menu.logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[9].handlers.onClick = function () menu.logbookData.curPage = menu.logbookData.curPage + 1; menu.refreshInfoFrame() end
		row[10]:createButton({ scaling = false, active = menu.logbookData.curPage < menu.logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[10].handlers.onClick = function () menu.logbookData.curPage = menu.logbookData.numPages; menu.refreshInfoFrame() end

		infotable:addEmptyRow(Helper.standardTextHeight / 2)

		if #menu.logbook > 0 then
			for i = #menu.logbook, 1, -1 do
				local entry = menu.logbook[i]
				local textcolor = entry.highlighted and Helper.color.red or Helper.standardColor
				row = infotable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
				if entry.interaction and IsValidComponent(entry.interactioncomponent) then
					local mouseoverobject = entry.interactioncomponent
					if IsComponentClass(mouseoverobject, "zone") and not IsComponentClass(mouseoverobject, "highway") then
						mouseoverobject = GetContextByClass(mouseoverobject, "sector")
					end
					row[1]:setColSpan(9):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
					row[10]:createButton({ scaling = false, bgColor = Helper.color.transparent, mouseOverText = string.format(entry.interactiontext, GetComponentData(mouseoverobject, "name")), height = buttonsize }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize })
					row[10].handlers.onClick = function () return menu.buttonLogbookInteraction(entry) end
				else
					row[1]:setColSpan(10):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
				end

				if (entry.entityname ~= "") or (entry.factionname ~= "") then
					row = infotable:addRow(false, { bgColor = Helper.color.transparent, borderBelow = false })
					if entry.entityname ~= "" then
						row[1]:setColSpan(2):createText(ReadText(1001, 5711) .. " " .. entry.entityname, { x = config.rowHeight })
					end
					row[3]:setColSpan(8):createText(entry.factionname, config.rightAlignTextProperties)
				end

				if entry.text ~= "" then
					row = infotable:addRow(false, { bgColor = Helper.color.transparent, borderBelow = false })
					row[1]:setColSpan(10):createText(entry.text, { x = config.rowHeight, color = textcolor, wordwrap = true })
				end

				row = infotable:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createText(Helper.getPassedTime(entry.time), { mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.rowHeight })
				local moneystring = ""
				if entry.money ~= 0 then
					local moneycolor = (entry.money >= 0) and Helper.color.green or Helper.color.red
					moneystring = moneystring .. Helper.convertColorToText(moneycolor) .. ((entry.bonus >= 0) and "+" or "-") .. ConvertMoneyString(entry.money, false, true, nil, true) .. " " .. ReadText(1001, 101)
				end
				if entry.bonus ~= 0 then
					local bonuscolor = (entry.bonus >= 0) and Helper.color.green or Helper.color.red
					moneystring = moneystring .. " " .. Helper.convertColorToText(bonuscolor) .. "(" .. ((entry.bonus >= 0) and "+" or "-") .. " " .. ReadText(1001, 5712) .. " " .. ConvertMoneyString(entry.bonus, false, true, nil, true) .. " " .. ReadText(1001, 101) .. ")"
				end
				row[3]:setColSpan(8):createText(moneystring, config.rightAlignTextProperties)

				if i ~= 1 then
					row = infotable:addRow(false, { bgColor = Helper.defaultSimpleBackgroundColor })
					row[1]:setColSpan(10):createText("", { fontsize = 1, minRowHeight = 1 })
				end
			end
		else
			row = infotable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end

		infotable:setTopRow(menu.settoprow)
		infotable:setSelectedRow(menu.setselectedrow)
		menu.settoprow = nil
		menu.setselectedrow = nil

		local buttontable = frame:addTable(3, { tabOrder = 2, borderEnabled = false, width = tableProperties.width, x = tableProperties.x, y = infotable.properties.y })

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")

		local row = buttontable:addRow(true, { fixed = true })
		row[1]:createButton():setText(ReadText(1001, 5722), { halign = "center" })
		row[1].handlers.onClick = menu.buttonLogbookClearQuestion

		local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
		buttontable.properties.y = buttontable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
		infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

		titletable:addConnection(1, 2, true)
		infotable:addConnection(2, 2)
		buttontable:addConnection(3, 2)

		local width = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize
		local descriptiontable = frame:addTable(1, { tabOrder = 0, width = width, x = Helper.viewWidth - width - Helper.frameBorder, y = Helper.viewHeight * 4 / 5 })
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:createText(ReadText(1001, 2427), Helper.titleTextProperties)

		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 5726), { wordwrap = true })
	end
end

function menu.messageHelper(numQuery, startIdx, category)
	local buf = ffi.new("MessageInfo[?]", numQuery)
	numQuery = C.GetMessages(buf, numQuery, startIdx, numQuery, category)
	returnvalue = {}
	for i = 0, numQuery - 1 do
		local entry = {}

		entry.id					= buf[i].id
		entry.time					= buf[i].time
		entry.category				= ffi.string(buf[i].category)
		entry.title					= ffi.string(buf[i].title)
		entry.text					= ffi.string(buf[i].text)
		entry.source				= ffi.string(buf[i].source)
		entry.sourcecomponent		= buf[i].sourcecomponent
		entry.interaction			= ffi.string(buf[i].interaction)
		entry.interactioncomponent	= buf[i].interactioncomponent
		entry.interactiontext		= ffi.string(buf[i].interactiontext)
		entry.interactionshorttext	= ffi.string(buf[i].interactionshorttext)
		local posrot = C.GetMessageInteractPosition(entry.id)
		entry.interactionposition	= { x = posrot.x, y = posrot.y, z = posrot.z }
		entry.cutscenekey			= ffi.string(buf[i].cutscenekey)
		entry.entityname			= ffi.string(buf[i].entityname)
		entry.factionname			= ffi.string(buf[i].factionname)
		entry.money					= buf[i].money
		entry.bonus					= buf[i].bonus
		entry.highlighted			= buf[i].highlighted
		entry.isread				= buf[i].isread

		table.insert(returnvalue, entry)
	end

	return returnvalue
end

function menu.messageCategoryIcon(entry)
	local numentries = C.GetNumMessages(entry.mode, true)
	return (numentries > 0) and entry.icon_unread or entry.icon
end

function menu.messageSidebarIcon()
	for i, entry in ipairs(config.messageCategories) do
		local numentries = C.GetNumMessages(entry.mode, true)
		if numentries > 0 then
			return entry.icon_unread
		end
	end
	-- if there are no unread messages, use the normal icon of the last category
	return config.messageCategories[#config.messageCategories].icon
end

function menu.messageSidebarIconColor()
	for i, entry in ipairs(config.messageCategories) do
		local numentries = C.GetNumMessages(entry.mode, true)
		if numentries > 0 then
			local period = 10
			local effectduration = 2
			local effectrepeat = 2

			-- number between 0 and period
			local x = getElapsedTime() % period

			if x <= effectduration then
				-- number between 0 and 1
				x = (x * effectrepeat / effectduration) % 1

				normalcolor = Helper.color.white
				overridecolor = Helper.color.mission
				local color = {
					r = (1 - x) * overridecolor.r + x * normalcolor.r,
					g = (1 - x) * overridecolor.g + x * normalcolor.g,
					b = (1 - x) * overridecolor.b + x * normalcolor.b,
					a = (1 - x) * overridecolor.a + x * normalcolor.a,
				}
				return color
			end
		end
	end
	-- if there are no unread messages, use the normal icon color
	return Helper.color.white
end

function menu.createMessages(frame, tableProperties)
	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize

	local infotable, buttontable, titletable, detailtable, interacttable
	if not menu.messageData.showFullscreen then
		-- entries
		local buttonsize = Helper.scaleY(config.rowHeight)
		infotable = frame:addTable(10, { tabOrder = 1, width = narrowtablewidth, x = tableProperties.x, y = 0, maxVisibleHeight = tableProperties.height })
		if menu.setdefaulttable then
			infotable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		infotable:setColWidth(1, narrowtablewidth / 3, false)
		infotable:setColWidth(4, config.rowHeight)
		infotable:setColWidth(5, config.rowHeight)
		infotable:setColWidth(6, config.rowHeight)
		infotable:setColWidth(7, config.rowHeight)
		infotable:setColWidth(8, narrowtablewidth / 3 - 4 * (buttonsize + Helper.borderSize), false)
		infotable:setColWidth(9, config.rowHeight)
		infotable:setColWidth(10, config.rowHeight)

		-- entries
		menu.messageData.numEntries = C.GetNumMessages(menu.messageData.category, false)
		if menu.messageData.searchtext ~= "" then
			menu.messages = {}
			for i = 1, math.ceil(menu.messageData.numEntries / config.logbookQueryLimit) do
				local numQuery = math.min(config.logbookQueryLimit, menu.messageData.numEntries - (i - 1) * config.logbookQueryLimit)
				local startIdx = (i - 1) * config.logbookQueryLimit + 1
				local messages = menu.messageHelper(numQuery, startIdx, menu.messageData.category)

				if #messages > 0 then
					for _, entry in ipairs(messages) do
						if menu.logbookSearchHelper(entry, menu.messageData.searchtext) then
							table.insert(menu.messages, entry)
						end
					end
				end
			end

			menu.messageData.numEntries = #menu.messages
		else
			local numQuery = math.min(config.logbookQueryLimit, menu.messageData.numEntries)
			local startIdx = menu.messageData.numEntries - numQuery + 1
			menu.messages = menu.messageHelper(numQuery, startIdx, menu.messageData.category)
		end

		-- category title / pages
		local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(10):createText(menu.messageData.name, {
			font = Helper.titleFont,
			fontsize = Helper.standardFontSize,
			height = Helper.subHeaderHeight,
			cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
			titleColor = Helper.defaultSimpleBackgroundColor,
			halign = "center",
		})

		local row = infotable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(9):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250) }):setText(menu.messageData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= menu.messageData.searchtext then menu.messageData.searchtext = text; menu.noupdate = nil; menu.refreshInfoFrame() end end
		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[10]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[10].handlers.onClick = function () menu.messageData.searchtext = ""; menu.refreshInfoFrame() end

		infotable:addEmptyRow(Helper.standardTextHeight / 2)

		local numunread = 0
		if #menu.messages > 0 then
			for i = #menu.messages, 1, -1 do
				local entry = menu.messages[i]
				if not entry.isread then
					numunread = numunread + 1
				end
				local font = entry.isread and Helper.standardFont or Helper.standardFontBold
				local textcolor = entry.highlighted and Helper.color.red or Helper.standardColor
				row = infotable:addRow(entry, { bgColor = Helper.color.transparent, borderBelow = false })
				if entry.id == menu.messageData.curEntry.id then
					infotable:setSelectedRow(row.index)
				end

				row[1]:setColSpan(6):createText(entry.title, { font = font, color = textcolor, wordwrap = true })
				row[7]:setColSpan(4):createText(Helper.getPassedTime(entry.time), { font = font, mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.rowHeight, halign = "right" })
			end
		else
			row = infotable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end

		infotable:setTopRow(menu.settoprow)
		menu.settoprow = nil

		-- buttons
		buttontable = frame:addTable(3, { tabOrder = 2, borderEnabled = false, width = narrowtablewidth, x = tableProperties.x, y = infotable.properties.y })

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")

		local row = buttontable:addRow(true, { fixed = true })
		row[3]:createButton({ active = numunread > 0 }):setText(ReadText(1001, 7744), { halign = "center" })
		row[3].handlers.onClick = menu.buttonMessagesRead

		local numcols = #config.messageCategories + 1
		titletable = frame:addTable(numcols, { tabOrder = 2, width = narrowtablewidth, x = tableProperties.x, y = tableProperties.y })
		for i, entry in ipairs(config.messageCategories) do
			if entry.empty then
				titletable:setColWidth(i, menu.sideBarWidth / 2, false)
			else
				titletable:setColWidth(i, menu.sideBarWidth, false)
			end
		end

		-- title
		local row = titletable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 7730), Helper.titleTextProperties)
		-- categories
		local row = titletable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		for i, entry in ipairs(config.messageCategories) do
			if not entry.empty then
				local bgcolor = Helper.defaultTitleBackgroundColor
				local color = Helper.color.white
				if entry.mode == menu.messageData.category then
					bgcolor = Helper.defaultArrowRowBackgroundColor
				end

				row[i]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false }):setIcon(function () return menu.messageCategoryIcon(entry) end, { color = color})
				row[i].handlers.onClick = function () return menu.buttonMessageCategory(entry.name, entry.mode, i) end
			end
		end

		if menu.setselectedcol then
			titletable:setSelectedCol(menu.setselectedcol)
			menu.setselectedcol = nil
		end

		infotable.properties.y = titletable.properties.y + titletable:getFullHeight() + 2 * Helper.borderSize

		local maxVisibleHeight = Helper.viewHeight - infotable.properties.y - buttontable:getFullHeight() - Helper.frameBorder
		buttontable.properties.y = infotable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
		infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

		titletable:addConnection(1, 2, true)
		infotable:addConnection(2, 2)
		buttontable:addConnection(3, 2)

		-- message details
		detailtable = frame:addTable(3, { tabOrder = 3, width = tableProperties.width - 2 * (narrowtablewidth + Helper.borderSize), x = tableProperties.x + infotable.properties.width + Helper.borderSize, y = titletable.properties.y, highlightMode = "off" })
		local row = detailtable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(menu.messageData.curEntry.title, Helper.titleTextProperties)

		if next(menu.messageData.curEntry) then
			local row = detailtable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(2):setBackgroundColSpan(3):createText(ReadText(1001, 7745) .. ReadText(1001, 120) .. " " .. menu.messageData.curEntry.source, {
				font = Helper.titleFont,
				fontsize = Helper.standardFontSize,
				height = Helper.subHeaderHeight,
				cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
				titleColor = Helper.defaultSimpleBackgroundColor,
			})
			row[3]:createText(ReadText(1001, 2691) .. ReadText(1001, 120) .. " " .. Helper.convertGameTimeToXTimeString(menu.messageData.curEntry.time), {
				font = Helper.titleFont,
				fontsize = Helper.standardFontSize,
				height = Helper.subHeaderHeight,
				cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
				titleColor = Helper.defaultSimpleBackgroundColor,
				halign = "right",
			})

			local interacttableheight = 0
			if (menu.messageData.curEntry.interaction ~= "") and (menu.messageData.curEntry.interactioncomponent > 0) and C.IsComponentOperational(menu.messageData.curEntry.interactioncomponent) then
				interacttable = frame:addTable(3, { tabOrder = 4, width = tableProperties.width - 2 * (narrowtablewidth + Helper.borderSize), x = tableProperties.x + infotable.properties.width + Helper.borderSize, y = titletable.properties.y })
				interacttable:addEmptyRow(config.rowHeight)

				local interactioncomponent = menu.messageData.curEntry.interactioncomponent
				if C.IsComponentClass(interactioncomponent, "zone") and (not C.IsComponentClass(interactioncomponent, "highway")) then
					interactioncomponent = GetContextByClass(interactioncomponent, "sector")
				end
				local name = ffi.string(C.GetComponentName(interactioncomponent))

				local row = interacttable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(name)
				local row = interacttable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[3]:createButton({ mouseOverText = string.format(menu.messageData.curEntry.interactiontext, name) }):setText(menu.messageData.curEntry.interactionshorttext, { halign = "center" })
				row[3].handlers.onClick = function () return menu.buttonMessagesInteraction(menu.messageData.curEntry) end

				interacttableheight = interacttable:getFullHeight() + Helper.frameBorder + Helper.borderSize
			end

			local maxnumlines = math.floor((Helper.viewHeight - interacttableheight - detailtable.properties.y) / (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize))
			local lines = GetTextLines(menu.messageData.curEntry.text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), detailtable.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx))
			if #lines > maxnumlines then
				-- scrollbar case
				lines = GetTextLines(menu.messageData.curEntry.text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), detailtable.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
			end
			for linenum, line in ipairs(lines) do
				local row = detailtable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(line)
			end

			if interacttable then
				if #lines > maxnumlines then
					interacttable.properties.y = Helper.viewHeight - interacttable:getFullHeight() - Helper.frameBorder
					detailtable.properties.maxVisibleHeight = interacttable.properties.y - detailtable.properties.y
				else
					interacttable.properties.y = detailtable.properties.y + detailtable:getFullHeight() + Helper.borderSize
				end

				detailtable:addConnection(1, 3, true)
				interacttable:addConnection(2, 3)
			end
		end
	end

	-- media
	if next(menu.messageData.curEntry) and (menu.messageData.curEntry.cutscenekey ~= "") then
		if config.messageCutscenes[menu.messageData.curEntry.cutscenekey] then
			local mediaProperties
			if menu.messageData.showFullscreen then
				local width = Helper.viewWidth
				local height = Helper.round(width * 9 / 16)
				if height > Helper.viewHeight then
					height = Helper.viewHeight
					width = Helper.round(height * 16 / 9)
				end
				mediaProperties = { width = width, x = (Helper.viewWidth - width) / 2, height = height, y = (Helper.viewHeight - height) / 2 }
			else
				local width = narrowtablewidth
				local height = Helper.round(width * 9 / 16)
				if height > tableProperties.height then
					height = tableProperties.height
					width = Helper.round(height * 16 / 9)
				end
				mediaProperties = { width = width, x = tableProperties.x + infotable.properties.width + detailtable.properties.width + (2 * Helper.borderSize), height = height, y = tableProperties.y }
			end

			menu.rendertarget = frame:addRenderTarget(mediaProperties)
			menu.messageData.activatecutscene = true

			local buttonsize = 2 * config.rowHeight
			local rendertargetbuttontable = frame:addTable(2, { tabOrder = 4, width = mediaProperties.width, x = mediaProperties.x, y = mediaProperties.y + mediaProperties.height - Helper.scaleX(buttonsize) })
			rendertargetbuttontable:setColWidth(2, buttonsize)
			local row = rendertargetbuttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[2]:createButton({ height = buttonsize, bgColor = Helper.color.transparent }):setIcon(menu.messageData.showFullscreen and "menu_minimize_video" or "menu_maximize_video")
			row[2].handlers.onClick = menu.buttonMessagesToggleCutsceneFullscreen
		else
			print("Unsupported message cutscene key: '" .. menu.messageData.curEntry.cutscenekey .. "'")
		end
	end
end

function menu.createPersonnelInfo(frame, tableProperties)
	if not menu.empireData.initialized or menu.empireData.init then
		menu.initEmpireData()
		menu.empireData.init = nil
	end

	local infotablewidth = 2 * (Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize)
	local numCols = 11
	local buttonsize = Helper.scaleY(config.rowHeight)

	local infotable = frame:addTable(numCols, { tabOrder = 1, width = infotablewidth, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, config.rowHeight)
	infotable:setColWidth(3, config.rowHeight)
	infotable:setColWidth(7, config.rowHeight)
	infotable:setColWidth(8, config.rowHeight)
	infotable:setColWidth(9, 6 * config.rowHeight)
	infotable:setColWidth(10, config.rowHeight)
	infotable:setColWidth(11, config.rowHeight)

	infotable:setDefaultBackgroundColSpan(1, numCols)
	infotable:setDefaultColSpan(2, 2)
	infotable:setDefaultColSpan(4, 2)
	infotable:setDefaultColSpan(6, 3)
	infotable:setDefaultColSpan(9, 3)

	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11034), Helper.titleTextProperties)

	-- overview
	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11035), Helper.headerRowCenteredProperties)

	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.color.darkgrey })
	row[1]:setColSpan(5):createText(ReadText(1001, 9113))	-- Number of hired personnel
	row[6]:setColSpan(6):createText((ConvertIntegerString(menu.empireData.numhiredpersonnel, true)), { halign = "right" })

	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.color.darkgrey })
	row[1]:setColSpan(5):createText(ReadText(1001, 9114))	-- Average personnel skill
	row[6]:setColSpan(6):createText(Helper.displaySkill(menu.empireData.averagepersonnelskill), { color = Helper.color.brightyellow, halign = "right" })

	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.color.darkgrey })
	row[1]:setColSpan(5):createText(ReadText(1001, 9115))	-- Total personnel skill
	row[6]:setColSpan(6):createText((ConvertIntegerString(menu.empireData.totalpersonnelskill, true)), { halign = "right" })

	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText("")

	-- list
	local employees = menu.getEmployeeList()
	if menu.personnelData.sort == "name" then
		table.sort(employees, function (a, b) return Helper.sortName(a, b, false) end)
	elseif menu.personnelData.sort == "name_inv" then
		table.sort(employees, function (a, b) return Helper.sortName(a, b, true) end)
	elseif menu.personnelData.sort == "skill" then
		table.sort(employees, function (a, b) return menu.skillSorter(a, b, false) end)
	elseif menu.personnelData.sort == "skill_inv" then
		table.sort(employees, function (a, b) return menu.skillSorter(a, b, true) end)
	elseif menu.personnelData.sort == "role" then
		table.sort(employees, function (a, b) return menu.roleSorter(a, b, false) end)
	elseif menu.personnelData.sort == "role_inv" then
		table.sort(employees, function (a, b) return menu.roleSorter(a, b, true) end)
	elseif menu.personnelData.sort == "workplace" then
		table.sort(employees, function (a, b) return menu.workplaceSorter(a, b, false) end)
	elseif menu.personnelData.sort == "workplace_inv" then
		table.sort(employees, function (a, b) return menu.workplaceSorter(a, b, true) end)
	end

	menu.personnelData.numPages = math.ceil(#employees / config.personnelPage)
	if #employees <= config.personnelPage then
		menu.personnelData.curPage = 1
	else
		local startIndex = config.personnelPage * (menu.personnelData.curPage - 1) + 1
		local endIndex = config.personnelPage + startIndex - 1
		if startIndex < 1 then
			startIndex = 1
		end
		employees = { table.unpack(employees, startIndex, endIndex) }
	end

	local row = infotable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11036), Helper.headerRowCenteredProperties)

	-- search & pages
	local roleOptions = {
		{ id = "post:aipilot",		text = ReadText(20208, 30101), icon = "", displayremoveoption = false },
		{ id = "post:manager",		text = ReadText(20208, 30301), icon = "", displayremoveoption = false },
		{ id = "post:shiptrader",	text = ReadText(20208, 30501), icon = "", displayremoveoption = false },
		{ id = "role:service",		text = ReadText(20208, 20103), icon = "", displayremoveoption = false },
		{ id = "role:marine",		text = ReadText(20208, 20203), icon = "", displayremoveoption = false },
	}
	table.sort(roleOptions, function (a, b) return a.text < b.text end)
	table.insert(roleOptions, 1, { id = "current", text = ReadText(1001, 8373), icon = "", displayremoveoption = false })
	local row = infotable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createEditBox({ description = ReadText(1001, 11038), defaultText = ReadText(1001, 3250), height = config.rowHeight }):setText(menu.personnelData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= menu.personnelData.searchtext then menu.personnelData.searchtext = text; menu.personnelData.curPage = 1; menu.noupdate = nil; menu.refreshInfoFrame() end end

	local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
	row[3]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setText("X", { halign = "center", font = Helper.standardFontBold })
	row[3].handlers.onClick = function () if menu.personnelData.searchtext ~= "" then menu.personnelData.searchtext = ""; menu.personnelData.curPage = 1; menu.refreshInfoFrame() end end
	row[4]:setColSpan(1):createText(ReadText(1001, 8399) .. ReadText(1001, 120), { halign = "right" })
	row[5]:createDropDown(roleOptions, { height = config.rowHeight, startOption = menu.personnelData.role })
	row[5].handlers.onDropDownConfirmed = function (_, newrole) if menu.personnelData.role ~= newrole then menu.personnelData.role = newrole; menu.personnelData.curPage = 1; menu.refreshInfoFrame() end end
	row[6]:setColSpan(1)
	row[7]:createButton({ scaling = false, active = menu.personnelData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[7].handlers.onClick = function () menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[8]:createButton({ scaling = false, active = menu.personnelData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[8].handlers.onClick = function () menu.personnelData.curPage = menu.personnelData.curPage - 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	menu.personnelPageEditBox = row[9]:setColSpan(1):createEditBox({ description = ReadText(1001, 7739) }):setText(menu.personnelData.curPage .. " / " .. menu.personnelData.numPages, { halign = "center" })
	row[9].handlers.onEditBoxDeactivated = menu.editboxPersonnelPage
	row[10]:createButton({ scaling = false, active = menu.personnelData.curPage < menu.personnelData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[10].handlers.onClick = function () menu.personnelData.curPage = menu.personnelData.curPage + 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[11]:createButton({ scaling = false, active = menu.personnelData.curPage < menu.personnelData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[11].handlers.onClick = function () menu.personnelData.curPage = menu.personnelData.numPages; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end

	-- sort
	local arrowWidth = Helper.scaleY(config.rowHeight)
	local row = infotable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 2809), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "name_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[1]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "name") or (menu.personnelData.sort == "name_inv")) and Helper.color.white or Helper.color.transparent })
	row[1].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "name") and "name_inv" or "name"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[4]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11037), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "workplace_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "workplace") or (menu.personnelData.sort == "workplace_inv")) and Helper.color.white or Helper.color.transparent })
	row[4].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "workplace") and "workplace_inv" or "workplace"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[6]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11200), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "role_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[6]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "role") or (menu.personnelData.sort == "role_inv")) and Helper.color.white or Helper.color.transparent })
	row[6].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "role") and "role_inv" or "role"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[9]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 9124), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "skill_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[9]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "skill") or (menu.personnelData.sort == "skill_inv")) and Helper.color.white or Helper.color.transparent })
	row[9].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "skill") and "skill_inv" or "skill"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end

	local found = false
	for i, employeedata in ipairs(employees) do
		if menu.personnelData.curEntry and next(menu.personnelData.curEntry) then
			if employeedata.id == menu.personnelData.curEntry.id then
				found = true
			end
		end

		local name = employeedata.name
		local namemouseovertext = ""
		local namecolor
		if GetComponentData(employeedata.container, "isonlineobject") then
			namecolor = Helper.color.grey
			namemouseovertext = ReadText(1026, 9118)
		end
		if employeedata.type == "person" then
			if C.IsPersonTransferScheduled(employeedata.container, employeedata.id) then
				name = Helper.convertColorToText(Helper.color.brightyellow) .. "\027[warning]" .. name
				namemouseovertext = ReadText(1026, 3228)
			elseif not C.HasPersonArrived(employeedata.container, employeedata.id) then
				namecolor = Helper.color.grey
				namemouseovertext = ReadText(1026, 3247)
			end
		end
		local adjustedskill = math.floor(employeedata.skill * 15 / 100)
		local workplace = employeedata.containername
		local assignment = employeedata.rolename

		local role, post, rolename
		if menu.personnelData.role ~= "current" then
			local type, id = string.match(menu.personnelData.role, "(.+):(.+)")
			if type == "post" then
				post = id
			elseif type == "role" then
				role = id
			end
			for _, option in ipairs(roleOptions) do
				if option.id == menu.personnelData.role then
					rolename = option.text
					break
				end
			end
		end

		local roleColor, mouseovertext
		if (menu.personnelData.role ~= "current") and (role ~= employeedata.roleid) and (post ~= employeedata.roleid) then
			roleColor = Helper.color.grey
			mouseovertext = string.format(ReadText(1026, 3231), assignment)
		end

		local isexpanded = menu.isPersonnelExpanded(employeedata.id)
		local row = infotable:addRow({"personnel_employee", employeedata}, { bgColor = Helper.color.transparent })
		row[1]:createButton({ height = config.mapRowHeight }):setText(function() return isexpanded and "-" or "+" end, { halign = "center" })
		row[1].handlers.onClick = function() return menu.expandPersonnel(employeedata.id, row.index) end
		row[2]:createText(name, { mouseOverText = namemouseovertext, color = namecolor })
		row[4]:createText(workplace)
		row[6]:createText(assignment, { color = roleColor, mouseOverText = mouseovertext })
		row[9]:createText(Helper.displaySkill(adjustedskill), { color = Helper.color.brightyellow, halign = "right", mouseOverText = ReadText(1026, 2) })
		if isexpanded then
			local numskills = C.GetNumSkills()
			local skilltable = ffi.new("Skill2[?]", numskills + 1)
			if employeedata.type == "person" then
				numskills = C.GetPersonSkillsForAssignment(skilltable, employeedata.id, employeedata.container, role, post)
			else
				numskills = C.GetEntitySkillsForAssignment(skilltable, employeedata.id, role, post)
			end
			local sortedskilltable = {}
			for i = 1, numskills do
				table.insert(sortedskilltable, skilltable[i])
			end
			table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
			for i, skill in ipairs(sortedskilltable) do
				local skillname = ReadText(1013, skill.textid)
				local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
				local mouseovertext = ReadText(1013, skill.descriptionid)
				local row = infotable:addRow(nil, { bgColor = Helper.color.transparent })
				row[2]:createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
				row[4]:createText(printedskill, { halign = "left", color = (skill.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow, mouseOverText = mouseovertext })
			end
		end
	end

	if not found then
		menu.personnelData.curEntry = {}
	end

	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	-- media & description
	if menu.personnelData.curEntry and next(menu.personnelData.curEntry) then
		local width = math.floor(infotablewidth / 2)
		local height = width
		if height > Helper.viewHeight / 2 then
			height = math.floor(Helper.viewHeight / 2)
			width = height
		end
		local x = tableProperties.x + infotablewidth + Helper.borderSize
		local mediaProperties = { width = width, x = x, height = height, y = tableProperties.y }

		if menu.personnelData.curEntry.type == "entity" then
			menu.rendertarget = frame:addRenderTarget(mediaProperties)
			if menu.personnelData.curEntry.id ~= menu.personnelData.renderobject then
				menu.personnelData.activatecutscene = true
			end
		end

		local descriptiontable = frame:addTable(2, { tabOrder = 0, width = width, x = x, y = tableProperties.y + height + Helper.borderSize })
		descriptiontable:setColWidthPercent(1, 33)
		-- no video icon
		if menu.personnelData.curEntry.type ~= "entity" then
			descriptiontable.properties.y = tableProperties.y
			local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createIcon("briefing_no_video", { width = width, height = height, scaling = false })
		end
		-- details
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(2):createText(ReadText(1001, 2961), Helper.titleTextProperties)
		-- name
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
		row[2]:createText(menu.personnelData.curEntry.name, { halign = "right" })
		-- skills
		local numskills = C.GetNumSkills()
		local skilltable = ffi.new("Skill2[?]", numskills + 1)
		if menu.personnelData.curEntry.type == "person" then
			numskills = C.GetPersonSkillsForAssignment(skilltable, menu.personnelData.curEntry.id, menu.personnelData.curEntry.container, role, post)
		else
			numskills = C.GetEntitySkillsForAssignment(skilltable, menu.personnelData.curEntry.id, role, post)
		end
		local sortedskilltable = {}
		for i = 1, numskills do
			table.insert(sortedskilltable, skilltable[i])
		end
		table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
		for i, skill in ipairs(sortedskilltable) do
			local skillname = ReadText(1013, skill.textid)
			local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
			local mouseovertext = ReadText(1013, skill.descriptionid)
			local row = descriptiontable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:createText("   " .. skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Helper.color.white or Helper.color.grey, mouseOverText = mouseovertext })
			row[2]:createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Helper.color.brightyellow or Helper.color.yellow, mouseOverText = mouseovertext })
		end
		-- workplace
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11037) .. ReadText(1001, 120))
		row[2]:createText(menu.personnelData.curEntry.containername, { halign = "right" })
		-- location
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11039) .. ReadText(1001, 120))
		row[2]:createText(function () return GetComponentData(menu.personnelData.curEntry.container, "sector") end, { halign = "right" })
		-- role
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11200) .. ReadText(1001, 120))
		row[2]:createText(menu.personnelData.curEntry.rolename, { halign = "right" })
		-- current command
		if (menu.personnelData.curEntry.type == "entity") and (menu.personnelData.curEntry.roleid == "aipilot") then
			local aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(menu.personnelData.curEntry.id, "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
			local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 78) .. ReadText(1001, 120))
			if #aicommandstack > 0 then
				aicommand = aicommandstack[1].command
				aicommandparam = aicommandstack[1].param
			end
			row[2]:createText(string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil), { halign = "right" })
			local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			local numaicommands = #aicommandstack
			if numaicommands > 1 then
				aicommandaction = aicommandstack[numaicommands].command
				aicommandactionparam = aicommandstack[numaicommands].param
			end
			row[2]:createText(string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil), { halign = "right" })
		end
	end

	infotable:addConnection(1, 2, true)
end

function menu.roleSorter(a, b, invert)
	if a.rolename == b.rolename then
		if a.skill == b.skill then
			return a.name < b.name
		end
		return a.currentskill > b.currentskill
	end
	if invert then
		return a.rolename > b.rolename
	else
		return a.rolename < b.rolename
	end
end

function menu.skillSorter(a, b, invert)
	if a.skill == b.skill then
		return a.name < b.name
	end
	if invert then
		return a.skill < b.skill
	else
		return a.skill > b.skill
	end
end

function menu.workplaceSorter(a, b, invert)
	if a.containername == b.containername then
		return a.name < b.name
	end
	if invert then
		return a.containername > b.containername
	else
		return a.containername < b.containername
	end
end

function menu.getEmployeeList()
	local employees = {}

	local role, post
	if menu.crewRole ~= "current" then
		local type, id = string.match(menu.personnelData.role, "(.+):(.+)")
		if type == "post" then
			post = id
		elseif type == "role" then
			role = id
		end
	end

	-- give the empire employee list an update to avoid referencing destroyed objects
	local empireemployees = {}
	local numownedships = C.GetNumAllFactionShips("player")
	local allownedships = ffi.new("UniverseID[?]", numownedships)
	numownedships = C.GetAllFactionShips(allownedships, numownedships, "player")
	for i = 0, numownedships - 1 do
		local locship = ConvertStringTo64Bit(tostring(allownedships[i]))
		if (not C.IsUnit(locship)) and (C.IsComponentOperational(locship)) and (not GetMacroData(GetComponentData(locship, "macro"), "islasertower")) then
			local shipname, shipmacro, pilot, isdeployable = GetComponentData(locship, "name", "macro", "assignedaipilot", "isdeployable")
			shipname = shipname .. " (" .. ffi.string(C.GetObjectIDCode(locship)) .. ")"
			local locshipware = GetMacroData(shipmacro, "ware")
			if locshipware and (not isdeployable) and (not C.IsUnit(locship)) then
				if pilot and IsValidComponent(pilot) then
					local name, combinedskill, poststring, postname = GetComponentData(pilot, "name", "combinedskill", "poststring", "postname")
					table.insert(empireemployees, { id = ConvertIDTo64Bit(pilot), type = "entity", name = name, currentskill = combinedskill, roleid = poststring, rolename = postname, container = locship, containername = shipname })
				end
				local numroles = C.GetNumAllRoles()
				local peopletable = ffi.new("PeopleInfo[?]", numroles)
				numroles = C.GetPeople2(peopletable, numroles, locship, true)
				for i = 0, numroles - 1 do
					local roleid = ffi.string(peopletable[i].id)
					local rolename = ffi.string(peopletable[i].name)
					local numtiers = peopletable[i].numtiers
					local tiertable = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers(tiertable, numtiers, locship, peopletable[i].id)
					for j = 0, numtiers - 1 do
						local numpersons = tiertable[j].amount
						local persontable = ffi.new("NPCSeed[?]", numpersons)
						numpersons = C.GetRoleTierNPCs(persontable, numpersons, locship, peopletable[i].id, tiertable[j].skilllevel)
						for k = 0, numpersons - 1 do
							table.insert(empireemployees, { id = persontable[k], type = "person", name = ffi.string(C.GetPersonName(persontable[k], locship)), currentskill = C.GetPersonCombinedSkill(locship, persontable[k], nil, nil), roleid = roleid, rolename = rolename, container = locship, containername = shipname })
						end
					end
				end
			end
		end
	end
	local numownedstations = C.GetNumAllFactionStations("player")
	local allownedstations = ffi.new("UniverseID[?]", numownedstations)
	numownedstations = C.GetAllFactionStations(allownedstations, numownedstations, "player")
	for i = 0, numownedstations - 1 do
		local locstation = ConvertStringTo64Bit(tostring(allownedstations[i]))
		local stationname, manager, shiptrader = GetComponentData(locstation, "name", "tradenpc", "shiptrader")
		stationname = stationname .. " (" .. ffi.string(C.GetObjectIDCode(locstation)) .. ")"
		if manager then
			local name, combinedskill, poststring, postname = GetComponentData(manager, "name", "combinedskill", "poststring", "postname")
			table.insert(empireemployees, { id = ConvertIDTo64Bit(manager), type = "entity", name = name, currentskill = combinedskill, roleid = poststring, rolename = postname, container = locstation, containername = stationname })
		end
		if shiptrader then
			local name, combinedskill, poststring, postname = GetComponentData(shiptrader, "name", "combinedskill", "poststring", "postname")
			table.insert(empireemployees, { id = ConvertIDTo64Bit(shiptrader), type = "entity", name = name, currentskill = combinedskill, roleid = poststring, rolename = postname, container = locstation, containername = stationname })
		end
	end
	menu.empireData.employees = empireemployees

	for _, employeedata in ipairs(menu.empireData.employees) do
		if (menu.personnelData.searchtext == "") or menu.employeeSearchHelper(employeedata, menu.personnelData.searchtext) then
			if menu.personnelData.role == "current" then
				employeedata.skill = employeedata.currentskill
			else
				if employeedata.type == "person" then
					employeedata.skill = C.GetPersonCombinedSkill(employeedata.container, employeedata.id, role, post)
				else
					employeedata.skill = C.GetEntityCombinedSkill(employeedata.id, role, post)
				end
			end
			table.insert(employees, employeedata)
		end
	end

	return employees
end

function menu.employeeSearchHelper(entry, text)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.name), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.containername), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.rolename), text, 1, true) then
		return true
	end

	return false
end

function menu.initEmpireData()
	menu.empireData.name = ffi.string(C.GetPlayerName())
	menu.empireData.factionname = ffi.string(C.GetPlayerFactionName(true))

	local shipworth = 0
	local stationworth = 0
	local inventoryworth = 0
	local cash = GetPlayerMoney()
	local onlineworth = 0
	local numonlineships = 0

	-- NB: personnel here refers to pilots, managers, crew, and marines
	local numhiredpersonnel = 0
	-- NB: totalpersonnelskill and averagepersonnelskill uses skill values to five points max per skill
	local totalpersonnelskill = 0
	local averagepersonnelskill = 0
	local numrelevantskills = 0
	local ships = {}
	local stations = {}
	local employees = {}

	local numownedships = C.GetNumAllFactionShips("player")
	local allownedships = ffi.new("UniverseID[?]", numownedships)
	numownedships = C.GetAllFactionShips(allownedships, numownedships, "player")
	--print("num owned ships: " .. numownedships .. ", all owned ships:")
	for i = 0, numownedships - 1 do
		--print(ffi.string(C.GetComponentName(allownedships[i])))
		local locship = ConvertStringTo64Bit(tostring(allownedships[i]))
		if (not C.IsUnit(locship)) and (not GetMacroData(GetComponentData(locship, "macro"), "islasertower")) then
			local shipname, shipmacro, isonlineobject, pilot, isdeployable = GetComponentData(locship, "name", "macro", "isonlineobject", "assignedaipilot", "isdeployable")
			shipname = shipname .. " (" .. ffi.string(C.GetObjectIDCode(locship)) .. ")"
			local locshipware = GetMacroData(shipmacro, "ware")
			if locshipware and not isdeployable and not C.IsUnit(locship) then
				local locshipworth = GetWareData(locshipware, "avgprice")
				shipworth = shipworth + locshipworth
				table.insert(ships, locship)

				if isonlineobject then
					numonlineships = numonlineships + 1
				end

				if pilot and IsValidComponent(pilot) then
					local name, combinedskill, poststring, postname = GetComponentData(pilot, "name", "combinedskill", "poststring", "postname")
					table.insert(employees, { id = ConvertIDTo64Bit(pilot), type = "entity", name = name, currentskill = combinedskill, roleid = poststring, rolename = postname, container = locship, containername = shipname })
					numhiredpersonnel = numhiredpersonnel + 1
					local skilltable = GetComponentData(pilot, "skills")
					for _, skill in ipairs(skilltable) do
						if skill.relevance > 0 then
							--print("skill: " .. tostring(skill.name) .. ", rel: " .. tostring(skill.relevance))
							totalpersonnelskill = totalpersonnelskill + skill.value
							numrelevantskills = numrelevantskills + 1
						end
					end
				end

				local numroles = C.GetNumAllRoles()
				local peopletable = ffi.new("PeopleInfo[?]", numroles)
				numroles = C.GetPeople2(peopletable, numroles, locship, true)
				for i = 0, numroles-1 do
					numhiredpersonnel = numhiredpersonnel + peopletable[i].amount

					local roleid = ffi.string(peopletable[i].id)
					local rolename = ffi.string(peopletable[i].name)
					local numtiers = peopletable[i].numtiers
					local tiertable = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers(tiertable, numtiers, locship, peopletable[i].id)
					for j = 0, numtiers-1 do
						local numpersons = tiertable[j].amount
						local persontable = ffi.new("NPCSeed[?]", numpersons)
						numpersons = C.GetRoleTierNPCs(persontable, numpersons, locship, peopletable[i].id, tiertable[j].skilllevel)
						for k = 0, numpersons-1 do
							--print("person " .. k)
							table.insert(employees, { id = persontable[k], type = "person", name = ffi.string(C.GetPersonName(persontable[k], locship)), currentskill = C.GetPersonCombinedSkill(locship, persontable[k], nil, nil), roleid = roleid, rolename = rolename, container = locship, containername = shipname })
							local numskills = C.GetNumSkills()
							local skilltable = ffi.new("SkillInfo[?]", numskills)
							numskills = C.GetPersonSkills3(skilltable, numskills, persontable[k], locship)
							for l = 0, numskills - 1 do
								if skilltable[l].relevance > 0 then
									totalpersonnelskill = totalpersonnelskill + skilltable[l].value
									numrelevantskills = numrelevantskills + 1
									--print("adding skill " .. tostring(skilltable[l].value) .. ". new total: " .. tostring(totalpersonnelskill))
								end
							end
						end
					end
				end
			end
		end
	end
	table.sort(ships, function (a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

	local numownedstations = C.GetNumAllFactionStations("player")
	local allownedstations = ffi.new("UniverseID[?]", numownedstations)
	numownedstations = C.GetAllFactionStations(allownedstations, numownedstations, "player")
	local totalstationaccountcash = 0
	for i = 0, numownedstations-1 do
		local locstation = ConvertStringTo64Bit(tostring(allownedstations[i]))
		local stationname, buildstorage, manager, shiptrader = GetComponentData(locstation, "name", "buildstorage", "tradenpc", "shiptrader")
		stationname = stationname .. " (" .. ffi.string(C.GetObjectIDCode(locstation)) .. ")"
		if C.IsComponentClass(locstation, "container") then
			totalstationaccountcash = totalstationaccountcash + (GetAccountData(locstation, "money") or 0)
		end
		table.insert(stations, locstation)

		if buildstorage then
			totalstationaccountcash = totalstationaccountcash + (GetAccountData(buildstorage, "money") or 0)
		end

		local numstationmodules = C.GetNumStationModules(allownedstations[i], false, false)
		local allstationmodules = ffi.new("UniverseID[?]", numstationmodules)
		numstationmodules = C.GetStationModules(allstationmodules, numstationmodules, allownedstations[i], false, false)
		for j = 0, numstationmodules-1 do
			local macro = GetComponentData(ConvertStringTo64Bit(tostring(allstationmodules[j])), "macro")
			local ware = GetMacroData(macro, "ware")
			if ware then
				stationworth = stationworth + GetWareData(ware, "avgprice")
			end
		end

		if manager then
			local name, combinedskill, poststring, postname = GetComponentData(manager, "name", "combinedskill", "poststring", "postname")
			table.insert(employees, { id = ConvertIDTo64Bit(manager), type = "entity", name = name, currentskill = combinedskill, roleid = poststring, rolename = postname, container = locstation, containername = stationname })
			numhiredpersonnel = numhiredpersonnel + 1
			local skilltable = GetComponentData(manager, "skills")
			for _, skill in ipairs(skilltable) do
				if skill.relevance > 0 then
					--print("skill: " .. tostring(skill.name) .. ", rel: " .. tostring(skill.relevance))
					totalpersonnelskill = totalpersonnelskill + skill.value
					numrelevantskills = numrelevantskills + 1
				end
			end
		end
		if shiptrader then
			local name, combinedskill, poststring, postname = GetComponentData(shiptrader, "name", "combinedskill", "poststring", "postname")
			table.insert(employees, { id = ConvertIDTo64Bit(shiptrader), type = "entity", name = name, currentskill = combinedskill, roleid = poststring, rolename = postname, container = locstation, containername = stationname })
			numhiredpersonnel = numhiredpersonnel + 1
			local skilltable = GetComponentData(shiptrader, "skills")
			for _, skill in ipairs(skilltable) do
				if skill.relevance > 0 then
					--print("skill: " .. tostring(skill.name) .. ", rel: " .. tostring(skill.relevance))
					totalpersonnelskill = totalpersonnelskill + skill.value
					numrelevantskills = numrelevantskills + 1
				end
			end
		end
	end
	table.sort(stations, function (a, b) return GetComponentData(a, "name") < GetComponentData(b, "name") end)

	if numrelevantskills > 0 then
		averagepersonnelskill = math.floor(totalpersonnelskill / numrelevantskills)
		--print("average skill: " .. tostring(averagepersonnelskill) .. ", total skill: " .. tostring(totalpersonnelskill) .. ", num skills: " .. tostring(numrelevantskills) .. ", num personnel: " .. tostring(numhiredpersonnel))
	end

	local onlineitems = OnlineGetUserItems()

	local numinventoryitems = 0
	-- { [ware1] = { name = "", amount = 0, price = 0 }, [ware2] = {} }
	local playerinventory = GetPlayerInventory()
	for item, itemdata in pairs(playerinventory) do
		local isequipment = GetWareData(item, "isequipment")
		if (not isequipment) and (not onlineitems[item]) then
			numinventoryitems = numinventoryitems + 1
			inventoryworth = inventoryworth + itemdata.amount * itemdata.price
		end
	end

	local numplayerpolicesectors = 0
	local clusters = GetClusters(true)
	for _, cluster in ipairs(clusters) do
		local sectors = GetSectors(cluster)
		for _, sector in ipairs(sectors) do
			if GetComponentData(sector, "isplayerowned") then
				numplayerpolicesectors = numplayerpolicesectors + 1
			end
		end
	end

	menu.empireData.networth = shipworth + stationworth + totalstationaccountcash + inventoryworth + cash

	menu.empireData.shipworth = shipworth
	menu.empireData.stationworth = stationworth
	menu.empireData.totalstationaccountcash = totalstationaccountcash
	menu.empireData.inventoryworth = inventoryworth
	menu.empireData.cash = cash

	menu.empireData.numownedships = numownedships
	menu.empireData.numownedstations = numownedstations

	menu.empireData.ships = ships
	menu.empireData.stations = stations
	menu.empireData.employees = employees

	menu.empireData.numonlineships = numonlineships

	menu.empireData.numhiredpersonnel = numhiredpersonnel
	menu.empireData.totalpersonnelskill = totalpersonnelskill
	menu.empireData.averagepersonnelskill = averagepersonnelskill

	menu.empireData.numinventoryitems = numinventoryitems

	menu.empireData.numplayerpolicesectors = numplayerpolicesectors

	menu.empireData.initialized = true
end

function menu.createEmpire(frame, tableProperties)
	--print("menu.createEmpire")
	if not menu.empireData.initialized or menu.empireData.init then
		menu.initEmpireData()
		menu.empireData.init = nil
	end

	if not menu.empireData.mode then
		menu.empireData.mode = {"empire", "name"}
	end

	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize

	-- 4 tables: left, center, topright, bottomright
	-- left: static numrows. selecting rows changes content of center.
	local numCols = (menu.mode == "empire") and 3 or 4
	local table_left = frame:addTable(numCols, { tabOrder = 1, borderEnabled = true, width = narrowtablewidth, x = tableProperties.x, y = tableProperties.y })
	table_left:setColWidth(numCols, Helper.scaleY(config.rowHeight), false)
	table_left:setDefaultBackgroundColSpan(1, numCols)

	local tabOrderOffset = 1
	local properties_table_center = { tabOrder = 2, borderEnabled = true, width = tableProperties.width - (table_left.properties.width * 2) - (Helper.borderSize * 2), x = tableProperties.x + table_left.properties.width + Helper.borderSize, y = tableProperties.y }
	local table_center, table_topright, table_bottomright
	if menu.empireData.mode[1] ~= "empire_call" then
		-- center: content depends on left selection.
		table_center = frame:addTable(5, properties_table_center)
		tabOrderOffset = tabOrderOffset + 1
	end

	-- topright: rendertarget, depends on selection in center.
	local properties_table_topright = { width = narrowtablewidth, x = tableProperties.x + table_left.properties.width + properties_table_center.width + (2 * Helper.borderSize), height = tableProperties.height / 2, y = tableProperties.y }

	-- bottomright: description, depends on selection in center.
	table_bottomright = frame:addTable(1, { tabOrder = 0, borderEnabled = true, width = narrowtablewidth, x = tableProperties.x + table_left.properties.width + properties_table_center.width + (2 * Helper.borderSize), height = tableProperties.height / 2, y = tableProperties.y + properties_table_topright.height })

	--print("widths. left: " .. table_left.properties.width .. ", center: " .. properties_table_center.width .. ", right: " .. properties_table_topright.width)

	if menu.setdefaulttable then
		table_left.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end

	if menu.mode == "empire" then
		-- Empire Overview
		local row = table_left:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 9100), Helper.titleTextProperties)	-- Empire Overview

		-- global properties
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 9101), Helper.headerRowCenteredProperties)	-- Global Properties

		row = table_left:addRow({"empire", "name"}, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 9102))	-- Player Name
		row[2]:setColSpan(2):createEditBox({ description = ReadText(1001, 9102) }):setText(menu.empireData.name)
		row[2].handlers.onEditBoxDeactivated = menu.editboxChangePlayerName

		row = table_left:addRow({"empire", "name"}, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 11006))	-- Player Name
		row[2]:setColSpan(2):createEditBox({ description = ReadText(1001, 11006) }):setText(menu.empireData.factionname)
		row[2].handlers.onEditBoxDeactivated = menu.editboxChangePlayerFactionName

		row = table_left:addRow({"empire_grid", "logo"}, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 9103))	-- Player Logo
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight })

		if #menu.empireData.ships > 0 then
			row = table_left:addRow({"empire_grid", "painttheme"}, { bgColor = Helper.color.transparent })
		else
			row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		end
		row[1]:setColSpan(2):createText(ReadText(1001, 9104))	-- Default Ship Skin
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight })

		-- TODO: reenable when we get clothing themes
		--[[
		if (C.GetNumAvailableClothingThemes() > 0) then
			if #menu.empireData.employees > 0 then
				row = table_left:addRow({"empire_grid", "uniform"}, { bgColor = Helper.color.transparent })
			else
				row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
			end
			row[1]:setColSpan(2):createText(ReadText(1001, 9105))	-- Default Uniform
			row[3]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		]]

		-- player wealth
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 9106), Helper.headerRowCenteredProperties)	-- Player Wealth

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		--row = table_left:addRow({"empire_call", "networth"}, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 9107))	-- Player net worth
		-- string = ConvertMoneyString(money [, showcents [, separators [, accuracy [, notrailingspaces [, colorprefix]]]]])
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.networth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		row[1]:createText(ReadText(1001, 9108), { x = Helper.standardIndentStep })	-- Total value of ships
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.shipworth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		row[1]:createText(ReadText(1001, 9109), { x = Helper.standardIndentStep })	-- Total value of stations
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.stationworth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		row[1]:createText(ReadText(1001, 2202), { x = Helper.standardIndentStep })	-- Inventory
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.inventoryworth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		--row = table_left:addRow({"empire_call", "cash"}, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 9110), { x = Helper.standardIndentStep })	-- Available cash
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.cash, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		row[1]:createText(ReadText(1001, 9111), { x = Helper.standardIndentStep })	-- Total cash in station accounts
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.totalstationaccountcash, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		-- personnel
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 9400), Helper.headerRowCenteredProperties)	-- Personnel

		row = table_left:addRow(nil, { bgColor = Helper.color.darkgrey })
		row[1]:createText(ReadText(1001, 9113))	-- Number of hired personnel
		row[2]:setColSpan(2):createText((ConvertIntegerString(menu.empireData.numhiredpersonnel, true)), { halign = "right" })

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		row[1]:createText(ReadText(1001, 9114))	-- Average personnel skill
		row[2]:setColSpan(2):createText(Helper.displaySkill(menu.empireData.averagepersonnelskill), { color = Helper.color.brightyellow, halign = "right" })

		row = table_left:addRow(nil, { bgColor = Helper.color.unselectable })
		row[1]:createText(ReadText(1001, 9115))	-- Total personnel skill
		row[2]:setColSpan(2):createText((ConvertIntegerString(menu.empireData.totalpersonnelskill, true)), { halign = "right" })

		-- online items
		--[[
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1041, 10141), Helper.headerRowCenteredProperties)	-- Online items

		row = table_left:addRow({"empire_list", "onlineitems"}, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 9122))	-- Venture Ships
		row[2]:createText((ConvertIntegerString(menu.empireData.numonlineships, true)), { halign = "right" })
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight }) --]]

		-- sector ownership
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 9180), Helper.headerRowCenteredProperties)	-- Government

		row = table_left:addRow({"empire_list", "sectorownership"}, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 9601))	-- Police Authority
		row[2]:createText((ConvertIntegerString(menu.empireData.numplayerpolicesectors, true)), { halign = "right" })
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight })
	else
		local row = table_left:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(4):createText(ReadText(1001, 9171), Helper.titleTextProperties)

		row = table_left:addRow({ "empire_list", "standingorders" }, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(ReadText(1001, 9301))	-- Global standing orders

		-- trade rules
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(4):createText(ReadText(1001, 11010), Helper.headerRowCenteredProperties)	-- Trade Rules

		menu.traderules = {}
		Helper.ffiVLA(menu.traderules, "TradeRuleID", C.GetNumAllTradeRules, C.GetAllTradeRules)
		for i = #menu.traderules, 1, -1 do
			local id = menu.traderules[i]

			local counts = C.GetTradeRuleInfoCounts(id)
			local buf = ffi.new("TradeRuleInfo")
			buf.numfactions = counts.numfactions
			buf.factions = Helper.ffiNewHelper("const char*[?]", counts.numfactions)
			if C.GetTradeRuleInfo(buf, id) then
				local factions = {}
				for j = 0, buf.numfactions - 1 do
					table.insert(factions, ffi.string(buf.factions[j]))
				end

				local defaults = {
					["trade"] = C.IsPlayerTradeRuleDefault(id, "buy") and C.IsPlayerTradeRuleDefault(id, "sell"),
					["supply"] = C.IsPlayerTradeRuleDefault(id, "supply"),
					["build"] = C.IsPlayerTradeRuleDefault(id, "build"),
				}

				menu.traderules[i] = { id = id, name = ffi.string(buf.name), factions = factions, iswhitelist = buf.iswhitelist, defaults = defaults }
			else
				table.remove(menu.traderules, i)
			end
		end
		table.sort(menu.traderules, Helper.sortID)

		for _, entry in ipairs(menu.traderules) do
			row = table_left:addRow({ "empire_list", "traderule", entry }, { bgColor = Helper.color.transparent })
			row[1]:createText(entry.name)
			local defaulttext = ""
			--print(entry.defaults.trade .. ", " .. entry.defaults.supply .. ", " .. entry.defaults.build)
			if entry.defaults.trade and entry.defaults.supply and entry.defaults.build then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11023) .. "]"
			else
				if entry.defaults.trade then
					if defaulttext == "" then
						defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " "
					else
						defaulttext = defaulttext .. ", "
					end
					defaulttext = defaulttext .. ReadText(1001, 11017)
				end
				if entry.defaults.supply then
					if defaulttext == "" then
						defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " "
					else
						defaulttext = defaulttext .. ", "
					end
					defaulttext = defaulttext .. ReadText(1001, 11018)
				end
				if entry.defaults.build then
					if defaulttext == "" then
						defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " "
					else
						defaulttext = defaulttext .. ", "
					end
					defaulttext = defaulttext .. ReadText(1001, 11019)
				end
				if defaulttext ~= "" then
					defaulttext = defaulttext .. "]"
				end
			end
			row[2]:setColSpan(2):createText(defaulttext, { halign = "right" })
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end

		row = table_left:addRow({ "empire_list", "traderule", {} }, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 11011))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })

		-- blacklists
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(4):createText(ReadText(1001, 9143), Helper.headerRowCenteredProperties)	-- Blacklist

		menu.blacklists = Helper.getBlackLists()

		for _, entry in ipairs(menu.blacklists) do
			row = table_left:addRow({ "empire_list", "blacklist", entry }, { bgColor = Helper.color.transparent })
			row[1]:createText(entry.name)
			local text = ""
			for _, option in ipairs(config.blacklistTypes) do
				if option.id == entry.type then
					text = option.shorttext
					break
				end
			end
			row[2]:createText(text)
			local defaulttext = ""
			if entry.defaults.civilian and entry.defaults.military then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 9175) .. "]"
			elseif entry.defaults.civilian then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 9173) .. "]"
			elseif entry.defaults.military then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 9174) .. "]"
			end
			row[3]:createText(defaulttext, { halign = "right" })
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		row = table_left:addRow({ "empire_list", "blacklist", {} }, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 9144))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })

		-- Fire authorization
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(4):createText(ReadText(1001, 7753), Helper.headerRowCenteredProperties)

		menu.fightrules = Helper.getFightRules()

		for _, entry in ipairs(menu.fightrules) do
			row = table_left:addRow({ "empire_list", "fightrule", entry }, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(entry.name)
			local defaulttext = ""
			if entry.defaults.attack then
				defaulttext = "[" .. ReadText(1001, 9172) .. "]"
			end
			row[3]:createText(defaulttext, { halign = "right" })
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		row = table_left:addRow({ "empire_list", "fightrule", {} }, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 7754))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })

		-- player alerts
		row = table_left:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(4):createText(ReadText(1001, 9183), Helper.headerRowCenteredProperties)	-- Alerts

		menu.playeralerts = {}
		local n = C.GetNumPlayerAlerts()
		local counts = ffi.new("PlayerAlertCounts[?]", n)
		n = C.GetPlayerAlertCounts(counts, n)
		local buf = ffi.new("PlayerAlertInfo2[?]", n)
		for i = 0, n - 1 do
			buf[i].numspaces = counts[i].numspaces
			buf[i].spaceids = Helper.ffiNewHelper("UniverseID[?]", counts[i].numspaces)
		end
		n = C.GetPlayerAlerts2(buf, n)
		for i = 0, n - 1 do
			local entry = {}

			entry.index				= buf[i].index
			entry.interval			= buf[i].interval
			entry.repeats			= buf[i].repeats
			entry.muted				= buf[i].muted
			entry.spaces = {}
			for j = 0, buf[i].numspaces - 1 do
				table.insert(entry.spaces, ConvertStringTo64Bit(tostring(buf[i].spaceids[j])))
			end
			entry.objectclasses		= {}
			for class in string.gmatch(ffi.string(buf[i].objectclass), "[%a_]+") do
				table.insert(entry.objectclasses, class)
			end
			table.sort(entry.objectclasses, menu.sortClasses)
			entry.objectpurpose		= ffi.string(buf[i].objectpurpose)
			entry.objectidcode		= ffi.string(buf[i].objectidcode)
			entry.objectowners		= {}
			for faction in string.gmatch(ffi.string(buf[i].objectowner), "[%a_]+") do
				table.insert(entry.objectowners, faction)
			end
			table.sort(entry.objectowners, Helper.sortFactionName)
			entry.name				= ffi.string(buf[i].name)
			entry.message			= ffi.string(buf[i].message)
			entry.soundid			= ffi.string(buf[i].soundid)

			table.insert(menu.playeralerts, entry)
		end
		Helper.ffiClearNewHelper()

		for _, entry in ipairs(menu.playeralerts) do
			row = table_left:addRow({ "empire_list", "playeralert", entry }, { bgColor = Helper.color.transparent })
			row[1]:createText(entry.name)
			local height = Helper.scaleY(config.rowHeight)
			row[3]:createButton({ height = height, width = height, x = row[3]:getWidth() - height, scaling = false }):setIcon(entry.muted and "menu_sound_off" or "menu_sound_on", { color = entry.muted and Helper.color.white or Helper.color.white })
			row[3].handlers.onClick = function () if entry.muted then C.UnmutePlayerAlert(entry.index, false) else C.MutePlayerAlert(entry.index) end menu.refreshInfoFrame() end
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		row = table_left:addRow({ "empire_list", "playeralert", {} }, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 9184))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
	end

	if menu.setselectedrow then
		table_left:setSelectedRow(menu.setselectedrow)
		menu.setselectedrow = nil
		if menu.settoprow then
			table_left:setTopRow(menu.settoprow)
			menu.settoprow = nil
		end
	end

	local table_called, table_called2 = menu.setupEmpireRows(menu.empireData.mode, properties_table_center, tabOrderOffset, table_center)

	if table_center then
		-- table_center is nil if menu.empireData.mode[1] == "empire_call"
		table_center:setTopRow(GetTopRow(menu.buttonTable))
		if menu.setselectedrow2 then
			local numvisiblerows = math.floor(tableProperties.height / (table_center.properties.width / 5 + Helper.borderSize) - 1)
			--print("numvisiblerows: " .. tostring(numvisiblerows) .. ", total height: " .. tostring(tableProperties.height) .. ", row height: " .. tostring(table_center.properties.width / 5 + Helper.borderSize))
			--print("set row: " .. tostring(menu.setselectedrow2))
			table_center:setSelectedRow(menu.setselectedrow2)
			if menu.setselectedrow2 > numvisiblerows then
				--print("setting top row to: " .. tostring(menu.setselectedrow2 - numvisiblerows + 2))
				table_center:setTopRow(menu.setselectedrow2 - numvisiblerows + 2)
			end
			menu.setselectedrow2 = nil
			if menu.setselectedcol2 then
				--print("set col: " .. tostring(menu.setselectedcol2))
				table_center:setSelectedCol(menu.setselectedcol2)
				menu.setselectedcol2 = nil
			end
		end

		table_left:addConnection(1, 2, true)
		table_center:addConnection(1, 3, true)
	elseif table_called then
		table_left:addConnection(1, 2, true)
		table_called:addConnection(1, 3, true)
		if table_called2 then
			table_called:addConnection(2, 3)
		end
	end

	if menu.empireData.selectedobject then
		-- menu.setupEmpireRenderTarget called from menu.onUpdate
		--print("menu.setupEmpireRenderTarget. object: " .. ffi.string(C.GetComponentName(menu.empireData.selectedobject)))
		menu.activatecutscene = true
		menu.rendertarget = frame:addRenderTarget(properties_table_topright)
	end

	menu.setupEmpireDescription(table_bottomright)
end

function menu.setupEmpireDescription(table_bottomright)
	--print("menu.setupEmpireDescription. object: " .. tostring(menu.empireData.selectedobject))

	-- Description
	local row = table_bottomright:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:createText(ReadText(1001, 2404), Helper.titleTextProperties)	-- Description

	if menu.empireData.mode then
		local descrtext = ""

		if (menu.empireData.mode[2] == "logo") then
			descrtext = ReadText(1001, 9140)		-- Select a logo to be applied to all of your ships.\n\nTo add your own logo, insert an image file to your logos folder. Files in any of the following formats are supported: .bmp, .dds, .gif, .jpg, .png, .tga
		elseif (menu.empireData.mode[2] == "painttheme") then
			descrtext = ReadText(1001, 9141)		-- Select a ship skin to be applied to all of your ships.
		elseif (menu.empireData.mode[2] == "uniform") then
			descrtext = ReadText(1001, 9142)		-- Select a uniform to be used by all of your employees.
		elseif menu.empireData.selectedobject and menu.rendertarget then
			if (menu.empireData.objecttype ~= "ware") then
				descrtext = GetComponentData(menu.empireData.selectedobject, "description")
			else
				descrtext = GetWareData(menu.empireData.selectedobject, "description")
			end
			--print("menu.setupEmpireDescription. object: " .. ffi.string(C.GetComponentName(menu.empireData.selectedobject)))
		elseif menu.empireData.mode[2] == "traderule" then
			descrtext = ReadText(1001, 11012)
		elseif menu.empireData.mode[2] == "blacklist" then
			descrtext = ReadText(1001, 9158)
		elseif menu.empireData.mode[2] == "fightrule" then
			descrtext = ReadText(1001, 7755)
		elseif menu.empireData.mode[2] == "playeralert" then
			descrtext = ReadText(1001, 9185)
		elseif menu.empireData.mode[2] == "sectorownership" then
			descrtext = ReadText(1001, 9182)
		end

		row = table_bottomright:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(tostring(descrtext), { wordwrap = true })
	end
end

function menu.cleanupCutsceneRenderTarget()
	if menu.cutsceneid then
		--print("stopping cutscene " .. tostring(menu.cutsceneid))
		StopCutscene(menu.cutsceneid)
	end
	if menu.cutscenedesc then
		--print("releasing cutscene descriptor " .. tostring(menu.cutscenedesc))
		ReleaseCutsceneDescriptor(menu.cutscenedesc)
	end
	if menu.precluster then
		--print("destroying cluster " .. tostring(menu.precluster))
		DestroyPresentationCluster(menu.precluster)
	end
	menu.precluster = nil
	menu.preobject = nil
	menu.personnelData.renderobject = nil
	menu.cutscenedesc = nil
	menu.cutsceneid = nil
	menu.currentrenderobject = nil
end

function menu.setupEmpireRenderTarget()
	--print("menu.setupEmpireRenderTarget. object: " .. tostring(menu.empireData.selectedobject))
	local renderobject = "encyclopedia_dummy_macro"
	local mode = nil
	if menu.empireData.selectedobject then
		if (menu.empireData.objecttype ~= "ware") and menu.empireCanShowObject(menu.empireData.selectedobject) then
			renderobject = menu.empireData.selectedobject
			mode = "object"
			if C.IsComponentClass(renderobject, "npc") then
				mode = "npc"
			end
		elseif (menu.empireData.objecttype == "ware") then
			local video = GetWareData(menu.empireData.selectedobject, "video")
			if video and (video ~= "") then
				renderobject = video
			end
			mode = "ware"
		end
	end
	--print("mode: " .. tostring(mode) .. ", renderobject: " .. tostring(renderobject))

	if not menu.currentrenderobject or not renderobject or (menu.currentrenderobject ~= renderobject) then
		if menu.cutsceneid then
			--print("calling menu.cleanupCutsceneRenderTarget")
			menu.cleanupCutsceneRenderTarget()
			return false
		end

		local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
		--print("rendertarget id: " .. tostring(menu.rendertarget.id) .. ", rendertarget texture: " .. tostring(rendertargetTexture))
		if rendertargetTexture then
			menu.currentrenderobject = renderobject
			if (mode == "object") then
				menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitelySlow", {targetobject = renderobject})
			elseif (mode == "npc") then
				menu.cutscenedesc = CreateCutsceneDescriptor("ShowCharacter", {npcref = renderobject})
			elseif not mode or (mode == "ware") then
				menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
				if menu.preobject then
					menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitely", {targetobject = menu.preobject})
				end
			end

			if menu.cutscenedesc then
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
				--print("started cutscene")
			end
		end
	end
	return true
end

function menu.setupMessageRenderTarget()
	if menu.cutsceneid then
		menu.cleanupCutsceneRenderTarget()
		return false
	end
	local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
	if rendertargetTexture then
		local cutscenekey = menu.messageData.curEntry.cutscenekey
		local cutsceneparameter = GetMessageCutsceneParameter(ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)), menu.messageData.curEntry.category)

		local refobjects
		if cutscenekey == "OrbitIndefinitely" then
			refobjects = { targetobject = cutsceneparameter }
		end

		menu.cutscenedesc = CreateCutsceneDescriptor(cutscenekey, refobjects)
		if menu.cutscenedesc then
			menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
		end
	end
	return true
end

function menu.setupInventoryRenderTarget()
	if menu.cutsceneid then
		menu.cleanupCutsceneRenderTarget()
		return false
	end
	local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
	if rendertargetTexture then
		local renderobject = "encyclopedia_dummy_macro"
		local video = GetWareData(menu.inventoryData.curEntry[1], "video")
		if video and (video ~= "") then
			renderobject = video
		end
		menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
		if menu.preobject then
			menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitely", { targetobject = menu.preobject })
			if menu.cutscenedesc then
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
			end
		end
	end
	return true
end

function menu.setupPersonnelRenderTarget()
	if menu.cutsceneid then
		menu.cleanupCutsceneRenderTarget()
		return false
	end
	if menu.personnelData.curEntry.type == "entity" then
		local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
		if rendertargetTexture then
			menu.personnelData.renderobject = menu.personnelData.curEntry.id
			menu.cutscenedesc = CreateCutsceneDescriptor("ShowCharacter", { npcref = menu.personnelData.renderobject })
			if menu.cutscenedesc then
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
			end
		end
	end
	return true
end

function menu.setupEmpireRows(mode, properties_table_center, tabOrderOffset, table_center)
	local locmode = nil
	if type(mode) == "table" then
		locmode = mode[2]
	else
		DebugError("menu.setupEmpireRows called with invalid mode: " .. tostring(mode))
		return
	end

	if mode[1] == "empire_grid" then
		local buttonheight = table_center.properties.width / 5
		local rowcounter = 0
		local headertext = ""
		local nonetext = ""
		table_center.properties.highlightMode = "column"

		if locmode == "logo" then
			local logooptiondata = { {{}, ReadText(1001, 9126)}, {{}, ReadText(1001, 9127)} }	-- Standard Logos, Custom Logos
			headertext = ReadText(1001, 9125)		-- Logo Selection
			local buf = C.GetCurrentPlayerLogo()
			menu.empireData.currentlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }

			local numlogos = C.GetNumPlayerLogos(true, false)
			local logos = ffi.new("UILogo[?]", numlogos)
			numlogos = C.GetPlayerLogos(logos, numlogos, true, false)
			for i = 0, numlogos-1 do
				--print("inserting logo: " .. ffi.string(logos[i].file))
				table.insert(logooptiondata[1][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
			end
			--print("num standard logos: " .. tostring(numlogos))

			numlogos = C.GetNumPlayerLogos(false, true)
			logos = ffi.new("UILogo[?]", numlogos)
			numlogos = C.GetPlayerLogos(logos, numlogos, false, true)
			for i = 0, numlogos-1 do
				--print("inserting logo: " .. ffi.string(logos[i].file))
				table.insert(logooptiondata[2][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
			end

			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(headertext, Helper.titleTextProperties)

			for _, logodata in ipairs(logooptiondata) do
				row = table_center:addRow(nil, { bgColor = Helper.defaultHeaderBackgroundColor })
				row[1]:setColSpan(5):createText(logodata[2], Helper.headerRowCenteredProperties)

				local rowbuttoncounter = 6
				if #logodata[1] > 0 then
					for i, logo in ipairs(logodata[1]) do
						if rowbuttoncounter == 6 then
							rowbuttoncounter = 1
							rowcounter = rowcounter + 1
							row = table_center:addRow(("empire_standardlogoselect_" .. rowcounter), { bgColor = Helper.color.transparent })
						end

						-- NB: icon more reliable than file name for comparison because file extensions vary.
						if logo.icon == menu.empireData.currentlogo.icon and logo.ispersonal == menu.empireData.currentlogo.ispersonal then
							--print("current logo found: " .. tostring(logo) .. ". row: " .. tostring(rowcounter) .. ", column: " .. tostring(rowbuttoncounter))
							menu.setselectedrow2 = row.index
							menu.setselectedcol2 = rowbuttoncounter
						end

						--print("adding button " .. tostring(rowbuttoncounter) .. " in row " .. tostring(rowcounter) .. " with icon: " .. tostring(logo.icon))
						local locrow = row.index
						local loccol = rowbuttoncounter
						row[rowbuttoncounter]:createButton({ height = buttonheight, scaling = false }):setIcon(logo.icon):setIcon2(function() return menu.logoButtonIcon2(logo) end, { color = function() return menu.logoButtonIcon2Color(logo) end })
						row[rowbuttoncounter].handlers.onClick = function() return menu.buttonSetPlayerLogo(logo, locrow, loccol) end

						rowbuttoncounter = rowbuttoncounter + 1
					end
				else
					row = table_center:addRow("empire_standardlogoselect_none", { bgColor = Helper.color.transparent })
					row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 9132) .. " ---")
				end
			end
		else
			local currentthemeid = ""
			local themeoptions = {}

			if locmode == "painttheme" then
				headertext = ReadText(1001, 9119)	-- Ship Skin Selection
				nonetext = ReadText(1001, 9130)		-- (Paint Theme)None
				currentthemeid = ffi.string(C.GetPlayerPaintTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numpaintthemes = C.GetNumAvailablePaintThemes()
				local paintthemes = ffi.new("UIPaintTheme[?]", numpaintthemes)
				numpaintthemes = C.GetAvailablePaintThemes(paintthemes, numpaintthemes)
				for i = 0, numpaintthemes - 1 do
					local icon = ffi.string(paintthemes[i].Icon)
					table.insert(themeoptions, { id = ffi.string(paintthemes[i].ID), text = ffi.string(paintthemes[i].Name), icon = ffi.string(paintthemes[i].Icon) })
					--print("id: " .. tostring(ffi.string(paintthemes[i].ID)) .. ", name: " .. tostring(ffi.string(paintthemes[i].Name)) .. ", icon: " .. tostring(ffi.string(paintthemes[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			elseif locmode == "uniform" then
				headertext = ReadText(1001, 9120)	-- Uniform Selection
				nonetext = ReadText(1001, 9131)		-- (Uniform)None
				currentthemeid = ffi.string(C.GetPlayerClothingTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numuniforms = C.GetNumAvailableClothingThemes()
				local uniforms = ffi.new("UIClothingTheme[?]", numuniforms)
				numuniforms = C.GetAvailableClothingThemes(uniforms, numuniforms)
				for i = 0, numuniforms - 1 do
					table.insert(themeoptions, { id = ffi.string(uniforms[i].ID), text = ffi.string(uniforms[i].Name), icon = "" })
					--print("id: " .. tostring(ffi.string(uniforms[i].ID)) .. ", name: " .. tostring(ffi.string(uniforms[i].Name)) .. ", icon: " .. tostring(ffi.string(uniforms[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			end

			table.sort(themeoptions, function (a, b) return a.text < b.text end)
			if locmode == "uniform" then
				table.insert(themeoptions, { id = "", text = nonetext, icon = "" })
			end

			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(headertext, Helper.titleTextProperties)

			local rowbuttoncounter = 6
			for i, theme in ipairs(themeoptions) do

				if rowbuttoncounter == 6 then
					rowbuttoncounter = 1
					rowcounter = rowcounter + 1
					row = table_center:addRow(("empire_themeselect_" .. rowcounter), { bgColor = Helper.color.transparent })
				end

				local icon2
				if theme.id == currentthemeid then
					--print("current theme found: " .. tostring(theme.id) .. ". row: " .. tostring(rowcounter) .. ", column: " .. tostring(rowbuttoncounter))
					table_center:setSelectedRow(row.index)
					table_center:setSelectedCol(rowbuttoncounter)
					icon2 = "be_upgrade_installed"
				end

				--print("adding button " .. tostring(rowbuttoncounter) .. " in row " .. tostring(rowcounter))
				local locrow = row.index
				local loccol = rowbuttoncounter
				local button = row[rowbuttoncounter]:createButton({ height = buttonheight, scaling = false, mouseOverText = theme.text })
				if theme.icon ~= "" then
					button:setIcon(theme.icon)
				end
				if icon2 then
					button:setIcon2(icon2)
				end
				row[rowbuttoncounter].handlers.onClick = function() return menu.buttonSetDefaultTheme(locmode, theme.id, locrow, loccol) end

				rowbuttoncounter = rowbuttoncounter + 1
			end
		end
	elseif mode[1] == "empire_list" then
		if (locmode == "painttheme") or (locmode == "uniform") then
			local currentthemeid = ""
			local headertext = ""
			local nonetext = ""
			local themeoptions = {}

			if (locmode == "painttheme") then
				headertext = ReadText(1001, 9119)	-- Ship Skin Selection
				nonetext = ReadText(1001, 9130)		-- (Paint Theme)None
				currentthemeid = ffi.string(C.GetPlayerPaintTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numpaintthemes = C.GetNumAvailablePaintThemes()
				local paintthemes = ffi.new("UIPaintTheme[?]", numpaintthemes)
				numpaintthemes = C.GetAvailablePaintThemes(paintthemes, numpaintthemes)
				for i = 0, numpaintthemes-1 do
					--table.insert(themeoptions, { id = ffi.string(paintthemes[i].ID), text = ffi.string(paintthemes[i].Name), icon = ffi.string(paintthemes[i].Icon) })
					table.insert(themeoptions, { id = ffi.string(paintthemes[i].ID), text = ffi.string(paintthemes[i].Name), icon = "" })
					--print("id: " .. tostring(ffi.string(paintthemes[i].ID)) .. ", name: " .. tostring(ffi.string(paintthemes[i].Name)) .. ", icon: " .. tostring(ffi.string(paintthemes[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			elseif (locmode == "uniform") then
				headertext = ReadText(1001, 9120)	-- Uniform Selection
				nonetext = ReadText(1001, 9131)		-- (Uniform)None
				currentthemeid = ffi.string(C.GetPlayerClothingTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numuniforms = C.GetNumAvailableClothingThemes()
				local uniforms = ffi.new("UIClothingTheme[?]", numuniforms)
				numuniforms = C.GetAvailableClothingThemes(uniforms, numuniforms)
				for i = 0, numuniforms-1 do
					--table.insert(themeoptions, { id = ffi.string(uniforms[i].ID), text = ffi.string(uniforms[i].Name), icon = ffi.string(uniforms[i].Icon) })
					table.insert(themeoptions, { id = ffi.string(uniforms[i].ID), text = ffi.string(uniforms[i].Name), icon = "" })
					--print("id: " .. tostring(ffi.string(uniforms[i].ID)) .. ", name: " .. tostring(ffi.string(uniforms[i].Name)) .. ", icon: " .. tostring(ffi.string(uniforms[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			end

			table.sort(themeoptions, function (a, b) return a.text < b.text end)
			table.insert(themeoptions, { id = "", text = nonetext, icon = "" })

			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(headertext, Helper.titleTextProperties)

			for i, theme in ipairs(themeoptions) do
				--print("adding " .. tostring(locmode) .. " theme: " .. tostring(theme.id))
				row = table_center:addRow({locmode, theme.id}, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(5):createText(theme.text)

				--print("current theme: " .. tostring(currentthemeid) .. ", this theme: " .. tostring(theme.id))
				if theme.id == currentthemeid then
					menu.setselectedrow2 = row.index
				end
			end
		elseif locmode == "ships" then
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 6), Helper.titleTextProperties)	-- Ships

			row = table_center:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 2809))	-- Name
			row[4]:createText(ReadText(1001, 9051))	-- Ship Type
			row[5]:createText(ReadText(1001, 2943))	-- Location
			for i, ship in ipairs(menu.empireData.ships) do
				local name, shiptype, location = GetComponentData(ship, "name", "shiptypename", "sector")
				if GetComponentData(ship, "isonlineobject") then
					location = ReadText(1001, 9121)	-- On venture
				end
				row = table_center:addRow({"empire_ship", ship}, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(name)
				row[4]:createText(shiptype)
				row[5]:createText(location)
			end
		elseif locmode == "stations" then
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 4), Helper.titleTextProperties)	-- Stations

			row = table_center:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 2809))	-- Name
			row[5]:createText(ReadText(1001, 2943))	-- Location

			for i, station in ipairs(menu.empireData.stations) do
				local name, sector = GetComponentData(station, "name", "sector")
				row = table_center:addRow({"empire_station", station}, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(4):createText(name)
				row[5]:createText(sector)
			end
		elseif locmode == "standingorders" then
			table_center:setColWidth(1, Helper.standardTextHeight)

			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 9301), Helper.titleTextProperties)	-- Global Standing Orders

			local faction = "player"
			menu.signals = {}
			local numsignals = C.GetNumAllSignals()
			local allsignals = ffi.new("SignalInfo[?]", numsignals)
			numsignals = C.GetAllSignals(allsignals, numsignals)
			for i = 0, numsignals - 1 do
				local signalid = ffi.string(allsignals[i].id)
				table.insert(menu.signals, {id = signalid, name = ffi.string(allsignals[i].name), description = ffi.string(allsignals[i].description), responses = {}})

				local numresponses = C.GetNumAllResponsesToSignal(signalid)
				local allresponses = ffi.new("ResponseInfo[?]", numresponses)
				numresponses = C.GetAllResponsesToSignal(allresponses, numresponses, signalid)
				for j = 0, numresponses - 1 do
					table.insert(menu.signals[#menu.signals].responses, {id = ffi.string(allresponses[j].id), name = ffi.string(allresponses[j].name), description = ffi.string(allresponses[j].description)})
				end
			end

			for _, signalentry in ipairs(menu.signals) do
				local signalid = signalentry.id
				local defask = C.GetAskToSignalForFaction(signalid, faction)
				local defresponse = ffi.string(C.GetDefaultResponseToSignalForFaction(signalid, faction))
				local locresponses = {}
				for _, responseentry in ipairs(signalentry.responses) do
					table.insert(locresponses, { id = responseentry.id, text = responseentry.name, icon = "", displayremoveoption = false })
				end
				table.insert(locresponses, { id = "reset", text = ReadText(1001, 9310), icon = "", displayremoveoption = false })	-- Reset standing orders of all ships for this scenario

				local row = table_center:addRow(false, {bgColor = Helper.color.unselectable})
				row[1]:setColSpan(5):createText(ReadText(1001, 9320) .. " " .. tostring(signalentry.name) .. ReadText(1001, 120), textproperties)	-- Default global response to, :

				local row = table_center:addRow("orders_" .. tostring(signalid) .. "_response", {bgColor = Helper.color.transparent})
				row[1]:setColSpan(5):createDropDown(locresponses, {height = Helper.standardTextHeight, startOption = defresponse}):setTextProperties({fontsize = config.mapFontSize})
				row[1].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(_, newresponseid, faction, signalid, "factionresponses") end

				local row = table_center:addRow("orders_" .. tostring(signalid) .. "_ask", {bgColor = Helper.color.transparent})
				row[1]:createCheckBox(defask, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[1].handlers.onClick = function() return menu.checkboxOrdersSetAsk(faction, signalid, "factionresponses") end
				row[2]:setColSpan(4):createText(ReadText(1001, 9330), textproperties)	-- Notify me if incident occurs

				table_center:addEmptyRow()
			end

			-- preferred build method
			local row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(5):createText(ReadText(1001, 7775) .. ReadText(1001, 120), textproperties)

			local cursetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the cursetting (which can be the method of the player's race) is in the list of options
					if id == cursetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				cursetting = "default"
			end

			local row = table_center:addRow("orders_buildmethod", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = cursetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = menu.dropdownOrdersBuildRule

			table_center:addEmptyRow()

			-- resupply
			local row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(5):createText(ReadText(1001, 7721) .. ReadText(1001, 120), textproperties)

			local locresponses = {
				{ id = 0,   text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
				{ id = 0.1, text = ReadText(1001, 7736), icon = "", displayremoveoption = false },
				{ id = 0.5, text = ReadText(1001, 7737), icon = "", displayremoveoption = false },
				{ id = 1.0, text = ReadText(1001, 7738), icon = "", displayremoveoption = false },
			}
			local row = table_center:addRow("orders_resupply", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = Helper.round(C.GetPlayerGlobalLoadoutLevel(), 1) }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = menu.dropdownOrdersResupply

			table_center:addEmptyRow()

			-- resupply
			local row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(5):createText(ReadText(1001, 7785) .. ReadText(1001, 120), textproperties)

			local locresponses = {
				{ id = "off",   text = ReadText(1001, 7726),  icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3276) },
				{ id = "on",    text = ReadText(1001, 11643), icon = "", displayremoveoption = false },
			}
			local row = table_center:addRow("orders_cargoreservations", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = C.GetPlayerGlobalTradeLoopCargoReservationSetting() and "on" or "off" }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = menu.dropdownOrdersCargoReservations

			table_center:addEmptyRow()

			-- default weapon mode
			local row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(5):createText(ReadText(1001, 7774) .. ReadText(1001, 120), textproperties)

			local weaponmodes = {
				[1] = { id = "defend",			text = ReadText(1001, 8613),	icon = "",	displayremoveoption = false },
				[2] = { id = "attackenemies",	text = ReadText(1001, 8614),	icon = "",	displayremoveoption = false },
				[3] = { id = "attackcapital",	text = ReadText(1001, 8624),	icon = "",	displayremoveoption = false },
				[4] = { id = "attackfighters",	text = ReadText(1001, 8625),	icon = "",	displayremoveoption = false },
			}
			local row = table_center:addRow("orders_weaponmode", {bgColor = Helper.color.transparent})
			row[1]:setColSpan(5):createDropDown(weaponmodes, { height = Helper.standardTextHeight, startOption = ffi.string(C.GetFactionDefaultWeaponMode("player")) }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return C.SetFactionDefaultWeaponMode("player", id) end

			table_center:addEmptyRow()

			-- wait for undock/signal
			local row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setColSpan(5):createText(ReadText(1001, 9331) .. ReadText(1001, 120), textproperties)

			local row = table_center:addRow("playershipswait", { bgColor = Helper.color.transparent })
			local waiting = C.ShouldPlayerShipsWaitForPlayer()
			row[1]:createCheckBox(waiting, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
			row[1].handlers.onClick = function(_, checked) C.SetPlayerShipsWaitForPlayer(checked) end
			row[1].properties.uiTriggerID = "playershipswait"
			row[2]:setColSpan(4):createText(ReadText(1001, 9332), textproperties)

			local row = table_center:addRow("playertaxiwait", { bgColor = Helper.color.transparent })
			local waiting = C.ShouldPlayerTaxiWaitForPlayer()
			row[1]:createCheckBox(waiting, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
			row[1].handlers.onClick = function(_, checked) C.SetPlayerTaxiWaitsForPlayer(checked) end
			row[1].properties.uiTriggerID = "playertaxiwait"
			row[2]:setColSpan(4):createText(ReadText(1001, 9333), textproperties)

			table_center:addEmptyRow()

			-- notifications
			local row = table_center:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 7727), Helper.titleTextProperties)	-- Notification Settings

			local typecategories = {
				[1] = { category = "npc_interactive",	name = ReadText(1001, 7728),	types = {} },
				[2] = { category = "npc_info",			name = ReadText(1001, 7729),	types = {} },
				[3] = { category = "ticker",			name = ReadText(1001, 7743),	types = {} },
			}
			local n = C.GetNumNotificationTypes()
			local buf = ffi.new("UINotificationType[?]", n)
			n = C.GetNotificationTypes(buf, n)
			for i = 0, n - 1 do
				local category = ffi.string(buf[i].category)
				for _, entry in ipairs(typecategories) do
					if entry.category == category then
						table.insert(entry.types, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), desc = ffi.string(buf[i].desc), enabled = buf[i].enabled })
						if entry.checkedcounts == nil then
							entry.checkedcounts = 0
						end
						if buf[i].enabled then
							entry.checkedcounts = entry.checkedcounts + 1
						end
					end
				end
			end

			local hasrows = false
			for i, entry in ipairs(typecategories) do
				if #entry.types ~= 0 then
					if hasrows then
						table_center:addEmptyRow()
					end

					local row = table_center:addRow(true, { bgColor = Helper.color.unselectable })
					row[1]:createCheckBox(function () return entry.checkedcounts == #entry.types end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
					row[1].handlers.onClick = function (_, checked) return menu.toggleAllNotificationSettings(entry, checked) end
					row[2]:setColSpan(4):createText(entry.name, Helper.subHeaderTextProperties)
					row[2].properties.font = Helper.standardFontBold
					hasrows = true

					for _, type in ipairs(entry.types) do
						local row = table_center:addRow(true, { bgColor = Helper.color.transparent })
						row[1]:createCheckBox(function () return type.enabled end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
						row[1].handlers.onClick = function (_, checked) return menu.checkboxNotification(entry, type.id, checked) end
						row[2]:setColSpan(4):createText(type.name, textproperties)
						row[2].properties.mouseOverText = type.desc
					end
				end
			end
		elseif locmode == "onlineitems" then
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 9122), Helper.titleTextProperties)	-- Venture Ships

			row = table_center:addRow(nil, { fixed = true, bgColor = Helper.color.unselectable })
			row[1]:setColSpan(4):createText(ReadText(1001, 2809), { font = Helper.standardFontBold })	-- Name
			row[5]:createText(ReadText(1001, 9051), { font = Helper.standardFontBold })	-- Ship Type

			for i, ship in ipairs(menu.empireData.ships) do
				if GetComponentData(ship, "isonlineobject") then
					local name, shiptype = GetComponentData(ship, "name", "shiptypename")
					row = table_center:addRow({"empire_onlineship", ship}, { bgColor = Helper.color.transparent, interative = false })
					row[1]:setColSpan(4):createText(name)
					row[5]:createText(shiptype)
				end
			end
		elseif locmode == "traderule" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(2, 25)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.traderule = Helper.tableCopy(mode[3])
			else
				menu.traderule = {
					name = ReadText(1001, 11013) .. " #" .. (#menu.traderules + 1),
					iswhitelist = false,
					factions = {},
					defaults = { trade = false, supply = false, build = false },
				}
			end
			menu.editedTradeRule = mode[4] or Helper.tableCopy(menu.traderule)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 11010), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedTradeRule.name)
			row[2].handlers.onTextChanged = menu.editboxTradeRuleNameChanged

			if menu.traderule.id then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ active = menu.buttonTradeRuleCheckChanges, mouseOverText = ReadText(1026, 9116) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonTradeRuleConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonTradeRuleCheckChanges, mouseOverText = ReadText(1026, 9117) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonTradeRuleReset
				-- delete
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ mouseOverText = ReadText(1026, 9115) }):setText(ReadText(1001, 11014), { halign = "center" })
				row[2].handlers.onClick = menu.buttonTradeRuleRemove
			else
				-- save
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 11015), { halign = "center" })
				row[4].handlers.onClick = menu.buttonTradeRuleConfirm

				row = table_center:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createText("")
			end

			-- defaults
			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")
			-- trade
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 11016) .. ReadText(1001, 120))
			row[2]:setColSpan(3):createText(ReadText(1001, 11017))
			row[5]:createCheckBox(menu.editedTradeRule.defaults.trade, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxTradeRuleDefault("trade", checked) end
			-- supply
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(3):createText(ReadText(1001, 11018))
			row[5]:createCheckBox(menu.editedTradeRule.defaults.supply, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxTradeRuleDefault("supply", checked) end
			-- build
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(3):createText(ReadText(1001, 11019))
			row[5]:createCheckBox(menu.editedTradeRule.defaults.build, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxTradeRuleDefault("build", checked) end

			-- data
			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")
			-- use whitelist
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(3):createText(ReadText(1001, 11020))
			row[5]:createCheckBox(menu.editedTradeRule.iswhitelist, {  })
			row[5].handlers.onClick = menu.checkboxTradeRuleUseWhitelist
			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")
			-- factions
			row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1].properties.cellBGColor = Helper.color.transparent
			row[2]:setColSpan(4):createText((menu.editedTradeRule.iswhitelist and ReadText(1001, 11022) or ReadText(1001, 11021)) .. ReadText(1001, 120))
			for _, faction in ipairs(menu.editedTradeRule.factions) do
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(3):createText("    " .. GetFactionData(faction, "name"), { color = (faction == "player") and Helper.color.green or nil })
				row[5]:createButton({  }):setText("x", { halign = "center" })
				row[5].handlers.onClick = function () return menu.buttonTradeRuleRemoveFaction(faction) end
			end
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9156), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonTradeRuleAddFaction(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end

		elseif locmode == "blacklist" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(2, 25)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.blacklist = Helper.tableCopy(mode[3])
			else
				menu.blacklist = {
					name = ReadText(1001, 9159) .. " #" .. (#menu.blacklists + 1),
					spaces = {},
					factions = {},
					defaults = { civilian = false, military = false },
				}
			end
			menu.editedBlacklist = mode[4] or Helper.tableCopy(menu.blacklist)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 9143), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedBlacklist.name)
			row[2].handlers.onTextChanged = menu.editboxBlacklistNameChanged

			if menu.blacklist.id then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ active = menu.buttonBlacklistCheckChanges, mouseOverText = ReadText(1026, 9107) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonBlacklistConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonBlacklistCheckChanges, mouseOverText = ReadText(1026, 9108) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonBlacklistReset
				-- delete
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ mouseOverText = ReadText(1026, 9106) }):setText(ReadText(1001, 9148), { halign = "center" })
				row[2].handlers.onClick = menu.buttonBlacklistRemove
				-- type
				row = table_center:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9161) .. ReadText(1001, 120))
				local text, mouseovertext = "", ""
				for _, option in ipairs(config.blacklistTypes) do
					if option.id == menu.editedBlacklist.type then
						text = option.text
						mouseovertext = option.mouseovertext .. "\n\n" .. ReadText(1026, 9104)
						break
					end
				end
				row[2]:setColSpan(4):createText(text, { mouseOverText = mouseovertext })
			else
				-- save
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[4]:setColSpan(2):createButton({ active = menu.editedBlacklist.type ~= nil, mouseOverText = (menu.editedBlacklist.type == nil) and ReadText(1026, 9109) or ReadText(1026, 9105) }):setText(ReadText(1001, 9160), { halign = "center" })
				row[4].handlers.onClick = menu.buttonBlacklistConfirm

				row = table_center:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createText("")
				-- type
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9161) .. ReadText(1001, 120))
				row[2]:setColSpan(4):createDropDown(config.blacklistTypes, { height = Helper.standardTextHeight, startOption = menu.editedBlacklist.type })
				row[2].handlers.onDropDownConfirmed = menu.dropdownBlacklistType
			end

			if menu.editedBlacklist.type ~= nil then
				row = table_center:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:createText("")
				-- military
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9149) .. ReadText(1001, 120))
				row[2]:setColSpan(3):createText(ReadText(1001, 9150))
				row[5]:createCheckBox(menu.editedBlacklist.defaults.military, {  })
				row[5].handlers.onClick = function (_, checked) return menu.checkboxBlacklistDefault("military", checked) end
				-- civilian
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(3):createText(ReadText(1001, 9151))
				row[5]:createCheckBox(menu.editedBlacklist.defaults.civilian, {  })
				row[5].handlers.onClick = function (_, checked) return menu.checkboxBlacklistDefault("civilian", checked) end
			end

			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")

			if menu.editedBlacklist.type == "sectortravel" then
				-- hazardous
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9168) .. ReadText(1001, 120))
				row[2]:setColSpan(3):createText(ReadText(1001, 9152))
				row[5]:createCheckBox(menu.editedBlacklist.hazardous, {  })
				row[5].handlers.onClick = menu.checkboxBlacklistHazard
			end
			if (menu.editedBlacklist.type == "sectortravel") or (menu.editedBlacklist.type == "sectoractivity") then
				-- relation
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(3):createText(ReadText(1001, 9153))
				row[5]:createCheckBox(menu.editedBlacklist.relation == "enemy", {  })
				row[5].handlers.onClick = menu.checkboxBlacklistRelation
			end
			if menu.editedBlacklist.type ~= nil then
				table_center:addEmptyRow()
				-- factions
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(3):createText(ReadText(1001, 11020))
				row[5]:createCheckBox(menu.editedBlacklist.usefactionwhitelist, {  })
				row[5].handlers.onClick = menu.checkboxBlacklistUseFactionWhitelist
				row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
				row[1].properties.cellBGColor = Helper.color.transparent
				row[2]:setColSpan(4):createText(((menu.editedBlacklist.type == "objectactivity") and (menu.editedBlacklist.usefactionwhitelist and ReadText(1001, 11041) or ReadText(1001, 9179)) or (menu.editedBlacklist.usefactionwhitelist and ReadText(1001, 11040) or ReadText(1001, 9154))) .. ReadText(1001, 120))
				for _, faction in ipairs(menu.editedBlacklist.factions) do
					row = table_center:addRow(true, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(3):createText("    " .. GetFactionData(faction, "name"), { color = (faction == "player") and Helper.color.green or nil })
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonBlacklistRemoveFaction(faction) end
				end
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9156), { halign = "center" })
				row[2].handlers.onClick = function () return menu.buttonBlacklistAddFaction(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			end
			if (menu.editedBlacklist.type == "sectortravel") or (menu.editedBlacklist.type == "sectoractivity") then
				table_center:addEmptyRow()
				-- macros
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(3):createText(ReadText(1001, 11043))
				row[5]:createCheckBox(menu.editedBlacklist.usemacrowhitelist, {  })
				row[5].handlers.onClick = menu.checkboxBlacklistUseMacroWhitelist
				row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
				row[1].properties.cellBGColor = Helper.color.transparent
				row[2]:setColSpan(4):createText((menu.editedBlacklist.usemacrowhitelist and ReadText(1001, 11042) or ReadText(1001, 9155)) .. ReadText(1001, 120))
				for _, spaceid in ipairs(menu.editedBlacklist.spaces) do
					row = table_center:addRow(true, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(3):createText("    " .. ffi.string(C.GetComponentName(spaceid)))
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonBlacklistRemoveMacro(spaceid) end
				end
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9157), { halign = "center" })
				row[2].handlers.onClick = function () return menu.buttonBlacklistAddMacro(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			end

		elseif locmode == "fightrule" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(3, 10)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.fightrule = Helper.tableCopy(mode[3], 3)
			else
				menu.fightrule = {
					name = ReadText(1001, 7756) .. " #" .. (#menu.fightrules + 1),
					settings = {},
					defaults = { attack = false },
				}
			end
			menu.editedFightRule = mode[4] or Helper.tableCopy(menu.fightrule, 3)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 7753), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedFightRule.name)
			row[2].handlers.onTextChanged = menu.editboxFightRuleNameChanged

			if menu.fightrule.id then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ active = menu.buttonFightRuleCheckChanges, mouseOverText = ReadText(1026, 7703) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonFightRuleConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonFightRuleCheckChanges, mouseOverText = ReadText(1026, 7704) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonFightRuleReset
				-- delete
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ mouseOverText = ReadText(1026, 7705) }):setText(ReadText(1001, 7757), { halign = "center" })
				row[2].handlers.onClick = menu.buttonFightRuleRemove
			else
				-- save
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 7758), { halign = "center" })
				row[4].handlers.onClick = menu.buttonFightRuleConfirm

				row = table_center:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createText("")
			end

			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")
			-- default
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 7766) .. ReadText(1001, 120))
			row[5]:createCheckBox(menu.editedFightRule.defaults.attack, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxFightRuleDefault("attack", checked) end

			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")

			row = table_center:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setBackgroundColSpan(5):createText(ReadText(1001, 44), { font = Helper.standardFontBold })
			row[2]:createText(ReadText(1001, 2809), { font = Helper.standardFontBold })
			row[3]:createText(ReadText(1001, 7749), { font = Helper.standardFontBold, halign = "center" })
			row[4]:setColSpan(2):createText(ReadText(1001, 7767), { font = Helper.standardFontBold, halign = "center" })

			local factions = {}
			local relations = GetLibrary("factions")
			for i, relation in ipairs(relations) do
				if relation.id ~= "player" then
					table.insert(factions, relation.id)
				end
			end
			table.sort(factions, Helper.sortFactionName)

			local overrideoptions = {
				{ id ="engage/default",		text = ReadText(1001, 7759), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 7706) },
				{ id ="default/engage",		text = ReadText(1001, 7760), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7707), C.GetRelationRangeUIMaxValue("kill")) },
				{ id ="hold/engage",		text = ReadText(1001, 7761), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 7708) },
				{ id ="default/default",	text = ReadText(1001, 7762), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7709), C.GetRelationRangeUIMaxValue("killmilitary"), C.GetRelationRangeUIMaxValue("kill")) },
				{ id ="hold/default",		text = ReadText(1001, 7763), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7710), C.GetRelationRangeUIMaxValue("killmilitary")) },
				{ id ="default/hold",		text = ReadText(1001, 7764), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7711), C.GetRelationRangeUIMaxValue("kill")) },
				{ id ="hold/hold",			text = ReadText(1001, 7765), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 7712) },
			}

			for i, faction in ipairs(factions) do
				local name, shortname = GetFactionData(faction, "name", "shortname")
				local startoption = "default/default"
				if menu.editedFightRule.settings[faction] then
					startoption = menu.editedFightRule.settings[faction].civilian .. "/" .. menu.editedFightRule.settings[faction].military
				end

				local row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(1):createText("[" .. shortname .. "] " .. name)
				row[3]:createText(function () return string.format("%+d", GetUIRelation(faction)) end, { halign = "right", font = Helper.standardFontMono, color = function () return menu.relationColor(faction) end })
				row[4]:setColSpan(2):createDropDown(overrideoptions, { height = Helper.standardTextHeight, startOption = startoption }):setTextProperties({ halign = "center" })
				row[4].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownFightRuleFactionSetting(faction, id) end
			end

		elseif locmode == "playeralert" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(2, 25)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.playeralert = Helper.tableCopy(mode[3])
			else
				menu.playeralert = {
					name = ReadText(1001, 9186) .. " #" .. (#menu.playeralerts + 1),
					interval = 300,
					objectclasses = { "object" },
					objectpurpose = "",
					objectidcode = "",
					objectowners = {},
					spaces = {},
					message = "",
					soundid = "",
				}
			end
			menu.editedPlayerAlert = mode[4] or Helper.tableCopy(menu.playeralert)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 9183), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedPlayerAlert.name)
			row[2].handlers.onTextChanged = menu.editboxPlayerAlertNameChanged

			if menu.playeralert.index then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ active = menu.buttonPlayerAlertCheckChanges, mouseOverText = ReadText(1026, 9111) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonPlayerAlertConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonPlayerAlertCheckChanges, mouseOverText = ReadText(1026, 9112) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonPlayerAlertReset
				-- delete
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createButton({ mouseOverText = ReadText(1026, 9110) }):setText(ReadText(1001, 9187), { halign = "center" })
				row[2].handlers.onClick = menu.buttonPlayerAlertRemove
			else
				-- save
				row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
				row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 9188), { halign = "center" })
				row[4].handlers.onClick = menu.buttonPlayerAlertConfirm

				row = table_center:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[2]:createText("")
			end

			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")

			-- notification text
			row = table_center:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 11009) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 11009) }):setText(menu.editedPlayerAlert.message)
			row[2].handlers.onTextChanged = menu.editboxPlayerAlertMessageChanged
			-- sound
			local n = C.GetNumPlayerAlertSounds2("general subtle hostile")
			local buf = ffi.new("SoundInfo[?]", n)
			n = C.GetPlayerAlertSounds2(buf, n, "general subtle hostile")
			local options = {}
			for i = 0, n - 1 do
				table.insert(options, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
			end
			table.sort(options, function (a, b) return a.text < b.text end)

			if (menu.editedPlayerAlert.soundid == "") and options[1] then
				menu.editedPlayerAlert.soundid = options[1].id
			end
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9192) .. ReadText(1001, 120))
			row[2]:setColSpan(3):createDropDown(options, { height = Helper.standardTextHeight, startOption = menu.editedPlayerAlert.soundid })
			row[2].handlers.onDropDownConfirmed = menu.dropdownPlayerAlertSound
			row[5]:createButton({ height = Helper.standardTextHeight }):setIcon("menu_sound_on")
			row[5].handlers.onClick = menu.buttonPlayerAlertSoundTest

			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")

			-- interval
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9193) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 9113) })
			row[2]:setColSpan(4):createSliderCell({ min = 1, max = 60, start = menu.editedPlayerAlert.interval / 60, suffix = ReadText(1001, 103), hideMaxValue = true, exceedMaxValue = true, height = Helper.standardTextHeight })
			row[2].handlers.onSliderCellChanged = menu.slidercellPlayerAlertInterval
			-- repeats
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9194) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 9114) })
			row[2]:setColSpan(4):createCheckBox(menu.editedPlayerAlert.repeats, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
			row[2].handlers.onClick = menu.checkboxPlayerAlertRepeat

			row = table_center:addRow(false, { bgColor = Helper.color.transparent })
			row[2]:createText("")

			-- spaces
			if #menu.editedPlayerAlert.spaces > 0 then
				for i, spaceid in ipairs(menu.editedPlayerAlert.spaces) do
					row = table_center:addRow(true, { bgColor = Helper.color.transparent })
						if i == 1 then
							row[1]:createText(ReadText(1001, 9190).. ReadText(1001, 120))
						end
					row[2]:setColSpan(3):createText("    " .. ffi.string(C.GetComponentName(spaceid)))
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonPlayerAlertRemoveSpace(spaceid) end
				end
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			else
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9190).. ReadText(1001, 120))
				row[2]:createText("    " .. ReadText(1001, 9191))
			end
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9157), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonPlayerAlertAddSpace(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end

			-- owner
			if #menu.editedPlayerAlert.objectowners > 0 then
				for i, faction in ipairs(menu.editedPlayerAlert.objectowners) do
					row = table_center:addRow(true, { bgColor = Helper.color.transparent })
					if i == 1 then
						row[1]:createText(ReadText(1001, 9195).. ReadText(1001, 120))
					end
					row[2]:setColSpan(3):createText("    " .. GetFactionData(faction, "name"))
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonPlayerAlertRemoveFaction(faction) end
				end
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			else
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9195).. ReadText(1001, 120))
			end
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9156), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonPlayerAlertAddFaction(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			-- class
			if #menu.editedPlayerAlert.objectclasses > 0 then
				for i, class in ipairs(menu.editedPlayerAlert.objectclasses) do
					row = table_center:addRow(true, { bgColor = Helper.color.transparent })
					if i == 1 then
						row[1]:createText(ReadText(1001, 9197).. ReadText(1001, 120))
					end
					row[2]:setColSpan(3):createText("    " .. config.classDefinitions[class])
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonPlayerAlertRemoveClass(class) end
				end
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			else
				row = table_center:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9197).. ReadText(1001, 120))
			end
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 11008), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonPlayerAlertAddClass(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			-- purpose
			local purposes = { "trade", "fight", "build", "mine", "auxiliary" }
			local options = {
				{ id = "default", text = ReadText(1001, 11004), icon = "", displayremoveoption = false }
			}
			for _, purpose in ipairs(purposes) do
				table.insert(options, { id = purpose, text = ffi.string(C.GetPurposeName(purpose)), icon = "", displayremoveoption = false })
			end
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9199) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createDropDown(options, { height = Helper.standardTextHeight, startOption = (menu.editedPlayerAlert.objectpurpose ~= "") and menu.editedPlayerAlert.objectpurpose or "default" })
			row[2].handlers.onDropDownConfirmed = menu.dropdownPlayerAlertPurpose
			-- idcode
			row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 11005) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 11005) }):setText(menu.editedPlayerAlert.objectidcode)
			row[2].handlers.onTextChanged = menu.editboxPlayerAlertIDCodeChanged
		elseif locmode == "sectorownership" then
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 9601), Helper.titleTextProperties)
			-- owned sectors
			local row = table_center:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
			row[1]:setBackgroundColSpan(5):createText(ReadText(1001, 9181))

			local skiprow = true
			local clusters = GetClusters(true)
			for _, cluster in ipairs(clusters) do
				local sectors = GetSectors(cluster)
				for _, sector in ipairs(sectors) do
					if GetComponentData(sector, "isplayerowned") then
						if not skiprow then
							row = table_center:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
							row[1]:setBackgroundColSpan(5)
						end
						skiprow = false
						row[2]:setColSpan(4):createText(ffi.string(C.GetComponentName(ConvertIDTo64Bit(sector))), { halign = "right" })
					end
				end
			end

			local row = table_center:addRow(nil, { bgColor = Helper.defaultHeaderBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 2435), Helper.headerRowCenteredProperties)
			-- illegal wares
			local illegalWares = {}
			local n = C.GetNumWares("economy", false, "", "")
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWares(buf, n, "economy", false, "", "")
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i])
				local name, playerillegal = GetWareData(ware, "name", "playerillegal")
				if playerillegal then
					table.insert(illegalWares, { ware = ware, name = name })
				end
			end
			table.sort(illegalWares, Helper.sortName)

			if #illegalWares > 0 then
				for _, entry in ipairs(illegalWares) do
					local row = table_center:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
					row[1]:createText(entry.name)
				end
			else
				local row = table_center:addRow(true, { bgColor = Helper.color.transparent, interactive = false })
				row[1]:createText("--- " .. ReadText(1001, 32) .. " ---")
			end
			-- button
			local row = table_center:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createButton({}):setText(ReadText(1001, 8378), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonIllegalWares(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
		end
	elseif mode[1] == "empire_call" then

		local tableProperties = properties_table_center
		tableProperties.height = Helper.viewHeight - tableProperties.y

		if locmode == "stationcash" then
			return menu.createAccounts(menu.infoFrame, tableProperties, tabOrderOffset)
		elseif locmode == "inventory" then
			return menu.createInventory(menu.infoFrame, tableProperties, nil, tabOrderOffset)
		end
	end
end

function menu.logoButtonIcon2(logo)
	if (logo.icon == menu.empireData.currentlogo.icon) and (logo.ispersonal == menu.empireData.currentlogo.ispersonal) then
		return "be_upgrade_installed"
	end
	return "solid"
end

function menu.logoButtonIcon2Color(logo)
	if (logo.icon == menu.empireData.currentlogo.icon) and (logo.ispersonal == menu.empireData.currentlogo.ispersonal) then
		return Helper.color.green
	end
	return Helper.color.transparent
end

function menu.buttonTradeRuleConfirm()
	local traderule = ffi.new("TradeRuleInfo")
	traderule.name = Helper.ffiNewString(menu.editedTradeRule.name)

	traderule.iswhitelist = menu.editedTradeRule.iswhitelist
	traderule.numfactions = #menu.editedTradeRule.factions
	traderule.factions = Helper.ffiNewHelper("const char*[?]", traderule.numfactions)
	for i, faction in ipairs(menu.editedTradeRule.factions) do
		traderule.factions[i - 1] = Helper.ffiNewString(faction)
	end

	if menu.editedTradeRule.id then
		traderule.id = menu.editedTradeRule.id
		C.UpdateTradeRule(traderule)
	else
		menu.editedTradeRule.id = C.CreateTradeRule(traderule)
	end

	if menu.editedTradeRule.id ~= 0 then
		if menu.editedTradeRule.defaults.trade or menu.traderule.defaults.trade then
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "buy", menu.editedTradeRule.defaults.trade)
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "sell", menu.editedTradeRule.defaults.trade)
		end
		if menu.editedTradeRule.defaults.supply or menu.traderule.defaults.supply then
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "supply", menu.editedTradeRule.defaults.supply)
		end
		if menu.editedTradeRule.defaults.build or menu.traderule.defaults.build then
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "build", menu.editedTradeRule.defaults.build)
		end
	end

	menu.empireData.mode[3] = menu.editedTradeRule
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleReset()
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleRemove()
	C.RemoveTradeRule(menu.editedTradeRule.id)
	menu.editedTradeRule = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleCheckChanges()
	for k, v in pairs(menu.traderule) do
		if type(v) == "table" then
			if #menu.editedTradeRule[k] ~= #v then
				return true
			end
			for k2, v2 in pairs(v) do
				if menu.editedTradeRule[k][k2] ~= v2 then
					return true
				end
			end
		else
			if menu.editedTradeRule[k] ~= v then
				return true
			end
		end
	end
	return false
end

function menu.buttonTradeRuleAddFaction(x, y)
	menu.contextMenuMode = "traderulefaction"
	menu.createContext(x, y)
end

function menu.buttonBlacklistConfirm()
	local blacklist = ffi.new("BlacklistInfo2")
	blacklist.type = Helper.ffiNewString(menu.editedBlacklist.type)
	blacklist.name = Helper.ffiNewString(menu.editedBlacklist.name)
	blacklist.relation = Helper.ffiNewString(menu.editedBlacklist.relation or "")
	blacklist.hazardous = menu.editedBlacklist.hazardous or false

	blacklist.nummacros = #menu.editedBlacklist.spaces
	blacklist.macros = Helper.ffiNewHelper("const char*[?]", blacklist.nummacros)
	for i, spaceid in ipairs(menu.editedBlacklist.spaces) do
		blacklist.macros[i - 1] = Helper.ffiNewString(GetComponentData(spaceid, "macro"))
	end
	blacklist.usemacrowhitelist = menu.editedBlacklist.usemacrowhitelist or false

	blacklist.numfactions = #menu.editedBlacklist.factions
	blacklist.factions = Helper.ffiNewHelper("const char*[?]", blacklist.numfactions)
	for i, faction in ipairs(menu.editedBlacklist.factions) do
		blacklist.factions[i - 1] = Helper.ffiNewString(faction)
	end
	blacklist.usefactionwhitelist = menu.editedBlacklist.usefactionwhitelist or false

	if menu.editedBlacklist.id then
		blacklist.id = menu.editedBlacklist.id
		C.UpdateBlacklist2(blacklist)
	else
		menu.editedBlacklist.id = C.CreateBlacklist2(blacklist)
	end

	if menu.editedBlacklist.id ~= 0 then
		if menu.editedBlacklist.defaults.civilian or menu.blacklist.defaults.civilian then
			C.SetPlayerBlacklistDefault(menu.editedBlacklist.id, menu.editedBlacklist.type, "civilian", menu.editedBlacklist.defaults.civilian)
		end
		if menu.editedBlacklist.defaults.military or menu.blacklist.defaults.military then
			C.SetPlayerBlacklistDefault(menu.editedBlacklist.id, menu.editedBlacklist.type, "military", menu.editedBlacklist.defaults.military)
		end
	end

	menu.empireData.mode[3] = menu.editedBlacklist
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistReset()
	--menu.editedBlacklist = Helper.tableCopy(menu.blacklist)
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistRemove()
	C.RemoveBlacklist(menu.editedBlacklist.id)
	menu.editedBlacklist = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistCheckChanges()
	for k, v in pairs(menu.blacklist) do
		if type(v) == "table" then
			if #menu.editedBlacklist[k] ~= #v then
				return true
			end
			for k2, v2 in pairs(v) do
				if menu.editedBlacklist[k][k2] ~= v2 then
					return true
				end
			end
		else
			if menu.editedBlacklist[k] ~= v then
				return true
			end
		end
	end
	return false
end

function menu.buttonBlacklistAddFaction(x, y)
	menu.contextMenuMode = "blacklistfaction"
	menu.createContext(x, y)
end

function menu.buttonBlacklistAddMacro(x, y)
	menu.contextMenuMode = "blacklistsector"
	menu.createContext(x, y)
end

function menu.buttonIllegalWares(x, y)
	menu.contextMenuMode = "illegalwares"
	menu.createContext(x, y)
end

function menu.buttonSelectContextSetList(data)
	if menu.contextMenuMode == "blacklistfaction" then
		menu.editedBlacklist.factions = {}
		local hasplayer = false
		for faction in pairs(data) do
			if faction == "player" then
				hasplayer = true
			else
				table.insert(menu.editedBlacklist.factions, faction)
			end
		end
		table.sort(menu.editedBlacklist.factions, Helper.sortFactionName)
		if hasplayer then
			table.insert(menu.editedBlacklist.factions, 1, "player")
		end
		menu.empireData.mode[4] = menu.editedBlacklist
	elseif menu.contextMenuMode == "blacklistsector" then
		menu.editedBlacklist.spaces = {}
		for spaceid in pairs(data) do
			table.insert(menu.editedBlacklist.spaces, spaceid)
		end
		table.sort(menu.editedBlacklist.spaces, Helper.sortUniverseIDName)
		menu.empireData.mode[4] = menu.editedBlacklist
	elseif menu.contextMenuMode == "illegalwares" then
		for _, entry in ipairs(menu.contextMenuData.data) do
			C.SetPlayerIllegalWare(entry, data[entry] or false)
		end
	elseif menu.contextMenuMode == "playeralertclass" then
		menu.editedPlayerAlert.objectclasses = {}
		for class in pairs(data) do
			table.insert(menu.editedPlayerAlert.objectclasses, class)
		end
		table.sort(menu.editedPlayerAlert.objectclasses, menu.sortClasses)
		menu.empireData.mode[4] = menu.editedPlayerAlert
	elseif menu.contextMenuMode == "playeralertfaction" then
		menu.editedPlayerAlert.objectowners = {}
		for faction in pairs(data) do
			table.insert(menu.editedPlayerAlert.objectowners, faction)
		end
		table.sort(menu.editedPlayerAlert.objectowners, Helper.sortFactionName)
		menu.empireData.mode[4] = menu.editedPlayerAlert
	elseif menu.contextMenuMode == "playeralertsector" then
		menu.editedPlayerAlert.spaces = {}
		for spaceid in pairs(data) do
			table.insert(menu.editedPlayerAlert.spaces, spaceid)
		end
		table.sort(menu.editedPlayerAlert.spaces, Helper.sortUniverseIDName)
		menu.empireData.mode[4] = menu.editedPlayerAlert
	elseif menu.contextMenuMode == "traderulefaction" then
		menu.editedTradeRule.factions = {}
		local hasplayer = false
		for faction in pairs(data) do
			if faction == "player" then
				hasplayer = true
			else
				table.insert(menu.editedTradeRule.factions, faction)
			end
		end
		table.sort(menu.editedTradeRule.factions, Helper.sortFactionName)
		if hasplayer then
			table.insert(menu.editedTradeRule.factions, 1, "player")
		end
		menu.empireData.mode[4] = menu.editedTradeRule
	end

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.sortClasses(a, b)
	local aname = config.classDefinitions[a] or ""
	local bname = config.classDefinitions[b] or ""

	return aname > bname
end

function menu.editboxTradeRuleNameChanged(_, text)
	menu.noupdate = nil
	menu.editedTradeRule.name = text
end

function menu.checkboxTradeRuleDefault(group, checked)
	menu.editedTradeRule.defaults[group] = checked
end

function menu.checkboxTradeRuleUseWhitelist(_, checked)
	menu.editedTradeRule.iswhitelist = checked
	if checked then
		menu.editedTradeRule.factions = { "player" }
	else
		menu.editedTradeRule.factions = {}
	end

	menu.empireData.mode[4] = menu.editedTradeRule
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleRemoveFaction(faction)
	for i, entry in ipairs(menu.editedTradeRule.factions) do
		if entry == faction then
			table.remove(menu.editedTradeRule.factions, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedTradeRule
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistRemoveFaction(faction)
	for i, entry in ipairs(menu.editedBlacklist.factions) do
		if entry == faction then
			table.remove(menu.editedBlacklist.factions, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistRemoveMacro(spaceid)
	for i, entry in ipairs(menu.editedBlacklist.spaces) do
		if entry == spaceid then
			table.remove(menu.editedBlacklist.spaces, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.checkboxBlacklistDefault(group, checked)
	menu.editedBlacklist.defaults[group] = checked
end

function menu.checkboxSelectContextSetList(entry, checked)
	menu.contextMenuData.selectedData[entry] = checked or nil
end

function menu.checkboxSelectContextToggleList(checked)
	for _, entry in ipairs(menu.contextMenuData.data) do
		menu.contextMenuData.selectedData[entry] = checked or nil
	end
end

function menu.checkboxBlacklistHazard(_, checked)
	menu.editedBlacklist.hazardous = checked
end

function menu.checkboxBlacklistRelation(_, checked)
	menu.editedBlacklist.relation = checked and "enemy" or ""
end

function menu.checkboxBlacklistUseFactionWhitelist(_, checked)
	menu.editedBlacklist.usefactionwhitelist = checked
	if checked then
		menu.editedBlacklist.factions = { "player" }
	else
		menu.editedBlacklist.factions = {}
	end

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.checkboxBlacklistUseMacroWhitelist(_, checked)
	menu.editedBlacklist.usemacrowhitelist = checked
	menu.editedBlacklist.spaces = {}

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.dropdownBlacklistType(_, newtype)
	menu.editedBlacklist.type = newtype
	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.editboxBlacklistNameChanged(_, text)
	menu.noupdate = nil
	menu.editedBlacklist.name = text
end

function menu.buttonFightRuleConfirm()
	local fightrule = ffi.new("FightRuleInfo")
	fightrule.name = Helper.ffiNewString(menu.editedFightRule.name)

	fightrule.numfactions = 0
	for faction, entry in pairs(menu.editedFightRule.settings) do
		fightrule.numfactions = fightrule.numfactions + 1
	end
	fightrule.factions = Helper.ffiNewHelper("UIFightRuleSetting[?]", fightrule.numfactions)
	local i = 0
	for faction, entry in pairs(menu.editedFightRule.settings) do
		fightrule.factions[i].factionid = Helper.ffiNewString(faction)
		if entry.civilian == "default" then
			fightrule.factions[i].civiliansetting = Helper.ffiNewString("")
		else
			fightrule.factions[i].civiliansetting = Helper.ffiNewString(entry.civilian)
		end
		if entry.military == "default" then
			fightrule.factions[i].militarysetting = Helper.ffiNewString("")
		else
			fightrule.factions[i].militarysetting = Helper.ffiNewString(entry.military)
		end
		i = i + 1
	end

	if menu.editedFightRule.id then
		fightrule.id = menu.editedFightRule.id
		C.UpdateFightRule(fightrule)
	else
		menu.editedFightRule.id = C.CreateFightRule(fightrule)
	end

	if menu.editedFightRule.id ~= 0 then
		if menu.editedFightRule.defaults.attack then
			C.SetPlayerFightRuleDefault(menu.editedFightRule.id, "attack", menu.editedFightRule.defaults.attack)
		end
	end

	menu.empireData.mode[3] = menu.editedFightRule
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonFightRuleReset()
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonFightRuleRemove()
	C.RemoveFightRule(menu.editedFightRule.id)
	menu.editedFightRule = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonFightRuleCheckChanges()
	for k, v in pairs(menu.fightrule) do
		if type(v) == "table" then
			if Helper.tableLength(menu.editedFightRule[k]) ~= Helper.tableLength(v) then
				return true
			end
			for k2, v2 in pairs(v) do
				if type(v2) == "table" then
					if Helper.tableLength(menu.editedFightRule[k][k2]) ~= Helper.tableLength(v2) then
						return true
					end
					for k3, v3 in pairs(v2) do
						if menu.editedFightRule[k][k2][k3] ~= v3 then
							return true
						end
					end
				else
					if menu.editedFightRule[k][k2] ~= v2 then
						return true
					end
				end
			end
		else
			if menu.editedFightRule[k] ~= v then
				return true
			end
		end
	end
	return false
end

function menu.editboxFightRuleNameChanged(_, text)
	menu.noupdate = nil
	menu.editedFightRule.name = text
end

function menu.checkboxFightRuleDefault(group, checked)
	menu.editedFightRule.defaults[group] = checked
end

function menu.dropdownFightRuleFactionSetting(faction, id)
	if id then
		local civilian, military = string.match(id, "(.+)/(.+)")
		if menu.editedFightRule.settings[faction] then
			if (civilian == "default") and (military == "default") then
				menu.editedFightRule.settings[faction] = nil
			else
				menu.editedFightRule.settings[faction].civilian = civilian
				menu.editedFightRule.settings[faction].military = military
			end
		elseif (civilian ~= "default") or (military ~= "default") then
			menu.editedFightRule.settings[faction] = { civilian = civilian, military = military }
		end
	end
end

function menu.buttonPlayerAlertConfirm()
	local playeralert = ffi.new("PlayerAlertInfo2")
	playeralert.interval = menu.editedPlayerAlert.interval
	playeralert.repeats = menu.editedPlayerAlert.repeats or false
	playeralert.muted = menu.editedPlayerAlert.muted or false

	playeralert.numspaces = #menu.editedPlayerAlert.spaces
	playeralert.spaceids = Helper.ffiNewHelper("UniverseID[?]", playeralert.numspaces)
	for i, space in ipairs(menu.editedPlayerAlert.spaces) do
		playeralert.spaceids[i - 1] = space
	end

	local objectclass = ""
	for i, class in ipairs(menu.editedPlayerAlert.objectclasses) do
		objectclass = objectclass .. ((i > 1) and " " or "") .. class
	end
	playeralert.objectclass = Helper.ffiNewString(objectclass)

	local objectowner = ""
	for i, faction in ipairs(menu.editedPlayerAlert.objectowners) do
		objectowner = objectowner .. ((i > 1) and " " or "") .. faction
	end
	playeralert.objectowner = Helper.ffiNewString(objectowner)

	playeralert.objectpurpose = Helper.ffiNewString(menu.editedPlayerAlert.objectpurpose or "")
	playeralert.objectidcode = Helper.ffiNewString(menu.editedPlayerAlert.objectidcode or "")
	playeralert.name = Helper.ffiNewString(menu.editedPlayerAlert.name or "")
	playeralert.message = Helper.ffiNewString(menu.editedPlayerAlert.message or "")
	playeralert.soundid = Helper.ffiNewString(menu.editedPlayerAlert.soundid or "")

	if menu.editedPlayerAlert.index then
		playeralert.index = menu.editedPlayerAlert.index
		C.UpdatePlayerAlert2(playeralert)
	else
		C.AddPlayerAlert2(playeralert)
		menu.editedPlayerAlert.index = #menu.playeralerts + 1
	end

	menu.empireData.mode[3] = menu.editedPlayerAlert
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertReset()
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertRemove()
	C.RemovePlayerAlert(menu.editedPlayerAlert.index)
	menu.editedPlayerAlert = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertCheckChanges()
	for k, v in pairs(menu.playeralert) do
		if type(v) == "table" then
			if #menu.editedPlayerAlert[k] ~= #v then
				return true
			end
			for k2, v2 in pairs(v) do
				if menu.editedPlayerAlert[k][k2] ~= v2 then
					return true
				end
			end
		elseif menu.editedPlayerAlert[k] ~= v then
			return true
		end
	end
	return false
end

function menu.buttonPlayerAlertSoundTest()
	if menu.editedPlayerAlert.soundid ~= "" then
		PlaySound(menu.editedPlayerAlert.soundid)
	end
end

function menu.buttonPlayerAlertRemoveClass(class)
	for i, entry in ipairs(menu.editedPlayerAlert.objectclasses) do
		if entry == class then
			table.remove(menu.editedPlayerAlert.objectclasses, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedPlayerAlert
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertRemoveFaction(faction)
	for i, entry in ipairs(menu.editedPlayerAlert.objectowners) do
		if entry == faction then
			table.remove(menu.editedPlayerAlert.objectowners, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedPlayerAlert
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertRemoveSpace(spaceid)
	for i, entry in ipairs(menu.editedPlayerAlert.spaces) do
		if entry == spaceid then
			table.remove(menu.editedPlayerAlert.spaces, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedPlayerAlert
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertAddClass(x, y)
	menu.contextMenuMode = "playeralertclass"
	menu.createContext(x, y)
end

function menu.buttonPlayerAlertAddFaction(x, y)
	menu.contextMenuMode = "playeralertfaction"
	menu.createContext(x, y)
end

function menu.buttonPlayerAlertAddSpace(x, y)
	menu.contextMenuMode = "playeralertsector"
	menu.createContext(x, y)
end

function menu.dropdownPlayerAlertSpace(_, newspace)
	menu.editedPlayerAlert.spaceid = ConvertStringTo64Bit(newspace)
end

function menu.dropdownPlayerAlertSound(_, newsound)
	menu.editedPlayerAlert.soundid = newsound
end

function menu.dropdownPlayerAlertPurpose(_, newpurpose)
	menu.editedPlayerAlert.objectpurpose = (newpurpose ~= "default") and newpurpose or ""
end

function menu.editboxPlayerAlertNameChanged(_, text)
	menu.noupdate = nil
	menu.editedPlayerAlert.name = text
end

function menu.editboxPlayerAlertMessageChanged(_, text)
	menu.noupdate = nil
	menu.editedPlayerAlert.message = text
end

function menu.editboxPlayerAlertIDCodeChanged(_, text)
	menu.noupdate = nil
	menu.editedPlayerAlert.objectidcode = text
end

function menu.slidercellPlayerAlertInterval(_, value)
	menu.editedPlayerAlert.interval = value * 60
end

function menu.checkboxPlayerAlertRepeat(_, checked)
	menu.editedPlayerAlert.repeats = checked
end

function menu.createContext(x, y)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		width = 1.5 * menu.contextMenuWidth,
		x = x,
		y = y,
		autoFrameHeight = true,
	})

	menu.contextMenuData = { data = {} , selectedData = {}, origSelectedData = {}}
	if menu.contextMenuMode == "blacklistfaction" then
		local relations = GetLibrary("factions")
		for i, relation in ipairs(relations) do
			if relation.id ~= "player" then
				table.insert(menu.contextMenuData.data, relation.id)
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortFactionName)
		table.insert(menu.contextMenuData.data, 1, "player")

		for _, faction in ipairs(menu.editedBlacklist.factions) do
			menu.contextMenuData.selectedData[faction] = true
			menu.contextMenuData.origSelectedData[faction] = true
		end
	elseif menu.contextMenuMode == "blacklistsector" then
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.data, ConvertIDTo64Bit(sector))
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortUniverseIDName)

		for _, spaceid in ipairs(menu.editedBlacklist.spaces) do
			menu.contextMenuData.selectedData[spaceid] = true
			menu.contextMenuData.origSelectedData[spaceid] = true
		end
	elseif menu.contextMenuMode == "illegalwares" then
		local n = C.GetNumWares("economy", false, "", "")
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, "economy", false, "", "")
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			table.insert(menu.contextMenuData.data, ware)
			if GetWareData(ware, "playerillegal") then
				menu.contextMenuData.selectedData[ware] = true
				menu.contextMenuData.origSelectedData[ware] = true
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortWareName)
	elseif menu.contextMenuMode == "playeralertclass" then
		menu.contextMenuData.data = { "object", "station", "ship_s", "ship_m", "ship_l", "ship_xl" }

		for _, class in ipairs(menu.editedPlayerAlert.objectclasses) do
			menu.contextMenuData.selectedData[class] = true
			menu.contextMenuData.origSelectedData[class] = true
		end
	elseif menu.contextMenuMode == "playeralertfaction" then
		local relations = GetLibrary("factions")
		for i, relation in ipairs(relations) do
			if relation.id ~= "player" then
				table.insert(menu.contextMenuData.data, relation.id)
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortFactionName)

		for _, faction in ipairs(menu.editedPlayerAlert.objectowners) do
			menu.contextMenuData.selectedData[faction] = true
			menu.contextMenuData.origSelectedData[faction] = true
		end
	elseif menu.contextMenuMode == "playeralertsector" then
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.data, ConvertIDTo64Bit(sector))
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortUniverseIDName)

		for _, spaceid in ipairs(menu.editedPlayerAlert.spaces) do
			menu.contextMenuData.selectedData[spaceid] = true
			menu.contextMenuData.origSelectedData[spaceid] = true
		end
	elseif menu.contextMenuMode == "traderulefaction" then
		local relations = GetLibrary("factions")
		for i, relation in ipairs(relations) do
			if relation.id ~= "player" then
				table.insert(menu.contextMenuData.data, relation.id)
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortFactionName)
		table.insert(menu.contextMenuData.data, 1, "player")

		for _, faction in ipairs(menu.editedTradeRule.factions) do
			menu.contextMenuData.selectedData[faction] = true
			menu.contextMenuData.origSelectedData[faction] = true
		end
	end

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 4 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidthPercent(3, 50)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedData) do count = count + 1 end; return #menu.contextMenuData.data == count end, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function (_, checked) return menu.checkboxSelectContextToggleList(checked) end
	local text = ""
	if menu.contextMenuMode == "blacklistfaction" then
		text = ReadText(1001, 9176)
	elseif menu.contextMenuMode == "blacklistsector" then
		text = ReadText(1001, 9177)
	elseif menu.contextMenuMode == "illegalwares" then
		text = ReadText(1001, 8376)
	elseif menu.contextMenuMode == "playeralertclass" then
		text = ReadText(1001, 11007)
	elseif menu.contextMenuMode == "playeralertfaction" then
		text = ReadText(1001, 9176)
	elseif menu.contextMenuMode == "playeralertsector" then
		text = ReadText(1001, 9177)
	elseif menu.contextMenuMode == "traderulefaction" then
		text = ReadText(1001, 9176)
	end
	row[2]:setColSpan(2):createText(text, Helper.headerRowCenteredProperties)

	if #menu.contextMenuData.data > 0 then
		for _, entry in ipairs(menu.contextMenuData.data) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(function () return menu.contextMenuData.selectedData[entry] or false end, {  })
			row[1].handlers.onClick = function (_, checked) return menu.checkboxSelectContextSetList(entry, checked) end
			local text, color = ""
			if menu.contextMenuMode == "blacklistfaction" then
				text = GetFactionData(entry, "name")
				if entry == "player" then
					color = Helper.color.green
				end
			elseif menu.contextMenuMode == "blacklistsector" then
				text = ffi.string(C.GetComponentName(entry))
			elseif menu.contextMenuMode == "illegalwares" then
				text = GetWareData(entry, "name")
			elseif menu.contextMenuMode == "playeralertclass" then
				text = config.classDefinitions[entry]
			elseif menu.contextMenuMode == "playeralertfaction" then
				text = GetFactionData(entry, "name")
			elseif menu.contextMenuMode == "playeralertsector" then
				text = ffi.string(C.GetComponentName(entry))
			elseif menu.contextMenuMode == "traderulefaction" then
				text = GetFactionData(entry, "name")
				if entry == "player" then
					color = Helper.color.green
				end
			end
			row[2]:setColSpan(2):createText(text, { color = color })
		end

		local buttontable = menu.contextFrame:addTable(2, { tabOrder = 5 })

		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = menu.isDataSelectionChanged }):setText(ReadText(1001, 14), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonSelectContextSetList(menu.contextMenuData.selectedData) end
		row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
		row[2].handlers.onClick = function () return menu.onCloseElement("back") end

		local dataheight = ftable:getFullHeight()
		local buttonheight = buttontable:getFullHeight()
		if menu.contextFrame.properties.y + ftable.properties.y + dataheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
			buttontable.properties.y = Helper.viewHeight - menu.contextFrame.properties.y - Helper.frameBorder - buttonheight
			ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
		else
			buttontable.properties.y = ftable.properties.y + dataheight + Helper.borderSize
		end

		ftable:addConnection(1, 4, true)
		buttontable:addConnection(2, 4)
	else
		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
	end

	menu.contextFrame:display()
end

function menu.isDataSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedData) do
		if not menu.contextMenuData.origSelectedData[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedData) do
		if not menu.contextMenuData.selectedData[ware] then
			return true
		end
	end
	return false
end

function menu.empireCanShowObject(object)
	if menu.empireData.mode and (menu.empireData.mode[2] == "inventory") then
		return false
	elseif not C.IsComponentClass(object, "object") and not C.IsComponentClass(object, "npc") then
		return false
	elseif C.IsComponentClass(object, "ship") and GetComponentData(object, "isdocked") and not C.IsShipAtExternalDock(object) then
		return false
	end

	return true
end

function menu.createContextFrame(data, x, y, width, nomouseout)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local contextmenuwidth = width or menu.contextMenuWidth

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		width = contextmenuwidth,
		x = x,
		y = 0,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 4, highlightMode = "off" })

	if menu.contextMenuMode == "inventory" then
		local counter = 0
		local allowencyclopedia = true
		local allowdrop = 0
		local dropmouseovertext = ReadText(1001, 7714)
		for ware in pairs(menu.inventoryData.selectedWares) do
			counter = counter + 1
			if counter > 1 then
				allowencyclopedia = false
			end
			if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
				allowdrop = allowdrop + 1
			else
				dropmouseovertext = dropmouseovertext .. "\n" .. GetWareData(ware, "name")
			end
		end

		local title = data[2].name
		if counter > 1 then
			title = string.format(ReadText(1001, 7713), counter)
		end

		local row = ftable:addRow(false, { fixed = true })
		row[1]:createText(title, Helper.titleTextProperties)

		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = allowencyclopedia, bgColor = allowencyclopedia and Helper.color.transparent or Helper.color.darkgrey }):setText(ReadText(1001, 2400), { color = allowencyclopedia and Helper.color.white or Helper.color.lightgrey })
		row[1].handlers.onClick = function () return menu.buttonInventoryEncyclopedia(data[1]) end

		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = allowdrop > 0, bgColor = allowdrop > 0 and Helper.color.transparent or Helper.color.darkgrey, mouseOverText = (allowdrop == counter) and "" or dropmouseovertext }):setText((allowdrop == counter) and ReadText(1001, 7711) or string.format(ReadText(1001, 7712), allowdrop, counter), { color = allowdrop > 0 and Helper.color.white or Helper.color.lightgrey })
		row[1].handlers.onClick = function () return menu.buttonInventoryDropAll(false) end
	elseif menu.contextMenuMode == "personnel" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:createText(menu.personnelData.curEntry.name, Helper.titleTextProperties)

		local controllable = menu.personnelData.curEntry.container
		local entity, person
		if menu.personnelData.curEntry.type == "person" then
			person = menu.personnelData.curEntry.id
		else
			entity = menu.personnelData.curEntry.id
		end

		local transferscheduled = false
		local hasarrived = true
		local personrole = ""
		if person then
			-- get real NPC if instantiated
			local instance = C.GetInstantiatedPerson(person, controllable)
			entity = (instance ~= 0 and instance or nil)
			transferscheduled = C.IsPersonTransferScheduled(controllable, person)
			hasarrived = C.HasPersonArrived(controllable, person)
			personrole = ffi.string(C.GetPersonRole(person, controllable))
		end

		local oldpilot, isonlineobject = GetComponentData(controllable, "assignedaipilot", "isonlineobject")
		if oldpilot then
			oldpilot = ConvertStringTo64Bit(tostring(oldpilot))
		end

		if isonlineobject then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ bgColor = Helper.color.transparent, active = false, height = Helper.standardTextHeight }):setText(ReadText(1026, 9118))
		else
			local row = ftable:addRow("info_person_containerinfo", { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(C.IsComponentClass(controllable, "station") and ReadText(1001, 8350) or ReadText(1001, 8602))
			row[1].handlers.onClick = function () return menu.buttonContainerInfo(controllable) end

			if person then
				if transferscheduled then
					local row = ftable:addRow("info_person_cancel_transfer", { fixed = true, bgColor = Helper.color.transparent })
					row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1001, 9435))	-- Cancel all scheduled transfers
					row[1].handlers.onClick = function () return menu.buttonPersonnelCancelTransfer(controllable, person) end
				elseif hasarrived and ((personrole == "service") or (personrole == "marine")) then
					local printedtitle = C.IsComponentClass(controllable, "ship_s") and ReadText(1001, 4847) or ReadText(1001, 4848)	-- Pilot, Captain
					-- promote
					local row = ftable:addRow("info_person_promote", { fixed = true, bgColor = Helper.color.transparent })
					row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1001, 9433) .. " " .. printedtitle)	-- Promote to(followed by "captain" or "pilot")
					row[1].handlers.onClick = function () return menu.buttonPersonnelReplacePilot(controllable, oldpilot, person) end
				end
			end
			if menu.personnelData.curEntry.roleid ~= "shiptrader" then
				if hasarrived then
					-- work somewhere else
					local row = ftable:addRow("info_person_worksomewhere", { fixed = true, bgColor = Helper.color.transparent })
					row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1002, 3008))
					if entity then
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", entity, 0 } }); menu.cleanup() end
					else
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", controllable, 0, person} }); menu.cleanup() end
					end
				end
				-- fire
				local row = ftable:addRow("info_person_fire", { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight }):setText(ReadText(1002, 15800))
				row[1].handlers.onClick = function () return menu.buttonPersonnelFireNPCConfirm(controllable, entity, person, menu.personnelData.curEntry.name) end
			end

			local conversationactor = ConvertStringTo64Bit(tostring(entity))
			local player = C.GetPlayerID()
			if person and ((not entity) or (C.GetContextByClass(entity, "container", false) ~= C.GetContextByClass(player, "container", false))) then
				-- Talking to person - either not instantiated as a real entity, or the instance is far away.
				-- Note: Only start comms with instantiated NPCs if they are on the player container, otherwise they are likely to get despawned during the conversation.
				conversationactor = { context = ConvertStringToLuaID(tostring(controllable)), person = ConvertStringToLuaID(tostring(person)) }
			end
			if (not transferscheduled) and hasarrived then
				row = ftable:addRow("info_actor_comm", { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createButton({ bgColor = Helper.color.transparent, height = Helper.standardTextHeight, active = (person ~= nil) or (entity and GetComponentData(entity, "caninitiatecomm")) }):setText(ReadText(1001, 3216))	-- (initiate comm)Comm
				row[1].handlers.onClick = function () menu.buttonPersonnelCommWithActor(conversationactor) end
			end
		end
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, "left")
	elseif menu.contextMenuMode == "transactionlog" then
		local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[data]
		if entryIdx == nil then
			return
		end
		local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
		local active = (entry.partner ~= 0) and C.IsComponentOperational(entry.partner)

		local row = ftable:addRow(false, { fixed = true })
		local text = TruncateText(entry.partnername, Helper.standardFontBold, Helper.scaleFont(Helper.standardFontBold, Helper.headerRow1FontSize), contextmenuwidth - 2 * Helper.scaleX(Helper.standardButtonWidth))
		row[1]:createText(text, Helper.headerRowCenteredProperties)
		row[1].properties.mouseOverText = entry.partnername

		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = active, bgColor = active and Helper.color.transparent or Helper.color.darkgrey }):setText(ReadText(1001, 2427), { color = active and Helper.color.white or Helper.color.lightgrey })
		row[1].handlers.onClick = function () return menu.buttonContainerInfo(entry.partner) end

		if active and GetComponentData(ConvertStringTo64Bit(tostring(entry.partner)), "isplayerowned") then
			row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createButton({ active = active, bgColor = active and Helper.color.transparent or Helper.color.darkgrey }):setText(ReadText(1001, 7702), { color = active and Helper.color.white or Helper.color.lightgrey })
			row[1].handlers.onClick = function () return menu.buttonTransactionLog(entry.partner) end
		end
	end

	if menu.contextFrame.properties.x + contextmenuwidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - contextmenuwidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()

	if not nomouseout then
		menu.mouseOutBox = {
			x1 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2                    - config.mouseOutRange,
			x2 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2 + contextmenuwidth + config.mouseOutRange,
			y1 = - menu.contextFrame.properties.y + Helper.viewHeight / 2                    + config.mouseOutRange,
			y2 = - menu.contextFrame.properties.y + Helper.viewHeight / 2 - height           - config.mouseOutRange
		}
	end
end

function menu.refreshContextFrame(setrow, setcol)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	local y = menu.contextFrame.properties.y
	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		width = menu.contextFrame.properties.width,
		x = menu.contextFrame.properties.x,
		y = 0,
		autoFrameHeight = true,
	})

	if menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, "left")
	end

	if menu.contextFrame.properties.x + menu.contextMenuWidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - menu.contextMenuWidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()
end

function menu.buttonPersonnelCommWithActor(actor)
	menu.closeContextMenu()
	if menu.conversationMenu then
		Helper.closeMenuForSubConversation(menu, "default", actor)
	else
		Helper.closeMenuForNewConversation(menu, "default", actor)
	end
	menu.cleanup()
end

function menu.buttonPersonnelReplacePilot(ship, oldpilot, newpilot)
	local oldpilotluaid = oldpilot and ConvertStringToLuaID(tostring(oldpilot))
	local post = (oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "poststring") or "aipilot"

	if not C.CanControllableHaveControlEntity(ship, post) then
		return false
	end

	if oldpilot then
		-- MD handles assignment of new pilot in this case.
		C.SignalObjectWithNPCSeed(oldpilot, "npc__control_dismissed", newpilot, ship)
	else
		newpilot = C.CreateNPCFromPerson(newpilot, ship)
		if C.SetEntityToPost(ship, newpilot, post) then
			SignalObject(ConvertStringTo64Bit(tostring(newpilot)), "npc_state_reinit")
		else
			DebugError("menu.infoSubmenuReplacePilot(): failed setting new pilot.")
		end
	end
	menu.empireData.init = true

	menu.closeContextMenu()
	menu.refresh = getElapsedTime() + 2
	menu.refreshdata = "reinitempire"
end

function menu.buttonPersonnelCancelTransfer(controllable, person)
	C.ReleasePersonFromCrewTransfer(controllable, person)

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.buttonPersonnelFireNPCConfirm(controllable, entity, person, name)
	menu.closeContextMenu()

	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fire", controllable = controllable, entity = entity, person = person, name = name, width = Helper.scaleX(400), xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

	menu.createUserQuestionFrame()
end

function menu.buttonPersonnelFireNPC(controllable, entity, person)
	if entity then
		SignalObject(ConvertStringTo64Bit(tostring(entity)), "npc__control_dismissed")
	else
		C.RemovePerson(controllable, person)
	end
	menu.empireData.init = true

	menu.closeContextMenu()
	menu.refresh = getElapsedTime()
	menu.refreshdata = "reinitempire"
end

function menu.buttonWarDeclarationConfirm(faction)
	menu.closeContextMenu()

	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "wardeclaration", faction = faction, width = Helper.scaleX(400), xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

	menu.createUserQuestionFrame()
end

function menu.butttonWarDeclaration(faction)
	C.SetFactionRelationToPlayerFaction(faction, "wardeclaration", -0.32)
	menu.closeContextMenu()
	menu.refresh = getElapsedTime()
end

function menu.buttonUserQuestionConfirm()
	if menu.contextMenuData.mode == "fire" then
		menu.buttonPersonnelFireNPC(menu.contextMenuData.controllable, menu.contextMenuData.entity, menu.contextMenuData.person)
	elseif menu.contextMenuData.mode == "wardeclaration" then
		menu.butttonWarDeclaration(menu.contextMenuData.faction)
	elseif menu.contextMenuData.mode == "clearlogbook" then
		menu.buttonLogbookClear(menu.contextMenuData.category)
	end
end

function menu.buttonContainerInfo(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", controllable } })
	menu.cleanup()
end

function menu.buttonTransactionLog(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, controllable });
	menu.cleanup()
end

function menu.createUserQuestionFrame()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - 2 * Helper.borderSize,
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + 2 * Helper.borderSize,
		layer = config.contextLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
	})

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	if menu.contextMenuData.mode == "fire" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 11202), menu.contextMenuData.name), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 11201), { wordwrap = true })
	elseif menu.contextMenuData.mode == "wardeclaration" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7751), menu.contextMenuData.name), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 7752), { wordwrap = true })
	elseif menu.contextMenuData.mode == "clearlogbook" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 5722), menu.contextMenuData.name), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText((menu.contextMenuData.category == "all") and ReadText(1001, 5723) or ReadText(1001, 5724), { wordwrap = true })
	end

	ftable:addEmptyRow(Helper.standardTextHeight)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
	row[2].handlers.onClick = menu.buttonUserQuestionConfirm
	row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
	row[4].handlers.onClick = menu.closeContextMenu

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	menu.contextFrame:display()
end

function menu.closeContextMenu()
	Helper.clearTableConnectionColumn(menu, 4)
	Helper.clearFrame(menu, config.contextLayer)
	menu.contextMenuMode = nil
	menu.mouseOutBox = nil
end

function menu.viewCreated(layer, ...)
	if layer == config.mainLayer then
		menu.mainTable = ...
	elseif layer == config.infoLayer then
		if menu.mode == "logbook" then
			menu.topLevelTable, menu.titleTable, menu.infoTable, menu.buttonTable = ...
		else
			menu.topLevelTable, menu.infoTable, menu.buttonTable = ...
		end
	end
end

function menu.onInteractiveElementChanged(element)
	menu.lastactivetable = element
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	if menu.activatecutscene then
		if menu.setupEmpireRenderTarget() then
			menu.activatecutscene = nil
		end
	end
	if menu.messageData.activatecutscene then
		if menu.setupMessageRenderTarget() then
			menu.messageData.activatecutscene = nil
		end
	end
	if menu.inventoryData.activatecutscene then
		if menu.setupInventoryRenderTarget() then
			menu.inventoryData.activatecutscene = nil
		end
	end
	if menu.personnelData.activatecutscene then
		if menu.setupPersonnelRenderTarget() then
			menu.personnelData.activatecutscene = nil
		end
	end

	if Helper.hasExtension("multiverse") then
		if Helper.callExtensionFunction("multiverse", "updateVentures", menu) then
			menu.refreshInfoFrame()
		end
	end

	menu.mainFrame:update()
	menu.infoFrame:update()
	if (menu.contextMenuMode == "blacklistfaction") or (menu.contextMenuMode == "blacklistsector") or (menu.contextMenuMode == "illegalwares") or (menu.contextMenuMode == "playeralertclass") or (menu.contextMenuMode == "playeralertfaction") or (menu.contextMenuMode == "playeralertsector") or (menu.contextMenuMode == "traderulefaction") then
		menu.contextFrame:update()
	end

	if menu.mouseOutBox then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.mode == "transactionlog" then
		Helper.onTransactionLogUpdate()
		if not Helper.transactionLogData.noupdate then
			local curtime = getElapsedTime()
			if curtime > menu.lastTransactionLogRefreshTime + 10 then
				menu.refreshInfoFrame()
			end
		end
	end

	local curtime = getElapsedTime()
	if menu.over then
		menu.over = nil
		menu.refresh = curtime - 1
	end

	if menu.inputModeHasChanged then
		if not menu.noupdate then
			menu.refresh = curtime - 1
			menu.inputModeHasChanged = nil
		end
	end

	if menu.refresh and (menu.refresh < curtime) then
		if menu.refreshdata then
			if menu.refreshdata == "reinitempire" then
				menu.empireData.init = true
				menu.personnelData.curEntry = {}
				menu.refreshInfoFrame()
			else
				menu.refreshInfoFrame(table.unpack(menu.refreshdata))
			end
		else
			menu.refreshInfoFrame()
		end
		menu.refreshdata = nil
		menu.refresh = nil
	end
end

function menu.updateSelectedRows()
	menu.inventoryData.selectedWares = {}
	local rows, highlightedborderrow = GetSelectedRows(menu.inventoryInfoTable.id)
	for _, row in ipairs(rows) do
		local rowdata = menu.rowDataMap[menu.inventoryInfoTable.id][row]
		if type(rowdata) == "table" then
			menu.inventoryData.selectedWares[rowdata[1]] = true
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable, modified, input)
	if uitable == menu.infoTable then
		if (menu.mode == "inventory") or (menu.mode == "spacesuit") then
			menu.onInventoryRowChange(row, rowdata, input, menu.mode)
		elseif menu.mode == "crafting" then
			if type(rowdata) == "table" then
				if menu.inventoryData.mode ~= "craft" then
					local isunbundleammo, component = GetWareData(rowdata[1], "isunbundleammo", "component")
					local ammospace = false
					if isunbundleammo then
						local playership = C.GetPlayerOccupiedShipID()
						if playership ~= 0 then
							ammospace = AddAmmo(ConvertStringToLuaID(tostring(playership)), component, 1, true) == 1
						end
					end

					local row = 1
					if menu.inventoryData.craftingHistory[1] then
						row = row + math.min(3, #menu.inventoryData.craftingHistory) + 2
					end

					if menu.findInventoryWare(menu.craftable, rowdata[1]) then
						local mot_craft = ""
						local active = false
						if rowdata[2].craftable > 0 then
							if (not isunbundleammo) or ammospace then
								mot_craft = ReadText(1026, 3900)
								active = true
							else
								mot_craft = ReadText(1026, 3903)
							end
						else
							mot_craft = ReadText(1026, 3901)
						end

						Helper.removeButtonScripts(menu, menu.buttonTable, row, 1)
						SetCellContent(menu.buttonTable, Helper.createButton(Helper.createTextInfo(ReadText(1001, 7706), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, active, 0, 0, 0, Helper.standardButtonHeight, nil, nil, nil, mot_craft), row, 1)
						Helper.setButtonScript(menu, nil, menu.buttonTable, row, 1, menu.buttonInventoryCraft)
					else
						Helper.removeButtonScripts(menu, menu.buttonTable, row, 1)
						SetCellContent(menu.buttonTable, Helper.getEmptyCellDescriptor(), row, 1)
					end
				end
			end
		elseif menu.mode == "factions" then
			if type(rowdata) == "table" then
				if rowdata[2].id ~= menu.factionData.curEntry.id then
					menu.factionData.curEntry = rowdata[2]
					menu.refresh = getElapsedTime()
				end
			end
		elseif menu.mode == "messages" then
			if type(rowdata) == "table" then
				if rowdata.id ~= menu.messageData.curEntry.id then
					if next(menu.messageData.curEntry) then
						C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
						AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
					end
					menu.messageData.curEntry = rowdata
					menu.messageData.showFullscreen = nil
					menu.cleanupCutsceneRenderTarget()
					menu.refresh = getElapsedTime()
				end
			end
		elseif menu.mode == "personnel" then
			if type(rowdata) == "table" then
				if rowdata[2].id ~= menu.personnelData.curEntry.id then
					menu.personnelData.curEntry = rowdata[2]
					menu.refresh = getElapsedTime()
				end
			end
		elseif menu.mode == "transactionlog" then
			Helper.onTransactionLogRowChanged(rowdata)
		elseif (menu.mode == "empire") or (menu.mode == "globalorders") then
			if (type(rowdata) == "table") and ((menu.empireData.mode[2] ~= rowdata[2]) or ((type(rowdata[3]) == "table") and ((menu.empireData.mode[3].id ~= rowdata[3].id) or (menu.empireData.mode[3].index ~= rowdata[3].index)))) then
				--print("onRowChanged. row: " .. tostring(row) .. ". rowdata 1: " .. tostring(rowdata[1]) .. ", rowdata 2: " .. tostring(rowdata[2]) .. ". oldmode 1: " .. tostring(menu.empireData.mode[1]) .. ", oldmode 2: " .. tostring(menu.empireData.mode[2]))
				--menu.empireData.oldmode = menu.empireData.mode
				if ((menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
					menu.inventoryData.selectedWares = {}
					C.ReadAllInventoryWares()
				end
				menu.empireData.mode = rowdata

				-- always clear the selected object when changing modes. selectedobject will be populated right after as appropriate.
				menu.empireData.selectedobject = nil
				menu.empireData.objecttype = nil

				menu.over = true
			end
		end
	elseif ((menu.mode == "empire") or (menu.mode == "globalorders")) and menu.empireData.mode and (type(menu.empireData.mode) == "table") then
		--print("mode 1: " .. tostring(menu.empireData.mode[1]) .. ", mode 2: " .. tostring(menu.empireData.mode[2]))
		if (menu.empireData.mode[1] == "empire_grid") then
			local changed = nil

			if (menu.empireData.mode[2] == "logo") or (menu.empireData.mode[2] == "painttheme") then
				local locship = ConvertStringTo64Bit(tostring(C.GetLastPlayerControlledShipID()))
				if locship and (locship ~= 0) and (locship ~= menu.empireData.selectedobject) and menu.empireCanShowObject(locship) and (not C.IsComponentClass(locship, "spacesuit")) and (not GetComponentData(locship, "paintmodlocked")) then
					--print("changing object from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(locship))
					menu.empireData.selectedobject = locship
					menu.empireData.objecttype = "object"
					changed = true
				end

				if (not menu.empireData.selectedobject) and (#menu.empireData.ships > 0) then
					for _, ship in ipairs(menu.empireData.ships) do
						if menu.empireCanShowObject(ship) and (not GetComponentData(ship, "paintmodlocked")) then
							menu.empireData.selectedobject = ship
							menu.empireData.objecttype = "object"
							changed = true
							break
						end
					end
				end
				--print("grid. selected object: " .. tostring(menu.empireData.selectedobject))
			elseif (menu.empireData.mode[2] == "uniform") then
				if not menu.empireData.selectedobject or (menu.empireData.objecttype ~= "npc") then
					for _, employeedata in ipairs(menu.empireData.employees) do
						if (employeedata.type == "entity") and menu.empireCanShowObject(employeedata.id) then
							if (menu.empireData.selectedobject ~= employeedata.id) then
								--print("switching selectedobject from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(employeedata.id))
								menu.empireData.selectedobject = employeedata.id
								menu.empireData.objecttype = "npc"
								changed = true
							end
							break
						end
					end
				end
			end

			if changed then
				menu.over = true
			end
		elseif (menu.empireData.mode[1] == "empire_list") then
			--print("rowdata type: " .. tostring(type(rowdata)) .. ", rowdata: " .. tostring(rowdata))
			if (type(rowdata) == "table") then
				local changed = nil

				if (rowdata[1] == "painttheme") then
					local locship = ConvertStringTo64Bit(tostring(C.GetLastPlayerControlledShipID()))
					if locship and (locship ~= 0) and (locship ~= menu.empireData.selectedobject) and menu.empireCanShowObject(locship) and not C.IsComponentClass(locship, "spacesuit") then
						--print("changing object from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(locship))
						menu.empireData.selectedobject = locship
						menu.empireData.objecttype = "object"
						changed = true
					end

					if not menu.empireData.selectedobject and #menu.empireData.ships > 0 then
						for _, ship in ipairs(menu.empireData.ships) do
							if menu.empireCanShowObject(ship) then
								menu.empireData.selectedobject = ship
								menu.empireData.objecttype = "object"
								changed = true
								break
							end
						end
					end

					--print("current theme: " .. ffi.string(C.GetPlayerPaintTheme()) .. ", new theme: " .. tostring(rowdata[2]))
					if (ffi.string(C.GetPlayerPaintTheme()) ~= rowdata[2]) then
						C.SetPlayerPaintTheme(rowdata[2])
						--print("new paint theme set: " .. ffi.string(C.GetPlayerPaintTheme()))
					end
				elseif (rowdata[1] == "uniform") then
					if not menu.empireData.selectedobject or (menu.empireData.objecttype ~= "npc") then
						for _, employeedata in ipairs(menu.empireData.employees) do
							if (employeedata.type == "entity") and menu.empireCanShowObject(employeedata.id) then
								if (menu.empireData.selectedobject ~= employeedata.id) then
									--print("switching selectedobject from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(employeedata.id))
									menu.empireData.selectedobject = employeedata.id
									menu.empireData.objecttype = "npc"
									changed = true
								end
								break
							end
						end
					end

					--print("current uniform: " .. ffi.string(C.GetPlayerClothingTheme()) .. ", new uniform: " .. tostring(rowdata[2]))
					if (ffi.string(C.GetPlayerClothingTheme()) ~= rowdata[2]) then
						C.SetPlayerClothingTheme(rowdata[2])
						--print("new uniform set: " .. ffi.string(C.GetPlayerClothingTheme()))
					end
				elseif (rowdata[1] == "empire_ship") or (rowdata[1] == "empire_station") or (rowdata[1] == "empire_onlineship") then
					if rowdata[2] and menu.empireCanShowObject(rowdata[2]) then
						if (menu.empireData.selectedobject ~= rowdata[2]) then
							menu.empireData.selectedobject = rowdata[2]
							menu.empireData.objecttype = "object"
							changed = true
							--print("selected object: " .. ffi.string(C.GetComponentName(rowdata[2])))
						end
					end
				elseif (rowdata[1] == "empire_employee") then
					if (rowdata[2].type == "entity") then
						if menu.empireCanShowObject(rowdata[2].id) and (menu.empireData.selectedobject ~= rowdata[2].id) then
							--print("switching selectedobject from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(rowdata[2].id))
							menu.empireData.selectedobject = rowdata[2].id
							menu.empireData.objecttype = "npc"
							changed = true
							--print("selected entity: " .. rowdata[2].name .. " " .. tostring(rowdata[2].id))
						end
					elseif (rowdata[2].type == "person") then
						local instantiatedperson = ConvertStringTo64Bit(tostring(C.GetInstantiatedPerson(rowdata[2].id, rowdata[2].container)))
						if (instantiatedperson ~= 0) and menu.empireCanShowObject(instantiatedperson) and (menu.empireData.selectedobject ~= instantiatedperson) then
							menu.empireData.selectedobject = instantiatedperson
							menu.empireData.objecttype = "npc"
							changed = true
							--print("selected person: " .. rowdata[2].name .. " " .. tostring(rowdata[2].id))
						end
					else
						DebugError("Empire Menu: unsupported employee type: " .. tostring(rowdata[2].type))
					end
				end

				if changed then
					menu.setselectedrow2 = row
					menu.over = true
				end
			end
		elseif (menu.empireData.mode[1] == "empire_call") then
			local changed = nil

			if (menu.empireData.mode[2] == "inventory") then
				if (type(rowdata) == "table") and (not menu.empireData.selectedobject or menu.empireData.selectedobject ~= rowdata[1]) then
					--print("ware: " .. tostring(rowdata[1]))
					menu.empireData.selectedobject = rowdata[1]
					menu.empireData.objecttype = "ware"
					changed = true
				end
				menu.onInventoryRowChange(row, rowdata, input, menu.empireData.mode[2])
			end

			if changed then
				menu.setselectedrow2 = row
				menu.over = true
			end
		end
	end

	-- kuertee start: callback
	if callbacks ["onRowChanged"] then
		for _, callback in ipairs (callbacks ["onRowChanged"]) do
			callback (row, rowdata, uitable, modified, input)
		end
	end
	-- kuertee end: callback
end

function menu.onInventoryRowChange(row, rowdata, input, mode)
	if type(rowdata) == "table" then
		menu.closeContextMenu()
		menu.updateSelectedRows()

		if not menu.skipread then
			C.ReadInventoryWare(rowdata[1])
			local name = menu.getInventoryName(rowdata[1], rowdata[2], true)
			Helper.updateCellText(menu.inventoryInfoTable.id, row, 1, name)
			if (input ~= "mouse") and (row > 1) then
				local prevrowdata = menu.rowDataMap[menu.inventoryInfoTable.id][row - 1]
				if type(prevrowdata) == "table" then
					C.ReadInventoryWare(prevrowdata[1])
					local name = menu.getInventoryName(prevrowdata[1], prevrowdata[2], true)
					Helper.updateCellText(menu.inventoryInfoTable.id, row - 1, 1, name)
				end
			end
		end
		menu.skipread = nil

		if menu.inventoryData.mode ~= "drop" then
			local buttonrow = (mode == "inventory") and 6 or 3
			Helper.removeButtonScripts(menu, menu.inventoryButtonTable.id, buttonrow, 1)
			local count = 0
			local allowdrop = false
			for ware in pairs(menu.inventoryData.selectedWares) do
				if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
					count = count + 1
					allowdrop = true
				end
			end
			local active = GetWareData(rowdata[1], "allowdrop") and (not menu.onlineitems[rowdata[1]])
			SetCellContent(menu.inventoryButtonTable.id, Helper.createButton(Helper.createTextInfo((count > 1) and ReadText(1001, 7733) or ReadText(1001, 7705), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, active, 0, 0, 0, Helper.standardButtonHeight, nil), buttonrow, 1)
			Helper.setButtonScript(menu, nil, menu.inventoryButtonTable.id, buttonrow, 1, menu.buttonInventoryDrop)

			if rowdata[1] ~= menu.inventoryData.curEntry[1] then
				menu.inventoryData.curEntry = rowdata
				menu.refresh = getElapsedTime()
			end
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
	--print("menu.onSelectElement")
	local rowdata = Helper.getCurrentRowData(menu, uitable)
	if uitable == menu.infoTable then
		if (menu.mode == "inventory") or (menu.mode == "spacesuit") then
			if type(rowdata) == "table" then
				menu.closeContextMenu()
			end
		end
	end
end

function menu.onEditBoxActivated(widget)
	menu.noupdate = true
	if menu.logbookPageEditBox and (widget == menu.logbookPageEditBox.id) then
		C.SetEditBoxText(menu.logbookPageEditBox.id, tostring(menu.logbookData.curPage))
	elseif menu.personnelPageEditBox and (widget == menu.personnelPageEditBox.id) then
		C.SetEditBoxText(menu.personnelPageEditBox.id, tostring(menu.personnelData.curPage))
	elseif menu.mode == "transactionlog" then
		Helper.onTransactionLogEditBoxActivated(widget)
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if (menu.mode == "inventory") or (menu.mode == "spacesuit") then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if type(rowdata) == "table" then
				menu.inventoryData.selectedWares[rowdata[1]] = true

				local rows = {}
				for row2, rowdata2 in pairs(menu.rowDataMap[uitable]) do
					if type(rowdata2) == "table" then
						if menu.inventoryData.selectedWares[rowdata2[1]] then
							table.insert(rows, row2)
						end
					end
				end
				SetSelectedRows(menu.infoTable, rows, row)

				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextMenuMode = "inventory"
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		end
	elseif menu.mode == "personnel" then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if type(rowdata) == "table" then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextMenuMode = "personnel"
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		end
	elseif menu.mode == "transactionlog" then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]

			local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[rowdata]
			if entryIdx == nil then
				return
			end
			local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
			if entry.partnername ~= "" then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextMenuMode = "transactionlog"
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y, Helper.scaleX(260))
			end
		end
	end
end

function menu.closeMenu(dueToClose)
	if next(menu.messageData.curEntry) then
		C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
		AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
		menu.messageData.showFullscreen = nil
		if menu.messageData.curEntry.category == "lowprio" then
			menu.messageData.curEntry = {}
		end
	end
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose)
	if menu.contextMenuMode then
		menu.closeContextMenu()
	elseif menu.messageData.showFullscreen and (dueToClose == "back") then
		menu.messageData.showFullscreen = nil
		menu.refreshInfoFrame()
	elseif menu.mode and (dueToClose == "back") then
		menu.deactivatePlayerInfo()
	else
		menu.closeMenu(dueToClose)
	end
end

-- menu helpers

function menu.getInventoryName(ware, waredata, showunread)
	local volatile, gift, unread = GetWareData(ware, "volatile", "gift", "isunreadinventory")

	local name = waredata.name .. (volatile and " [" .. ReadText(1001, 3902) .. "]" or "") .. (gift and " [" .. ReadText(1001, 3903) .. "]" or "")
	local color = Helper.standardColor
	if menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction) then
		color = Helper.color.illegal
	end
	if showunread and unread then
		name = Helper.convertColorToText(Helper.color.orange) .. "\027[workshop_error]\027X " .. name
	end

	return name, color
end

function menu.addInventoryWareEntry(ftable, ware, waredata, iscrafting, isresource, hideprice, isonline)
	local bgColor = Helper.color.transparent
	if iscrafting and (not isresource) then
		bgColor = Helper.defaultTitleBackgroundColor
	end
	local row = ftable:addRow({ware, waredata}, { bgColor = bgColor, multiSelected = menu.inventoryData.selectedWares[ware] })

	-- name
	local rawname, color = menu.getInventoryName(ware, waredata, not iscrafting)
	local name = rawname
	if isresource then
		name = "    " .. name
	end
	row[1]:setColSpan(hideprice and 4 or 1)
	row[1]:createText(name, { color = color })
	if not hideprice then
		-- amount
		if isresource then
			row[2]:createText(waredata.amount .. " / " .. waredata.needed, config.rightAlignTextProperties)
		else
			row[2]:createText(waredata.amount, config.rightAlignTextProperties)
		end
		-- base price
		local avgprice = GetWareData(ware, "avgprice")
		row[3]:createText(ConvertMoneyString(avgprice, false, true, 0, true) .. " " .. ReadText(1001, 101), config.rightAlignTextProperties)
		-- total price
		row[4]:createText(ConvertMoneyString(avgprice * waredata.amount, false, true, 0, true) .. " " .. ReadText(1001, 101), config.rightAlignTextProperties)
	end

	local ispaintmod = GetWareData(ware, "ispaintmod")
	if ispaintmod then
		AddKnownItem("paintmods", ware)
	else
		AddKnownItem("inventory_wares", ware)
	end
end

function menu.findInventoryWare(array, ware)
	for _, entry in ipairs(array) do
		if entry.ware == ware then
			return true
		end
	end
	return false
end

function menu.createCraftableEntry(ware)
	if not menu.findInventoryWare(menu.craftable, ware) then
		local waredata
		if menu.inventory[ware] then
			waredata = menu.inventory[ware]
		else
			local name, buyprice = GetWareData(ware, "name", "buyprice")
			waredata = { name = name, amount = 0, price = buyprice }
		end

		local resources = {}
		local rawresources = GetWareData(ware, "resources")
		local resourcecount = 0
		local craftableamount
		if #rawresources > 0 then
			for _, resource in ipairs(rawresources) do
				local resourcedata = menu.inventory[resource.ware]
				if resourcedata then
					resourcecount = resourcecount + resourcedata.amount
					local maxcraftable = math.floor(resourcedata.amount / resource.amount)
					craftableamount = craftableamount and math.min(maxcraftable, craftableamount) or maxcraftable
					table.insert(resources, { ware = resource.ware, data = { name = resourcedata.name, amount = resourcedata.amount, price = resourcedata.price, needed = resource.amount } })
				else
					local resourcename, resourcebuyprice = GetWareData(resource.ware, "name", "buyprice")
					craftableamount = 0
					table.insert(resources, { ware = resource.ware, data = { name = resourcename, amount = 0, price = resourcebuyprice, needed = resource.amount } })
				end
			end
		else
			craftableamount = 0
		end
		resources.count = resourcecount

		local isunbundleammo, component = GetWareData(ware, "isunbundleammo", "component")
		if isunbundleammo then
			local playership = C.GetPlayerOccupiedShipID()
			if playership ~= 0 then
				craftableamount = AddAmmo(ConvertStringToLuaID(tostring(playership)), component, craftableamount, true)
			end
		end
		waredata.craftable = craftableamount

		table.insert(menu.craftable, { ware = ware, data = waredata, resources = resources })
	end
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- 
	-- buttonTogglePlayerInfo_on_start (mode, config)
	-- createPlayerInfo_on_start (config)
	-- createInfoFrame_on_start ()
	-- createInfoFrame_on_info_frame_mode (infoFrame, tableProperties)
	-- createFactions_on_before_render_licences (frame, tableProperties, relation.id, infotable)
	-- createFactions_on_after_declare_war_button(frame, tableProperties, relation.id, infotable)
	-- createAccounts_add_new_table (frame, tableProperties, tabOrderOffset)
	-- createAccounts_add_new_table (frame, tableProperties, tabOrderOffset)
	-- onRowChanged (row, rowdata, uitable, modified, input)
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuertee end

init()
﻿-- section == cArch_configureships
-- param == { 0, 0, container, mode, modeparam, immediate }

-- modes:	"purchase",	param:	{}
--			"upgrade",			{ selectableships }
--			"modify",			{ [ paintonly = false, selectedships = {} ] }
--			"customgamestart",	{ gamestartid, creative, shipproperty, shiploadoutproperty, shippeopleproperty, shippeoplefillpercentageproperty, shippilotproperty, paintthemeproperty, playerpropertyid, propertymacro, propertycommander, propertypeopledef, propertypeoplefillpercentage }
--			"comparison",		{ id }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef int32_t BlacklistID;
	typedef uint64_t BuildTaskID;
	typedef int32_t FightRuleID;
	typedef uint64_t NPCSeed;
	typedef uint64_t UniverseID;
	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;
	typedef struct {
		const char* ammomacroname;
		const char* weaponmode;
	} UILoadoutWeaponSetting;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		BlacklistID id;
		const char* type;
	} BlacklistTypeID;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* newroleid;
		NPCSeed seed;
		uint32_t amount;
		int64_t price;
	} CrewTransferContainer2;
	typedef struct {
		CrewTransferContainer2* removed;
		uint32_t numremoved;
		CrewTransferContainer2* added;
		uint32_t numadded;
		CrewTransferContainer2* transferred;
		uint32_t numtransferred;
	} CrewTransferInfo2;
	typedef struct {
		uint32_t numremoved;
		uint32_t numadded;
		uint32_t numtransferred;
	} CrewTransferInfoCounts;
	typedef struct {
		const char* state;
		float defaultvalue;
	} CustomGameStartFloatPropertyState;
	typedef struct {
		const char* state;
	} CustomGameStartLoadoutPropertyState;
	typedef struct {
		const char* race;
		const char* tags;
		uint32_t numskills;
		SkillInfo* skills;
	} CustomGameStartPersonEntry;
	typedef struct {
		const char* state;
		const char* defaultvalue;
		const char* options;
	} CustomGameStartStringPropertyState;
	typedef struct {
		const char* tag;
		const char* name;
	} EquipmentCompatibilityInfo;
	typedef struct {
		const char* type;
		const char* ware;
		const char* macro;
		int amount;
	} EquipmentWareInfo;
	typedef struct {
		const char* PropertyType;
		float MinValueFloat;
		float MaxValueFloat;
		uint32_t MinValueUINT;
		uint32_t MaxValueUINT;
		uint32_t BonusMax;
		float BonusChance;
	} EquipmentModInfo;
	typedef struct {
		FightRuleID id;
		const char* type;
	} FightRuleTypeID;
	typedef struct {
		const char* id;
		const char* name;
		int32_t state;
		const char* requiredversion;
		const char* installedversion;
	} InvalidPatchInfo;
	typedef struct {
		const char* name;
		const char* icon;
	} LicenceInfo;
	typedef struct {
		MissionID missionid;
		const char* macroname;
		uint32_t amount;
	} MissionShipDeliveryInfo;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
	} PeopleDefinitionInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		UniverseID context;
		const char* group;
		UniverseID component;
	} ShieldGroup;
	typedef struct {
		const char* max;
		const char* current;
	} SoftwareSlot;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float ForwardThrustFactor;
		float StrafeThrustFactor;
		float RotationThrustFactor;
		float BoostThrustFactor;
		float BoostDurationFactor;
		float BoostAttackTimeFactor;
		float BoostReleaseTimeFactor;
		float BoostChargeTimeFactor;
		float BoostRechargeTimeFactor;
		float TravelThrustFactor;
		float TravelStartThrustFactor;
		float TravelAttackTimeFactor;
		float TravelReleaseTimeFactor;
		float TravelChargeTimeFactor;
	} UIEngineMod;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
	} UIEquipmentMod;
	typedef struct {
		const char* macro;
		uint32_t amount;
		bool optional;
	} UILoadoutAmmoData;
	typedef struct {
		const char* roleid;
		uint32_t count;
		bool optional;
	} UILoadoutCrewData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
	} UILoadoutGroupData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
		UILoadoutWeaponSetting weaponsetting;
	} UILoadoutGroupData2;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
	} UILoadoutMacroData;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
		UILoadoutWeaponSetting weaponsetting;
	} UILoadoutMacroData2;
	typedef struct {
		const char* ware;
	} UILoadoutSoftwareData;
	typedef struct {
		const char* macro;
		bool optional;
	} UILoadoutVirtualMacroData;
	typedef struct {
		uint32_t numweapons;
		uint32_t numturrets;
		uint32_t numshields;
		uint32_t numengines;
		uint32_t numturretgroups;
		uint32_t numshieldgroups;
		uint32_t numammo;
		uint32_t numunits;
		uint32_t numsoftware;
		uint32_t numcrew;
	} UILoadoutCounts2;
	typedef struct {
		UILoadoutMacroData* weapons;
		uint32_t numweapons;
		UILoadoutMacroData* turrets;
		uint32_t numturrets;
		UILoadoutMacroData* shields;
		uint32_t numshields;
		UILoadoutMacroData* engines;
		uint32_t numengines;
		UILoadoutGroupData* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
	} UILoadout;
	typedef struct {
		UILoadoutMacroData2* weapons;
		uint32_t numweapons;
		UILoadoutMacroData2* turrets;
		uint32_t numturrets;
		UILoadoutMacroData2* shields;
		uint32_t numshields;
		UILoadoutMacroData2* engines;
		uint32_t numengines;
		UILoadoutGroupData2* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData2* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
		uint32_t numcrew;
		UILoadoutCrewData* crew;
		bool hascrewexperience;
	} UILoadout2;
	typedef struct {
		const char* id;
		const char* name;
		const char* iconid;
		bool deleteable;
	} UILoadoutInfo;
	typedef struct {
		const char* upgradetype;
		size_t slot;
	} UILoadoutSlot;
	typedef struct {
		float HullValue;
		float ShieldValue;
		double ShieldDelay;
		float ShieldRate;
		float GroupedShieldValue;
		double GroupedShieldDelay;
		float GroupedShieldRate;
		float BurstDPS;
		float SustainedDPS;
		float TurretBurstDPS;
		float TurretSustainedDPS;
		float GroupedTurretBurstDPS;
		float GroupedTurretSustainedDPS;
		float ForwardSpeed;
		float BoostSpeed;
		float TravelSpeed;
		float YawSpeed;
		float PitchSpeed;
		float RollSpeed;
		float HorizontalStrafeSpeed;
		float VerticalStrafeSpeed;
		float ForwardAcceleration;
		float HorizontalStrafeAcceleration;
		float VerticalStrafeAcceleration;
		uint32_t NumDocksShipMedium;
		uint32_t NumDocksShipSmall;
		uint32_t ShipCapacityMedium;
		uint32_t ShipCapacitySmall;
		uint32_t CrewCapacity;
		uint32_t ContainerCapacity;
		uint32_t SolidCapacity;
		uint32_t LiquidCapacity;
		uint32_t CondensateCapacity;
		uint32_t UnitCapacity;
		uint32_t MissileCapacity;
		uint32_t CountermeasureCapacity;
		uint32_t DeployableCapacity;
		float RadarRange;
	} UILoadoutStatistics4;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		uint32_t Amount;
	} UIPaintMod;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float CapacityFactor;
		float RechargeDelayFactor;
		float RechargeRateFactor;
	} UIShieldMod;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float DamageFactor;
		float CoolingFactor;
		float ReloadFactor;
		float SpeedFactor;
		float LifeTimeFactor;
		float MiningFactor;
		float StickTimeFactor;
		float ChargeTimeFactor;
		float BeamLengthFactor;
		uint32_t AddedAmount;
		float RotationSpeedFactor;
		float SurfaceElementFactor;
	} UIWeaponMod;
	typedef struct {
		const char* macro;
		const char* category;
		uint32_t amount;
	} UnitData;
	typedef struct {
		const char* path;
		const char* group;
	} UpgradeGroup;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;
	typedef struct {
		UniverseID shipid;
		const char* macroname;
		UILoadout loadout;
		uint32_t amount;
	} UIBuildOrderList;
	typedef struct {
		BlacklistTypeID* blacklists;
		uint32_t numblacklists;
		FightRuleTypeID* fightrules;
		uint32_t numfightrules;
	} AddBuildTask5Container;
	BuildTaskID AddBuildTask4(UniverseID containerid, UniverseID defensibleid, const char* macroname, UILoadout2 uiloadout, int64_t price, CrewTransferInfo2 crewtransfer, bool immediate, const char* customname);
	BuildTaskID AddBuildTask5(UniverseID containerid, UniverseID defensibleid, const char* macroname, UILoadout2 uiloadout, int64_t price, CrewTransferInfo2 crewtransfer, bool immediate, const char* customname, AddBuildTask5Container* additionalinfo);
	bool CanApplyKnownLoadout(const char* macroname, const char* loadoutid);
	bool CanBuildLoadout(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	bool CanBuildMissionLoadout(UniverseID containerid, MissionID missionid, const char* uimacroname);
	bool CanContainerEquipShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerSupplyShip(UniverseID containerid, UniverseID shipid);
	bool CanGenerateValidKnownLoadout(const char* macroname);
	bool CanGenerateValidLoadout(UniverseID containerid, const char* macroname);
	bool CanPlayerUseRace(const char* raceid, const char* postid);
	bool CheckGroupedShieldModCompatibility(UniverseID defensibleid, UniverseID contextid, const char* group, const char* wareid);
	bool CheckShipModCompatibility(UniverseID shipid, const char* wareid);
	bool CheckWeaponModCompatibility(UniverseID weaponid, const char* wareid);
	void ClearMapBehaviour(UniverseID holomapid);
	void ClearSelectedMapMacroSlots(UniverseID holomapid);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool defaultorder);
	void DismantleEngineMod(UniverseID objectid);
	void DismantleGroupedWeaponMod(UniverseID defensibleid, UniverseID contextid, const char* group);
	void DismantleShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group);
	void DismantleShipMod(UniverseID shipid);
	void DismantleWeaponMod(UniverseID weaponid);
	bool EnableOrder(UniverseID controllableid, size_t idx);
	EquipmentModInfo GetEquipmentModInfo(const char* wareid);
	void GenerateShipKnownLoadout2(UILoadout2* result, const char* macroname, float level);
	void GenerateShipKnownLoadoutCounts2(UILoadoutCounts2* result, const char* macroname, float level);
	void GenerateShipLoadout2(UILoadout2* result, UniverseID containerid, UniverseID shipid, const char* macroname, float level);
	void GenerateShipLoadoutCounts2(UILoadoutCounts2* result, UniverseID containerid, UniverseID shipid, const char* macroname, float level);
	uint32_t GetAllCountermeasures(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllEquipment(EquipmentWareInfo* result, uint32_t resultlen, bool playerblueprint);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMissiles(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAllRoles(PeopleInfo* result, uint32_t resultlen);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllShipMacros2(const char** result, uint32_t resultlen, bool playerblueprint, bool customgamestart);
	uint32_t GetAllUnits(UnitData* result, uint32_t resultlen, UniverseID defensibleid, bool onlydrones);
	uint32_t GetAvailableEquipment(EquipmentWareInfo* result, uint32_t resultlen, UniverseID containerid, const char* classid);
	uint32_t GetAvailableEquipmentMods(UIEquipmentMod* result, uint32_t resultlen);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	double GetBuildDuration(UniverseID containerid, UIBuildOrderList order);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetBuildResources(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* wareid);
	void GetBuildTaskCrewTransferInfo2(CrewTransferInfo2* result, UniverseID containerid, BuildTaskID id);
	BuildTaskInfo GetBuildTaskInfo(BuildTaskID id);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	int64_t GetBuildWarePrice(UniverseID containerid, const char* warename);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	uint32_t GetContainerBuilderMacros(const char** result, uint32_t resultlen, UniverseID containerid);
	float GetContainerBuildPriceFactor(UniverseID containerid);
	UILoadoutStatistics4 GetCurrentLoadoutStatistics4(UniverseID shipid);
	float GetCustomGameStartFloatProperty(const char* id, const char* propertyid, CustomGameStartFloatPropertyState* state);
	void GetCustomGameStartLoadoutProperty2(UILoadout2* result, const char* id, const char* propertyid);
	void GetCustomGameStartLoadoutPropertyCounts2(UILoadoutCounts2* result, const char* id, const char* propertyid);
	CustomGameStartLoadoutPropertyState GetCustomGameStartLoadoutPropertyState(const char* id, const char* propertyid);
	void GetCustomGameStartPlayerPropertyLoadout(UILoadout2* result, const char* id, const char* propertyid, const char* entryid);
	void GetCustomGameStartPlayerPropertyLoadoutCounts(UILoadoutCounts2* result, const char* id, const char* propertyid, const char* entryid);
	bool GetCustomGameStartPlayerPropertyPerson(CustomGameStartPersonEntry* result, const char* id, const char* propertyid, const char* entryid);
	int64_t GetCustomGameStartShipPeopleValue2(const char* id, const char* macroname, const char* peopledefid, float peoplefillpercentage);
	int64_t GetCustomGameStartShipPersonValue(const char* id, CustomGameStartPersonEntry uivalue);
	bool GetCustomGameStartShipPilot(CustomGameStartPersonEntry* result, const char* id, const char* propertyid);
	const char* GetCustomGameStartStringProperty(const char* id, const char* propertyid, CustomGameStartStringPropertyState* state);
	uint32_t GetDamagedSubComponents(UniverseID* result, uint32_t resultlen, UniverseID objectid);
	uint32_t GetDefaultLoadoutMacros(const char** result, uint32_t resultlen, const char* macroname);
	uint32_t GetDefaultMissileStorageCapacity(const char* macroname);
	uint32_t GetDefaultCountermeasureStorageCapacity(const char* macroname);
	uint32_t GetDefensibleDeployableCapacity(UniverseID defensibleid);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	const char* GetEquipmentModPropertyName(const char* wareid);
	bool GetInstalledEngineMod(UniverseID objectid, UIEngineMod* enginemod);
	bool GetInstalledPaintMod(UniverseID objectid, UIPaintMod* paintmod);
	bool GetInstalledShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group, UIShieldMod* shieldmod);
	bool GetInstalledWeaponMod(UniverseID weaponid, UIWeaponMod* weaponmod);
	uint32_t GetInventoryPaintMods(UIPaintMod* result, uint32_t resultlen);
	uint32_t GetLibraryEntryAliases(const char** result, uint32_t resultlen, const char* librarytypeid, const char* id);
	bool GetLicenceInfo(LicenceInfo* result, const char* factionid, const char* licenceid);
	void GetLoadout2(UILoadout2* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutCounts2(UILoadoutCounts2* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutsInfo(UILoadoutInfo* result, uint32_t resultlen, UniverseID componentid, const char* macroname);
	UILoadoutStatistics4 GetLoadoutStatistics4(UniverseID shipid, const char* macroname, UILoadout uiloadout);
	const char* GetMacroClass(const char* macroname);
	uint32_t GetMacroDeployableCapacity(const char* macroname);
	uint32_t GetMacroMissileCapacity(const char* macroname);
	UILoadoutStatistics4 GetMaxLoadoutStatistics4(UniverseID shipid, const char* macroname);
	uint32_t GetMissileCargo(UIWareInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetMissingBuildResources(UIWareInfo* result, uint32_t resultlen);
	uint32_t GetMissingLoadoutResources(UIWareInfo* result, uint32_t resultlen);
	void GetMissionLoadout(UILoadout2* result, MissionID missionid, const char* uimacroname);
	void GetMissionLoadoutCounts(UILoadoutCounts2* result, MissionID missionid, const char* uimacroname);
	uint32_t GetNumAllCountermeasures(UniverseID defensibleid);
	uint32_t GetNumAllEquipment(bool playerblueprint);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllMissiles(UniverseID defensibleid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumAllShipMacros2(bool playerblueprint, bool customgamestart);
	uint32_t GetNumAllUnits(UniverseID defensibleid, bool onlydrones);
	uint32_t GetNumAvailableEquipment(UniverseID containerid, const char* classid);
	uint32_t GetNumAvailableEquipmentMods();
	uint32_t GetNumBlacklistTypes(void);
	uint32_t GetNumBuildResources(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* wareid);
	CrewTransferInfoCounts GetNumBuildTaskCrewTransferInfo(UniverseID containerid, BuildTaskID id);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumContainerBuilderMacros(UniverseID containerid);
	uint32_t GetNumDefaultLoadoutMacros(const char* macroname);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumFightRuleTypes(void);
	uint32_t GetNumInventoryPaintMods(void);
	uint32_t GetNumLibraryEntryAliases(const char* librarytypeid, const char* id);
	uint32_t GetNumLoadoutsInfo(UniverseID componentid, const char* macroname);
	uint32_t GetNumMissileCargo(UniverseID containerid);
	uint32_t GetNumMissingBuildResources2(UniverseID containerid, UIBuildOrderList* orders, uint32_t numorders, bool playercase);
	uint32_t GetNumMissingLoadoutResources2(UniverseID containerid, UIBuildOrderList* orders, uint32_t numorders, bool playercase);
	uint32_t GetNumPlayerPeopleDefinitions(void);
	uint32_t GetNumRepairResources2(UniverseID containerid, UniverseID defensibleid, UniverseID componenttorepairid);
	uint32_t GetNumRequestedMissionShips(void);
	uint32_t GetNumShieldGroups(UniverseID defensibleid);
	uint32_t GetNumSkills(void);
	uint32_t GetNumSlotCompatibilities(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	uint32_t GetNumSoftwarePredecessors(const char* softwarename);
	uint32_t GetNumSoftwareSlots(UniverseID controllableid, const char* macroname);
	uint32_t GetNumSubComponents(UniverseID containerid);
	uint32_t GetNumSuitableBuildProcessors(UniverseID containerid, UniverseID objectid, const char* macroname);
	uint32_t GetNumUnitCargo(UniverseID containerid, bool onlydrones);
	uint32_t GetNumUpgradeGroupCompatibilities(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	size_t GetNumVirtualUpgradeSlots(UniverseID objectid, const char* macroname, const char* upgradetypename);
	const char* GetObjectIDCode(UniverseID objectid);
	bool GetPaintThemeMod(const char* themeid, const char* factionid, UIPaintMod* paintmod);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPeopleCapacity(UniverseID controllableid, const char* macroname, bool includecrew);
	bool GetPickedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadoutSlot* result);
	UniverseID GetPlayerOccupiedShipID(void);
	const char* GetPlayerPaintTheme(void);
	bool GetPlayerPaintThemeMod(UniverseID objectid, const char* macroname, UIPaintMod* paintmod);
	uint32_t GetPlayerPeopleDefinitions(PeopleDefinitionInfo* result, uint32_t resultlen);
	uint32_t GetPurchasableCargo(UniverseID containerid, const char*);
	int64_t GetRepairPrice(UniverseID componenttorepairid, UniverseID containerid);
	uint32_t GetRepairResources2(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID defensibleid, UniverseID componenttorepairid);
	uint32_t GetRequestedMissionShips(MissionShipDeliveryInfo* result, uint32_t resultlen);
	uint32_t GetRoleTierNPCs(NPCSeed* result, uint32_t resultlen, UniverseID controllableid, const char* role, int32_t skilllevel);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	bool GetShieldGroup(ShieldGroup* result, UniverseID defensibleid, UniverseID destructibleid);
	uint32_t GetShieldGroups(ShieldGroup* result, uint32_t resultlen, UniverseID defensibleid);
	int64_t GetShipValue(const char* macroname, UILoadout2 uiloadout);
	uint32_t GetSkills(SkillInfo* result, uint32_t resultlen);
	uint32_t GetSlotCompatibilities(EquipmentCompatibilityInfo* result, uint32_t resultlen, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	const char* GetSlotSize(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	const char* GetSoftwareMaxCompatibleVersion(UniverseID controllableid, const char* macroname, const char* softwarename);
	uint32_t GetSoftwarePredecessors(const char** result, uint32_t resultlen, const char* softwarename);
	uint32_t GetSoftwareSlots(SoftwareSlot* result, uint32_t resultlen, UniverseID controllableid, const char* macroname);
	uint32_t GetUnitCargo(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, bool onlydrones);
	uint32_t GetUpgradeGroupCompatibilities(EquipmentCompatibilityInfo* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	UpgradeGroupInfo GetUpgradeGroupInfo(UniverseID destructibleid, const char* macroname, const char* path, const char* group, const char* upgradetypename);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups(UpgradeGroup* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	const char* GetUpgradeSlotCurrentMacro(UniverseID objectid, UniverseID moduleid, const char* upgradetypename, size_t slot);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetVirtualUpgradeSlotCurrentMacro(UniverseID defensibleid, const char* upgradetypename, size_t slot);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasDefaultLoadout2(const char* macroname, bool allowloadoutoverride);
	bool HasResearched(const char* wareid);
	bool HasSuitableBuildModule(UniverseID containerid, UniverseID defensibleid, const char* macroname);
	bool IsNextStartAnimationSkipped(bool reset);
	bool InstallEngineMod(UniverseID objectid, const char* wareid);
	bool InstallGroupedWeaponMod(UniverseID defensibleid, UniverseID contextid, const char* group, const char* wareid);
	bool InstallPaintMod(UniverseID objectid, const char* wareid, bool useinventory);
	bool InstallShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group, const char* wareid);
	bool InstallShipMod(UniverseID shipid, const char* wareid);
	bool InstallWeaponMod(UniverseID weaponid, const char* wareid);
	bool IsAmmoMacroCompatible(const char* weaponmacroname, const char* ammomacroname);
	bool IsDeployableMacroCompatible(UniverseID containerid, const char* macroname, const char* deployablemacroname);
	bool IsLoadoutCompatible(const char* macroname, const char* loadoutid);
	bool IsLoadoutValid(UniverseID defensibleid, const char* macroname, const char* loadoutid, uint32_t* numinvalidpatches);
	bool IsSlotMandatory(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	bool IsSoftwareDefault(UniverseID controllableid, const char* macroname, const char* softwarename);
	bool IsUnitMacroCompatible(UniverseID containerid, const char* macroname, const char* unitmacroname);
	bool IsUpgradeMacroCompatible(UniverseID objectid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool IsVirtualUpgradeMacroCompatible(UniverseID defensibleid, const char* macroname, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool RemoveLoadout(const char* source, const char* macroname, const char* localid);
	void SaveLoadout2(const char* macroname, UILoadout2 uiloadout, const char* source, const char* id, bool overwrite, const char* name, const char* desc);
	void SetBuildTaskTransferredMoney(BuildTaskID id, int64_t value);
	void SetCustomGameStartFloatProperty(const char* id, const char* propertyid, float uivalue);
	const char* SetCustomGameStartPlayerPropertyMacroAndLoadout2(const char* id, const char* propertyid, const char* entryid, const char* commanderid, const char* macroname, UILoadout2 uiloadout);
	void SetCustomGameStartPlayerPropertyPeople(const char* id, const char* propertyid, const char* entryid, const char* peopledefid);
	void SetCustomGameStartPlayerPropertyPeopleFillPercentage2(const char* id, const char* propertyid, const char* entryid, float fillpercentage);
	void SetCustomGameStartPlayerPropertyPerson(const char* id, const char* propertyid, const char* entryid, CustomGameStartPersonEntry uivalue);
	void SetCustomGameStartShipAndLoadoutProperty2(const char* id, const char* shippropertyid, const char* loadoutpropertyid, const char* macroname, UILoadout2 uiloadout);
	void SetCustomGameStartShipPilot(const char* id, const char* propertyid, CustomGameStartPersonEntry uivalue);
	void SetCustomGameStartStringProperty(const char* id, const char* propertyid, const char* uivalue);
	void SetMapPaintMod(UniverseID holomapid, const char* wareid);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetPaintModLocked(UniverseID objectid, bool value);
	void SetSelectedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	void ShowObjectConfigurationMap2(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout, size_t cp_idx);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void UpdateObjectConfigurationMap(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout);
]]

local utf8 = require("utf8")

local menu = {
	name = "ShipConfigurationMenu",
	currentIdx = 0,
	expandedModSlots = {},
	expandedUpgrades = {},
	captainSelected = true,
	undoStack = {},
	undoIndex = 1,
	showStats = true,
	customgamestartpeopledef = "",
	equipmentfilter_races = {},
	equipmentfilter_races_y = 0,
	equipmentsearch_editboxrow = 0,
}

local config = {
	mainLayer = 5,
	infoLayer = 4,
	contextLayer = 2,
	classorder = { "ship_xl", "ship_l", "ship_m", "ship_s", "ship_xs" },
	leftBar = {
		{ name = ReadText(1001, 1103),	icon = "shipbuildst_engine",		mode = "engine",		iscapship = false },
		{ name = ReadText(1001, 8520),	icon = "shipbuildst_enginegroups",	mode = "enginegroup",	iscapship = true },
		{ name = ReadText(1001, 8001),	icon = "shipbuildst_thruster",		mode = "thruster" },
		{ name = ReadText(1001, 1317),	icon = "shipbuildst_shield",		mode = "shield" },
		{ name = ReadText(1001, 2663),	icon = "shipbuildst_weapon",		mode = "weapon" },
		{ name = ReadText(1001, 1319),	icon = "shipbuildst_turret",		mode = "turret",		iscapship = false },
		{ name = ReadText(1001, 7901),	icon = "shipbuildst_turretgroups",	mode = "turretgroup",	iscapship = true },
		{ name = ReadText(1001, 87),	icon = "shipbuildst_software",		mode = "software" },
		{ spacing = true,																			comparison = false },
		{ name = ReadText(1001, 8003),	icon = "shipbuildst_consumable",	mode = "consumables",	comparison = false },
		{ name = ReadText(1001, 80),	icon = "shipbuildst_crew",			mode = "crew",			comparison = false },
		{ spacing = true,																			customgamestart = false,	comparison = false,		hascontainer = true },
		{ name = ReadText(1001, 3000),	icon = "shipbuildst_repair",		mode = "repair",		customgamestart = false,	comparison = false,		hascontainer = true },
		{ spacing = true,																			comparison = false,			hascontainer = true },
		{ name = ReadText(1001, 8549),	icon = "tlt_optionsmenu",			mode = "settings",		comparison = false,			hascontainer = true },
	},
	leftBarMods = {
		{ name = ReadText(1001, 8038),	icon = "shipbuildst_chassis",		mode = "shipmods",		upgrademode = "ship",	modclass = "ship" },
		{ name = ReadText(1001, 6600),	icon = "shipbuildst_weapon",		mode = "weaponmods",	upgrademode = "weapon",	modclass = "weapon" },
		{ name = ReadText(1001, 8004),	icon = "shipbuildst_turret",		mode = "turretmods",	upgrademode = "turret",	modclass = "weapon" },
		{ name = ReadText(1001, 8515),	icon = "shipbuildst_shield",		mode = "shieldmods",	upgrademode = "shield",	modclass = "shield" },
		{ name = ReadText(1001, 8028),	icon = "shipbuildst_engine",		mode = "enginemods",	upgrademode = "engine",	modclass = "engine" },
		{ name = ReadText(1001, 8510),	icon = "shipbuildst_paint",			mode = "paintmods",		upgrademode = "paint",	modclass = "paint" },
	},
	dropDownTextProperties = {
		halign = "center",
		font = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Helper.color.white,
		x = 0,
		y = 0
	},
	stateKeys = {
		{ "object", "UniverseID" },
		{ "macro" },
		{ "class" },
		{ "upgradetypeMode" },
		{ "currentSlot" },
		{ "upgradeplan" },
		{ "crew" },
		{ "editingshoppinglist" },
		{ "loadoutName" },
		{ "captainSelected", "bool" },
		{ "validLicence", "bool" },
		{ "validLoadoutPossible", "bool" },
		{ "shoppinglist" },
	},
	dropdownRatios = {
		class = 0.7,
		ship = 1.3,
	},
	stats = {
		{ id = "HullValue",					name = ReadText(1001, 8048),	unit = ReadText(1001, 118),	type = "float",		accuracy = 0 },
		{ id = "ShieldValue",				name = ReadText(1001, 8049),	unit = ReadText(1001, 118),	type = "float",		accuracy = 0 },
		{ id = "ShieldRate",				name = "   " .. ReadText(1001, 8553),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "ShieldDelay",				name = "   " .. ReadText(1001, 8554),	unit = ReadText(1001, 100),	type = "double",	accuracy = 2,	inverted = true },
		{ id = "GroupedShieldValue",		name = ReadText(1001, 8533),	unit = ReadText(1001, 118),	type = "float",		accuracy = 0,	mouseovertext = ReadText(1026, 8018) },
		{ id = "GroupedShieldRate",			name = "   " .. ReadText(1001, 8553),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "GroupedShieldDelay",		name = "   " .. ReadText(1001, 8554),	unit = ReadText(1001, 100),	type = "double",	accuracy = 2,	inverted = true },
		{ id = "RadarRange",				name = ReadText(1001, 8068),	unit = ReadText(1001, 108),	type = "float",		accuracy = 0 },
		{ id = "BurstDPS",					name = ReadText(1001, 8073),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "SustainedDPS",				name = ReadText(1001, 8074),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "TurretSustainedDPS",		name = ReadText(1001, 8532),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0,	mouseovertext = ReadText(1026, 8017),	capshipid = "GroupedTurretSustainedDPS" },
		{ id = "" },
		{ id = "CrewCapacity",				name = ReadText(1001, 8057),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "UnitCapacity",				name = ReadText(1001, 8061),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "MissileCapacity",			name = ReadText(1001, 8062),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "DeployableCapacity",		name = ReadText(1001, 8064),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "CountermeasureCapacity",	name = ReadText(1001, 8063),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "" },
		{ id = "" },
		-- new column
		{ id = "ForwardSpeed",				name = ReadText(1001, 8051),	unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "ForwardAcceleration",		name = ReadText(1001, 8069),	unit = ReadText(1001, 111),	type = "float",		accuracy = 0 },
		{ id = "BoostSpeed",				name = ReadText(1001, 8052),	unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "TravelSpeed",				name = ReadText(1001, 8053),	unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "HorizontalStrafeSpeed",		name = ReadText(1001, 8559),	unit = ReadText(1001, 113),	type = "float",		accuracy = 1 },
		{ id = "HorizontalStrafeAcceleration",	name = ReadText(1001, 8560),	unit = ReadText(1001, 111),	type = "float",		accuracy = 1 },
		{ id = "YawSpeed",					name = ReadText(1001, 8054),	unit = ReadText(1001, 117),	type = "float",		accuracy = 1 },
		{ id = "PitchSpeed",				name = ReadText(1001, 8055),	unit = ReadText(1001, 117),	type = "float",		accuracy = 1 },
		{ id = "RollSpeed",					name = ReadText(1001, 8056),	unit = ReadText(1001, 117),	type = "float",		accuracy = 1 },
		{ id = "" },
		{ id = "ContainerCapacity",			name = ReadText(1001, 8058),	unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "SolidCapacity",				name = ReadText(1001, 8059),	unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "LiquidCapacity",			name = ReadText(1001, 8060),	unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "CondensateCapacity",		name = ReadText(20109, 9801),	unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "" },
		{ id = "NumDocksShipMedium",		name = ReadText(1001, 8524),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "NumDocksShipSmall",			name = ReadText(1001, 8525),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "ShipCapacityMedium",		name = ReadText(1001, 8526),	unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "ShipCapacitySmall",			name = ReadText(1001, 8527),	unit = "",					type = "UINT",		accuracy = 0 },
	},
	scaleSize = 2,
	deployableOrder = {
		["satellite"]		= 1,
		["navbeacon"]		= 2,
		["resourceprobe"]	= 3,
		["lasertower"]		= 4,
		["mine"]			= 5,
		[""]				= 6,
	},
	maxStatusRowCount = 9,
	comparisonShipLibraries = { "shiptypes_xl", "shiptypes_l", "shiptypes_m", "shiptypes_s" },
	comparisonEquipmentLibraries = {
		{ library = "weapons_lasers",			type = "weapon" },
		{ library = "weapons_missilelaunchers",	type = "weapon" },
		{ library = "weapons_turrets",			type = "turret" },
		{ library = "weapons_missileturrets",	type = "turret" },
		{ library = "shieldgentypes",			type = "shield" },
		{ library = "enginetypes",				type = "engine" },
		{ library = "thrustertypes",			type = "thruster" },
	},
	maxSlotRows = 50,
	undoSteps = 100,
	maxSidePanelWidth = 800,
	maxCenterPanelWidth = 1600,
	compatibilityFontSize = 5,
	equipmentfilter_races_width = 300,
}

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	menu.shoppinglist = {}

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_ship_configuration.xpl.init - kuertee")
end
-- kuertee end

function menu.cleanup()
	menu.isReadOnly = nil
	menu.container = nil
	menu.containerowner = nil
	menu.isplayerowned = nil
	menu.object = nil
	menu.objectgroup = nil
	menu.macro = nil
	menu.class = nil
	menu.upgradewares = {}
	menu.groups = {}
	menu.slots = {}
	menu.ammo = {}
	menu.software = {}
	menu.upgradeplan = {}
	menu.selectableships = {}
	menu.selectableshipsbyclass = {}
	menu.shoppinglist = {}
	menu.shoppinglisttotal = 0
	menu.total = nil
	menu.crewtotal = nil
	menu.activatemap = nil
	menu.editingshoppinglist = nil
	menu.updateMoney = nil
	menu.equipmentsearchtext = {}
	menu.loadoutName = ""
	menu.loadout = nil
	menu.inventory = {}
	menu.modwares = {}
	menu.captainSelected = true
	menu.initialLoadoutStatistics = {}
	menu.currentIdx = 0
	menu.immediate = nil
	menu.installedPaintMod = nil
	menu.selectedPaintMod = nil
	menu.validLicence = nil
	menu.tasks = {}
	menu.contextMode = nil
	menu.validLoadoutPossible = nil
	menu.customshipname = nil
	menu.useloadoutname = nil
	menu.playershipname = nil
	menu.warningShown = nil
	menu.customgamestartpeopledef = ""
	menu.customgamestartpeoplefillpercentage = nil
	menu.customgamestartpilot = {}
	menu.clearUndoStack()

	menu.equipmentfilter_races = {}
	menu.equipmentfilter_races_y = 0
	menu.equipmentsearch_editboxrow = 0

	menu.repairplan = {}
	menu.damagedcomponents = {}
	menu.repairslots = {}
	menu.totalrepairprice = nil

	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end

	menu.frameworkData = {}
	menu.slotData = {}
	menu.planData = {}
	menu.statsData = {}
	menu.titleData = {}
	menu.mapData = {}

	menu.picking = true
	menu.pickstate = nil

	menu.leftbartable = nil
	menu.slottable = nil
	menu.plantable = nil
	menu.titlebartable = nil
	menu.map = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	
	UnregisterAddonBindings("ego_detailmonitor", "undo")
end

-- button scripts

function menu.isModSlotExpanded(type, slot)
	return menu.expandedModSlots[type .. slot]
end

function menu.expandModSlot(type, slot, row)
	if menu.expandedModSlots[type .. slot] then
		menu.expandedModSlots[type .. slot] = nil
	else
		menu.expandedModSlots[type .. slot] = true
	end

	menu.currentSlot = slot
	menu.selectedRows.slots = row
	menu.refreshMenu()
end

function menu.isUpgradeExpanded(idx, ware, category)
	if ware then
		return menu.expandedUpgrades[idx .. ware .. category]
	end
	return false
end

function menu.expandUpgrade(idx, ware, category, row)
	if menu.expandedUpgrades[idx .. ware .. category] then
		menu.expandedUpgrades[idx .. ware .. category] = nil
	else
		menu.expandedUpgrades[idx .. ware .. category] = true
	end

	menu.topRows.plan = GetTopRow(menu.plantable)
	menu.selectedRows.plan = row
	menu.refreshMenu()
end

function menu.buttonSelectSlot(slot, row, col)
	if menu.currentSlot ~= slot then
		menu.currentSlot = slot
	end
	
	menu.selectMapMacroSlot()

	menu.topRows.slots = GetTopRow(menu.slottable)
	menu.selectedRows.slots = row
	menu.selectedCols.slots = col
	menu.refreshMenu()
end

function menu.buttonSelectUpgradeMacro(type, slot, macro, row, col, keepcontext, skipvolatilecheck)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
		if macro ~= menu.upgradeplan[type][slot].macro then
			local isvolatile = false
			local currentmacro = menu.upgradeplan[type][slot].macro
			if currentmacro ~= "" then
				local j = menu.findUpgradeMacro(type, currentmacro)
				if j then
					local upgradeware = menu.upgradewares[type][j]
					isvolatile = GetWareData(upgradeware.ware, "volatile")
				end
			end

			if (not skipvolatilecheck) and isvolatile then
				menu.contextData = { mode = "removevolatile", type = type, slot = slot, macro = macro, row = row, col = col }
				menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
			else
				if upgradetype.mergeslots then
					for i, slotdata in ipairs(menu.slots[type]) do
						if menu.mode == "upgrade" then
							if slotdata.component then
								menu.removeRepairedComponent(menu.object, slotdata.component)
							end
						end
						menu.upgradeplan[type][i] = { macro = macro, ammomacro = "", weaponmode = "" }
					end
				else
					if menu.mode == "upgrade" then
						if menu.slots[type][slot].component then
							menu.removeRepairedComponent(menu.object, menu.slots[type][slot].component)
						end
					end
					menu.upgradeplan[type][slot] = { macro = macro, ammomacro = "", weaponmode = "" }
				end

				menu.addUndoStep()

				menu.selectedRows.slots = row
				menu.selectedCols.slots = col
				menu.refreshMenu()
			end
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextMenu()
	end
end

function menu.buttonDiscardShoppingListAndEditGroup(group, shipid)
	for i = #menu.shoppinglist, 1, -1 do
		local entry = menu.shoppinglist[i]
		for _, ship in ipairs(menu.shipgroups[group].ships) do
			if ship.ship == entry.object then
				table.remove(menu.shoppinglist, i)
				break
			end
		end
	end
	menu.closeContextMenu()
	menu.dropdownShip(_, shipid)
end

function menu.checkboxSelectCaptain(row)
	menu.captainSelected = true

	menu.addUndoStep()

	menu.selectedRows.slots = row
	menu.refreshMenu()
end

function menu.checkboxSelectSoftware(type, slot, software, row, keepcontext)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if software ~= menu.upgradeplan[type][slot] then
		menu.upgradeplan[type][slot] = software
	else
		if menu.software[type][slot].defaultsoftware ~= 0 then
			menu.upgradeplan[type][slot] = menu.software[type][slot].possiblesoftware[menu.software[type][slot].defaultsoftware]
		else
			menu.upgradeplan[type][slot] = ""
		end
	end

	menu.selectedRows.slots = row
	menu.refreshMenu()

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextMenu()
	end
end

function menu.checkboxLoadoutName(_, checked)
	menu.useloadoutname = not menu.useloadoutname
	menu.playershipname = nil
	menu.setCustomShipName()
end

function menu.setCustomShipName()
	if menu.useloadoutname then
		menu.customshipname = menu.getCustomShipName()
	else
		menu.customshipname = menu.playershipname or ""
	end
	if menu.customShipNameEditBox then
		local name = ""
		if menu.object ~= 0 then
			name = ffi.string(C.GetComponentName(menu.object))
		else
			name = GetMacroData(menu.macro, "name")
		end
		C.SetEditBoxText(menu.customShipNameEditBox.id, (menu.customshipname ~= "") and menu.customshipname or name)
	end
end

function menu.getUpgradeTypeText(upgradetype)
	if upgradetype == "turrets" then
		return ReadText(1001, 1319)
	elseif upgradetype == "engines" then
		return ReadText(1001, 1103)
	end

	return ""
end

function menu.getCustomShipName()
	local macroname = ""
	if menu.object ~= 0 then
		macroname = GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"), "basename")
	else
		macroname = GetMacroData(menu.macro, "basename")
	end

	return macroname .. " (" .. menu.loadoutName .. ")"
end

function menu.buttonSelectRepair(row, col, objectstring, keepcontext)
	menu.repairplan[objectstring] = menu.repairplan[objectstring] or {}
	if menu.objectgroup then
		for i, ship in ipairs(menu.objectgroup.ships) do
			for j = #menu.objectgroup.shipdata[i].damagedcomponents, 1, -1 do
				if tostring(ship.ship) == objectstring then
					local componentstring = tostring(menu.objectgroup.shipdata[i].damagedcomponents[j])
					if menu.repairplan[objectstring][componentstring] then
						menu.repairplan[objectstring][componentstring] = nil
					else
						menu.repairplan[objectstring][componentstring] = true
					end
				end
			end
		end
	else
		for i = #menu.damagedcomponents, 1, -1 do
			local componentstring = tostring(menu.damagedcomponents[i])
			if menu.repairplan[objectstring][componentstring] then
				menu.repairplan[objectstring][componentstring] = nil
			else
				menu.repairplan[objectstring][componentstring] = true
			end
		end
	end

	menu.addUndoStep()

	menu.selectedRows.slots = row
	menu.selectedCols.slots = col
	menu.refreshMenu()
end

function menu.removeRepairedComponent(object, component)
	local objectstring = tostring(object)
	local componentstring = tostring(component)

	if menu.repairplan[objectstring] then
		menu.repairplan[objectstring][componentstring] = nil
	end
end

function menu.buttonSelectGroupUpgrade(type, group, macro, row, col, keepcontext)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if macro ~= menu.upgradeplan[type][group].macro then
			for i, slotdata in ipairs(menu.slots[upgradetype.grouptype]) do
				local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, upgradetype.grouptype, i)
				if upgradetype.mergeslots or ((groupinfo.path == menu.upgradeplan[type][group].path) and (groupinfo.group == menu.upgradeplan[type][group].group)) then
					if menu.mode == "upgrade" then
						if slotdata.component then
							menu.removeRepairedComponent(menu.object, slotdata.component)
						end
					end
				end
			end

			-- handle already installed equipment
			local haslicence = menu.checkLicence(macro)
			if (macro == menu.groups[group][upgradetype.grouptype].currentmacro) and (not haslicence) then
				menu.upgradeplan[type][group].count = math.min(menu.upgradeplan[type][group].count, menu.groups[group][upgradetype.grouptype].count)
			end

			menu.upgradeplan[type][group].macro = macro
			menu.upgradeplan[type][group].ammomacro = ""
			menu.upgradeplan[type][group].weaponmode = ""
			if (macro ~= "") and (menu.upgradeplan[type][group].count == 0) then
				menu.upgradeplan[type][group].count = 1
			elseif (macro == "") and (menu.upgradeplan[type][group].count ~= 0) then
				menu.upgradeplan[type][group].count = 0
			end

			if upgradetype.pseudogroup then
				for i, slotdata in ipairs(menu.slots[upgradetype.grouptype]) do
					local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, upgradetype.grouptype, i)
					if upgradetype.mergeslots or ((groupinfo.path == menu.upgradeplan[type][group].path) and (groupinfo.group == menu.upgradeplan[type][group].group)) then
						menu.upgradeplan[upgradetype.grouptype][i] = { macro = macro, ammomacro = "", weaponmode = "" }
					end
				end
			end

			menu.addUndoStep()

			menu.selectedRows.slots = row
			menu.selectedCols.slots = col
			menu.refreshMenu()
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextMenu()
	end
end

function menu.buttonTitleSave()
	if menu.contextMode and next(menu.contextMode) and (menu.contextMode.mode == "saveLoadout") then
		menu.closeContextMenu()
	else
		menu.displayContextFrame("saveLoadout", menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize, menu.titleData.offsetX + 2 * (menu.titleData.dropdownWidth + Helper.borderSize), menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonSave(overwrite)
	local loadoutid
	if overwrite then
		loadoutid = menu.loadout
	end

	Helper.closeDropDownOptions(menu.titlebartable, 1, 1)
	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
	if menu.mode ~= "modify" then
		Helper.closeDropDownOptions(menu.titlebartable, 1, 3)
	end
	local macro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.object)), "macro")
	if macro ~= nil then
		for i, entry in ipairs(menu.crew.roles) do
			menu.upgradeplan.crew[entry.id] = entry.wanted
		end

		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.SaveLoadout2(macro, loadout, "local", loadoutid or "player", loadoutid ~= nil, menu.loadoutName, "") end, nil, "UILoadout2")
		menu.getPresetLoadouts()
	end
	menu.closeContextMenu()
	menu.displayMenu()
end

function menu.buttonDismantleMod(type, component, context, group)
	local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
	menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)

	if (type == "turret") and group then
		C.DismantleGroupedWeaponMod(component, context, group)
	elseif (type == "weapon") or (type == "turret") then
		C.DismantleWeaponMod(component)
	elseif type == "engine" then
		C.DismantleEngineMod(component)
	elseif type == "shield" then
		C.DismantleShieldMod(component, context, group)
	elseif type == "ship" then
		C.DismantleShipMod(component)
	end
	menu.prepareModWares()
	menu.refreshMenu()
end

function menu.buttonInstallMod(type, component, ware, price, context, group, dismantle)
	if menu.isplayerowned or (GetPlayerMoney() >= price * menu.moddingdiscounts.totalfactor) then
		local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
		menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)

		if (type == "turret") and group then
			C.DismantleGroupedWeaponMod(component, context, group)
		elseif (type == "weapon") or (type == "turret") then
			C.DismantleWeaponMod(component)
		elseif type == "engine" then
			C.DismantleEngineMod(component)
		elseif type == "shield" then
			C.DismantleShieldMod(component, context, group)
		elseif type == "ship" then
			C.DismantleShipMod(component)
		end

		if not menu.isplayerowned then
			TransferPlayerMoneyTo(price * menu.moddingdiscounts.totalfactor, menu.container)
		end

		if (type == "turret") and group then
			C.InstallGroupedWeaponMod(component, context, group, ware)
		elseif (type == "weapon") or (type == "turret") then
			C.InstallWeaponMod(component, ware)
		elseif type == "engine" then
			C.InstallEngineMod(component, ware)
		elseif type == "shield" then
			C.InstallShieldMod(component, context, group, ware)
		elseif type == "ship" then
			C.InstallShipMod(component, ware)
		end
		AddUITriggeredEvent(menu.name, "modinstalled", { ConvertStringToLuaID(tostring(component)), ware })
		menu.prepareModWares()
		menu.refreshMenu()
	end
end

function menu.buttonContextEncyclopedia(selectedUpgrade)
	local upgradetype = Helper.findUpgradeType(selectedUpgrade.type)

	if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") or (upgradetype.supertype == "group") then
		local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, library, selectedUpgrade.macro })
		menu.cleanup()
	elseif upgradetype.supertype == "software" then
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, "software", selectedUpgrade.software })
		menu.cleanup()
	elseif upgradetype.supertype == "ammo" then
		local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
		if upgradetype.emode then
			local emode = upgradetype.emode
			if library == "mines" then
				emode = "Weapons"
			end
			Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, emode, library, selectedUpgrade.macro })
			menu.cleanup()
		end
	end
end

function menu.buttonEditBlacklist()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonEditFightRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonInteract(selectedData, button, row, col, posx, posy)
	menu.selectedUpgrade = selectedData
	local x, y = GetLocalMousePosition()
	if x == nil then
		-- gamepad case
		x = posx
		y = -posy
	end
	if menu.mode ~= "customgamestart" then
		menu.displayContextFrame("equipment", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
	end
end

function menu.buttonShowStats()
	menu.showStats = not menu.showStats
	menu.refreshMenu()
end

function menu.slidercellSelectAmount(type, slot, macro, row, value)
	menu.closeContextMenu()

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "ammo") then
		menu.upgradeplan[type][macro] = value
		menu.selectedRows.slots = row
	end
	menu.addUndoStep()
end

function menu.slidercellSelectCrewAmount(slot, tier, row, istier, value)
	menu.noupdate = true

	local oldwanted = istier and menu.crew.roles[slot].tiers[tier].wanted or menu.crew.roles[slot].wanted

	local change = value - oldwanted
	if istier then
		menu.crew.roles[slot].wanted = menu.crew.roles[slot].wanted + change
	else
		menu.crew.roles[slot].wanted = value
	end
	if change > 0 then
		-- adding crew
		-- first use npcs from the unassigned pool
		if #menu.crew.unassigned > 0 then
			if #menu.crew.unassigned >= change then
				-- first reassign npcs from the correct role to the correct tier
				for i = #menu.crew.unassigned, 1, -1 do
					if menu.crew.unassigned[i].role == menu.crew.roles[slot].id then
						menu.crew.roles[slot].tiers[menu.crew.unassigned[i].tier].wanted = menu.crew.roles[slot].tiers[menu.crew.unassigned[i].tier].wanted + 1
						table.insert(menu.crew.roles[slot].tiers[menu.crew.unassigned[i].tier].currentnpcs, menu.crew.unassigned[i].npc)
						table.insert(menu.crew.transferdetails, { npc = menu.crew.unassigned[i].npc, newrole = menu.crew.roles[slot].id, price = 0 })
						table.remove(menu.crew.unassigned, i)
						change = change - 1
						if change == 0 then
							break
						end
					end
				end
				if change > 0 then
					-- if that wasn't enough, use all unassigned npcs
					for i = #menu.crew.unassigned, 1, -1 do
						menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted + 1
						table.insert(menu.crew.roles[slot].tiers[tier].currentnpcs, menu.crew.unassigned[i].npc)
						table.insert(menu.crew.transferdetails, { npc = menu.crew.unassigned[i].npc, newrole = menu.crew.roles[slot].id, price = 0 })
						table.remove(menu.crew.unassigned, i)
						change = change - 1
						if change == 0 then
							break
						end
					end
				end
			else
				change = change - #menu.crew.unassigned
				for _, entry in ipairs(menu.crew.unassigned) do
					local npctier = tier
					if entry.role == menu.crew.roles[slot].id then
						npctier = entry.tier
					end
					menu.crew.roles[slot].tiers[npctier].wanted = menu.crew.roles[slot].tiers[npctier].wanted + 1
					table.insert(menu.crew.roles[slot].tiers[npctier].currentnpcs, entry.npc)
					table.insert(menu.crew.transferdetails, { npc = entry.npc, newrole = menu.crew.roles[slot].id, price = 0 })
				end
				menu.crew.unassigned = {}
			end
		end
		-- if any are left add newly hired npcs
		if change > 0 then
			menu.crew.hired = menu.crew.hired + change
			menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted + change
			local found = false
			for i, entry in ipairs(menu.crew.hireddetails) do
				if entry.newrole == menu.crew.roles[slot].id then
					menu.crew.hireddetails[i].amount = menu.crew.hireddetails[i].amount + change
					found = true
					break
				end
			end
			if not found then
				table.insert(menu.crew.hireddetails, { newrole = menu.crew.roles[slot].id, amount = change, price = menu.crew.price })
			end
		end
	else
		-- removing crew
		-- first remove newly hired crew
		for i, entry in ipairs(menu.crew.hireddetails) do
			if entry.newrole == menu.crew.roles[slot].id then
				if entry.amount >= -change then
					menu.crew.hireddetails[i].amount = menu.crew.hireddetails[i].amount + change
					menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted + change
					if menu.crew.hireddetails[i].amount == 0 then
						table.remove(menu.crew.hireddetails, i)
					end
					menu.crew.hired = menu.crew.hired + change
					change = 0
				else
					menu.crew.hired = menu.crew.hired - entry.amount
					change = change + entry.amount
					menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted - entry.amount
					table.remove(menu.crew.hireddetails, i)
				end
				break
			end
		end
		-- if any are left move them to unassigned
		if change < 0 then
			for i = 1, -change do
				local npc, npctier
				if #menu.crew.roles[slot].tiers[tier].currentnpcs > 0 then
					npc = table.remove(menu.crew.roles[slot].tiers[tier].currentnpcs)
					npctier = tier
					menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted - 1
				else
					for j = 1, #menu.crew.roles[slot].tiers do
						if #menu.crew.roles[slot].tiers[j].currentnpcs > 0 then
							npc = table.remove(menu.crew.roles[slot].tiers[j].currentnpcs)
							npctier = j
							menu.crew.roles[slot].tiers[j].wanted = menu.crew.roles[slot].tiers[j].wanted - 1
							break
						end
					end
				end
				if npc then
					table.insert(menu.crew.unassigned, { npc = npc, role = menu.crew.roles[slot].id, tier = npctier })
				else
					DebugError("Could not find npc to remove. [Florian]")
				end
			end
		end
	end
	menu.addUndoStep()

	menu.selectedRows.slots = row
end

function menu.slidercellSelectGroupAmount(type, group, row, keepcontext, value)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if value ~= menu.upgradeplan[type][group].count then
			menu.upgradeplan[type][group].count = value

			menu.addUndoStep()

			menu.selectedRows.slots = row
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextMenu()
	end
end

function menu.onSliderCellConfirm()
	menu.refreshMenu()
	menu.noupdate = nil
end

function menu.checkCommanderRepairOrders(shipidstring)
	local commander = GetCommander(ConvertStringTo64Bit(shipidstring))
	if commander then
		local commanderidstring = tostring(ConvertIDTo64Bit(commander))
		if menu.repairplan[commanderidstring] then
			return true
		else
			return menu.checkCommanderRepairOrders(commanderidstring)
		end
	end

	return false
end

function menu.getLastUnprocessedSubordinate(shipidstring, list_processed)
	local ship = ConvertStringToLuaID(tostring(shipidstring))
	local subordinates = GetSubordinates(ship)
	local subordinate = nil

	for _, locsubordinate in pairs(subordinates) do
		local skip = nil
		for _, eval in pairs(list_processed) do
			if tostring(locsubordinate) == tostring(eval) then
				skip = true
				break
			end
		end
		if not skip then
			if locsubordinate then
				local locsubordinatestring = tostring(ffi.new("UniverseID", ConvertStringTo64Bit(tostring(locsubordinate))))
				local result = menu.getLastUnprocessedSubordinate(locsubordinatestring, list_processed)
				subordinate = result[1]
				if not subordinate then
					subordinate = locsubordinate
				end
			end
		else
			skip = nil
		end
	end

	--print("returning " .. tostring(subordinate))
	return {subordinate, list_processed}
end

function menu.processRepairsFor(shipidstring, orderindex)
	local ship = ConvertStringTo64Bit(shipidstring)
	local subordinates = GetSubordinates(ConvertStringToLuaID(tostring(shipidstring)))
	local subordinateorders = {}
	local list_processed = {}

	while #subordinates > 0 do
		local result = menu.getLastUnprocessedSubordinate(shipidstring, list_processed)
		local subordinate = result[1]
		list_processed = result[2]

		if subordinate then
			table.insert(list_processed, subordinate)
			for i = #subordinates, 1, -1 do
				if tostring(subordinate) == tostring(subordinates[i]) then
					table.remove(subordinates, i)
					break
				end
			end
			local subordinateidstring = tostring(ffi.new("UniverseID", ConvertStringTo64Bit(tostring(subordinate))))
			local param2 = nil
			local param3 = {}
			if menu.repairplan[subordinateidstring] then
				for componentidstring, _ in pairs(menu.repairplan[subordinateidstring]) do
					if componentidstring ~= "processed" then
						if componentidstring == subordinateidstring then
							param2 = 100
						else
							table.insert(param3, ConvertStringToLuaID(componentidstring))
						end
					end
				end
				subordinateorders[subordinate] = { ConvertStringToLuaID(tostring(menu.container)), param2, param3, false, 0 }
				menu.repairplan[subordinateidstring]["processed"] = true
			end
		else
			break
		end
	end

	local shipluaid = ConvertStringToLuaID(tostring(shipidstring))

	-- param 1 == destination (component)
	SetOrderParam(shipluaid, orderindex, 1, nil, ConvertStringToLuaID(tostring(menu.container)))

	for componentidstring, _ in pairs(menu.repairplan[shipidstring]) do
		if componentidstring ~= "processed" then
			if componentidstring == shipidstring then
				SetOrderParam(shipluaid, orderindex, 2, nil, 100)
			else
				-- param 3 == damagedcomponents (list)
				SetOrderParam(shipluaid, orderindex, 3, nil, ConvertStringToLuaID(componentidstring))
			end
		end
	end

	-- param 4 == repairall (bool)
	SetOrderParam(shipluaid, orderindex, 4, nil, false)

	-- param 5 == acceptedcost (money)
	SetOrderParam(shipluaid, orderindex, 5, nil, menu.totalrepairprice)

	-- param 6 == urgent (bool); by default, repairs ordered by the player are always urgent
	SetOrderParam(shipluaid, orderindex, 6, nil, true)

	-- param 7 == blacklist_stations (list)

	-- param 8 == subordinaterepairorders (table)
	SetOrderParam(shipluaid, orderindex, 8, nil, subordinateorders)

	-- param 9 == subordinateorders (list) (used for undocking subordinates)

	-- param 10 == debugchance (int)
	--SetOrderParam(shipluaid, orderindex, 10, nil, 100)

	menu.repairplan[shipidstring]["processed"] = true

	if not C.EnableOrder(ship, orderindex) then
		print("ERROR: Order to initiate repairs for " .. ffi.string(C.GetComponentName(ship)) .. " was not enabled.")
	end
end

function menu.buttonConfirm()
	local playermoney = GetPlayerMoney()
	if menu.isplayerowned or ((playermoney - menu.shoppinglisttotal + menu.shoppinglistrefund) >= 0) then
		if (menu.mode == "purchase") or (menu.mode == "upgrade") then
			for i, entry in ipairs(menu.shoppinglist) do
				if i ~= menu.editingshoppinglist then
					local haspaid
					if not menu.isplayerowned then
						-- Pay upfront, receive money when build finishes
						if (entry.price + entry.crewprice) > 0 then
							TransferPlayerMoneyTo(entry.amount * (entry.price + entry.crewprice), menu.container)
							haspaid = entry.price + entry.crewprice
						end
					end

					if entry.objectgroup then
						local groupentry = menu.shipgroups[entry.objectgroup]
						for i, ship in ipairs(groupentry.ships) do
							menu.repairandupgrade(entry, ship.ship, "", entry.groupstates[i].hasupgrades, haspaid, entry.groupstates[i].price, entry.groupstates[i].crewprice)
						end
					else
						menu.repairandupgrade(entry, entry.object, entry.macro, entry.hasupgrades, haspaid)
					end
				end
			end
		elseif menu.mode == "modify" then
			-- TODO
		elseif menu.mode == "customgamestart" then
			for i, entry in ipairs(menu.crew.roles) do
				menu.upgradeplan.crew[entry.id] = entry.wanted
			end
			if menu.modeparam.playerpropertyid then
				local entryid = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.SetCustomGameStartPlayerPropertyMacroAndLoadout2(menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.playerpropertyid, menu.modeparam.propertycommander, menu.macro, loadout) end, nil, "UILoadout2")
				C.SetCustomGameStartPlayerPropertyPeople(menu.modeparam.gamestartid, menu.modeparam.shipproperty, entryid, menu.customgamestartpeopledef)
				C.SetCustomGameStartPlayerPropertyPeopleFillPercentage2(menu.modeparam.gamestartid, menu.modeparam.shipproperty, entryid, menu.customgamestartpeoplefillpercentage)

				local numskills = C.GetNumSkills()
				local buf = ffi.new("CustomGameStartPersonEntry")
				buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
				buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
				local skillbuf = ffi.new("SkillInfo[?]", numskills)
				numskills = C.GetSkills(skillbuf, numskills)
				buf.numskills = numskills
				buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
				for i = 0, numskills - 1 do
					local id = ffi.string(skillbuf[i].id)
					buf.skills[i].id = Helper.ffiNewString(id)
					buf.skills[i].value = menu.customgamestartpilot.skills and menu.customgamestartpilot.skills[id] or 0
				end
				C.SetCustomGameStartPlayerPropertyPerson(menu.modeparam.gamestartid, menu.modeparam.shipproperty, entryid, buf)
			else
				Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.SetCustomGameStartShipAndLoadoutProperty2(menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.shiploadoutproperty, menu.macro, loadout) end, nil, "UILoadout2")
				C.SetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.shippeopleproperty, menu.customgamestartpeopledef)
				C.SetCustomGameStartFloatProperty(menu.modeparam.gamestartid, menu.modeparam.shippeoplefillpercentageproperty, menu.customgamestartpeoplefillpercentage)

				if menu.modeparam.shippilotproperty then
					local numskills = C.GetNumSkills()
					local buf = ffi.new("CustomGameStartPersonEntry")
					buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
					buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
					local skillbuf = ffi.new("SkillInfo[?]", numskills)
					numskills = C.GetSkills(skillbuf, numskills)
					buf.numskills = numskills
					buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
					for i = 0, numskills - 1 do
						local id = ffi.string(skillbuf[i].id)
						buf.skills[i].id = Helper.ffiNewString(id)
						buf.skills[i].value = menu.customgamestartpilot.skills and menu.customgamestartpilot.skills[id] or 0
					end
					C.SetCustomGameStartShipPilot(menu.modeparam.gamestartid, menu.modeparam.shippilotproperty, buf)
				end
			end
		elseif menu.mode == "comparison" then
			Helper.addShipComparison(menu.modeparam[1], menu.macro, menu.upgradeplan)
		end

		menu.closeMenu("back")
	else
		menu.displayMenu()
	end
end

function menu.buttonSelectPaintMod(entry, row, col)
	menu.selectedPaintMod = entry
	C.SetMapPaintMod(menu.holomap, entry.ware)
	
	menu.selectedRows.slots = row
	menu.selectedCols.slots = col
	menu.refreshMenu()
end

function menu.buttonInstallPaintMod()
	if menu.modeparam[1] then
		for _, ship in pairs(menu.modeparam[2]) do
			local change = false
			local paintmod = ffi.new("UIPaintMod")
			if C.GetInstalledPaintMod(ship, paintmod) then
				if menu.selectedPaintMod.ware ~= ffi.string(paintmod.Ware) then
					change = true
				end
			else
				change = true
			end
			if change then
				C.InstallPaintMod(ship, menu.selectedPaintMod.ware, not menu.selectedPaintMod.isdefault)
				AddUITriggeredEvent(menu.name, "paintmodinstalled", { ConvertStringToLuaID(tostring(ship)), menu.selectedPaintMod.ware })
			end
		end
	else
		C.InstallPaintMod(menu.object, menu.selectedPaintMod.ware, not menu.selectedPaintMod.isdefault)
		AddUITriggeredEvent(menu.name, "paintmodinstalled", { ConvertStringToLuaID(tostring(menu.object)), menu.selectedPaintMod.ware })
	end

	menu.selectedRows.slots = Helper.currentTableRow[menu.slottable]
	menu.selectedCols.slots = Helper.currentTableCol[menu.slottable]
	
	menu.mapstate = ffi.new("HoloMapState")
	C.GetMapState(menu.holomap, menu.mapstate)
	menu.prepareModWares()
	menu.getDataAndDisplay(nil, nil, nil, nil, true)
end

function menu.dropdownShipClass(_, class)
	if class ~= menu.class then
		menu.class = class or ""
		if menu.usemacro then
			menu.validLicence = false
			menu.macro = ""
		elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
			local entry = menu.selectableshipsbyclass[class][1]
			if type(entry) == "table" then
				if entry.group then
					menu.objectgroup = menu.shipgroups[entry.group]
					menu.object = menu.objectgroup.ships[1].ship
				elseif entry.grouped ~= nil then
					menu.objectgroup = nil
					menu.object = entry.ship.ship
				else
					menu.objectgroup = nil
					menu.object = entry.ship
				end
			else
				menu.objectgroup = nil
				menu.object = entry
			end

			menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
			menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))

			if menu.mode == "upgrade" then
				local aipilot = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "assignedaipilot")
				if aipilot then
					menu.captainSelected = true
				else
					menu.captainSelected = false
				end
			elseif menu.mode == "modify" then
				local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
				menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)
				menu.selectedPaintMod = nil
				menu.prepareModWares()
			end
		end
		menu.customshipname = ""
		menu.useloadoutname = false
		menu.loadoutName = ""
		menu.playershipname = nil
		menu.clearUndoStack()
		menu.getDataAndDisplay()
	end
end

function menu.dropdownShip(_, shipid)
	if menu.usemacro then
		local oldmacro = menu.macro
		menu.macro = shipid or ""
		if menu.macro ~= oldmacro then
			menu.hasDefaultLoadout = false
			menu.defaultLoadoutMacros = {}
			if menu.macro ~= "" then
				menu.hasDefaultLoadout = C.HasDefaultLoadout2(menu.macro, true)
				if menu.hasDefaultLoadout then
					local n = C.GetNumDefaultLoadoutMacros(menu.macro)
					local buf = ffi.new("const char*[?]", n)
					n = C.GetDefaultLoadoutMacros(buf, n, menu.macro)
					for i = 0, n - 1 do
						menu.defaultLoadoutMacros[ffi.string(buf[i])] = true
					end
				end
			end

			menu.setdefaulttable = true
			menu.currentSlot = nil
			menu.captainSelected = (menu.mode == "customgamestart") or (menu.mode == "comparison")
			menu.validLicence = menu.checkLicence(menu.macro, true)
			if menu.mode == "customgamestart" then
				menu.validLoadoutPossible = true
			elseif menu.mode == "comparison" then
				menu.validLoadoutPossible = C.CanGenerateValidKnownLoadout(menu.macro)
			else
				menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, menu.macro)
			end
			menu.customshipname = ""
			menu.useloadoutname = false
			menu.loadoutName = ""
			menu.playershipname = nil
			menu.clearUndoStack()
			menu.getDataAndDisplay()
		end
	elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
		local oldobject = menu.object
		local oldobjectgroup = menu.objectgroup and menu.objectgroup.idx or 0

		local i
		if menu.mode == "upgrade" then
			i = menu.findMacroIdx(menu.shipgroups, shipid)
		end
		if i then
			for idx, entry in ipairs(menu.shoppinglist) do
				for _, ship in ipairs(menu.shipgroups[i].ships) do
					if ship.ship == entry.object then
						menu.contextData = { mode = "replacesingleshoppinglistentry", group = i, shipid = shipid }
						menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
						return
					end
				end
			end

			menu.objectgroup = menu.shipgroups[i]
			menu.object = menu.objectgroup.ships[1].ship
		else
			menu.objectgroup = nil
			menu.object = ffi.new("UniverseID", ConvertStringTo64Bit(shipid))
		end
		menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
		menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
		
		if (menu.object ~= oldobject) or ((menu.objectgroup and menu.objectgroup.idx or 0) ~= oldobjectgroup) then
			menu.setdefaulttable = true
			if menu.editingshoppinglist then
				table.remove(menu.shoppinglist, menu.editingshoppinglist)
			end

			menu.hasDefaultLoadout = false
			menu.defaultLoadoutMacros = {}
			if menu.object ~= 0 then
				local macro = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
				menu.hasDefaultLoadout = C.HasDefaultLoadout2(macro, true)
				if menu.hasDefaultLoadout then
					local n = C.GetNumDefaultLoadoutMacros(macro)
					local buf = ffi.new("const char*[?]", n)
					n = C.GetDefaultLoadoutMacros(buf, n, macro)
					for i = 0, n - 1 do
						menu.defaultLoadoutMacros[ffi.string(buf[i])] = true
					end
				end
			end

			if menu.mode == "upgrade" then
				local aipilot = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "assignedaipilot")
				if aipilot then
					menu.captainSelected = true
				else
					menu.captainSelected = false
				end
			elseif menu.mode == "modify" then
				local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
				menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)
				menu.selectedPaintMod = nil
				menu.prepareModWares()
			end

			local found = false
			for idx, entry in ipairs(menu.shoppinglist) do
				if menu.object == entry.object then
					found = true

					menu.editingshoppinglist = idx
					menu.object = entry.object
					menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
					menu.macro = entry.macro
					menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
					menu.clearUndoStack()
					menu.getDataAndDisplay(entry.upgradeplan, entry.crew, true, true)
					break
				elseif menu.objectgroup and (menu.objectgroup.idx == entry.objectgroup) then
					found = true

					menu.editingshoppinglist = idx
					menu.clearUndoStack()
					menu.getDataAndDisplay(entry.upgradeplan, entry.crew, true, true)
					break
				end
			end
		
			if not found then
				menu.editingshoppinglist = nil

				menu.currentSlot = nil
				menu.customshipname = ""
				menu.useloadoutname = false
				menu.loadoutName = ""
				menu.playershipname = nil
				menu.clearUndoStack()
				menu.getDataAndDisplay(nil, nil, nil, true)
			end
		end
	end
end

function menu.dropdownLoadout(_, loadoutid)
	if loadoutid ~= nil then
		menu.loadout = loadoutid
		local preset, mission
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.id == menu.loadout then
				menu.loadoutName = loadout.name
				menu.setCustomShipName()
				if loadout.preset then
					preset = loadout.preset
					menu.loadout = nil
				elseif loadout.mission then
					menu.loadoutName = string.match(menu.loadoutName, "\27#.*#\27%[.*%] (.*)\27X")
					mission = loadout.mission
					menu.loadout = nil
				end
				break
			end
		end
		local loadout, crew
		if preset then
			if menu.mode == "customgamestart" then
				loadout = Helper.getLoadoutHelper2(C.GenerateShipLoadout2, C.GenerateShipLoadoutCounts2, "UILoadout2", 0, menu.object, menu.macro, preset)
			elseif menu.mode == "comparison" then
				loadout = Helper.getLoadoutHelper2(C.GenerateShipKnownLoadout2, C.GenerateShipKnownLoadoutCounts2, "UILoadout2", menu.macro, preset)
			else
				loadout = Helper.getLoadoutHelper2(C.GenerateShipLoadout2, C.GenerateShipLoadoutCounts2, "UILoadout2", menu.container, menu.object, menu.macro, preset)
			end
			if menu.usemacro then
				if menu.mode ~= "customgamestart" then
					local intendedcrew = preset * menu.crew.capacity
					local intendedcrewperrole = math.floor(intendedcrew / #menu.crew.roles)

					crew = {
						roles = {},
						unassigned = {},
						hired = 0,
						hireddetails = {},
						fired = {},
					}

					for i, entry in ipairs(menu.crew.roles) do
						crew.roles[i] = { tiers = { [1] = {} } }
						crew.roles[i].wanted = intendedcrewperrole
						crew.roles[i].tiers[1].wanted = intendedcrewperrole

						crew.hired = crew.hired + intendedcrewperrole
						table.insert(crew.hireddetails, { newrole = entry.id, amount = intendedcrewperrole, price = menu.crew.price })
					end
				else
					if preset >= 0.9 then
						menu.customgamestartpeopledef = "player_argon_elite_freighter_crew"
					elseif preset >= 0.4 then
						menu.customgamestartpeopledef = "player_argon_veteran_freighter_crew"
					elseif preset > 0 then
						menu.customgamestartpeopledef = "player_argon_regular_freighter_crew"
					else
						menu.customgamestartpeopledef = ""
					end
					menu.customgamestartpeoplefillpercentage = preset * 100
				end
			end
		elseif mission then
			loadout = Helper.getLoadoutHelper2(C.GetMissionLoadout, C.GetMissionLoadoutCounts, "UILoadout2", mission.id, mission.macro)
		else
			loadout = Helper.getLoadoutHelper2(C.GetLoadout2, C.GetLoadoutCounts2, "UILoadout2", menu.object, menu.macro, loadoutid)
		end
		local upgradeplan = Helper.convertLoadout(menu.object, menu.macro, loadout, menu.software, "UILoadout2")
		if menu.usemacro then
			menu.captainSelected = true
		end
		menu.getDataAndDisplay(upgradeplan, crew)
	end
end

function menu.dropdownLoadoutRemoved(_, loadoutid)
	local macro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.object)), "macro")
	C.RemoveLoadout("local", macro, loadoutid)
	if loadoutid == menu.loadout then
		menu.loadout = nil
		menu.loadoutName = ""
	end
	for i, loadout in ipairs(menu.loadouts) do
		if loadout.id == loadoutid then
			table.remove(menu.loadouts, i)
			break
		end
	end
end

function menu.dropdownChangePurchaseAmount(idx, amountstring)
	local entry = menu.shoppinglist[idx]
	entry.amount = tonumber(amountstring)
	menu.refreshMenu()
end

function menu.onDropDownActivated()
	menu.closeContextMenu()
end

function menu.buttonAddPurchase(hasupgrades, hasrepairs)
	menu.closeContextMenu()

	local objectgroup
	local object = menu.object
	local groupstates = {}
	if menu.objectgroup then
		objectgroup = menu.objectgroup.idx
		object = nil
		groupstates = menu.objectgroup.states
	end

	table.insert(menu.shoppinglist, { objectgroup = objectgroup, groupstates = groupstates, object = object, macro = menu.macro, hasupgrades = hasupgrades, upgradeplan = menu.upgradeplan, crew = menu.crew, settings = menu.settings, amount = 1, price = menu.total, crewprice = menu.crewtotal, duration = menu.duration, warnings = menu.warnings, customshipname = menu.customshipname, useloadoutname = menu.useloadoutname, loadoutName = menu.loadoutName, playershipname = menu.playershipname })
	menu.object = 0
	menu.objectgroup = nil
	menu.damagedcomponents = {}
	menu.macro = ""
	menu.customshipname = ""
	menu.useloadoutname = false
	menu.loadoutName = ""
	menu.playershipname = nil
	menu.clearUndoStack()
	menu.getDataAndDisplay()
end

function menu.buttonConfirmPurchaseEdit(hasupgrades, hasrepairs)
	menu.closeContextMenu()

	if (not hasupgrades) and (not hasrepairs) then
		table.remove(menu.shoppinglist, menu.editingshoppinglist)
	else
		if menu.objectgroup then
			menu.shoppinglist[menu.editingshoppinglist].objectgroup = menu.objectgroup.idx
			menu.shoppinglist[menu.editingshoppinglist].groupstates = menu.objectgroup.states
		else
			menu.shoppinglist[menu.editingshoppinglist].object = menu.object
		end
		menu.shoppinglist[menu.editingshoppinglist].macro = menu.macro
		menu.shoppinglist[menu.editingshoppinglist].hasupgrades = hasupgrades
		menu.shoppinglist[menu.editingshoppinglist].upgradeplan = menu.upgradeplan
		menu.shoppinglist[menu.editingshoppinglist].settings = menu.settings
		menu.shoppinglist[menu.editingshoppinglist].crew = menu.crew
		menu.shoppinglist[menu.editingshoppinglist].price = menu.total
		menu.shoppinglist[menu.editingshoppinglist].crewprice = menu.crewtotal
		menu.shoppinglist[menu.editingshoppinglist].duration = menu.duration
		menu.shoppinglist[menu.editingshoppinglist].warnings = menu.warnings
		menu.shoppinglist[menu.editingshoppinglist].customshipname = menu.customshipname
		menu.shoppinglist[menu.editingshoppinglist].useloadoutname = menu.useloadoutname
		menu.shoppinglist[menu.editingshoppinglist].loadoutName = menu.loadoutName
		menu.shoppinglist[menu.editingshoppinglist].playershipname = menu.playershipname
	end

	menu.object = 0
	menu.objectgroup = nil
	menu.damagedcomponents = {}
	menu.macro = ""
	menu.customshipname = ""
	menu.useloadoutname = false
	menu.loadoutName = ""
	menu.playershipname = nil
	menu.editingshoppinglist = nil
	menu.clearUndoStack()
	menu.getDataAndDisplay()
end

function menu.buttonEditPurchase(idx)
	menu.closeContextMenu()

	local entry = menu.shoppinglist[idx]
	menu.editingshoppinglist = idx
	if entry.objectgroup then
		menu.objectgroup = menu.shipgroups[entry.objectgroup]
		menu.object = menu.objectgroup.ships[1].ship
	else
		menu.objectgroup = nil
		menu.object = entry.object
	end
	if (menu.mode == "upgrade") or (menu.mode == "modify") then
		menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
	end
	menu.macro = entry.macro
	if menu.object ~= 0 then
		menu.class = ffi.string(C.GetComponentClass(menu.object))
	elseif menu.macro ~= "" then
		menu.class = ffi.string(C.GetMacroClass(menu.macro))
	end
	menu.customshipname = entry.customshipname
	menu.useloadoutname = entry.useloadoutname
	menu.loadoutName = entry.loadoutName
	menu.playershipname = entry.playershipname
	menu.captainSelected = true
	menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, (menu.object ~= 0) and GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro") or menu.macro)
	menu.clearUndoStack()
	menu.getDataAndDisplay(entry.upgradeplan, entry.crew, true, true, nil, entry.settings)
end

function menu.buttonRemovePurchase(idx)
	table.remove(menu.shoppinglist, idx)
	menu.refreshMenu()
end

function menu.buttonLeftBar(mode, row, overrideMode, overrideSlot)
	local isreopencontextframe, contextmodemode, contextmodewidth, contextmodex, contextmodey
	if menu.contextMode then
		if menu.contextMode.mode == "equipmentfilter" then
			if menu.upgradetypeMode ~= "crew" and menu.upgradetypeMode ~= "repair" and menu.upgradetypeMode ~= "settings" then
				isreopencontextframe = true
			end
		end
		if isreopencontextframe then
			contextmodemode = menu.contextMode.mode
			contextmodewidth = menu.contextMode.width
			contextmodex = menu.contextMode.x
			contextmodey = menu.contextMode.y
		end
	end
	menu.closeContextMenu()

	menu.prevUpgradetypeMode = menu.upgradetypeMode
	if (overrideMode ~= nil) and (menu.upgradetypeMode == overrideMode) and (menu.currentSlot == overrideSlot) then
		menu.upgradetypeMode = nil
	else
		AddUITriggeredEvent(menu.name, mode, menu.upgradetypeMode == mode and "off" or "on")
		if menu.upgradetypeMode == mode then
			PlaySound("ui_negative_back")
			menu.upgradetypeMode = nil
		else
			menu.setdefaulttable = true
			PlaySound("ui_positive_select")
			menu.upgradetypeMode = overrideMode or mode
		end
	end
	menu.currentSlot = overrideSlot or 1

	if menu.upgradetypeMode then
		menu.selectMapMacroSlot()
	else
		C.ClearSelectedMapMacroSlots(menu.holomap)
	end
	
	menu.displayMenu(true)
	if isreopencontextframe then
		if contextmodemode == "equipmentfilter" then
			contextmodey = menu.equipmentfilter_races_y
		end
		menu.displayContextFrame(contextmodemode, contextmodewidth, contextmodex, contextmodey, true)
	end
end

function menu.deactivateUpgradeMode()
	menu.prevUpgradetypeMode = menu.upgradetypeMode
	PlaySound("ui_negative_back")
	menu.upgradetypeMode = nil
	menu.currentSlot = 1
	C.ClearSelectedMapMacroSlots(menu.holomap)
	menu.displayMenu()
end

function menu.buttonModCategory(category, row, col)
	if category ~= menu.modCategory then
		menu.modCategory = category

		menu.topRows.slots = GetTopRow(menu.slottable)
		menu.displayMenu()
	end
end

function menu.getModQuality(category)
	for i, entry in ipairs(Helper.modQualities) do
		if entry.category == category then
			return i
		end
	end
end

function menu.buttonResetCrew()
	menu.crew.fired = {}
	menu.crew.hired = 0
	menu.crew.hireddetails = {}
	menu.crew.transferdetails = {}
	menu.crew.unassigned = {}
	for i, entry in ipairs(menu.crew.roles) do
		menu.crew.roles[i].wanted = entry.total
		for j, tier in ipairs(entry.tiers) do
			for _, npc in ipairs(menu.crew.roles[i].tiers[j].npcs) do
				table.insert(menu.crew.roles[i].tiers[j].currentnpcs, npc)
			end
			menu.crew.roles[i].tiers[j].wanted = tier.total
		end
	end

	menu.addUndoStep()

	menu.refreshMenu()
end

function menu.buttonFireCrew()
	for _, entry in ipairs(menu.crew.unassigned) do
		table.insert(menu.crew.fired, { npc = entry.npc, price = menu.crew.price })
	end
	menu.crew.unassigned = {}

	menu.addUndoStep()

	menu.refreshMenu()
end

-- editbox scripts
function menu.editboxSearchUpdateText(_, text, textchanged)
	if textchanged then
		table.insert(menu.equipmentsearchtext, { text = text })
	end

	menu.refreshMenu()
end

function menu.editboxLoadoutNameUpdateText(_, text)
	menu.loadoutName = text
	menu.setCustomShipName()
	menu.loadout = nil
end

function menu.editboxCustomShipName(_, text)
	if text == "" then
		menu.playershipname = nil
	else
		menu.playershipname = text
	end
	menu.useloadoutname = false
	menu.customshipname = text
end

function menu.editboxCustomShipNameDeactivated(_, text, textchanged)
	if text == "" then
		menu.setCustomShipName()
	end
end

-- Menu member functions

function menu.hotkey(action)
	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_UNDO" then
		menu.undoHelper(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REDO" then
		menu.undoHelper(false)
	end
end

function menu.undoHelper(undo)
	if undo then
		menu.undoIndex = math.min(#menu.undoStack, menu.undoIndex + 1)
	else
		menu.undoIndex = math.max(1, menu.undoIndex - 1)
	end
	menu.captainSelected = menu.undoStack[menu.undoIndex].captainSelected
	menu.repairplan = Helper.tableCopy(menu.undoStack[menu.undoIndex].repairplan, 3)
	menu.getDataAndDisplay(menu.undoStack[menu.undoIndex].upgradeplan, menu.undoStack[menu.undoIndex].crew, nil, nil, true)
end

function menu.addUndoStep(upgradeplan, crew)
	-- making a new branch, remove current redos
	for i = menu.undoIndex - 1, 1, -1 do
		table.remove(menu.undoStack, i)
	end
	-- add current data
	menu.undoIndex = 1
	table.insert(menu.undoStack, 1, { upgradeplan = Helper.tableCopy(upgradeplan or menu.upgradeplan, 3), crew = Helper.tableCopy(crew or menu.crew, 3), captainSelected = menu.captainSelected, repairplan = Helper.tableCopy(menu.repairplan, 3) })
	-- check for stack limit
	while #menu.undoStack > config.undoSteps do
		table.remove(menu.undoStack)
	end
end

function menu.clearUndoStack()
	menu.undoIndex = 1
	menu.undoStack = {}
end

function menu.refreshMenu()
	if not menu.topRows.slots then
		menu.topRows.slots = GetTopRow(menu.slottable)
	end
	if not menu.selectedRows.slots then
		menu.selectedRows.slots = Helper.currentTableRow[menu.slottable]
	end

	menu.displayMenu()
end

function menu.findUpgradeMacro(loctype, macro)
	if type(menu.upgradewares[loctype]) == "table" then
		for i, upgradeware in ipairs(menu.upgradewares[loctype]) do
			if upgradeware.macro == macro then
				return i
			end
		end
	end
end

function menu.determineInitialSlot()
	menu.currentSlot = 1
	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		local curslotsizepriority
		for i, group in ipairs(menu.groups) do
			if (menu.upgradetypeMode == "enginegroup") == (group["engine"].total > 0) then
				if group.slotsize and (group.slotsize ~= "") then
					local sizeorder = Helper.slotSizeOrder[group.slotsize] or 0
					if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
						curslotsizepriority = sizeorder
						menu.currentSlot = i
					end
				end
			end
		end
	end
end

function menu.onShowMenu(state)
	menu.damagedcomponents = {}
	
	-- layout
	menu.scaleSize = Helper.scaleX(config.scaleSize)
	menu.frameworkData = {
		sidebarWidth = Helper.scaleX(Helper.sidebarWidth),
		offsetX = Helper.frameBorder,
		offsetY = Helper.frameBorder + 20,
		scaleWidth = 3 * menu.scaleSize,
	}
	local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
	local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
	reservedSidePanelWidth = reservedSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize
	menu.slotData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetX = menu.frameworkData.sidebarWidth + menu.frameworkData.scaleWidth + menu.frameworkData.offsetX + 3 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}
	menu.planData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}

	local reserverdCenterPanelWidth = Helper.viewWidth - 2 * menu.slotData.offsetX - 2 * reservedSidePanelWidth - 4 * Helper.borderSize
	local actualCenterPanelWidth = math.min(reserverdCenterPanelWidth, Helper.scaleX(config.maxCenterPanelWidth))
	menu.statsData = {
		width =  actualCenterPanelWidth,
		offsetX = menu.slotData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData = {
		width =  actualCenterPanelWidth,
		height = Helper.scaleY(40),
		offsetX = menu.slotData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData.dropdownWidth = math.floor((menu.titleData.width - 4 * (menu.titleData.height + Helper.borderSize) - 2 * Helper.borderSize) / 3)
	menu.planData.offsetX = Helper.viewWidth - actualSidePanelWidth - 2 * Helper.borderSize
	menu.mapData = {
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		offsetX = 0,
		offsetY = 0
	}
	menu.subHeaderRowHeight = Helper.scaleY(26)

	menu.headerTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
		titleColor = Helper.defaultSimpleBackgroundColor,
	}

	menu.headerWarningTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
		color = function () return menu.warningColor(Helper.color.orange) end,
		titleColor = Helper.color.orange,
		halign = "center",
	}

	menu.subHeaderTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		minRowHeight = menu.subHeaderRowHeight,
		scaling = false,
		cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
		titleColor = Helper.defaultSimpleBackgroundColor,
	}
	
	menu.subHeaderSliderCellTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		scaling = false,
	}

	-- parameters
	menu.mode = menu.param[4]
	if menu.param[3] == nil then
		if menu.mode == "upgrade" then
			menu.isReadOnly = true
		end
	else
		menu.container = ConvertIDTo64Bit(menu.param[3])
		menu.containerowner, menu.isplayerowned  = GetComponentData(menu.container, "owner", "isplayerowned")
	end
	menu.modeparam = {}
	if type(menu.param[5]) == "table" then
		if menu.mode == "modify" then
			if menu.param[5][1] == 1 then
				menu.modeparam[1] = true
				menu.modeparam[2] = {}
				for _, ship in pairs(menu.param[5][2]) do
					table.insert(menu.modeparam[2], ConvertIDTo64Bit(ship))
				end
			end
		elseif menu.mode == "customgamestart" then
			menu.modeparam = menu.param[5]
			menu.modeparam.gamestartid							= menu.modeparam[1]
			menu.modeparam.creative								= menu.modeparam[2] ~= 0
			menu.modeparam.shipproperty							= menu.modeparam[3]
			menu.modeparam.shiploadoutproperty					= menu.modeparam[4]
			menu.modeparam.shippeopleproperty					= menu.modeparam[5]
			menu.modeparam.shippeoplefillpercentageproperty		= menu.modeparam[6]
			menu.modeparam.shippilotproperty					= menu.modeparam[7]
			menu.modeparam.paintthemeproperty					= menu.modeparam[8]
			menu.modeparam.playerpropertyid						= menu.modeparam[9]
			menu.modeparam.propertymacro						= menu.modeparam[10]
			menu.modeparam.propertycommander					= menu.modeparam[11]
			menu.modeparam.propertypeopledef					= menu.modeparam[12]
			menu.modeparam.propertypeoplefillpercentage			= menu.modeparam[13]
		elseif menu.mode == "comparison" then
			menu.modeparam = menu.param[5]
		else
			for _, ship in pairs(menu.param[5]) do
				table.insert(menu.modeparam, ConvertIDTo64Bit(ship))
			end
		end
	end
	menu.immediate = false
	if menu.param[6] then
		menu.immediate = menu.param[6]
	end
	menu.usemacro = nil
	if (menu.mode == "purchase") or (menu.mode == "customgamestart") or (menu.mode == "comparison") then
		menu.usemacro = true
	end

	if menu.mode == "modify" then
		--menu.frameworkData.offsetY = 2 * (menu.titleData.height + Helper.borderSize) + menu.slotData.offsetY
		menu.titleData.dropdownWidth = math.floor((menu.titleData.width - 3 * (menu.titleData.height + Helper.borderSize) - Helper.borderSize) / 2)
	end

	-- prepare ships
	if menu.mode == "purchase" then
		menu.availableshipmacros = {}
		local n = C.GetNumContainerBuilderMacros(menu.container)
		if n > 0 then
			local buf = ffi.new("const char*[?]", n)
			n = C.GetContainerBuilderMacros(buf, n, menu.container)
			for i = 0, n - 1 do
				table.insert(menu.availableshipmacros, ffi.string(buf[i]))
			end
		end

		menu.object = 0
		if not menu.macro then
			menu.macro = ""
		end
		menu.customshipname = ""
		menu.useloadoutname = false
		menu.loadoutName = ""
		menu.playershipname = nil
		menu.class = ""

		menu.availableshipmacrosbyclass = {}
		for _, macro in ipairs(menu.availableshipmacros) do
			local class = ffi.string(C.GetMacroClass(macro))
			if menu.availableshipmacrosbyclass[class] then
				table.insert(menu.availableshipmacrosbyclass[class], macro)
			else
				menu.availableshipmacrosbyclass[class] = { macro }
			end
		end
	elseif menu.mode == "upgrade" then
		menu.selectableships = {}
		if #menu.modeparam > 0 then
			for _, ship in pairs(menu.modeparam) do
				--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to list of ships.")
				table.insert(menu.selectableships, ffi.new("UniverseID", ConvertStringTo64Bit(ship)))
			end
		elseif not menu.isReadOnly then
			Helper.ffiVLA(menu.selectableships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.container, "player")
		end

		for i = #menu.selectableships, 1, -1 do
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(menu.selectableships[i], hasloop)

			if (not menu.isReadOnly) and (not C.CanContainerEquipShip(menu.container, menu.selectableships[i])) and (not C.CanContainerSupplyShip(menu.container, menu.selectableships[i])) then
				table.remove(menu.selectableships, i)
			elseif ffi.string(C.GetOwnerDetails(menu.selectableships[i]).factionID) ~= "player" then
				table.remove(menu.selectableships, i)
			elseif menu.selectableships[i] == C.GetPlayerOccupiedShipID() then
				menu.object = menu.selectableships[i]
			elseif (not menu.isReadOnly) and hasloop[0] then
				-- loops on player occupied ship is allowed, so do this check after the player occupied check
				table.remove(menu.selectableships, i)
			end
		end
		for i, ship in ipairs(menu.selectableships) do
			local name = ffi.string(C.GetComponentName(ship))
			local idcode = ffi.string(C.GetObjectIDCode(ship))
			local class = ffi.string(C.GetComponentClass(ship))
			local primarypurpose, icon, macro, hasanymod = GetComponentData(ConvertStringTo64Bit(tostring(ship)), "primarypurpose", "icon", "macro", "hasanymod")
			menu.selectableships[i] = { ship = ship, icon = icon, name = name, objectid = idcode, class = class, purpose = primarypurpose, macro = macro, hasanymod = hasanymod }
		end
		table.sort(menu.selectableships, Helper.sortShipsByClassAndPurpose)

		if not menu.object then
			menu.object = menu.selectableships[1] and menu.selectableships[1].ship
		end
		menu.macro = ""
		menu.customshipname = ""
		menu.useloadoutname = false
		menu.loadoutName = ""
		menu.playershipname = nil

		menu.class = ""
		menu.repairplan = {}
		if menu.object then
			menu.class = ffi.string(C.GetComponentClass(menu.object))
			menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
			menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
			
			local aipilot = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "assignedaipilot")
			if aipilot then
				menu.captainSelected = true
			else
				menu.captainSelected = false
			end
		else
			menu.object = 0
		end

		menu.shipgroups = {}
		for _, ship in ipairs(menu.selectableships) do
			local hastask = false
			local n = C.GetNumOrders(ship.ship)
			local buf = ffi.new("Order[?]", n)
			n = C.GetOrders(buf, n, ship.ship)
			for i = 0, n - 1 do
				if ffi.string(buf[i].orderdef) == "Equip" then
					local params = GetOrderParams(ConvertStringTo64Bit(tostring(ship.ship)), tonumber(buf[i].queueidx))
					hastask = params[1].value
					break
				elseif ffi.string(buf[i].orderdef) == "Repair" then
					hastask = true
					break
				end
			end

			if (not ship.hasanymod) and (not hastask) then
				local i = menu.findMacroIdx(menu.shipgroups, ship.macro)
				if i then
					table.insert(menu.shipgroups[i].ships, ship)
				else
					table.insert(menu.shipgroups, { idx = #menu.shipgroups + 1, macro = ship.macro, ships = { ship }, shipdata = {}, states = {} })
				end
			else
				table.insert(menu.shipgroups, { ship = ship })
			end
		end

		menu.selectableshipsbyclass = {}
		for i, entry in ipairs(menu.shipgroups) do
			if entry.ships then
				if #entry.ships > 1 then
					local groupentry = { group = i }
					if menu.selectableshipsbyclass[entry.ships[1].class] then
						table.insert(menu.selectableshipsbyclass[entry.ships[1].class], groupentry)
					else
						menu.selectableshipsbyclass[entry.ships[1].class] = { groupentry }
					end
				end
				for _, ship in ipairs(entry.ships) do
					local shipentry = { ship = ship, grouped = #entry.ships > 1, groupidx = i }
					if menu.selectableshipsbyclass[ship.class] then
						table.insert(menu.selectableshipsbyclass[ship.class], shipentry)
					else
						menu.selectableshipsbyclass[ship.class] = { shipentry }
					end
				end
			else
				if menu.selectableshipsbyclass[entry.ship.class] then
					table.insert(menu.selectableshipsbyclass[entry.ship.class], entry.ship)
				else
					menu.selectableshipsbyclass[entry.ship.class] = { entry.ship }
				end
			end
		end

	elseif menu.mode == "modify" then
		menu.selectableships = {}
		if menu.modeparam[1] then
			for _, ship in pairs(menu.modeparam[2]) do
				--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to list of ships.")
				table.insert(menu.selectableships, ship)
			end
			for i = #menu.selectableships, 1, -1 do
				if ffi.string(C.GetOwnerDetails(menu.selectableships[i]).factionID) ~= "player" then
					table.remove(menu.selectableships, i)
				elseif menu.selectableships[i] == C.GetPlayerOccupiedShipID() then
					menu.object = menu.selectableships[i]
				end
			end
		else
			Helper.ffiVLA(menu.selectableships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.container, "player")
			for i = #menu.selectableships, 1, -1 do
				if not C.CanContainerEquipShip(menu.container, menu.selectableships[i]) then
					table.remove(menu.selectableships, i)
				elseif ffi.string(C.GetOwnerDetails(menu.selectableships[i]).factionID) ~= "player" then
					table.remove(menu.selectableships, i)
				elseif menu.selectableships[i] == C.GetPlayerOccupiedShipID() then
					menu.object = menu.selectableships[i]
				end
			end
		end

		table.sort(menu.selectableships, Helper.sortUniverseIDName)

		if not menu.object then
			menu.object = menu.selectableships[1]
		end
		menu.macro = ""

		menu.class = ""
		if menu.object then
			menu.class = ffi.string(C.GetComponentClass(menu.object))
			menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))

			local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
			menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)
		else
			menu.object = 0
		end

		menu.selectableshipsbyclass = {}
		for _, ship in ipairs(menu.selectableships) do
			local class = ffi.string(C.GetComponentClass(ship))
			if menu.selectableshipsbyclass[class] then
				table.insert(menu.selectableshipsbyclass[class], ship)
			else
				menu.selectableshipsbyclass[class] = { ship }
			end
		end

		menu.prepareModWares()
	elseif menu.mode == "customgamestart" then
		menu.object = 0
		local options = ""
		if menu.modeparam.playerpropertyid then
			menu.macro = menu.modeparam.propertymacro or ""
			menu.customgamestartpeopledef = menu.modeparam.propertypeopledef or ""
			menu.customgamestartpeoplefillpercentage = menu.modeparam.propertypeoplefillpercentage or 100
			if menu.customgamestartpeoplefillpercentage == -1 then
				menu.customgamestartpeoplefillpercentage = 100
			end

			menu.customgamestartpilot = {}
			if menu.macro ~= "" then
				local buf = ffi.new("CustomGameStartPersonEntry[1]")
				buf[0].numskills = C.GetNumSkills()
				buf[0].skills = Helper.ffiNewHelper("SkillInfo[?]", buf[0].numskills)
				if C.GetCustomGameStartPlayerPropertyPerson(buf, menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.playerpropertyid) then
					menu.customgamestartpilot.race = ffi.string(buf[0].race)
					menu.customgamestartpilot.tags = ffi.string(buf[0].tags)
					menu.customgamestartpilot.skills = {}
					for i = 0, buf[0].numskills - 1 do
						local skill = ffi.string(buf[0].skills[i].id)
						menu.customgamestartpilot.skills[skill] = buf[0].skills[i].value
					end
				end
			end
		else
			local buf = ffi.new("CustomGameStartStringPropertyState[1]")
			menu.macro = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.shipproperty, buf))
			options = ffi.string(buf[0].options)
			menu.customgamestartpeopledef = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.shippeopleproperty, buf))
			local buf = ffi.new("CustomGameStartFloatPropertyState[1]")
			menu.customgamestartpeoplefillpercentage = tonumber(C.GetCustomGameStartFloatProperty(menu.modeparam.gamestartid, menu.modeparam.shippeoplefillpercentageproperty, buf))
			if menu.customgamestartpeoplefillpercentage == -1 then
				menu.customgamestartpeoplefillpercentage = 100
			end

			menu.customgamestartpilot = {}
			if menu.modeparam.shippilotproperty then
				local buf = ffi.new("CustomGameStartPersonEntry[1]")
				buf[0].numskills = C.GetNumSkills()
				buf[0].skills = Helper.ffiNewHelper("SkillInfo[?]", buf[0].numskills)
				if C.GetCustomGameStartShipPilot(buf, menu.modeparam.gamestartid, menu.modeparam.shippilotproperty) then
					menu.customgamestartpilot.race = ffi.string(buf[0].race)
					menu.customgamestartpilot.tags = ffi.string(buf[0].tags)
					menu.customgamestartpilot.skills = {}
					for i = 0, buf[0].numskills - 1 do
						local skill = ffi.string(buf[0].skills[i].id)
						menu.customgamestartpilot.skills[skill] = buf[0].skills[i].value
					end
				end
			end
		end
		menu.class = (menu.macro ~= "") and ffi.string(C.GetMacroClass(menu.macro)) or ""

		menu.availableshipmacros = {}
		if options ~= "" then
			for macro in string.gmatch(options, "[%a_]+") do
				table.insert(menu.availableshipmacros, macro)
			end
		else
			local n = C.GetNumAllShipMacros2(true, not menu.modeparam.creative)
			if n > 0 then
				local buf = ffi.new("const char*[?]", n)
				n = C.GetAllShipMacros2(buf, n, true, not menu.modeparam.creative)
				for i = 0, n - 1 do
					table.insert(menu.availableshipmacros, ffi.string(buf[i]))
				end
			end
		end

		menu.availableshipmacrosbyclass = {}
		for _, macro in ipairs(menu.availableshipmacros) do
			local class = ffi.string(C.GetMacroClass(macro))
			if menu.availableshipmacrosbyclass[class] then
				table.insert(menu.availableshipmacrosbyclass[class], macro)
			else
				menu.availableshipmacrosbyclass[class] = { macro }
			end
		end
	elseif menu.mode == "comparison" then
		menu.object = 0
		menu.macro = Helper.getShipComparisonMacro(menu.modeparam[1]) or ""
		menu.class = ffi.string(C.GetMacroClass(menu.macro))

		menu.availableshipmacros = {}
		for _, library in ipairs(config.comparisonShipLibraries) do
			local data = GetLibrary(library)
			for _, entry in ipairs(data) do
				table.insert(menu.availableshipmacros, entry.id)
			end
		end

		menu.availableshipmacrosbyclass = {}
		for _, macro in ipairs(menu.availableshipmacros) do
			local class = ffi.string(C.GetMacroClass(macro))
			if menu.availableshipmacrosbyclass[class] then
				table.insert(menu.availableshipmacrosbyclass[class], macro)
			else
				menu.availableshipmacrosbyclass[class] = { macro }
			end
		end
	end

	menu.hasDefaultLoadout = false
	menu.defaultLoadoutMacros = {}
	if (menu.object ~= 0) or (menu.macro ~= "") then
		local macro
		if menu.macro ~= "" then
			macro = menu.macro
		else
			macro = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
		end
		menu.hasDefaultLoadout = C.HasDefaultLoadout2(macro, true)
		if menu.hasDefaultLoadout then
			local n = C.GetNumDefaultLoadoutMacros(macro)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetDefaultLoadoutMacros(buf, n, macro)
			for i = 0, n - 1 do
				menu.defaultLoadoutMacros[ffi.string(buf[i])] = true
			end
		end
	end

	menu.equipmentsearchtext = {}
	menu.loadoutName = ""
	if (menu.mode == "purchase") or (menu.mode == "upgrade") or (menu.mode == "customgamestart") or (menu.mode == "comparison") then
		menu.upgradetypeMode = "engine"
	elseif menu.mode == "modify" then
		menu.upgradetypeMode = "shipmods"
	end
	menu.loadouts = {}

	menu.modCategory = "basic"

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	local upgradeplan, crew
	if state then
		upgradeplan, crew = menu.onRestoreState(state)
	elseif menu.mode == "customgamestart" then
		menu.software = {}
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "software" then
				menu.software[upgradetype.type] = {}
				if menu.macro ~= "" then
					local n = C.GetNumSoftwareSlots(0, menu.macro)
					local buf = ffi.new("SoftwareSlot[?]", n)
					n = C.GetSoftwareSlots(buf, n, 0, menu.macro)
					for j = 0, n - 1 do
						local entry = {}
						entry.maxsoftware = ffi.string(buf[j].max)
						entry.currentsoftware = ffi.string(buf[j].current)
						table.insert(menu.software[upgradetype.type], entry)
					end
				end
			end
		end

		if menu.modeparam.playerpropertyid then
			if menu.macro ~= "" then
				local loadout = Helper.getLoadoutHelper2(C.GetCustomGameStartPlayerPropertyLoadout, C.GetCustomGameStartPlayerPropertyLoadoutCounts, "UILoadout2", menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.playerpropertyid)
				upgradeplan = Helper.convertLoadout(menu.object, menu.macro, loadout, menu.software, "UILoadout2")
			end
		else
			local loadout = Helper.getLoadoutHelper2(C.GetCustomGameStartLoadoutProperty2, C.GetCustomGameStartLoadoutPropertyCounts2, "UILoadout2", menu.modeparam.gamestartid, menu.modeparam.shiploadoutproperty)
			upgradeplan = Helper.convertLoadout(menu.object, menu.macro, loadout, menu.software, "UILoadout2")
		end
	elseif menu.mode == "comparison" then
		if menu.macro ~= "" then
			menu.software = {}
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				if upgradetype.supertype == "software" then
					menu.software[upgradetype.type] = {}
					local n = C.GetNumSoftwareSlots(0, menu.macro)
					local buf = ffi.new("SoftwareSlot[?]", n)
					n = C.GetSoftwareSlots(buf, n, 0, menu.macro)
					for j = 0, n - 1 do
						local entry = {}
						entry.maxsoftware = ffi.string(buf[j].max)
						entry.currentsoftware = ffi.string(buf[j].current)
						table.insert(menu.software[upgradetype.type], entry)
					end
				end
			end

			upgradeplan = Helper.getShipComparisonUpgradeplan(menu.modeparam[1])
		end
	end

	if menu.container then
		menu.moddingdiscounts = GetComponentData(menu.container, "moddingdiscounts")
		menu.moddingdiscounts.totalfactor = 1
		for _, entry in ipairs(menu.moddingdiscounts) do
			menu.moddingdiscounts.totalfactor = menu.moddingdiscounts.totalfactor - entry.amount / 100
		end

		menu.repairdiscounts = GetComponentData(menu.container, "repairdiscounts")
		menu.repairdiscounts.totalfactor = 1
		for _, entry in ipairs(menu.repairdiscounts) do
			menu.repairdiscounts.totalfactor = menu.repairdiscounts.totalfactor - entry.amount / 100
		end

		menu.hiringdiscounts = GetComponentData(menu.container, "hiringdiscounts")
		menu.hiringdiscounts.totalfactor = 1
		for _, entry in ipairs(menu.hiringdiscounts) do
			menu.hiringdiscounts.totalfactor = menu.hiringdiscounts.totalfactor - entry.amount / 100
		end
	else
		menu.moddingdiscounts = { totalfactor = 1 }
		menu.repairdiscounts  = { totalfactor = 1 }
		menu.hiringdiscounts  = { totalfactor = 1 }
	end

	menu.displayMainFrame()

	AddUITriggeredEvent(menu.name, menu.upgradetypeMode)

	menu.getDataAndDisplay(upgradeplan, crew, nil, true)
	
	RegisterAddonBindings("ego_detailmonitor", "undo")
	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onShowMenuSound()
	if not C.IsNextStartAnimationSkipped(false) then
		PlaySound("ui_config_ship_open")
	else
		PlaySound("ui_menu_changed")
	end
end

function menu.displayMainFrame()
	Helper.removeAllWidgetScripts(menu, config.mainLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainLayer,
		standardButtons = { back = true, close = menu.mode ~= "customgamestart" },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- construction map
	menu.mainFrame:addRenderTarget({width = menu.mapData.width, height = menu.mapData.height, x = menu.mapData.offsetX, y = menu.mapData.offsetY, scaling = false, alpha = 100})

	menu.mainFrame:display()
end

function menu.displayLeftBar(frame)
	local leftBar = config.leftBar
	if menu.mode == "modify" then
		leftBar = config.leftBarMods
	end
	local spacingHeight = menu.frameworkData.sidebarWidth / 4
	local maxSlotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)

	local ftable = frame:addTable(2, { tabOrder = 2, width = menu.frameworkData.sidebarWidth + menu.frameworkData.scaleWidth + Helper.borderSize, height = 0, x = menu.frameworkData.offsetX, y = menu.slotData.offsetY + menu.titleData.height + 2 * Helper.borderSize + maxSlotWidth, scaling = false, reserveScrollBar = false })
	if (menu.upgradetypeMode == nil) and menu.setdefaulttable then
		ftable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	ftable:setColWidth(1, menu.frameworkData.scaleWidth)

	-- Fallback if nothing is selected yet, so if it is a shipyard show the groups, if not do not (so this condition can change when looking at a equipment dock)
	local iscapship = menu.container and GetComponentData(menu.container, "isshipyard") or false
	-- If we have an object or a macro use its size information
	if menu.object ~= 0 then
		iscapship = C.IsComponentClass(menu.object, "ship_l") or C.IsComponentClass(menu.object, "ship_xl")
	elseif menu.macro ~= "" then
		iscapship = IsMacroClass(menu.macro, "ship_l") or IsMacroClass(menu.macro, "ship_xl")
	end

	local found = true
	for _, entry in ipairs(leftBar) do
		local condition = true
		if condition and (entry.iscapship ~= nil) then
			condition = entry.iscapship == iscapship
		end
		if condition and (entry.customgamestart ~= nil) then
			condition = entry.customgamestart == (menu.mode == "customgamestart")
		end
		if condition and (entry.comparison ~= nil) then
			condition = entry.comparison == (menu.mode == "comparison")
		end
		if condition and (entry.hascontainer ~= nil) then
			condition = entry.hascontainer == (menu.container ~= nil)
		end

		if condition then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createIcon("mapst_seperator_line", { width = menu.frameworkData.sidebarWidth + menu.frameworkData.scaleWidth + Helper.borderSize, height = spacingHeight })
			else
				local active, skip = false, false
				local selected = entry.mode == menu.upgradetypeMode
				local prevSelected = entry.mode == menu.prevUpgradetypeMode
				local missing = false
				local overrideMode, overrideSlot
				local count, total = 0, 0
				local canequip = true
				if (menu.mode == "upgrade") and (not menu.isReadOnly) and (menu.object ~= 0) then
					canequip = C.CanContainerEquipShip(menu.container, menu.object)
				end
				local mouseovertext

				local upgradetype = Helper.findUpgradeType(entry.mode)

				if menu.mode == "modify" then
					local upgradetype = Helper.findUpgradeType(entry.upgrademode)
					if entry.upgrademode == "paint" then
						active = true
					elseif (entry.upgrademode == "ship") or (menu.slots[entry.upgrademode] and ((menu.slots[entry.upgrademode].count > 0) or (#menu.slots[entry.upgrademode] > 0))) then
						active = not menu.modeparam[1]
						if ((entry.upgrademode == "turret") and next(menu.groups)) or (entry.upgrademode == "shield") then
							active = active and (#menu.shieldgroups > 0)
							if #menu.shieldgroups == 0 then
								mouseovertext = "\27R" .. ReadText(1001, 4808) .. "\27X"
							end
						elseif menu.slots[entry.upgrademode] and (menu.slots[entry.upgrademode].count > 0) then
							local found = false
							for _, slot in ipairs(menu.slots[entry.upgrademode]) do
								if slot.currentmacro ~= "" then
									found = true
									break
								end
							end
							active = active and found
							if not found then
								mouseovertext = "\27R" .. ReadText(1001, 4808) .. "\27X"
							end
						end
					else
						mouseovertext = "\27R" .. ReadText(1001, 39) .. "\27X"
					end
				elseif entry.mode == "repair" then
					if #menu.damagedcomponents > 0 then
						active = true
						total = #menu.damagedcomponents
						if menu.repairplan and menu.repairplan[tostring(menu.object)] then
							for componentidstring in pairs(menu.repairplan[tostring(menu.object)]) do
								count = count + 1
							end
						end
					end
				elseif entry.mode == "settings" then
					if (menu.object ~= 0) or (menu.macro ~= "") then
						active = true
					end
				elseif (entry.mode == "enginegroup") or (entry.mode == "turretgroup") then
					skip = not canequip
					if next(menu.groups) then
						active = true
						local curslotsizepriority
						for slot, groupdata in pairs(menu.groups) do
							if groupdata[upgradetype.grouptype] and (groupdata[upgradetype.grouptype].total > 0) then
								if groupdata.slotsize and (groupdata.slotsize ~= "") then
									local sizeorder = Helper.slotSizeOrder[groupdata.slotsize] or 0
									if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
										curslotsizepriority = sizeorder
										overrideSlot = slot
									end
								end
							end
						end
						for _, upgradetype in ipairs(Helper.upgradetypes) do
							if upgradetype.supertype == "group" then
								for slot, group in pairs(menu.upgradeplan[upgradetype.type]) do
									if (entry.mode == "enginegroup") == (menu.groups[slot]["engine"].total > 0) then
										if (menu.groups[slot][upgradetype.grouptype].total > 0) then
											if upgradetype.mergeslots then
												count = count + ((menu.upgradeplan[upgradetype.type][slot].count > 0) and 1 or 0)
												total = total + 1
											else
												count = count + menu.upgradeplan[upgradetype.type][slot].count
												total = total + menu.groups[slot][upgradetype.grouptype].total
											end
										end
									end
								end
							end
						end
					end
					for _, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "group" then
							if upgradetype.allowempty == false then
								if ((upgradetype.grouptype == "engine") and (entry.mode == "enginegroup")) or ((upgradetype.grouptype == "turret") and (entry.mode == "turretgroup")) or ((upgradetype.grouptype ~= "engine") and (upgradetype.grouptype ~= "turret")) then
									for slot, group in pairs(menu.upgradeplan[upgradetype.type]) do
										if (group.macro == "") and (menu.groups[slot][upgradetype.grouptype].total > 0) then
											missing = true
											break
										end
									end
								end
							end
						end
					end
				elseif entry.mode == "software" then
					if menu.software[entry.mode] and (#menu.software[entry.mode] > 0) then
						active = true
						total = #menu.software[entry.mode]
						for slot, ware in ipairs(menu.upgradeplan[entry.mode]) do
							if ware ~= "" then
								count = count + 1
							end
						end
						for slot, slotdata in ipairs(menu.software[upgradetype.type]) do
							if #slotdata.possiblesoftware > 0 then
								if (slotdata.defaultsoftware ~= 0) and (menu.upgradeplan[upgradetype.type][slot] == "") then
									missing = true
									break
								end
							end
						end
					end
				elseif entry.mode == "consumables" then
					for _, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "ammo" then
							if next(menu.ammo[upgradetype.type]) then
								local ammocount, capacity = menu.getAmmoUsage(upgradetype.type)
								for macro, amount in pairs(menu.upgradeplan[upgradetype.type]) do
									if (ammocount > 0) or ((capacity > 0) and menu.isAmmoCompatible(upgradetype.type, macro)) then
										active = true
										count = count + ammocount
										total = total + capacity
										break
									end
								end

								if ((ammocount > 0) or (capacity > 0)) and active then
									if ammocount > capacity then
										missing = true
									end
								end
							end
						end
					end
				elseif entry.mode == "crew" then
					if (menu.object ~= 0) or (menu.macro ~= "") then
						active = menu.objectgroup == nil
						if menu.crew.capacity > 0 then
							if active then
								if menu.mode == "customgamestart" then
									count = ((menu.customgamestartpeopledef == "") and 0 or Helper.round(menu.crew.capacity * menu.customgamestartpeoplefillpercentage / 100)) + (menu.modeparam.playerpropertyid and 1 or 0)
									total = menu.crew.capacity + (menu.modeparam.playerpropertyid and 1 or 0)
								else
									count = menu.crew.total + menu.crew.hired - #menu.crew.fired + (menu.captainSelected and 1 or 0)
									total = menu.crew.capacity + 1
								end
							end
							if menu.usemacro and (not menu.captainSelected) then
								missing = true
							end
							if #menu.crew.unassigned > 0 then
								missing = true
							end
						else
							if active then
								if menu.mode == "customgamestart" then
									active = active and (menu.modeparam.playerpropertyid ~= nil)
									count = menu.modeparam.playerpropertyid and 1 or 0
									total = menu.modeparam.playerpropertyid and 1 or 0
								else
									count = menu.captainSelected and 1 or 0
									total = 1
								end
							end
							if menu.usemacro and (not menu.captainSelected) then
								missing = true
							end
						end
					end
				elseif upgradetype and (upgradetype.supertype == "macro") then
					skip = not canequip
					if menu.slots[entry.mode] and (menu.slots[entry.mode].count > 0) then
						active = true
						total = menu.slots[entry.mode].count
						for slot, data in ipairs(menu.upgradeplan[entry.mode]) do
							if data.macro ~= "" then
								count = count + 1
							end
						end
						local curslotsizepriority
						for slot, slotdata in ipairs(menu.slots[entry.mode]) do
							if not slotdata.isgroup then
								if slotdata.slotsize and (slotdata.slotsize ~= "") then
									local sizeorder = Helper.slotSizeOrder[slotdata.slotsize] or 0
									if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
										curslotsizepriority = sizeorder
										overrideSlot = slot
									end
								end
							end
						end
					else
						-- override engine category to point to group with engines
						if upgradetype.type == "engine" then
							if next(menu.groups) then
								active = true
								overrideMode = "enginegroup"
								for slot, groupdata in pairs(menu.groups) do
									if groupdata[upgradetype.type].total > 0 then
										overrideSlot = slot
										break
									end
								end
							end
						end
					end
					for slot, data in pairs(menu.upgradeplan[upgradetype.type]) do
						if data.macro == "" then
							if (upgradetype.allowempty == false) or C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, slot) then
								missing = true
								break
							end
						end
					end
				else
					skip = not canequip
					if menu.slots[entry.mode] and (#menu.slots[entry.mode] > 0) then
						active = true
						total = #menu.slots[entry.mode]
						for slot, data in ipairs(menu.upgradeplan[entry.mode]) do
							if data.macro ~= "" then
								count = count + 1
							end
						end
					end
					if upgradetype.allowempty == false then
						for slot, data in pairs(menu.upgradeplan[upgradetype.type]) do
							if data.macro == "" then
								missing = true
								break
							end
						end
					end
				end

				if not skip then
					if menu.mode == "purchase" then
						active = active and (menu.validLicence == true)
					end

					-- if nothing selected yet, select this one if active
					if (not found) and active and (menu.upgradetypeMode ~= nil) then
						found = true
						selected = true
						menu.upgradetypeMode = entry.mode
						menu.selectMapMacroSlot()
					end

					-- if selected, but not active, select next active entry
					if selected and (not active) then
						found = false
						selected = false
					end

					local color = Helper.color.white
					if active then
						if missing then
							color = Helper.color.red
						end
					else
						color = Helper.color.grey
					end

					local row = ftable:addRow(active, { fixed = true, bgColor = Helper.color.transparent })
					if total > 0 then
						local height = math.floor((menu.frameworkData.sidebarWidth - 2 * menu.scaleSize) * math.min(count, total) / total)
						row[1]:createIcon("solid", { cellBGColor = active and Helper.defaultSimpleBackgroundColor or Helper.color.darkgrey, color = Helper.color.white, width = menu.scaleSize, height = height, x = menu.scaleSize, y = (menu.frameworkData.sidebarWidth - height - 2 * menu.scaleSize) / 2 })
					else
						row[1]:createText("", { cellBGColor = active and Helper.defaultSimpleBackgroundColor or Helper.color.darkgrey, x = 0, y = 0 })
					end

					if selected then
						menu.selectedRows.left = row.index
					elseif prevSelected then
						menu.selectedRows.left = row.index
					end
					if mouseovertext then
						mouseovertext = entry.name .. "\n" .. mouseovertext
					else
						mouseovertext = entry.name
					end
					row[2]:createButton({ active = active, height = menu.frameworkData.sidebarWidth, mouseOverText = mouseovertext, bgColor = selected and Helper.defaultArrowRowBackgroundColor or Helper.defaultButtonBackgroundColor }):setIcon(entry.icon, { color = color })
					row[2].handlers.onClick = function () return menu.buttonLeftBar(entry.mode, row.index, overrideMode, overrideSlot) end
				elseif selected then
					found = false
				end
			end
		else
			if entry.mode == menu.upgradetypeMode then
				found = false
			end
		end
	end
	ftable:setTopRow(menu.topRows.left)
	ftable:setSelectedRow(menu.selectedRows.left)
	menu.topRows.left = nil
	menu.selectedRows.left = nil
end

function menu.getPresetLoadouts()
	menu.loadouts = {}
	if not menu.isReadOnly then
		if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") and (menu.object ~= 0)) then
			local currentmacro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
			local n = C.GetNumLoadoutsInfo(menu.object, menu.macro)
			local buf = ffi.new("UILoadoutInfo[?]", n)
			n = C.GetLoadoutsInfo(buf, n, menu.object, menu.macro)
			for i = 0, n - 1 do
				local id = ffi.string(buf[i].id)
				local active = false
				local mouseovertext = ""
				local numinvalidpatches = ffi.new("uint32_t[?]", 1)
				if not C.IsLoadoutValid(menu.object, menu.macro, id, numinvalidpatches) then
					local numpatches = numinvalidpatches[0]
					local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
					numpatches = C.GetLoadoutInvalidPatches(patchbuf, numpatches, menu.object, menu.macro, id)
					mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
					for j = 0, numpatches - 1 do
						if j > 3 then
							mouseovertext = mouseovertext .. "\n- ..."
							break
						end
						mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
						if patchbuf[j].state == 2 then
							mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
						elseif patchbuf[j].state == 3 then
							mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
						elseif patchbuf[j].state == 4 then
							mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
						end
					end
				elseif not C.IsLoadoutCompatible(currentmacro, id) then
					mouseovertext = ReadText(1026, 8024)
				elseif menu.mode == "customgamestart" then
					active = true
				elseif menu.mode == "comparison" then
					active = C.CanApplyKnownLoadout(menu.macro, id)
					if not active then
						mouseovertext = ReadText(1026, 8015)
					end
				else
					active = C.CanBuildLoadout(menu.container, menu.object, menu.macro, id)
					if not active then
						mouseovertext = ReadText(1026, 8011)
					end
				end
				table.insert(menu.loadouts, { id = id, name = ffi.string(buf[i].name), icon = ffi.string(buf[i].iconid), deleteable = buf[i].deleteable, active = active, mouseovertext = mouseovertext })
			end
		end
		table.sort(menu.loadouts, Helper.sortName)

		local missionloadouts = {}
		if (menu.mode == "purchase") or (menu.mode == "upgrade") then
			if (menu.object ~= 0) or (menu.macro ~= "") then
				local currentmacro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
				local n = C.GetNumRequestedMissionShips()
				local buf = ffi.new("MissionShipDeliveryInfo[?]", n)
				n = C.GetRequestedMissionShips(buf, n)
				for i = 0, n - 1 do
					local id = buf[i].missionid
					local macro = ffi.string(buf[i].macroname)
					if macro == currentmacro then
						local missiondetails = C.GetMissionIDDetails(id)
						local active = C.CanBuildMissionLoadout(menu.container, id, macro)
						if not active then
							mouseovertext = ReadText(1026, 8011)
						end
						table.insert(missionloadouts, 1, { id = "mission" .. i, name = Helper.convertColorToText(Helper.color.mission) .. "\27[" .. "missiontype_" .. ffi.string(missiondetails.subType) .. "] " .. ffi.string(missiondetails.missionName) .. "\27X", icon = "", deleteable = false, mission = { id = id, macro = macro }, active = active, mouseovertext = mouseovertext })
					end
				end
			end
		end
		table.sort(missionloadouts, Helper.sortName)
		for i, entry in ipairs(missionloadouts) do
			table.insert(menu.loadouts, i, entry)
		end

		local hasanymod = false
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			local slots = (upgradetype.supertype == "group") and menu.upgradeplan[upgradetype.type] or menu.slots[upgradetype.type]
			local first = true
			for slot, macro in pairs(slots or {}) do
				if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
					if menu.groups[slot] and (menu.groups[slot][upgradetype.grouptype].total > 0) then
						local hasmod = menu.checkMod(upgradetype.grouptype, menu.groups[slot][upgradetype.grouptype].currentcomponent, true)
						if hasmod then
							hasanymod = true
							break
						end
					end
				elseif upgradetype.supertype == "macro" then
					if type(slot) == "number" then
						local hasmod = menu.checkMod(upgradetype.type, slots[slot].component)
						if hasmod then
							hasanymod = true
							break
						end
					end
				end
			end
			if hasanymod then
				break
			end
		end

		if not menu.hasDefaultLoadout then
			table.insert(menu.loadouts, 1, { id = "empty",	name = ReadText(1001, 7941), icon = "", deleteable = false, preset = 0,		active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = hasanymod and ("\27R" .. ReadText(1026, 8020)) or "" })
			table.insert(menu.loadouts, 2, { id = "low",	name = ReadText(1001, 7910), icon = "", deleteable = false, preset = 0.1,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = hasanymod and ("\27R" .. ReadText(1026, 8020)) or "" })
			table.insert(menu.loadouts, 3, { id = "medium",	name = ReadText(1001, 7911), icon = "", deleteable = false, preset = 0.5,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = hasanymod and ("\27R" .. ReadText(1026, 8020)) or "" })
			table.insert(menu.loadouts, 4, { id = "high",	name = ReadText(1001, 7912), icon = "", deleteable = false, preset = 1.0,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = hasanymod and ("\27R" .. ReadText(1026, 8020)) or "" })
		else
			table.insert(menu.loadouts, 1, { id = "default",	name = ReadText(1001, 3231), icon = "", deleteable = false,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = hasanymod and ("\27R" .. ReadText(1026, 8020)) or "" })
		end
	end
end

function menu.getDataAndDisplay(upgradeplan, crew, newedit, firsttime, noundo, settings)
	-- init upgradeplan
	menu.upgradeplan = {}
	menu.upgradewares = {}
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		menu.upgradeplan[upgradetype.type] = {}
		if upgradetype.supertype ~= "group" then
			menu.upgradewares[upgradetype.type] = {}
		end
	end

	-- assemble possible upgrades (wares, macros, stock)
	if menu.mode == "comparison" then
		for _, libraryentry in ipairs(config.comparisonEquipmentLibraries) do
			local data = GetLibrary(libraryentry.library)
			for _, dataentry in ipairs(data) do
				-- check all aliases due to collision / no-collision compatibilities
				local n = C.GetNumLibraryEntryAliases(libraryentry.library, dataentry.id)
				local buf = ffi.new("const char*[?]", n)
				n = C.GetLibraryEntryAliases(buf, n, libraryentry.library, dataentry.id)
				for j = 0, n - 1 do
					local aliasid = ffi.string(buf[j])
					local entry = {}
					local ware, name = GetMacroData(aliasid, "ware", "name")
					entry.ware = ware
					entry.macro = aliasid
					entry.name = name
					entry.objectamount = 0
					entry.isFromShipyard = true

					if menu.upgradewares[libraryentry.type] then
						table.insert(menu.upgradewares[libraryentry.type], entry)
					else
						menu.upgradewares[libraryentry.type] = { entry }
					end
				end
			end
		end
	else
		local n = 0
		local buf
		if menu.mode == "customgamestart" then
			n = C.GetNumAllEquipment(true)
			buf = ffi.new("EquipmentWareInfo[?]", n)
			n = C.GetAllEquipment(buf, n, true)
		elseif (not menu.isReadOnly) and ((menu.mode ~= "modify") or (not menu.modeparam[1])) then
			n = C.GetNumAvailableEquipment(menu.container, "")
			buf = ffi.new("EquipmentWareInfo[?]", n)
			n = C.GetAvailableEquipment(buf, n, menu.container, "")
		end
		if n > 0 then
			for i = 0, n - 1 do
				local type = ffi.string(buf[i].type)
				local entry = {}
				entry.ware = ffi.string(buf[i].ware)
				entry.macro = ffi.string(buf[i].macro)
				if type == "software" then
					entry.name = GetWareData(entry.ware, "name")
				else
					entry.name = GetMacroData(entry.macro, "name")
				end
				entry.objectamount = 0
				entry.isFromShipyard = true
				if (type == "lasertower") or (type == "satellite") or (type == "mine") or (type == "navbeacon") or (type == "resourceprobe") then
					type = "deployable"
				end
				if type == "" then
					DebugError(string.format("Could not find upgrade type for the equipment ware: '%s'. Check the ware tags. [Florian]", entry.ware))
				else
					if menu.upgradewares[type] then
						table.insert(menu.upgradewares[type], entry)
					else
						menu.upgradewares[type] = { entry }
					end
				end
			end
		end
	end

	-- sort
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype ~= "group" then
			table.sort(menu.upgradewares[upgradetype.type], Helper.sortName)
		end
	end

	-- assemble available slots/ammo/software
	menu.groups = {}
	menu.slots = {}
	menu.ammo = { missile = {}, drone = {}, deployable = {}, countermeasure = {}, }
	menu.software = {}
	menu.crew = { 
		total = 0,
		capacity = 0,
		unassigned = {},
		roles = {},
		hired = 0,
		hireddetails = {},
		transferdetails = {},
		fired = {},
		ware = "crew",
		availableworkforce = 0,
		maxavailableworkforce = 0,
		availabledockcrew = 0,
		maxavailabledockcrew = 0,
	}
	if settings then
		menu.settings = settings
	else
		menu.settings = {
			blacklists = {},
			fightrules = {},
		}
	end

	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and ((menu.mode ~= "modify") or (not menu.modeparam[1])) then
		if C.IsComponentClass(menu.container, "ship") then
			local n = C.GetNumAllRoles()
			local buf = ffi.new("PeopleInfo[?]", n)
			n = C.GetPeople2(buf, n, menu.container, true)
			local numhireable = 0
			for i = 0, n - 1 do
				menu.crew.availabledockcrew = menu.crew.availabledockcrew + buf[i].amount
			end
			menu.crew.maxavailabledockcrew = C.GetPeopleCapacity(menu.container, "", false)
		else
			local workforceinfo = C.GetWorkForceInfo(menu.container, "")
			menu.crew.availableworkforce = workforceinfo.available
			menu.crew.maxavailableworkforce = workforceinfo.maxavailable
		end

		local minprice, maxprice = GetWareData(menu.crew.ware, "minprice", "maxprice")
		menu.crew.price = Helper.round(menu.hiringdiscounts.totalfactor * C.GetContainerBuildPriceFactor(menu.container) * (maxprice - (menu.crew.availableworkforce + menu.crew.availabledockcrew) / (menu.crew.maxavailableworkforce + menu.crew.maxavailabledockcrew) * (maxprice - minprice)))
	end

	menu.defaultpaintmod = {}
	local buf = ffi.new("UIPaintMod")
	if (menu.object ~= 0) or (menu.macro ~= "") then
		if C.GetPlayerPaintThemeMod(menu.object, menu.macro, buf) then
			menu.defaultpaintmod.name = ffi.string(buf.Name)
			menu.defaultpaintmod.ware = ffi.string(buf.Ware)
			menu.defaultpaintmod.quality = buf.Quality
			menu.defaultpaintmod.isdefault = true
		end
	end

	menu.installedPaintMod = nil
	if menu.object ~= 0 then
		local paintmod = ffi.new("UIPaintMod")
		if C.GetInstalledPaintMod(menu.object, paintmod) then
			menu.installedPaintMod = {}
			menu.installedPaintMod.name = ffi.string(paintmod.Name)
			menu.installedPaintMod.ware = ffi.string(paintmod.Ware)
			menu.installedPaintMod.quality = paintmod.Quality
			menu.installedPaintMod.amount = paintmod.Amount
			menu.installedPaintMod.isdefault = menu.defaultpaintmod.ware == menu.installedPaintMod.ware
		end
	elseif menu.macro ~= "" then
		if menu.mode == "customgamestart" then
			local buf = ffi.new("CustomGameStartStringPropertyState[1]")
			local painttheme = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.paintthemeproperty, buf))
			local paintmod = ffi.new("UIPaintMod")
			if C.GetPaintThemeMod(painttheme, "player", paintmod) then
				menu.installedPaintMod = {}
				menu.installedPaintMod.name = ffi.string(paintmod.Name)
				menu.installedPaintMod.ware = ffi.string(paintmod.Ware)
				menu.installedPaintMod.quality = paintmod.Quality
				menu.installedPaintMod.amount = paintmod.Amount
				menu.installedPaintMod.isdefault = menu.defaultpaintmod.ware == menu.installedPaintMod.ware
			end
		else
			local paintmod = ffi.new("UIPaintMod")
			if C.GetPlayerPaintThemeMod(menu.object, menu.macro, paintmod) then
				menu.installedPaintMod = {}
				menu.installedPaintMod.name = ffi.string(paintmod.Name)
				menu.installedPaintMod.ware = ffi.string(paintmod.Ware)
				menu.installedPaintMod.quality = paintmod.Quality
				menu.installedPaintMod.amount = paintmod.Amount
				menu.installedPaintMod.isdefault = menu.defaultpaintmod.ware == menu.installedPaintMod.ware
			end
		end
	end

	menu.groups = {}
	if (menu.usemacro and (menu.macro ~= "")) or (((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0)) then
		menu.setupGroupData(menu.object, menu.macro, menu.groups, true)
	end

	if menu.usemacro then
		if menu.macro ~= "" then
			menu.prepareMacroUpgradeSlots(menu.macro)
			menu.prepareMacroCrewInfo(menu.macro)
		end
	elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
		if menu.object ~= 0 then
			menu.prepareComponentUpgradeSlots(menu.object, menu.slots, menu.ammo, menu.software, true)
			menu.prepareComponentCrewInfo(menu.object)

			menu.checkCurrentBuildTasks()

			if menu.objectgroup then
				for i = 1, #menu.objectgroup.ships do
					menu.objectgroup.shipdata[i] = {
						slots = {},
						groups = {},
						ammo = {},
						software = {},
					}
					menu.prepareComponentUpgradeSlots(menu.objectgroup.ships[i].ship, menu.objectgroup.shipdata[i].slots, menu.objectgroup.shipdata[i].ammo, menu.objectgroup.shipdata[i].software, false)
					menu.setupGroupData(menu.objectgroup.ships[i].ship, "", menu.objectgroup.shipdata[i].groups, false)
					menu.objectgroup.shipdata[i].damagedcomponents = menu.determineNeededRepairs(menu.objectgroup.ships[i].ship)
				end

				-- check for foreign macros (aka not sold by shipyard) - if all ships have the same as menu.object, it's fine. Otherwise the macro has to be deinstalled
				-- This is necessary as otherwise each ship in the group would need to keep track of an individual upgradeplan
				for i, upgradetype in ipairs(Helper.upgradetypes) do
					if upgradetype.supertype == "macro" then
						for j = 1, tonumber(C.GetNumUpgradeSlots(menu.object, "", upgradetype.type)) do
							if menu.upgradeplan[upgradetype.type][j].checkforeignmacro then
								local found = false
								for i = 1, #menu.objectgroup.ships do
									if menu.upgradeplan[upgradetype.type][j].macro ~= menu.objectgroup.shipdata[i].slots[upgradetype.type][j].currentmacro then
										menu.upgradeplan[upgradetype.type][j].macro = ""
										menu.slots[upgradetype.type][j].hasstock = false
										found = true
										break
									end
								end
								if not found then
									menu.upgradeplan[upgradetype.type][j].checkforeignmacro = nil
								end
							end
						end
					elseif upgradetype.supertype == "group" then
						for j, group in pairs(menu.upgradeplan[upgradetype.type]) do
							if group.checkforeignmacro then
								local found = false
								for i = 1, #menu.objectgroup.ships do
									if group.macro ~= menu.objectgroup.shipdata[i].groups[j][upgradetype.grouptype].currentmacro then
										menu.upgradeplan[upgradetype.type][j].macro = ""
										menu.groups[j][upgradetype.grouptype].hasstock = false
										found = true
										break
									end
								end
								if not found then
									menu.upgradeplan[upgradetype.type][j].checkforeignmacro = nil
								end
							end
						end
					end
				end
			end
		end
	end
	if menu.mode == "modify" then
		if menu.object ~= 0 then
			menu.shieldgroups = {}
			local shieldsizecounts = {}
			local n = C.GetNumShieldGroups(menu.object)
			local buf = ffi.new("ShieldGroup[?]", n)
			n = C.GetShieldGroups(buf, n, menu.object)
			for i = 0, n - 1 do
				local entry = {}
				entry.context = buf[i].context
				entry.group = ffi.string(buf[i].group)
				entry.component = buf[i].component

				if (entry.context == menu.object) and (entry.group == "") then -- mainship
					local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", entry.context, "", entry.group, "shield")
					entry.slotsize = ffi.string(groupinfo.slotsize)
					entry.count = groupinfo.count
					entry.upgradetype = "shields"
				else
					local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", entry.context, "", entry.group, "engine")
					if groupinfo.total > 0 then	-- EngineGroup
						entry.slotsize = ffi.string(groupinfo.slotsize)
						entry.upgradetype = "engines"	
					else -- TurretGroup
						local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", entry.context, "", entry.group, "turret")
						entry.slotsize = ffi.string(groupinfo.slotsize)
						entry.upgradetype = "turrets"
					end
				end
				entry.sizecount = 0

				if entry.slotsize ~= "" then
					if shieldsizecounts[entry.upgradetype] then
						if shieldsizecounts[entry.upgradetype][entry.slotsize] then
							shieldsizecounts[entry.upgradetype][entry.slotsize] = shieldsizecounts[entry.upgradetype][entry.slotsize] + 1
						else
							shieldsizecounts[entry.upgradetype][entry.slotsize] = 1
						end
					else
						shieldsizecounts[entry.upgradetype] = {}
						shieldsizecounts[entry.upgradetype][entry.slotsize] = 1
					end
					entry.sizecount = shieldsizecounts[entry.upgradetype][entry.slotsize]
				end

				table.insert(menu.shieldgroups, entry)
			end
			for i, entry in ipairs(menu.shieldgroups) do
				if (entry.context == menu.object) and (entry.group == "") then
					menu.shieldgroups.hasMainGroup = true
					-- force maingroup to first index
					table.insert(menu.shieldgroups, 1, entry)
					table.remove(menu.shieldgroups, i + 1)
					break
				end
			end
		end

		if menu.installedPaintMod then
			if menu.modwares["paint"] then
				local found = false
				for i, mod in ipairs(menu.modwares["paint"]) do
					if mod.ware == menu.installedPaintMod.ware then
						found = true
						break
					end
				end
				if not found then
					table.insert(menu.modwares["paint"], menu.installedPaintMod)
				end
			else
				menu.modwares["paint"] = { menu.installedPaintMod }
			end
		end
	end

	if menu.currentSlot == nil then
		menu.determineInitialSlot()
	end

	-- assemble possible upgrades per slot
	for type, slots in pairs(menu.slots) do
		local upgradetype = Helper.findUpgradeType(type)
		if upgradetype.supertype == "macro" then
			slots.count = #slots
			local sizecounts = {}
			for i, slot in ipairs(slots) do
				if menu.upgradewares[type] then
					for _, upgradeware in ipairs(menu.upgradewares[type]) do
						if menu.checkCompatibility(upgradeware.macro) and C.IsUpgradeMacroCompatible(menu.object, 0, menu.macro, false, type, i, upgradeware.macro) then
							if upgradeware.isFromShipyard or (slot.currentmacro == upgradeware.macro) then
								table.insert(slot.possiblemacros, upgradeware.macro)
							end
						elseif slot.currentmacro and (slot.currentmacro == upgradeware.macro) then
							table.insert(slot.possiblemacros, upgradeware.macro)
						end
					end
					table.sort(slot.possiblemacros, Helper.sortMacroRaceAndShortname)
				end

				local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, type, i)
				if (ffi.string(groupinfo.path) ~= "..") or (ffi.string(groupinfo.group) ~= "") then
					slot.isgroup = true
					slots.count = slots.count - 1
				end
				if not slot.isgroup then
					slot.slotname = i
					slot.slotsize = ffi.string(C.GetSlotSize(menu.object, 0, menu.macro, false, upgradetype.type, i))
					if slot.slotsize ~= "" then
						if sizecounts[slot.slotsize] then
							sizecounts[slot.slotsize] = sizecounts[slot.slotsize] + 1
						else
							sizecounts[slot.slotsize] = 1
						end
						slot.slotname = upgradetype.shorttext[slot.slotsize] .. sizecounts[slot.slotsize]
					end
				end
			end
		elseif upgradetype.supertype == "virtualmacro" then
			for i, slot in ipairs(slots) do
				if menu.upgradewares[type] then
					for _, upgradeware in ipairs(menu.upgradewares[type]) do
						if menu.checkCompatibility(upgradeware.macro) and C.IsVirtualUpgradeMacroCompatible(menu.object, menu.macro, type, i, upgradeware.macro) then
							table.insert(slot.possiblemacros, upgradeware.macro)
						end
					end
					table.sort(slot.possiblemacros, Helper.sortMacroRaceAndShortname)
				end
			end
		end
	end

	-- assemble possible upgrades per group
	for i, group in ipairs(menu.groups) do
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local wares = menu.upgradewares[upgradetype.grouptype] or {}
				for _, upgradeware in ipairs(wares) do
					if upgradeware.macro ~= "" then
						if menu.checkCompatibility(upgradeware.macro) and C.IsUpgradeGroupMacroCompatible(menu.object, menu.macro, group.path, group.group, upgradetype.grouptype, upgradeware.macro) then
							if upgradeware.isFromShipyard or (group[upgradetype.grouptype].currentmacro == upgradeware.macro) then
								table.insert(menu.groups[i][upgradetype.grouptype].possiblemacros, upgradeware.macro)
							end
						end
					end
					table.sort(menu.groups[i][upgradetype.grouptype].possiblemacros, Helper.sortMacroRaceAndShortname)
				end
			end
		end
	end

	-- assemble possible software per slot
	for type, softwarelist in pairs(menu.software) do
		for j, software in ipairs(softwarelist) do
			software.defaultsoftware = 0
			software.possiblesoftware = {}
			local n = C.GetNumSoftwarePredecessors(software.maxsoftware)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetSoftwarePredecessors(buf, n, software.maxsoftware)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i])
				if (not menu.isReadOnly) or (ware == software.currentsoftware) then
					table.insert(software.possiblesoftware, ware)
				end
				if C.IsSoftwareDefault(menu.object, menu.macro, ware) then
					software.defaultsoftware = i + 1
					if software.currentsoftware == "" then
						if upgradeplan or (menu.mode ~= "purchase") or (menu.upgradeplan[type][j] ~= "") then
							menu.upgradeplan[type][j] = ware
						end
					end
				end
			end
			if (not menu.isReadOnly) or (software.maxsoftware == software.currentsoftware) then
				table.insert(software.possiblesoftware, software.maxsoftware)
			end
			if C.IsSoftwareDefault(menu.object, menu.macro, software.maxsoftware) then
				software.defaultsoftware = #software.possiblesoftware
				if software.currentsoftware == "" then
					if upgradeplan or (menu.mode ~= "purchase") or (menu.upgradeplan[type][j] ~= "") then
						menu.upgradeplan[type][j] = software.maxsoftware
					end
				end
			end
		end
	end

	-- get preset loadouts
	menu.getPresetLoadouts()

	if upgradeplan then
		for type, upgradelist in pairs(menu.upgradeplan) do
			local upgradetype = Helper.findUpgradeType(type)
			for key, upgrade in pairs(upgradelist) do
				if upgradetype.supertype == "group" then
					local found = false
					for key2, upgrade2 in pairs(upgradeplan[type]) do
						if (upgrade2.path == upgrade.path) and (upgrade2.group == upgrade.group) then
							found = true
							menu.upgradeplan[type][key].macro = upgrade2.macro or ""
							menu.upgradeplan[type][key].count = upgrade2.count or 0
							menu.upgradeplan[type][key].ammomacro = upgrade2.ammomacro or ""
							menu.upgradeplan[type][key].weaponmode = upgrade2.weaponmode or ""
							break
						end
					end
					if not found then
						menu.upgradeplan[type][key].macro = ""
						menu.upgradeplan[type][key].count = 0
					end
				else
					local newvalue
					if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
						newvalue = upgradeplan[type][key] or { macro = "", ammomacro = "", weaponmode = "" }
					elseif (upgradetype.supertype == "software") then
						if not upgradeplan[type][key] then
							if menu.upgradeplan[type][key] ~= "" then
								if menu.software[type][key].defaultsoftware ~= 0 then
									newvalue = menu.software[type][key].possiblesoftware[menu.software[type][key].defaultsoftware]
								else
									newvalue = ""
								end
							else
								newvalue = ""
							end
						else
							newvalue = upgradeplan[type][key]
						end
					elseif (upgradetype.supertype == "ammo") then
						newvalue = 0
					end
					menu.upgradeplan[type][key] = newvalue
				end
			end
			if upgradetype.supertype == "crew" then
				if menu.usemacro then
					menu.crew.hired = 0
					menu.crew.hireddetails = {}
					menu.crew.unassigned = {}
					menu.crew.fired = {}

					for i, entry in ipairs(menu.crew.roles) do
						for roleid, amount in pairs(upgradeplan[type]) do
							if roleid == entry.id then
								menu.crew.roles[i].wanted = amount
								menu.crew.roles[i].tiers[1].wanted = amount

								menu.crew.hired = menu.crew.hired + amount
								table.insert(menu.crew.hireddetails, { newrole = roleid, amount = amount, price = menu.crew.price })
								break
							end
						end
					end
				end
			end
		end
		-- second pass due to ammo commpatibility being based on weapons and turrets
		for type, upgradelist in pairs(menu.upgradeplan) do
			local upgradetype = Helper.findUpgradeType(type)
			for key, upgrade in pairs(upgradelist) do
				if (upgradetype.supertype == "ammo") then
					if menu.isAmmoCompatible(type, key) then
						newvalue = upgradeplan[type][key] or 0
					else
						newvalue = 0
					end
					menu.upgradeplan[type][key] = newvalue
				end
			end
		end
		menu.upgradeplan.hascrewexperience = upgradeplan.hascrewexperience
	end
	if crew then
		menu.crew.hired = crew.hired
		for _, entry in ipairs(crew.fired) do
			table.insert(menu.crew.fired, entry)
		end
		menu.crew.unassigned = crew.unassigned
		for _, entry in ipairs(crew.hireddetails) do
			table.insert(menu.crew.hireddetails, entry)
		end
		for i, entry in ipairs(crew.roles) do
			menu.crew.roles[i].wanted = entry.wanted
			for j, tier in ipairs(entry.tiers) do
				menu.crew.roles[i].tiers[j].wanted = tier.wanted
			end
		end
	end

	if not noundo then
		menu.addUndoStep()
	end
	
	if menu.holomap and (menu.holomap ~= 0) then
		if (menu.usemacro and (menu.macro ~= "")) or (((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0)) then
			if (not newedit) and upgradeplan then
				Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
			else
				menu.currentIdx = menu.currentIdx + 1
				Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.ShowObjectConfigurationMap2(menu.holomap, menu.object, 0, menu.macro, false, loadout, 0) end)
			end
			if menu.installedPaintMod then
				C.SetMapPaintMod(menu.holomap, menu.installedPaintMod.ware)
			end
			menu.selectMapMacroSlot()
			if menu.mapstate then
				C.SetMapState(menu.holomap, menu.mapstate)
				menu.mapstate = nil
			end
		else
			C.ClearMapBehaviour(menu.holomap)
		end
	end

	menu.displayMenu(firsttime)
end

function menu.checkCurrentBuildTasks()
	menu.tasks = {}
	local n = C.GetNumOrders(menu.object)
	local buf = ffi.new("Order[?]", n)
	n = C.GetOrders(buf, n, menu.object)
	for i = 0, n - 1 do
		if ffi.string(buf[i].orderdef) == "Equip" then
			local params = GetOrderParams(ConvertStringTo64Bit(tostring(menu.object)), tonumber(buf[i].queueidx))
			menu.tasks[tostring(menu.object)] = params[1].value
			break
		elseif ffi.string(buf[i].orderdef) == "Repair" then
			menu.tasks[tostring(menu.object)] = true
			break
		end
	end
end

function menu.checkCompatibility(macro)
	local makerrace = GetMacroData(macro, "makerraceid")
	local isxenon, iskhaak = false, false
	for _, race in ipairs(makerrace) do
		if race == "xenon" then
			isxenon = true
		end
		if race == "khaak" then
			iskhaak = true
		end
		if isxenon and iskhaak then
			break
		end
	end

	if menu.hasDefaultLoadout then
		return menu.defaultLoadoutMacros[macro]
	else
		return (next(makerrace) == nil) or ((not isxenon) and (not iskhaak))
	end
end

function menu.displayAmmoSlot(ftable, type, macro, total, capacity, first)
	if (menu.upgradeplan[type][macro] and (menu.upgradeplan[type][macro] > 0)) or menu.isAmmoCompatible(type, macro) then
		local planned = menu.upgradeplan[type][macro] or 0
		local name, infolibrary = GetMacroData(macro, "name", "infolibrary")
		AddKnownItem(infolibrary, macro)

		local difference = planned - menu.ammo[type][macro]
		local color = Helper.color.white
		if difference < 0 then
			color = Helper.color.red
		elseif difference > 0 then
			color = Helper.color.green
		end

		local errorcase = total > capacity

		local scale = {
			min            = 0,
			max            = math.max(capacity, planned),
			maxSelect      = errorcase and planned or math.min(capacity, planned + capacity - total),
			start          = planned,
			step           = 1,
			suffix         = "",
			exceedMaxValue = false,
			readOnly       = menu.isReadOnly,
		}
		
		local price
		local j = menu.findUpgradeMacro(type, macro)
		if j then
			local upgradeware = menu.upgradewares[type][j]
			if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				price = tonumber(C.GetBuildWarePrice(menu.container, upgradeware.ware))
			end

			if (not errorcase) and (not upgradeware.isFromShipyard) then
				if menu.objectgroup then
					local maxamount = math.floor((upgradeware.objectamount - menu.ammo[type][macro]) / #menu.objectgroup.ships)
					scale.maxSelect = math.min(scale.maxSelect, maxamount)
					scale.start = math.min(scale.start, scale.maxSelect)
					menu.upgradeplan[type][macro] = math.min(planned, maxamount)
				else
					scale.maxSelect = math.min(scale.maxSelect, upgradeware.objectamount)
				end
			end
		end

		if not first then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		local row = ftable:addRow((type ~= "countermeasure") and { type = type, name = name, macro = macro } or true, { scaling = true, borderBelow = false, bgColor = Helper.color.transparent })
		row[1]:setColSpan(price and 8 or 11):setBackgroundColSpan(11):createBoxText(name)
		if price then
			row[9]:setColSpan(3):createBoxText(ConvertMoneyString(price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
		end

		local row = ftable:addRow(true, { scaling = true })
		row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = scale.min, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, readOnly = scale.readOnly }):setText(ReadText(1001, 1202), { color = color })
		row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectAmount(type, nil, macro, row.index, ...) end
		row[1].handlers.onRightClick = function (...) return menu.buttonInteract({ type = type, name = name, macro = macro }, ...) end

		return row
	end
end

function menu.displayCrewSlot(ftable, idx, data, buttonWidth, price, first)
	local lastrow
	if data.canhire then
		local color = Helper.color.white
		local capacity = menu.crew.capacity
		for _, entry in ipairs(menu.crew.roles) do
			if entry.id ~= data.id then
				capacity = capacity - entry.wanted
			end
		end
		capacity = math.max(0, capacity)

		local scale
		if (menu.mode == "purchase") or (menu.mode == "customgamestart") then
			scale = {
				min            = 0,
				max            = menu.crew.capacity,
				maxSelect      = capacity,
				start          = data.wanted,
				step           = 1,
				suffix         = "",
				exceedMaxValue = false,
				readOnly       = menu.isReadOnly,
			}
		else
			scale = {
				min            = 0,
				max            = menu.crew.capacity,
				maxSelect      = math.min(data.wanted + #menu.crew.unassigned + menu.crew.availableworkforce + menu.crew.availabledockcrew, capacity),
				start          = math.min(data.wanted, capacity),
				step           = 1,
				suffix         = "",
				exceedMaxValue = false,
				readOnly       = menu.isReadOnly,
			}
		end

		if not first then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		local row = ftable:addRow(true, { scaling = true, borderBelow = false, bgColor = Helper.color.transparent })
		row[1]:setColSpan(((not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart")) and 8 or 11):setBackgroundColSpan(11):createBoxText(data.name)
		if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") then
			local mouseovertext = ""
			if #menu.hiringdiscounts > 0 then
				if mouseovertext ~= "" then
					mouseovertext = mouseovertext .. "\n\n"
				end
				mouseovertext = mouseovertext .. ReadText(1001, 2819) .. ReadText(1001, 120)
				for _, entry in ipairs(menu.hiringdiscounts) do
					mouseovertext = mouseovertext .. "\n· " .. entry.name .. ReadText(1001, 120) .. " " .. entry.amount .. " %"
				end
			end
			row[9]:setColSpan(3):createBoxText(ConvertMoneyString(price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })
		end

		local row = ftable:addRow(true, { scaling = true })
		row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = scale.min, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, readOnly = scale.readOnly }):setText(ReadText(1001, 1202), { color = color })
		row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectCrewAmount(idx, 1, row.index, false, ...) end
		lastrow = row

		if menu.mode ~= "purchase" then
			for j, tier in ipairs(data.tiers) do
				if not tier.hidden then
					local scale = {
						min            = 0,
						max            = data.wanted,
						maxSelect      = tier.wanted,
						start          = tier.wanted,
						step           = 1,
						suffix         = "",
						exceedMaxValue = false,
						readOnly       = menu.isReadOnly,
					}

					local row = ftable:addRow(true, { scaling = true })
					row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = scale.min, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, readOnly = scale.readOnly }):setText("  " .. tier.name, { color = color })
					row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectCrewAmount(idx, j, row.index, true, ...) end
					lastrow = row
				end
			end
		end
	else
		local row = ftable:addRow(false, { scaling = true })
		row[1]:setColSpan(11):createText(data.name .. ": " .. data.total)
		lastrow = row
	end

	return lastrow
end

function menu.displaySoftwareSlot(ftable, type, slot, slotdata)
	local plansoftware = menu.upgradeplan[menu.upgradetypeMode][slot]
	local name = GetWareData(slotdata.possiblesoftware[1], "factoryname")

	local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
	local lastrow = row
	if slotdata.defaultsoftware ~= 0 then
		local color = Helper.color.white
		if plansoftware == "" then
			color = Helper.color.red
		end

		row[1]:setColSpan(7):setBackgroundColSpan(11):createText(name, menu.subHeaderTextProperties)
		row[1].properties.color = color
		row[8]:setColSpan(4):createText(ReadText(1001, 8047), menu.subHeaderTextProperties)
		row[8].properties.color = color
		row[8].properties.halign = "right"
	else
		row[1]:setColSpan(11):createText(name, menu.subHeaderTextProperties)
	end

	for i, software in ipairs(slotdata.possiblesoftware) do
		if i >= slotdata.defaultsoftware then
			if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(software, menu.equipmentsearchtext) then
				local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(software, nil, true)

				local price
				if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
					price = C.GetContainerBuildPriceFactor(menu.container) * GetContainerWarePrice(ConvertStringTo64Bit(tostring(menu.container)), software, false)
				end

				local installcolor = Helper.color.white
				if software == slotdata.currentsoftware then
					if software ~= plansoftware then
						installcolor = Helper.color.red
					end
				elseif software == plansoftware then
					installcolor = Helper.color.green
				end

				local active = not menu.isReadOnly
				if software == plansoftware then
					if i == slotdata.defaultsoftware then
						active = false
					end
				end

				local name = GetWareData(software, "name")
				AddKnownItem("software", software)
				local row = ftable:addRow({ type = type, name = name, software = software }, { scaling = true, bgColor = Helper.color.transparent })
				row[1]:setColSpan(1):createCheckBox(software == plansoftware, { scaling = false, active = active, width = menu.rowHeight, height = menu.rowHeight })
				row[1].handlers.onClick = function () return menu.checkboxSelectSoftware(type, slot, software, row.index) end
				row[2]:setColSpan(price and 7 or 10):createText(name, { color = installcolor })
				if price then
					row[9]:setColSpan(3):createText(ConvertMoneyString(price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
				end
				lastrow = row
			end
		end
	end

	return lastrow
end

function menu.checkCurrentSlot(slots, slot)
	local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
	if upgradetype then
		if menu.upgradetypeMode == "enginegroup" then
			if (not menu.groups[slot]) or (menu.groups[slot]["engine"].total == 0) then
				for i, upgradegroup in ipairs(menu.groups) do
					if upgradegroup["engine"].total > 0 then
						slot = i
						break
					end
				end
			end
		elseif menu.upgradetypeMode == "turretgroup" then
			if (not menu.groups[slot]) or (menu.groups[slot]["engine"].total > 0) then
				for i, upgradegroup in ipairs(menu.groups) do
					if upgradegroup["engine"].total == 0 then
						slot = i
						break
					end
				end
			end
		elseif (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "software") then
			if not upgradetype.mergeslots then
				if (not slots[slot]) or slots[slot].isgroup then
					for i, slot2 in ipairs(slots) do
						if not slot2.isgroup then
							slot = i
							break
						end
					end
				end
			else
				slot = 1
			end
		end
	end

	return slot
end

function menu.buttonEquipmentFilter(offsety)
	if menu.contextMode and (menu.contextMode.mode == "equipmentfilter") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 1)
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		Helper.closeDropDownOptions(menu.titlebartable, 1, 3)
		menu.displayContextFrame("equipmentfilter", Helper.scaleX(config.equipmentfilter_races_width), menu.slotData.offsetX + menu.slotData.width + Helper.borderSize, offsety)
	end
end

function menu.displaySlots(frame, firsttime)
	if menu.upgradetypeMode and ((menu.mode ~= "purchase") or menu.validLicence) then
		local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
	
		local count, rowcount, slidercount = 1, 0, 0
		menu.groupedupgrades = {}

		local slots = {}
		if (menu.upgradetypeMode ~= "enginegroup") and (menu.upgradetypeMode ~= "turretgroup") and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "repair") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
				slots = menu.slots[menu.upgradetypeMode] or {}
			end
		end

		menu.currentSlot = menu.checkCurrentSlot(slots, menu.currentSlot)
		local currentSlotInfo = {}

		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local upgradegroup = menu.groups[menu.currentSlot]
			if upgradegroup then
				for i, upgradetype2 in ipairs(Helper.upgradetypes) do
					local upgradegroupcount = 1
					if upgradetype2.supertype == "group" then
						menu.groupedupgrades[upgradetype2.grouptype] = {}
						for i, macro in ipairs(upgradegroup[upgradetype2.grouptype].possiblemacros) do
							local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
							for race_i, race in ipairs(makerrace) do
								if (not menu.equipmentfilter_races[race]) then
									menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
								end
								if (not menu.equipmentfilter_races[race].upgradeTypes) then
									menu.equipmentfilter_races[race].upgradeTypes = {}
								end
								if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
									menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
								end
							end
							if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(macro, menu.equipmentsearchtext) then
								local group = math.ceil(upgradegroupcount / 3)
								menu.groupedupgrades[upgradetype2.grouptype][group] = menu.groupedupgrades[upgradetype2.grouptype][group] or {}
								table.insert(menu.groupedupgrades[upgradetype2.grouptype][group], { macro = macro, icon = (C.IsIconValid("upgrade_" .. macro) and ("upgrade_" .. macro) or "upgrade_notfound"), name = macroname })
								upgradegroupcount = upgradegroupcount + 1
							end
						end

						if (not menu.isReadOnly) and upgradetype2.allowempty then
							local group = math.ceil(upgradegroupcount / 3)
							menu.groupedupgrades[upgradetype2.grouptype][group] = menu.groupedupgrades[upgradetype2.grouptype][group] or {}
							table.insert(menu.groupedupgrades[upgradetype2.grouptype][group], { macro = "", icon = "upgrade_empty", name = ReadText(1001, 7906) })
							upgradegroupcount = upgradegroupcount + 1
						end
					end
					if upgradegroupcount > 1 then
						slidercount = slidercount + 1
					end
					rowcount = rowcount + math.ceil((upgradegroupcount - 1) / 3)
				end
			end
		elseif (menu.upgradetypeMode == "repair") then
			if menu.objectgroup then
				for i, ship in ipairs(menu.objectgroup.ships) do
					if #menu.objectgroup.shipdata[i].damagedcomponents > 0 then
						local group = math.ceil(count / 3)
						menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
						table.insert(menu.groupedupgrades[group], { macro = ship.macro, icon = (C.IsIconValid("ship_" .. ship.macro) and ("ship_" .. ship.macro) or "ship_notfound"), name = ship.name, component = ship.ship })
						count = count + 1
					end
				end
			else
				local component = menu.object
				local group = math.ceil(count / 3)
				local macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
				local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
				for race_i, race in ipairs(makerrace) do
					if (not menu.equipmentfilter_races[race]) then
						menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
					end
					if (not menu.equipmentfilter_races[race].upgradeTypes) then
						menu.equipmentfilter_races[race].upgradeTypes = {}
					end
					if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
						menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
					end
				end
				menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
				table.insert(menu.groupedupgrades[group], { macro = macro, icon = (C.IsIconValid("ship_" .. macro) and ("ship_" .. macro) or "ship_notfound"), name = macroname, component = component })
				count = count + 1
			end
			rowcount = rowcount + math.ceil(count / 3)
		elseif (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if #slots > 0 then
				if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					for i, macro in ipairs(slots[menu.currentSlot].possiblemacros) do
						local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
						for race_i, race in ipairs(makerrace) do
							if (not menu.equipmentfilter_races[race]) then
								menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
							end
							if (not menu.equipmentfilter_races[race].upgradeTypes) then
								menu.equipmentfilter_races[race].upgradeTypes = {}
							end
							if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
								menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
							end
						end
						if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(macro, menu.equipmentsearchtext) then
							local group = math.ceil(count / 3)
							menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
							table.insert(menu.groupedupgrades[group], { macro = macro, icon = (C.IsIconValid("upgrade_" .. macro) and ("upgrade_" .. macro) or "upgrade_notfound"), name = macroname })
							count = count + 1
						end
					end

					if (not menu.isReadOnly) and (upgradetype.allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot))) then
						local group = math.ceil(count / 3)
						menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
						table.insert(menu.groupedupgrades[group], { macro = "", icon = "upgrade_empty", name = ReadText(1001, 7906) })
						count = count + 1
					end
				end
			end
			rowcount = rowcount + math.ceil(count / 3)
		end

		menu.groupedslots = {}
		local groupedslots = {}
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local groupcount = 1
			for i, upgradegroup in ipairs(menu.groups) do
				if (menu.upgradetypeMode == "enginegroup") == (upgradegroup["engine"].total > 0) then
					local groupname = upgradegroup.groupname
					local slotsize = upgradegroup[upgradetype.grouptype].slotsize
					local compatibilities = upgradegroup[upgradetype.grouptype].compatibilities

					if i == menu.currentSlot then
						currentSlotInfo.slotsize = slotsize
						currentSlotInfo.compatibilities = compatibilities
					end

					table.insert(groupedslots, { i, upgradegroup, groupname, sizecount = i, slotsize = slotsize, compatibilities = compatibilities })
					groupcount = groupcount + 1
				end
			end
		elseif menu.upgradetypeMode == "repair" then
			local slotcount = 1
			menu.repairslots = {}

			if menu.objectgroup then
				for i, ship in ipairs(menu.objectgroup.ships) do
					if #menu.objectgroup.shipdata[i].damagedcomponents > 0 then
						local group = math.ceil(i / 3)

						menu.repairslots[group] = menu.repairslots[group] or {}
						table.insert(menu.repairslots[group], { i, ship.macro, i, ship.ship })
					end
				end
			else
				if #menu.damagedcomponents > 0 then
					local component = menu.object
					local group = math.ceil(slotcount / 3)
					local macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
					local slotnum = 1

					menu.repairslots[group] = menu.repairslots[group] or {}
					table.insert(menu.repairslots[group], { slotnum, macro, slotcount, component })
				end
			end
		elseif (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if not upgradetype.mergeslots then
				for i, slot in ipairs(slots) do
					if not slot.isgroup then
						local slotname = slot.slotname
						local slotsize = slot.slotsize
							
						local compatibilities
						local n = C.GetNumSlotCompatibilities(menu.object, 0, menu.macro, false, upgradetype.type, i)
						if n > 0 then
							compatibilities = {}
							local buf = ffi.new("EquipmentCompatibilityInfo[?]", n)
							n = C.GetSlotCompatibilities(buf, n, menu.object, 0, menu.macro, false, upgradetype.type, i)
							for j = 0, n - 1 do
								compatibilities[ffi.string(buf[j].tag)] = ffi.string(buf[j].name)
							end
						end

						if i == menu.currentSlot then
							currentSlotInfo.slotsize = slotsize
							currentSlotInfo.compatibilities = compatibilities
						end

						table.insert(groupedslots, { i, slot, slotname, sizecount = i, slotsize = slotsize, compatibilities = compatibilities })
					end
				end
			else
				if upgradetype.supertype == "macro" then
					currentSlotInfo.slotsize = ffi.string(C.GetSlotSize(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot))

					local n = C.GetNumSlotCompatibilities(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot)
					if n > 0 then
						currentSlotInfo.compatibilities = {}
						local buf = ffi.new("EquipmentCompatibilityInfo[?]", n)
						n = C.GetSlotCompatibilities(buf, n, menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot)
						for j = 0, n - 1 do
							currentSlotInfo.compatibilities[ffi.string(buf[j].tag)] = ffi.string(buf[j].name)
						end
					end
				end
			end
		end
		table.sort(groupedslots, Helper.sortSlots)

		for i, entry in ipairs(groupedslots) do
			local group = math.ceil(i / 9)
			menu.groupedslots[group] = menu.groupedslots[group] or {}
			table.insert(menu.groupedslots[group], entry)
		end
		
		menu.rowHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
		menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
		local maxSlotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)

		local hasScrollbar = false
		local headerHeight = menu.titleData.height + #menu.groupedslots * (maxSlotWidth + Helper.borderSize) + menu.rowHeight + 2 * Helper.borderSize
		local boxTextHeight = math.ceil(C.GetTextHeight(" \n ", Helper.standardFont, menu.extraFontSize, 0)) + 2 * Helper.borderSize
		--[[ Keep for simpler debugging
			print((Helper.viewHeight - 2 * menu.slotData.offsetY) .. " vs " .. (headerHeight + rowcount * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) + slidercount * (menu.subHeaderRowHeight + Helper.borderSize)))
			print(headerHeight)
			print(boxTextHeight)
			print(rowcount .. " * " .. 3 * (maxSlotWidth + Helper.borderSize))
			print(slidercount .. " * " .. menu.subHeaderRowHeight + Helper.borderSize) --]]
		if (Helper.viewHeight - 2 * menu.slotData.offsetY) < (headerHeight + rowcount * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) + slidercount * (menu.subHeaderRowHeight + Helper.borderSize)) then
			hasScrollbar = true
		end

		local slotWidth = maxSlotWidth - math.floor((hasScrollbar and Helper.scrollbarWidth or 0) / 9)
		local extraPixels = (menu.slotData.width - 8 * Helper.borderSize) % 9
		local slotWidths = { slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth }
		if extraPixels > 0 then
			for i = 1, extraPixels do
				slotWidths[i] = slotWidths[i] + 1
			end
		end
		-- prevent negative column width
		if slotWidths[1] - menu.rowHeight - Helper.borderSize < 1 then
			slotWidths[1] = menu.rowHeight + Helper.borderSize + 1
		end
		local columnWidths = {}
		local maxColumnWidth = 0
		for i = 1, 3 do
			columnWidths[i] = slotWidths[(i - 1) * 3 + 1] + slotWidths[(i - 1) * 3 + 2] + slotWidths[(i - 1) * 3 + 3] + 2 * Helper.borderSize
			maxColumnWidth = math.max(maxColumnWidth, columnWidths[i])
		end
		local slidercellWidth = menu.slotData.width - math.floor(hasScrollbar and Helper.scrollbarWidth or 0)

		local maxVisibleHeight
		local highlightmode = "column"
		if (menu.upgradetypeMode == "consumables") or (menu.upgradetypeMode == "crew") or (menu.upgradetypeMode == "software") or (menu.upgradetypeMode == "settings") then
			highlightmode = "on"
		end
		local ftable = frame:addTable(11, { tabOrder = 1, width = menu.slotData.width, maxVisibleHeight = Helper.viewHeight - 2 * menu.slotData.offsetY, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = false, reserveScrollBar = menu.upgradetypeMode == "consumables", highlightMode = highlightmode, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		if menu.setdefaulttable then
			ftable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		ftable:setColWidth(1, menu.rowHeight)
		ftable:setColWidth(2, slotWidths[1] - menu.rowHeight - Helper.borderSize)
		-- exact col widths are unimportant in these menus, keeping them variable and equal helps with scrollbar support
		if (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			for i = 2, 8 do
				ftable:setColWidth(i + 1, slotWidths[i])
			end
		end
		ftable:setColWidth(11, menu.rowHeight)
		ftable:setDefaultColSpan(1, 4)
		ftable:setDefaultColSpan(5, 3)
		ftable:setDefaultColSpan(8, 4)

		local name = menu.getLeftBarEntry(menu.upgradetypeMode).name or ""
		local sizeicon
		if (menu.upgradetypeMode ~= "enginegroup") and (menu.upgradetypeMode ~= "turretgroup") and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "repair") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if upgradetype.supertype == "macro" and ((menu.object ~= 0) or (menu.macro ~= "")) then
				if currentSlotInfo.slotsize and (currentSlotInfo.slotsize ~= "") then
					name = upgradetype.text[currentSlotInfo.slotsize]
					sizeicon = "be_upgrade_size_" .. currentSlotInfo.slotsize
				end
			elseif upgradetype.supertype == "virtualmacro" then
				if menu.class == "ship_s" then
					name = upgradetype.text["small"]
					sizeicon = "be_upgrade_size_small"
				elseif menu.class == "ship_m" then
					name = upgradetype.text["medium"]
					sizeicon = "be_upgrade_size_medium"
				elseif menu.class == "ship_l" then
					name = upgradetype.text["large"]
					sizeicon = "be_upgrade_size_large"
				elseif menu.class == "ship_xl" then
					name = upgradetype.text["extralarge"]
					sizeicon = "be_upgrade_size_extralarge"
				end
			end
		end

		local color = Helper.color.white
		if upgradetype then
			local allowempty = upgradetype.allowempty
			if upgradetype.supertype == "macro" then
				allowempty = allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot))
			end
			if not allowempty then
				if menu.upgradeplan[upgradetype.type][menu.currentSlot].macro == "" then
					color = Helper.color.red
				end
			end
		end
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(11):createText(name, menu.headerTextProperties)
		row[1].properties.color = color

		for _, group in ipairs(menu.groupedslots) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			for i = 1, 9 do
				if group[i] then
					local col = (i > 1) and (i + 1) or 1
					local colspan = ((i == 1) or (i == 9)) and 2 or 1

					local color = Helper.color.white
					local bgcolor = Helper.defaultTitleBackgroundColor
					if group[i][1] == menu.currentSlot then
						bgcolor = Helper.defaultArrowRowBackgroundColor
					end
					local count, total = 0, 0
					if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
						for _, upgradetype2 in ipairs(Helper.upgradetypes) do
							if upgradetype2.supertype == "group" then
								if menu.groups[group[i][1]][upgradetype2.grouptype].total > 0 then
									if upgradetype2.mergeslots then
										count = count + ((menu.upgradeplan[upgradetype2.type][group[i][1]].count > 0) and 1 or 0)
										total = total + 1
									else
										count = count + menu.upgradeplan[upgradetype2.type][group[i][1]].count
										total = total + menu.groups[group[i][1]][upgradetype2.grouptype].total
									end
									if upgradetype2.allowempty == false then
										if menu.upgradeplan[upgradetype2.type][group[i][1]].macro == "" then
											color = Helper.color.red
										end
									end
								end
							end
						end
					else
						total = 1
						if menu.upgradeplan[upgradetype.type][group[i][1]].macro == "" then
							if (upgradetype.allowempty == false) or C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, group[i][1]) then
								color = Helper.color.red
							end
						else
							count = 1
						end
					end

					local mouseovertext = ""
					if upgradetype then
						mouseovertext = ReadText(1001, 66) .. " " .. group[i][3]
					else
						mouseovertext = ReadText(1001, 8023) .. " " .. group[i][3]
					end

					row[col]:setColSpan(colspan):createButton({ height = slotWidths[i], width = slotWidths[i], bgColor = bgcolor, mouseOverText = mouseovertext }):setText(group[i][3], { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), color = color })
					if total > 0 then
						local width = math.max(1, math.floor(count * (slotWidths[i] - 2 * menu.scaleSize) / total))
						row[col]:setIcon("solid", { color = Helper.color.white, width = width + 2 * Helper.configButtonBorderSize, height = menu.scaleSize + 2 * Helper.configButtonBorderSize, x = menu.scaleSize - Helper.configButtonBorderSize, y = slotWidths[i] - 2 * menu.scaleSize - Helper.configButtonBorderSize })
					end
					if group[i].compatibilities then
						local compatibilitytext = ""
						local j = 0
						for _, entry in ipairs(Helper.equipmentCompatibilities) do
							if group[i].compatibilities[entry.tag] then
								compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. "\27[menu_weaponslot]"
								j = j + 1
							end
							if (j > 0) and (j % 4 == 0) then
								compatibilitytext = compatibilitytext .. "\n"
							end
						end
						-- slotwidth is based on Helper.viewWidth but limited, so we need to reflect that here
						local fontsize = math.floor(config.compatibilityFontSize * Helper.viewWidth / 1920)
						local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
						local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
						fontsize = fontsize * actualSidePanelWidth / reservedSidePanelWidth

						local compatibilityTextHeight = math.ceil(C.GetTextHeight(compatibilitytext, Helper.standardFont, fontsize, 0)) + 2 * Helper.borderSize
						row[col]:setText2(compatibilitytext, { halign = "center", fontsize = fontsize, y = (slotWidths[i] - compatibilityTextHeight) / 2 })
					end
					row[col].handlers.onClick = function () return menu.buttonSelectSlot(group[i][1], row.index, col) end
				end
			end
		end

		if currentSlotInfo.compatibilities then
			local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent, scaling = true })
			row[1]:setBackgroundColSpan(11):setColSpan(5):createText(ReadText(1001, 8548) .. ReadText(1001, 120))
			local compatibilitytext = ""
			for _, entry in ipairs(Helper.equipmentCompatibilities) do
				if currentSlotInfo.compatibilities[entry.tag] then
					compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. currentSlotInfo.compatibilities[entry.tag]
				end
			end
			row[6]:setColSpan(6):createText(compatibilitytext, { halign = "right" })
		end

		if next(menu.groupedupgrades) then
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				for i, upgradetype2 in ipairs(Helper.upgradetypes) do
					if upgradetype2.supertype == "group" then
						if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype2.grouptype].total > 0) then
							local plandata = menu.upgradeplan[upgradetype2.type][menu.currentSlot]
							local slotsize = menu.groups[menu.currentSlot][upgradetype2.grouptype].slotsize

							local name = upgradetype2.headertext.default
							if slotsize ~= "" then
								name = upgradetype2.headertext[slotsize]
							end

							local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent, scaling = true })
							row[1]:setBackgroundColSpan(11):setColSpan(5):createText(name .. ReadText(1001, 120))
							if not upgradetype2.mergeslots then
								row[6]:setColSpan(6):createText(plandata.count .. " / " .. menu.groups[menu.currentSlot][upgradetype2.grouptype].total, { halign = "right" })
							else
								row[6]:setColSpan(6):createText(((plandata.macro == "") and 0 or menu.groups[menu.currentSlot][upgradetype2.grouptype].total) .. " / " .. menu.groups[menu.currentSlot][upgradetype2.grouptype].total, { halign = "right" })
							end
						end
					end
				end
			end
		end

		ftable:addEmptyRow(Helper.standardTextHeight / 2)

		-- local editboxheight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
		local rowy = ftable:getFullHeight()
		local row = ftable:addRow(true, { fixed = true })
		local issearchandfilteractive = menu.upgradetypeMode ~= "crew" and menu.upgradetypeMode ~= "repair" and menu.upgradetypeMode ~= "settings"
		row[1]:setColSpan(10):createEditBox({ active = issearchandfilteractive, defaultText = ReadText(1001, 3250), scaling = true }):setText("", { x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = menu.editboxSearchUpdateText
		menu.equipmentsearch_editboxrow = row.index
		row[11]:createButton({ active = issearchandfilteractive, height = menu.rowHeight }):setIcon("menu_filter")
		menu.equipmentfilter_races_y = menu.slotData.offsetY + rowy + Helper.borderSize
		row[11].handlers.onClick = function () return menu.buttonEquipmentFilter(menu.equipmentfilter_races_y) end

		if #menu.equipmentsearchtext > 0 and issearchandfilteractive then
			table.sort(menu.equipmentsearchtext, function (a, b)
				if a.race == b.race then
					return a.text < b.text
				end
				if (a.race == "generic") or (b.race == "generic") then
					return a.race == "generic"
				end
				return a.text < b.text
			end)
			local row = ftable:addRow((#menu.equipmentsearchtext > 0), { fixed = true, bgColor = Helper.color.transparent })
			local searchindex = 0
			local cols = { 1, 5, 8 }
			for i = 1, math.min(3, #menu.equipmentsearchtext) do
				searchindex = searchindex + 1
				local truncatedString = TruncateText(menu.equipmentsearchtext[i].text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), row[cols[i]]:getWidth() - 3 * Helper.scaleX(10))
				if i < 3 or #menu.equipmentsearchtext <= 3 then
					row[cols[i]]:createButton({ scaling = true, height = Helper.standardTextHeight, mouseOverText = (truncatedString ~= menu.equipmentsearchtext[i].text) and menu.equipmentsearchtext[i].text or "" }):setText(truncatedString, { halign = "center" }):setText2("X", { halign = "right" })
				else
					row[cols[i]]:setColSpan(2):createButton({ scaling = true, height = Helper.standardTextHeight, mouseOverText = (truncatedString ~= menu.equipmentsearchtext[i].text) and menu.equipmentsearchtext[i].text or "" }):setText(truncatedString, { halign = "center" }):setText2("X", { halign = "right" })
				end
				if menu.equipmentsearchtext[i].race then
					row[cols[i]]:setIcon("menu_filter", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				end
				row[cols[i]].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
			end
			if #menu.equipmentsearchtext > 3 then
				row[10]:setColSpan(2):createText(string.format("%+d", #menu.equipmentsearchtext - 3), { scaling = true })
			end
		end

		local row = ftable:addEmptyRow(Helper.standardTextHeight / 2)
		row.properties.fixed = true

		if next(menu.groupedupgrades) then
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				for i, upgradetype2 in ipairs(Helper.upgradetypes) do
					if upgradetype2.supertype == "group" then
						if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype2.grouptype].total > 0) then
							local hasmod, modicon = menu.checkMod(upgradetype2.grouptype, menu.groups[menu.currentSlot][upgradetype2.grouptype].currentcomponent, true)

							local color = Helper.color.white
							if upgradetype2.allowempty == false then
								if menu.upgradeplan[upgradetype2.type][menu.currentSlot].macro == "" then
									color = Helper.color.red
								end
							end
							local plandata = menu.upgradeplan[upgradetype2.type][menu.currentSlot]
							
							local row = ftable:addRow(true, { bgColor = (not upgradetype2.mergeslots) and Helper.color.transparent or nil })
							local name = upgradetype2.text.default
							local slotsize = menu.groups[menu.currentSlot][upgradetype2.grouptype].slotsize
							if slotsize ~= "" then
								name = upgradetype2.text[slotsize]
								sizeicon = "be_upgrade_size_" .. slotsize
							end

							if plandata.macro ~= "" then
								name = GetMacroData(plandata.macro, "name")
							end

							if not upgradetype2.mergeslots then
								local scale = {
									min       = 0,
									minSelect = (plandata.macro == "") and 0 or 1,
									max       = menu.groups[menu.currentSlot][upgradetype2.grouptype].total,
								}
								scale.maxSelect = (plandata.macro == "") and 0 or scale.max

								-- handle already installed equipment
								if (plandata.macro == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) then
									local haslicence = menu.checkLicence(plandata.macro)
									if not haslicence then
										scale.maxSelect = math.min(scale.maxSelect, menu.groups[menu.currentSlot][upgradetype2.grouptype].count)
										menu.upgradeplan[upgradetype2.type][menu.currentSlot].count = math.min(scale.maxSelect, menu.upgradeplan[upgradetype2.type][menu.currentSlot].count)
									end
									local j = menu.findUpgradeMacro(upgradetype2.grouptype, plandata.macro)
									if j then
										local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]
										if not upgradeware.isFromShipyard then
											scale.maxSelect = math.min(scale.maxSelect, menu.groups[menu.currentSlot][upgradetype2.grouptype].count)
											menu.upgradeplan[upgradetype2.type][menu.currentSlot].count = math.min(scale.maxSelect, menu.upgradeplan[upgradetype2.type][menu.currentSlot].count)
										end
									end
								end
								scale.start = math.max(scale.minSelect, math.min(scale.maxSelect, plandata.count))

								local mouseovertext = ""
								if hasmod then
									mouseovertext = "\27R" .. ReadText(1026, 8009) .. "\27X"
								end

								row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = menu.subHeaderRowHeight, valueColor = Helper.color.slidervalue, min = scale.min, minSelect = scale.minSelect, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, readOnly = hasmod or menu.isReadOnly, mouseOverText = mouseovertext }):setText(name, menu.subHeaderSliderCellTextProperties)
								row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectGroupAmount(upgradetype2.type, menu.currentSlot, row.index, false, ...) end
								row[1].properties.text.color = color
							else
								row[1]:setColSpan(11):createText(name, menu.subHeaderTextProperties)
								row[1].properties.color = color
							end

							if #menu.groupedupgrades[upgradetype2.grouptype] > 0 then
								for _, group in ipairs(menu.groupedupgrades[upgradetype2.grouptype]) do
									local row = ftable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
									local row2 = ftable:addRow(false, { bgColor = Helper.color.transparent })
									for i = 1, 3 do
										if group[i] then
											local column = i * 3 - 2
											if i > 1 then
												column = column + 1
											end

											local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(group[i].macro)
											local extraText = ""
											local untruncatedExtraText = ""

											-- handle already installed equipment
											if (group[i].macro == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) and (not haslicence) then
												haslicence = true
												mouseovertext = mouseovertext .. "\n" .. "\27G" .. ReadText(1026, 8004)
											end

											local weaponicon, compatibility = GetMacroData(group[i].macro, "ammoicon", "compatibility")
											if weaponicon and (weaponicon ~= "") and C.IsIconValid(weaponicon) then
												weaponicon = "\27[" .. weaponicon .. "]"
											else
												weaponicon = ""
											end
											if compatibility then
												local color = Helper.color.white
												for _, entry in ipairs(Helper.equipmentCompatibilities) do
													if entry.tag == compatibility then
														color = entry.color
														break
													end
												end
												weaponicon = Helper.convertColorToText(color) .. "\27[menu_weaponmount]\27X" .. weaponicon
											end
											if hasmod then
												mouseovertext = "\27R" .. ReadText(1026, 8009) .. "\27X\n" .. mouseovertext
											end

											local price
											local hasstock = group[i].macro == ""
											local j = menu.findUpgradeMacro(upgradetype2.grouptype, group[i].macro)
											if j then
												local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]

												local isvolatile = GetWareData(upgradeware.ware, "volatile")
												if isvolatile then
													icon = "\27[bse_venture]"
												end

												if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (not isvolatile) then
													price = tonumber(C.GetBuildWarePrice(menu.container, upgradeware.ware))
													if upgradetype2.mergeslots then
														price = menu.groups[menu.currentSlot][upgradetype2.grouptype].total * price
													end
												end

												hasstock = upgradeware.isFromShipyard or ((menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro == group[i].macro) and (menu.groups[menu.currentSlot][upgradetype2.grouptype].hasstock ~= false))
											end
										
											local amounttext = ""
											if upgradetype2.mergeslots and (menu.groups[menu.currentSlot][upgradetype2.grouptype].total > 1) then
												amounttext = menu.groups[menu.currentSlot][upgradetype2.grouptype].total .. ReadText(1001, 42) .. " "
											end
											if group[i].macro ~= "" then
												local shortname, infolibrary = GetMacroData(group[i].macro, "shortname", "infolibrary")
												extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. shortname, group[i].macro, price)
												AddKnownItem(infolibrary, group[i].macro)
											else
												extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. group[i].name, nil, price)
											end

											local installicon, installcolor = (group[i].macro ~= "") and (sizeicon or "") or ""
											if not haslicence then
												installcolor = Helper.color.darkgrey
											elseif (group[i].macro ~= "") then
												if (group[i].macro == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) and (group[i].macro ~= plandata.macro) then
													installicon = "be_upgrade_uninstalled"
													installcolor = Helper.color.red
												elseif (group[i].macro == plandata.macro) then
													installicon = "be_upgrade_installed"
													installcolor = Helper.color.green
													if hasmod then
														weaponicon = weaponicon .. " " .. modicon
													end
													if firsttime then
														menu.selectedRows.slots = row.index
														menu.selectedCols.slots = column
														firsttime = nil
													end
												end
											end
											local active = ((group[i].macro == plandata.macro) or (not hasmod)) 

											-- start: mycu call-back
											if callbacks ["displaySlots_on_before_create_button_mouseovertext"] then
												for _, callback in ipairs (callbacks ["displaySlots_on_before_create_button_mouseovertext"]) do
													result = callback (group[i].macro, plandata.macro, mouseovertext)
													if result then
														mouseovertext = result.mouseovertext
													end
												end
											end
											-- end: mycu call-back

											local useable = hasstock and haslicence
											row[column]:createButton({
												active = active,
												width = columnWidths[i],
												height = maxColumnWidth,
												mouseOverText = mouseovertext,
												bgColor = useable and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
												highlightColor = useable and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
											}):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor }):setText(icon, { y = maxColumnWidth / 2 - Helper.scaleY(Helper.standardTextHeight) / 2 - Helper.configButtonBorderSize, halign = "right", color = overridecolor, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) }):setText2(weaponicon, { x = 3, y = -maxColumnWidth / 2 + Helper.scaleY(Helper.standardTextHeight) / 2 + Helper.configButtonBorderSize, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
											if useable then
												row[column].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, group[i].macro, row.index, column) end
											end
											if group[i].macro ~= "" then
												row[column].handlers.onRightClick = function (...) return menu.buttonInteract({ type = upgradetype2.type, name = group[i].name, macro = group[i].macro }, ...) end
											end

											row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, color = overridecolor, boxColor = (active and useable) and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor, mouseOverText = untruncatedExtraText })
										end
									end
									if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
										maxVisibleHeight = ftable:getFullHeight()
									end
								end
							else
								local row = ftable:addRow(nil, { bgColor = Helper.color.transparent, scaling = true })
								row[1]:setColSpan(11):createText("--- " .. upgradetype2.nonetext.default .. " ---")
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "repair" then
				for k, group in ipairs(menu.groupedupgrades) do
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
					local row2 = ftable:addRow(false, { bgColor = Helper.color.transparent })
					for i = 1, 3 do
						if group[i] then
							local repairslotdata = menu.repairslots[k][i]
							local componentstring = tostring(repairslotdata[4])

							local totalprice = 0
							local mouseovertext = ""
							if menu.objectgroup then
								for j, ship in ipairs(menu.objectgroup.ships) do
									if ship.ship == repairslotdata[4] then
										for k = #menu.objectgroup.shipdata[j].damagedcomponents, 1, -1 do
											local component = menu.objectgroup.shipdata[j].damagedcomponents[k]
											if k ~= #menu.objectgroup.shipdata[j].damagedcomponents then
												mouseovertext = mouseovertext .. "\n"
											end

											local price = tonumber(C.GetRepairPrice(component, menu.container))
											if price then
												totalprice = totalprice + price
											end
											local hull = GetComponentData(ConvertStringTo64Bit(tostring(component)), "hullpercent")
											mouseovertext = mouseovertext .. group[i].name .. " (" .. (100 - hull) .. "% " .. ReadText(1001, 1) .. ")"
										end
										break
									end
								end
							else
								for j = #menu.damagedcomponents, 1, -1 do
									local component = menu.damagedcomponents[j]
									local macro

									if component == menu.object then
										macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
									else
										for _, upgradetype in ipairs(Helper.upgradetypes) do
											if upgradetype.supertype == "macro" then
												if menu.slots[upgradetype.type] then
													for k = 1, #menu.slots[upgradetype.type] do
														if menu.slots[upgradetype.type][k].component == component then
															macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
															break
														end
													end
												end
											end
										end
									end
									if macro then
										if j ~= #menu.damagedcomponents then
											mouseovertext = mouseovertext .. "\n"
										end

										local price = tonumber(C.GetRepairPrice(component, menu.container))
										if price then
											totalprice = totalprice + price
										end
										local shortname = GetMacroData(macro, "shortname")
										local hull = GetComponentData(ConvertStringTo64Bit(tostring(component)), "hullpercent")
										mouseovertext = mouseovertext .. shortname .. " (" .. (100 - hull) .. "% " .. ReadText(1001, 1) .. ")"
									end
								end
							end

							if #menu.repairdiscounts > 0 then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n\n"
								end
								mouseovertext = mouseovertext .. ReadText(1001, 2819) .. ReadText(1001, 120)
								for _, entry in ipairs(menu.repairdiscounts) do
									mouseovertext = mouseovertext .. "\n· " .. entry.name .. ReadText(1001, 120) .. " " .. entry.amount .. " %"
								end
							end

							local shortname
							if menu.objectgroup then
								shortname = group[i].name .. "\n" .. ffi.string(C.GetObjectIDCode(group[i].component))
							else
								shortname = GetMacroData(group[i].macro, "shortname")
							end
							local extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], shortname, group[i].macro, (totalprice > 0) and totalprice * menu.repairdiscounts.totalfactor or nil, repairslotdata[4])

							local color = Helper.defaultButtonBackgroundColor
							-- TODO: handle button colors for queued items here.

							local installicon, installcolor = sizeicon or ""
							menu.repairplan[componentstring] = menu.repairplan[componentstring] or {}
							if menu.repairplan[componentstring][componentstring] then
								installicon = "be_upgrade_installed"
								installcolor = Helper.color.green
							end

							local column = i * 3 - 2
							if i > 1 then
								column = column + 1
							end
							--print("adding button for component: " .. tostring(componentstring) .. " row: " .. tostring(row.index) .. ", col: " .. tostring(column))
							row[column]:createButton({ width = columnWidths[i], height = maxColumnWidth, bgColor = color, mouseOverText = mouseovertext }):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor })
							row[column].handlers.onClick = function () return menu.buttonSelectRepair(row.index, column, componentstring) end
							row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, mouseOverText = untruncatedExtraText })
						end
					end
					if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
						maxVisibleHeight = ftable:getFullHeight()
					end
				end
			else
				local plandata = menu.upgradeplan[menu.upgradetypeMode][menu.currentSlot]
				local hasmod, modicon = menu.checkMod(upgradetype.type, slots[menu.currentSlot].component)

				for _, group in ipairs(menu.groupedupgrades) do
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
					local row2 = ftable:addRow(false, { bgColor = Helper.color.transparent })
					for i = 1, 3 do
						if group[i] then
							local column = i * 3 - 2
							if i > 1 then
								column = column + 1
							end

							local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(group[i].macro, nil, false)
							local extraText = ""
							local untruncatedExtraText = ""

							-- handle already installed equipment
							if (group[i].macro == slots[menu.currentSlot].currentmacro) and (not haslicence) then
								haslicence = true
								mouseovertext = mouseovertext .. "\n" .. "\27G" .. ReadText(1026, 8004)
							end

							local weaponicon, compatibility
							if upgradetype.supertype == "macro" then
								weaponicon, compatibility = GetMacroData(group[i].macro, "ammoicon", "compatibility")
							end
							if weaponicon and (weaponicon ~= "") and C.IsIconValid(weaponicon) then
								weaponicon = "\27[" .. weaponicon .. "]"
							else
								weaponicon = ""
							end
							if compatibility then
								local color = Helper.color.white
								for _, entry in ipairs(Helper.equipmentCompatibilities) do
									if entry.tag == compatibility then
										color = entry.color
										break
									end
								end
								weaponicon = Helper.convertColorToText(color) .. "\27[menu_weaponmount]\27X" .. weaponicon
							end
							if hasmod then
								mouseovertext = "\27R" .. ReadText(1026, 8009) .. "\27X\n" .. mouseovertext
							end

							local price
							local hasstock = group[i].macro == ""
							local j = menu.findUpgradeMacro(upgradetype.type, group[i].macro)
							if j then
								local upgradeware = menu.upgradewares[upgradetype.type][j]

								local isvolatile = GetWareData(upgradeware.ware, "volatile")
								if isvolatile then
									icon = "\27[bse_venture]"
								end

								if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (not isvolatile) then
									price = tonumber(C.GetBuildWarePrice(menu.container, upgradeware.ware))
									if upgradetype.mergeslots then
										price = #menu.upgradeplan[upgradetype.type] * price
									end
								end

								hasstock = upgradeware.isFromShipyard or ((slots[menu.currentSlot].currentmacro == group[i].macro) and (slots[menu.currentSlot].hasstock ~= false))
							end
							
							local amounttext = ""
							if upgradetype.mergeslots and (#menu.upgradeplan[upgradetype.type] > 1) then
								amounttext = #menu.upgradeplan[upgradetype.type] .. ReadText(1001, 42) .. " "
							end
							if group[i].macro ~= "" then
								local shortname, infolibrary = GetMacroData(group[i].macro, "shortname", "infolibrary")
								extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. shortname, group[i].macro, price, nil, upgradetype.type)
								AddKnownItem(infolibrary, group[i].macro)
							else
								extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. group[i].name, nil, price)
							end

							local installicon, installcolor = (group[i].macro ~= "") and (sizeicon or "") or ""
							if not haslicence then
								installcolor = Helper.color.darkgrey
							else
								if (group[i].macro ~= "") then
									if (group[i].macro == slots[menu.currentSlot].currentmacro) and (group[i].macro ~= plandata.macro) then
										installicon = "be_upgrade_uninstalled"
										installcolor = Helper.color.red
									elseif (group[i].macro == plandata.macro) then
										installicon = "be_upgrade_installed"
										installcolor = Helper.color.green
										if hasmod then
											weaponicon = weaponicon .. " " .. modicon
										end
										if firsttime then
											menu.selectedRows.slots = row.index
											menu.selectedCols.slots = column
											firsttime = nil
										end
									end
								end
							end

							-- start: mycu call-back
							if callbacks ["displaySlots_on_before_create_button_mouseovertext"] then
								for _, callback in ipairs (callbacks ["displaySlots_on_before_create_button_mouseovertext"]) do
									result = callback (group[i].macro, plandata.macro, mouseovertext)
									if result then
										mouseovertext = result.mouseovertext
									end
								end
							end
							-- end: mycu call-back

							local active = ((group[i].macro == plandata.macro) or (not hasmod))
							local useable = hasstock and haslicence
							row[column]:createButton({
								active = active,
								width = columnWidths[i],
								height = maxColumnWidth,
								mouseOverText = mouseovertext,
								bgColor = useable and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
								highlightColor = useable and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
							}):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor }):setText(icon, { y = maxColumnWidth / 2 - Helper.scaleY(Helper.standardTextHeight) / 2 - Helper.configButtonBorderSize, halign = "right", color = overridecolor, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) }):setText2(weaponicon, { x = 3, y = -maxColumnWidth / 2 + Helper.scaleY(Helper.standardTextHeight) / 2 + Helper.configButtonBorderSize, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
							if useable then
								row[column].handlers.onClick = function () return menu.buttonSelectUpgradeMacro(menu.upgradetypeMode, menu.currentSlot, group[i].macro, row.index, column, nil, (menu.mode == "customgamestart") or (menu.mode == "comparison")) end
							end
							if group[i].macro ~= "" then
								row[column].handlers.onRightClick = function (...) return menu.buttonInteract({ type = menu.upgradetypeMode, name = group[i].name, macro = group[i].macro }, ...) end
							end
							row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, color = overridecolor, boxColor = (active and useable) and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor, mouseOverText = untruncatedExtraText })
						end
					end
					if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
						maxVisibleHeight = ftable:getFullHeight()
					end
				end
			end
		else
			if menu.upgradetypeMode == "consumables" then
				-- ammo
				local titlefirst = true
				for _, upgradetype in ipairs(Helper.upgradetypes) do
					if upgradetype.supertype == "ammo" then
						if next(menu.ammo[upgradetype.type]) then
							local total, capacity = menu.getAmmoUsage(upgradetype.type)
							local display = false
							for macro, _ in pairs(menu.ammo[upgradetype.type]) do
								if (total > 0) or menu.isAmmoCompatible(upgradetype.type, macro) then
									display = true
									break
								end
							end

							if ((total > 0) or (capacity > 0)) and display then
								if not titlefirst then
									ftable:addEmptyRow(Helper.standardTextHeight / 2)
								end
								titlefirst = false

								local name = upgradetype.type
								if upgradetype.type == "drone" then
									name = ReadText(1001, 8)
								elseif upgradetype.type == "missile" then
									name = ReadText(1001, 1304)
								elseif upgradetype.type == "deployable" then
									name = ReadText(1001, 1332)		-- "Deployables"
								elseif upgradetype.type == "countermeasure" then
									name = ReadText(1001, 8063)		-- "Countermeasures"
								end
								
								local row = ftable:addRow(false, { bgColor = Helper.defaultHeaderBackgroundColor })
								row[1]:setColSpan(7):setBackgroundColSpan(10):createText(name, menu.subHeaderTextProperties)
								row[8]:setColSpan(4):createText(total .. "\27X" .. " / " .. capacity, menu.subHeaderTextProperties)
								row[8].properties.halign = "right"
								row[8].properties.color = (total > capacity) and Helper.color.red or Helper.color.white

								local first = true
								local sortedammo = Helper.orderedKeys(menu.ammo[upgradetype.type], menu.sortAmmo)
								for _, macro in ipairs(sortedammo) do
									local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
									for race_i, race in ipairs(makerrace) do
										if (not menu.equipmentfilter_races[race]) then
											menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
										end
										if (not menu.equipmentfilter_races[race].upgradeTypes) then
											menu.equipmentfilter_races[race].upgradeTypes = {}
										end
										if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
											menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
										end
									end
									if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(macro, menu.equipmentsearchtext) then
										local row = menu.displayAmmoSlot(ftable, upgradetype.type, macro, total, capacity, first)
										first = false
										if (maxVisibleHeight == nil) and row and row.index >= config.maxSlotRows then
											maxVisibleHeight = ftable:getFullHeight()
										end
									end
								end
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "crew" then
				-- crew
				if ((menu.mode == "purchase") or (not menu.usemacro)) and (not menu.isReadOnly) then
					-- total hires on the shoppinglist without current ship
					local totalhiring = 0
					for idx, entry in ipairs(menu.shoppinglist) do
						if idx ~= menu.editingshoppinglist then
							totalhiring = totalhiring + entry.amount * entry.crew.hired
						end
					end
					-- amount of current ship
					local shoppinglistamount = 1
					if menu.editingshoppinglist then
						shoppinglistamount = menu.shoppinglist[menu.editingshoppinglist].amount
					end
					-- still available workforce
					local availableworkforce = menu.crew.availableworkforce + menu.crew.availabledockcrew - menu.addedCrewByPlayerBuildTasks - totalhiring - shoppinglistamount * menu.crew.hired
					-- resources for next resource shift
					local resourceinfos = GetWorkForceRaceResources(ConvertStringTo64Bit(tostring(menu.container)))
					local races = {}
					local n = C.GetNumAllRaces()
					local buf = ffi.new("RaceInfo[?]", n)
					n = C.GetAllRaces(buf, n)
					for i = 0, n - 1 do
						local entry = {}
						entry.id = ffi.string(buf[i].id)
						entry.name = ffi.string(buf[i].name)

						table.insert(races, entry)
					end
					local workforceresources = {}
					for _, race in ipairs(races) do
						local workforceinfo = C.GetWorkForceInfo(menu.container, race.id)
						if workforceinfo.capacity > 0 then
							local resourcedata
							for _, resourceinfo in ipairs(resourceinfos) do
								if resourceinfo.race == race.id then
									resourcedata = resourceinfo
								end
							end
							for i, resource in ipairs(resourcedata.resources) do
								local amount = Helper.round(resource.cycle * workforceinfo.current / resourcedata.productamount)
								if workforceresources[resource.ware] then
									workforceresources[resource.ware] = workforceresources[resource.ware] + amount
								else
									workforceresources[resource.ware] = amount
								end
							end
						end
					end
					-- compare with station cargo
					local resourceerror
					local cargo = GetComponentData(ConvertStringTo64Bit(tostring(menu.container)), "cargo")
					for ware, amount in pairs(workforceresources) do
						if (cargo[ware] or 0) < amount then
							resourceerror = ReadText(1001, 8540)
							break
						end
					end

					local errormessage, errorcolor
					local color = Helper.color.white
					if availableworkforce < 0 then
						errormessage = C.IsComponentClass(menu.container, "station") and ReadText(1001, 8541) or ReadText(1001, 8545)
						errorcolor = Helper.color.red
						color = Helper.color.red
					elseif menu.crew.availableworkforce + menu.crew.availabledockcrew - totalhiring < shoppinglistamount * menu.crew.capacity then
						errormessage = C.IsComponentClass(menu.container, "station") and ReadText(1001, 8538) or ReadText(1001, 8544)
						errorcolor = Helper.color.orange
						color = Helper.color.orange
					end

					local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(11):createText(C.IsComponentClass(menu.container, "station") and ReadText(1001, 8542) or ReadText(1001, 8543), menu.subHeaderTextProperties)

					local row = ftable:addRow(false, { bgColor = Helper.color.transparent, scaling = true })
					row[1]:setColSpan(8):createText(string.format(ReadText(1001, 8024), ffi.string(C.GetComponentName(menu.container))), { mouseOverText = menu.isplayerowned and "" or (ReadText(1001, 2808) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(menu.crew.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101)) })
					row[9]:setColSpan(3):createText(math.max(0, availableworkforce), { halign = "right", color = color })

					if menu.mode == "purchase" then
						local row = ftable:addRow(nil, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createText(ReadText(1001, 8539), { wordwrap = true })
					end

					if errormessage then
						local row = ftable:addRow(nil, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createText(errormessage, { wordwrap = true, color = errorcolor })
					end
					if resourceerror then
						local row = ftable:addRow(nil, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createText(resourceerror, { wordwrap = true, color = Helper.color.orange })
					end

					local row = ftable:addRow(false, { bgColor = Helper.color.transparent, scaling = true })
					row[1]:setColSpan(11):createText("")
				end

				local isbigship = (menu.class == "ship_m") or (menu.class == "ship_l") or (menu.class == "ship_xl")
				if menu.mode == "customgamestart" then
					if menu.modeparam.shippilotproperty or menu.modeparam.playerpropertyid then
						local value = 0
						if next(menu.customgamestartpilot) then
							local skills = {}
							for skill, value in pairs(menu.customgamestartpilot.skills or {}) do
								table.insert(skills, { id = skill, value = value })
							end
							local buf = ffi.new("CustomGameStartPersonEntry")
							buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
							buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
							buf.numskills = #skills
							buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
							for i, entry in ipairs(skills) do
								buf.skills[i - 1].id = Helper.ffiNewString(entry.id)
								buf.skills[i - 1].value = entry.value
							end
							value = tonumber(C.GetCustomGameStartShipPersonValue(menu.modeparam.gamestartid, buf))
						end

						local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
						if menu.modeparam.creative then
							row[1]:setColSpan(11):createText(isbigship and ReadText(1001, 4848) or ReadText(1001, 4847), menu.subHeaderTextProperties)
						else
							row[1]:setColSpan(7):setBackgroundColSpan(11):createText(isbigship and ReadText(1001, 4848) or ReadText(1001, 4847), menu.subHeaderTextProperties)
							row[8]:setColSpan(4):createText(ConvertIntegerString(value, true, 0, true)  .. " " .. Helper.convertColorToText(Helper.color.red) .. "\27[gamestart_custom_people]", menu.subHeaderTextProperties)
							row[8].properties.halign = "right"
						end

						local raceoptions = {}
						local n = C.GetNumAllRaces()
						local buf = ffi.new("RaceInfo[?]", n)
						n = C.GetAllRaces(buf, n)
						for i = 0, n - 1 do
							local id = ffi.string(buf[i].id)
							local name = ffi.string(buf[i].name)
							if C.CanPlayerUseRace(id, "aipilot") then
								table.insert(raceoptions, { id = id, text = name, icon = "", displayremoveoption = false })
							end
						end
						table.sort(raceoptions, function (a, b) return a.text < b.text end)
						table.insert(raceoptions, 1, { id = "any", text = ReadText(1001, 9930), icon = "", displayremoveoption = false })

						local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createDropDown(raceoptions, { startOption = (menu.customgamestartpilot.race and (menu.customgamestartpilot.race ~= "")) and menu.customgamestartpilot.race or "any", height = Helper.standardTextHeight, x = Helper.standardTextOffsetx })
						row[1].handlers.onDropDownConfirmed = function(_, raceid) if raceid == "any" then menu.customgamestartpilot.race = "" else menu.customgamestartpilot.race = raceid end; menu.refreshMenu() end

						ftable:addEmptyRow(Helper.standardTextHeight / 2)

						local numskills = C.GetNumSkills()
						local buf = ffi.new("SkillInfo[?]", numskills)
						numskills = C.GetSkills(buf, numskills)
						for i = 0, numskills - 1 do
							local id = ffi.string(buf[i].id)

							local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
							row[1]:setColSpan(11):createSliderCell({ height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = 0, max = 15, start = menu.customgamestartpilot.skills and menu.customgamestartpilot.skills[id] or 0, step = 1 }):setText(ReadText(1013, buf[i].textid))
							row[1].handlers.onSliderCellChanged = function(_, newamount) if menu.customgamestartpilot.skills then menu.customgamestartpilot.skills[id] = newamount else menu.customgamestartpilot.skills = { [id] = newamount } end end
						end

						ftable:addEmptyRow()
					end
				end

				if (menu.mode ~= "customgamestart") or (menu.crew.capacity > 0) then
					local row = ftable:addRow(menu.mode ~= "customgamestart", { bgColor = Helper.color.transparent })
					row[1]:setColSpan(7):setBackgroundColSpan(9):createText(ReadText(1001, 80), menu.subHeaderTextProperties)
					-- include the +1 for the captain
					if menu.mode ~= "customgamestart" then
						row[8]:setColSpan(3):createText((menu.crew.total + menu.crew.hired - #menu.crew.fired + (menu.captainSelected and 1 or 0)) .. " / " .. (menu.crew.capacity + 1), menu.subHeaderTextProperties)
						row[8].properties.halign = "right"
						row[11]:createButton({ active = (not menu.isReadOnly), mouseOverText = ReadText(1026, 8001), height = menu.rowHeight, y = math.max(0, row:getHeight() - menu.rowHeight) }):setIcon("menu_reset")
						row[11].handlers.onClick = menu.buttonResetCrew
					elseif not menu.modeparam.creative then
						local value = tonumber(C.GetCustomGameStartShipPeopleValue2(menu.modeparam.gamestartid, menu.macro, menu.customgamestartpeopledef, menu.customgamestartpeoplefillpercentage))

						row[8]:setColSpan(4):createText(ConvertIntegerString(value, true, 0, true)  .. " " .. Helper.convertColorToText(Helper.color.red) .. "\27[gamestart_custom_people]", menu.subHeaderTextProperties)
						row[8].properties.halign = "right"
					else
						row[8]:setColSpan(4):createText(" ", menu.subHeaderTextProperties)
					end
				end

				if menu.mode ~= "customgamestart" then
					local row = ftable:addRow(true, { scaling = true, bgColor = Helper.color.transparent })
					row[1]:setColSpan(1):createCheckBox(menu.captainSelected, { scaling = false, active = (menu.mode == "purchase") and (not menu.captainSelected), width = menu.rowHeight, height = menu.rowHeight })
					row[1].handlers.onClick = function () return menu.checkboxSelectCaptain(row.index) end
					row[2]:setColSpan(7):createText(isbigship and ReadText(1001, 4848) or ReadText(1001, 4847), { color = ((menu.mode ~= "purchase") or menu.captainSelected) and Helper.color.white or Helper.color.red })
					if menu.usemacro then
						row[9]:setColSpan(3):createText(ReadText(1001, 8047), { halign = "right", color = menu.captainSelected and Helper.color.white or Helper.color.red })
					end
				end

				if menu.crew.capacity > 0 then
					if menu.mode == "customgamestart" then
						local peopleoptions = {}
						local n = C.GetNumPlayerPeopleDefinitions()
						local buf = ffi.new("PeopleDefinitionInfo[?]", n)
						n = C.GetPlayerPeopleDefinitions(buf, n)
						for i = 0, n - 1 do
							table.insert(peopleoptions, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false, mouseovertext = ffi.string(buf[i].desc) })
						end
						table.sort(peopleoptions, function (a, b) return a.text < b.text end)
						table.insert(peopleoptions, 1, { id = "none", text = ReadText(1001, 9931), icon = "", displayremoveoption = false })

						local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createDropDown(peopleoptions, { startOption = (menu.customgamestartpeopledef and (menu.customgamestartpeopledef ~= "")) and menu.customgamestartpeopledef or "none", height = Helper.standardTextHeight, x = Helper.standardTextOffsetx })
						row[1].handlers.onDropDownConfirmed = function(_, peopledefid) if peopledefid == "none" then menu.customgamestartpeopledef = "" else menu.customgamestartpeopledef = peopledefid end; menu.refreshMenu() end

						local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createSliderCell({ height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = 0, max = menu.crew.capacity, start = (menu.customgamestartpeopledef == "") and 0 or Helper.round(menu.crew.capacity * menu.customgamestartpeoplefillpercentage / 100), step = 1, readOnly = menu.customgamestartpeopledef == "" }):setText(ReadText(1001, 47))
						row[1].handlers.onSliderCellChanged = function(_, newamount) menu.customgamestartpeoplefillpercentage = newamount / menu.crew.capacity * 100 end 
					else
						local row = ftable:addRow(false, { bgColor = Helper.color.transparent, scaling = true })
						row[1]:setColSpan(11):createText("")

						if (not menu.usemacro) and (not menu.isReadOnly) then
							local color = Helper.color.white
							if #menu.crew.unassigned > 0 then
								color = Helper.color.red
							end

							local row = ftable:addRow(true, { scaling = true, bgColor = Helper.color.transparent })
							row[1]:setColSpan(7):createText(ReadText(1001, 8025))
							row[8]:setColSpan(3):createText(#menu.crew.unassigned, { halign = "right", color = color })
							row[11]:createButton({ active = (not menu.isReadOnly), mouseOverText = ReadText(1026, 8002) }):setIcon("menu_dismiss")
							row[11].handlers.onClick = menu.buttonFireCrew
						end

						local first = true
						for i, entry in ipairs(menu.crew.roles) do
							local row = menu.displayCrewSlot(ftable, i, entry, buttonWidth, menu.crew.price, first)
							first = false
							if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
								maxVisibleHeight = ftable:getFullHeight()
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "software" then
				-- software
				local first = true
				if menu.software[menu.upgradetypeMode] then
					for slot, slotdata in ipairs(menu.software[menu.upgradetypeMode]) do
						if #slotdata.possiblesoftware > 0 then
							if first then
								first = false
							else
								local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
								row[1]:setColSpan(11):createText(" ")
							end
							local row = menu.displaySoftwareSlot(ftable, menu.upgradetypeMode, slot, slotdata)
							if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
								maxVisibleHeight = ftable:getFullHeight()
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "settings" then
				-- settings
				-- blacklists
				local row = ftable:addRow(false, { bgColor = Helper.defaultHeaderBackgroundColor })
				row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 9143), menu.subHeaderTextProperties)

				local blacklists = Helper.getBlackLists()

				local purpose = GetMacroData(menu.macro, "primarypurpose")
				local group = ((purpose == "fight") or (purpose == "auxiliary")) and "military" or "civilian"
				local types = {
					{ type = "sectortravel",	name = ReadText(1001, 9165) },
					{ type = "sectoractivity",	name = ReadText(1001, 9166) },
					{ type = "objectactivity",	name = ReadText(1001, 9167) },
				}
				for i, entry in ipairs(types) do
					row = ftable:addRow(false, { scaling = true, bgColor = Helper.color.transparent })
					row[1]:setColSpan(11):createText(entry.name .. ReadText(1001, 120))

					local blacklistid = menu.settings.blacklists[entry.type] or 0

					local rowdata = "orders_blacklist_" .. entry.type .. "_global"
					local row = ftable:addRow({ rowdata }, { scaling = true, bgColor = Helper.color.transparent })
					row[1]:setColSpan(1):createCheckBox(blacklistid == 0, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
					row[1].handlers.onClick = function(_, checked) menu.settings.blacklists[entry.type] = checked and 0 or -1; menu.refreshMenu() end
					row[2]:setColSpan(10):createText(ReadText(1001, 8367))

					local locresponses = {
						{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
					}

					local defaultblacklistid = -1
					for _, blacklist in ipairs(blacklists) do
						if blacklist.type == entry.type then
							if blacklist.defaults[group] then
								defaultblacklistid = blacklist.id
							end
							table.insert(locresponses, { id = blacklist.id, text = blacklist.name, icon = "", displayremoveoption = false })
						end
					end
					local row = ftable:addRow("orders_resupply", { scaling = true, bgColor = Helper.color.transparent })
					row[1]:setColSpan(10):createDropDown(locresponses, { startOption = (blacklistid ~= 0) and blacklistid or defaultblacklistid, active = blacklistid ~= 0 })
					row[1].handlers.onDropDownConfirmed = function (_, id) menu.settings.blacklists[entry.type] = tonumber(id) end
					row[11]:createButton({ mouseOverText = ReadText(1026, 8413) }):setIcon("menu_edit")
					row[11].handlers.onClick = menu.buttonEditBlacklist

					ftable:addEmptyRow()
				end

				-- fight rules
				local row = ftable:addRow(false, { bgColor = Helper.defaultHeaderBackgroundColor })
				row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 7753), menu.subHeaderTextProperties)

				local fightrules = Helper.getFightRules()

				local fightruleid = menu.settings.fightrules["attack"] or 0

				local rowdata = "orders_fightrule_attack_global"
				local row = ftable:addRow({ rowdata }, { scaling = true, bgColor = Helper.color.transparent })
				row[1]:setColSpan(1):createCheckBox(fightruleid == 0, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[1].handlers.onClick = function(_, checked) menu.settings.fightrules["attack"] = checked and 0 or -1; menu.refreshMenu() end
				row[2]:setColSpan(10):createText(ReadText(1001, 8367))

				local locresponses = {
					{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
				}

				local defaultfightruleid = -1
				for _, fightrule in ipairs(fightrules) do
					if fightrule.defaults["attack"] then
						defaultfightruleid = fightrule.id
					end
					table.insert(locresponses, { id = fightrule.id, text = fightrule.name, icon = "", displayremoveoption = false })
				end
				local row = ftable:addRow("orders_resupply", { scaling = true, bgColor = Helper.color.transparent })
				row[1]:setColSpan(10):createDropDown(locresponses, { startOption = (fightruleid ~= 0) and fightruleid or defaultfightruleid, active = fightruleid ~= 0 })
				row[1].handlers.onDropDownConfirmed = function (_, id) menu.settings.fightrules["attack"] = tonumber(id) end
				row[11]:createButton({ mouseOverText = ReadText(1026, 8414) }):setIcon("menu_edit")
				row[11].handlers.onClick = menu.buttonEditFightRule

				-- missile launchers
				local hasmissilelauncher = false
				for slot, data in pairs(menu.upgradeplan.weapon) do
					if data.macro ~= "" then
						if IsMacroClass(data.macro, "missilelauncher") then
							hasmissilelauncher = true
							break
						end
					end
				end
				if hasmissilelauncher then
					ftable:addEmptyRow()

					local row = ftable:addRow(false, { bgColor = Helper.defaultHeaderBackgroundColor })
					row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 9030), menu.subHeaderTextProperties)
					for slot, data in pairs(menu.upgradeplan.weapon) do
						if data.macro ~= "" then
							if IsMacroClass(data.macro, "missilelauncher") then
								menu.displayWeaponAmmoSelection(ftable, "weapon", slot, data)
							end
						end
					end
				end
				-- turrets
				local hasindividualturrets = false
				for slot, data in pairs(menu.upgradeplan.turret) do
					if data.macro ~= "" then
						hasindividualturrets = true
						break
					end
				end
				if hasindividualturrets then
					ftable:addEmptyRow()

					local row = ftable:addRow(false, { bgColor = Helper.defaultHeaderBackgroundColor })
					row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 1319), menu.subHeaderTextProperties)
					for slot, data in pairs(menu.upgradeplan.turret) do
						if data.macro ~= "" then
							menu.displayWeaponModeSelection(ftable, "turret", slot, data)
						end
					end
				end
				-- turret groups
				if next(menu.upgradeplan.turretgroup) then
					ftable:addEmptyRow()

					local row = ftable:addRow(false, { bgColor = Helper.defaultHeaderBackgroundColor })
					row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 7901), menu.subHeaderTextProperties)
					for slot, groupdata in pairs(menu.upgradeplan.turretgroup) do
						if groupdata.macro ~= "" then
							menu.displayWeaponModeSelection(ftable, "turretgroup", slot, groupdata)
						end
					end
				end
			end
		end

		if maxVisibleHeight ~= nil then
			ftable.properties.maxVisibleHeight = maxVisibleHeight
		end

		ftable:setTopRow(menu.topRows.slots)
		ftable:setSelectedRow(menu.selectedRows.slots)
		ftable:setSelectedCol(menu.selectedCols.slots or 0)
	end

	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil
end

function menu.getExtraText(columnwidth, basetext, macro, price, component, upgradetype)
	local extraText = ""
	local untruncatedExtraText = ""
	if price then
		extraText = ConvertMoneyString(price, false, true, 3, true) .. " " .. ReadText(1001, 101)
	end
	if macro then
		local makerrace, mk = GetMacroData(macro, "makerrace", "mk")
		local extraText2 = ""
		if component then
			local class = ffi.string(C.GetComponentClass(component))
			if (class == "weapon") or (class == "missilelauncher") then
				if mk > 0 then
					extraText2 = ReadText(20111, 100 * mk + 1)
				end
			end
		end
		if upgradetype == "weapon" then
			if mk > 0 then
				extraText2 = ReadText(20111, 100 * mk + 1)
			end
		end
		for _, racestring in ipairs(makerrace) do
			extraText2 = racestring .. ((extraText2 ~= "") and " - " or "") .. extraText2
		end

		local separator = ((extraText2 ~= "") and (extraText ~= "")) and "\n" or ""
		extraText = extraText2 .. separator .. extraText
		local truncatedtext = TruncateText(basetext, Helper.standardFont, menu.extraFontSize, columnwidth - 2 * Helper.borderSize)
		if truncatedtext ~= basetext then
			untruncatedExtraText = basetext .. " " .. extraText
		end
		extraText = truncatedtext .. "\n" .. extraText
	else
		if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			extraText = "\n" .. extraText
		end
		local truncatedtext = TruncateText(basetext, Helper.standardFont, menu.extraFontSize, columnwidth - 2 * Helper.borderSize)
		if truncatedtext ~= basetext then
			untruncatedExtraText = basetext .. " " .. extraText
		end
		extraText = truncatedtext .. "\n" .. extraText
	end
	return extraText, untruncatedExtraText
end

function menu.displayWeaponAmmoSelection(ftable, upgradetype, slot, data)
	local dropdowndata = {}
	for macro, _ in pairs(menu.ammo["missile"]) do
		if C.IsAmmoMacroCompatible(data.macro, macro) then
			table.insert(dropdowndata, {id = macro, text = GetMacroData(macro, "name"), icon = "", displayremoveoption = false})
		end
	end

	local row = ftable:addRow("ammo_config", { scaling = true, bgColor = Helper.color.transparent })
	local name = GetMacroData(data.macro, "name")
	if upgradetype == "turretgroup" then
		name = menu.groups[slot].groupname .. " - " .. name
	else
		name = menu.slots[upgradetype][slot].slotname .. " - " .. name
	end
	row[1]:setColSpan(6):createText(name)
	row[7]:setColSpan(5):createDropDown(dropdowndata, { startOption = data.ammomacro })
	row[7].handlers.onDropDownConfirmed = function(_, newammomacro) menu.upgradeplan[upgradetype][slot].ammomacro = newammomacro end
end

function menu.displayWeaponModeSelection(ftable, upgradetype, slot, data)
	local row = ftable:addRow("ammo_config", { scaling = true, bgColor = Helper.color.transparent })
	local name = GetMacroData(data.macro, "name")
	if upgradetype == "turretgroup" then
		name = menu.groups[slot].groupname .. " - " .. name
	else
		name = menu.slots[upgradetype][slot].slotname .. " - " .. name
	end
	row[1]:setColSpan(6):createText(name)
	row[7]:setColSpan(5):createDropDown(Helper.getMacroTurretModes(data.macro), { startOption = data.weaponmode })
	row[7].handlers.onDropDownConfirmed = function(_, newturretmode) menu.upgradeplan[upgradetype][slot].weaponmode = newturretmode end
end

function menu.displayModifySlots(frame)
	if menu.upgradetypeMode then
		local slotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)
		local modIconWidth = C.GetTextWidth("\27[" .. Helper.modQualities[3].icon2 .. "]", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)) + 2 * Helper.scaleX(Helper.standardTextOffsetx)

		local ftable = frame:addTable(8, { tabOrder = 1, width = menu.slotData.width, height = 0, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		if menu.setdefaulttable then
			ftable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		ftable:setColWidth(1, Helper.scaleX(Helper.standardTextHeight))
		ftable:setColWidth(2, slotWidth - Helper.scaleX(Helper.standardTextHeight) - Helper.borderSize)
		ftable:setColWidth(3, slotWidth)
		ftable:setColWidth(4, slotWidth)
		ftable:setColWidth(6, menu.slotData.width * 2 / 9)
		ftable:setColWidth(7, menu.slotData.width * 1 / 9)
		ftable:setColWidth(8, modIconWidth)
		ftable:setDefaultBackgroundColSpan(1, 8)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(8):createText(ReadText(1001, 8031), menu.headerTextProperties)

		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		for i, entry in ipairs(Helper.modQualities) do
			local col = i
			if i > 1 then
				col = col + 1
			end

			local bgColor = Helper.defaultButtonBackgroundColor
			if entry.category == menu.modCategory then
				bgColor = Helper.defaultArrowRowBackgroundColor
			end

			row[col]:setColSpan((i == 1) and 2 or 1):createButton({ height = slotWidth, mouseOverText = entry.name, bgColor = bgColor }):setIcon(entry.icon)
			row[col].handlers.onClick = function () return menu.buttonModCategory(entry.category, row.index, col) end
		end
		row[6]:setColSpan(3)

		if menu.object ~= 0 then
			local entry = menu.getLeftBarEntry(menu.upgradetypeMode)
			if next(entry) then
				if entry.upgrademode == "ship" then
					menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, 1)
				elseif entry.upgrademode == "shield" then
					table.sort(menu.shieldgroups, Helper.sortSlots)
					for i, shieldgroupdata in ipairs(menu.shieldgroups) do
						menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, i, shieldgroupdata)
					end
				elseif (entry.upgrademode == "turret") and next(menu.groups) then
					table.sort(menu.shieldgroups, Helper.sortSlots)
					for i, shieldgroupdata in ipairs(menu.shieldgroups) do
						menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, i, shieldgroupdata, true)
					end
				else
					local upgradetype = Helper.findUpgradeType(entry.upgrademode)

					if upgradetype.mergeslots then
						local slotdata = menu.slots[entry.upgrademode][1]
						if slotdata.currentmacro ~= "" then
							menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, 1, slotdata)
						end
					else
						for slot, slotdata in ipairs(menu.slots[entry.upgrademode]) do
							if slotdata.currentmacro ~= "" then
								menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, slot, slotdata)
							end
						end
					end
				end
			end
		end

		ftable:setTopRow(menu.topRows.slots)
		ftable:setSelectedRow(menu.selectedRows.slots)
		ftable:setSelectedCol(menu.selectedCols.slots or 0)
	end
	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil
end

function menu.displayModifyPaintSlots(frame)
	if menu.upgradetypeMode then	
		local entry = menu.getLeftBarEntry(menu.upgradetypeMode)
		-- available mods
		local categoryQuality = menu.getModQuality(menu.modCategory)
		if not categoryQuality then
			DebugError(string.format("Could not resolve mod category '%s' to quality level. Check Helper.modQualities [Florian]", menu.modCategory))
			return
		end
		
		if not menu.selectedPaintMod then
			if menu.modeparam[1] and (#menu.selectableships > 1) then
				menu.selectedPaintMod = menu.defaultpaintmod
			elseif menu.installedPaintMod then
				menu.selectedPaintMod = menu.installedPaintMod
			else
				menu.selectedPaintMod = menu.defaultpaintmod
			end
		end

		local count = 0
		menu.paintmodgroups = {}

		if categoryQuality == 1 then
			if menu.defaultpaintmod then
				count = count + 1
				local group = math.ceil(count / 3)
				if menu.paintmodgroups[group] then
					table.insert(menu.paintmodgroups[group], menu.defaultpaintmod)
				else
					menu.paintmodgroups[group] = { menu.defaultpaintmod }
				end
			end
		end

		if menu.modwares[entry.modclass] then
			for _, entry in ipairs(menu.modwares[entry.modclass]) do
				if (entry.quality == categoryQuality) and ((menu.defaultpaintmod == nil) or (entry.ware ~= menu.defaultpaintmod.ware)) then
					count = count + 1
					local group = math.ceil(count / 3)
					if menu.paintmodgroups[group] then
						table.insert(menu.paintmodgroups[group], entry)
					else
						menu.paintmodgroups[group] = { entry }
					end
				end
			end
		end

		local buttontable = frame:addTable(3, { tabOrder = 9, width = menu.slotData.width, height = 0, x = menu.slotData.offsetX, y = 0, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		buttontable:setColWidth(1, Helper.standardTextHeight)
		buttontable:setColWidthPercent(3, 40)

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 8550), menu.headerTextProperties)

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(menu.installedPaintMod and (menu.installedPaintMod.isdefault and ReadText(1001, 8516) or menu.installedPaintMod.name) or "", { color =  menu.installedPaintMod and Helper.modQualities[menu.installedPaintMod.quality].color or Helper.color.white })

		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		local islocked = false
		if menu.object ~= 0 then
			islocked = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "paintmodlocked")
		end
		row[1]:createCheckBox(islocked, { active = true })
		row[1].handlers.onClick = function () return C.SetPaintModLocked(menu.object, not islocked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 8551))

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(3):createText(ReadText(1001, 8514), menu.headerTextProperties)

		local active = menu.selectedPaintMod ~= nil
		local missingcount
		if menu.selectedPaintMod then
			if menu.modeparam[1] then
				missingcount = 0
				for _, ship in pairs(menu.modeparam[2]) do
					local paintmod = ffi.new("UIPaintMod")
					if C.GetInstalledPaintMod(ship, paintmod) then
						if menu.selectedPaintMod.ware ~= ffi.string(paintmod.Ware) then
							missingcount = missingcount + 1
						end
					else
						missingcount = missingcount + 1
					end
				end
				if (missingcount == 0) or ((not menu.selectedPaintMod.isdefault) and (missingcount > menu.selectedPaintMod.amount)) then
					active = false
				end
			else
				active = menu.selectedPaintMod.ware ~= (menu.installedPaintMod and menu.installedPaintMod.ware or "")
			end
		end

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(menu.selectedPaintMod and (menu.selectedPaintMod.isdefault and ReadText(1001, 8516) or (((missingcount and (missingcount > 0)) and (missingcount .. ReadText(1001, 42) .. " ") or "") .. menu.selectedPaintMod.name)) or "", { color =  menu.selectedPaintMod and Helper.modQualities[menu.selectedPaintMod.quality].color or Helper.color.white })

		local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[3]:createButton({ active = active }):setText(ReadText(1001, 4803), { halign = "center" })
		row[3].handlers.onClick = menu.buttonInstallPaintMod

		buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - Helper.frameBorder
		
		menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
		local maxSlotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)
		local boxTextHeight = math.ceil(C.GetTextHeight(" ", Helper.standardFont, menu.extraFontSize, 0)) + 2 * Helper.borderSize
		local headerHeight = menu.titleData.height + (maxSlotWidth + Helper.borderSize) + 2 * Helper.borderSize
		--[[ Keep for simpler debugging
			print((buttontable.properties.y - menu.slotData.offsetY) .. " vs " .. (headerHeight + #menu.paintmodgroups * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight)))
			print(headerHeight)
			print(boxTextHeight)
			print(#menu.paintmodgroups .. " * " .. 3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) --]]
		if (buttontable.properties.y - menu.slotData.offsetY) < (headerHeight + #menu.paintmodgroups * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight)) then
			hasScrollbar = true
		end

		local slotWidth = maxSlotWidth - math.floor((hasScrollbar and Helper.scrollbarWidth or 0) / 9)
		local extraPixels = (menu.slotData.width - 8 * Helper.borderSize) % 9
		local slotWidths = { slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth }
		if extraPixels > 0 then
			for i = 1, extraPixels do
				slotWidths[i] = slotWidths[i] + 1
			end
		end
		columnWidths = {}
		maxColumnWidth = 0
		for i = 1, 3 do
			columnWidths[i] = slotWidths[(i - 1) * 3 + 1] + slotWidths[(i - 1) * 3 + 2] + slotWidths[(i - 1) * 3 + 3] + 2 * Helper.borderSize
			maxColumnWidth = math.max(maxColumnWidth, columnWidths[i])
		end

		local ftable = frame:addTable(9, { tabOrder = 1, width = menu.slotData.width, maxVisibleHeight = buttontable.properties.y - menu.slotData.offsetY, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = false, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60, highlightMode = "column" })
		if menu.setdefaulttable then
			ftable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		for i = 1, 8 do
			ftable:setColWidth(i, slotWidths[i])
		end

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(9):createText(ReadText(1001, 8031), menu.headerTextProperties)

		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		for i, entry in ipairs(Helper.modQualities) do
			local col = i

			local bgColor = Helper.defaultButtonBackgroundColor
			if entry.category == menu.modCategory then
				bgColor = Helper.defaultArrowRowBackgroundColor
			end

			row[col]:createButton({ height = slotWidth, mouseOverText = entry.name, bgColor = bgColor }):setIcon(entry.icon)
			row[col].handlers.onClick = function () return menu.buttonModCategory(entry.category, row.index, col) end
		end

		if menu.object ~= 0 then
			if next(menu.paintmodgroups) then
				for _, group in ipairs(menu.paintmodgroups) do
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
					local row2 = ftable:addRow(false, { bgColor = Helper.color.transparent })
					for i, entry in ipairs(group) do
						local col = i * 3 - 2

						local active, overridecolor = true, nil
						if menu.modeparam[1] then
							local missingcount = 0
							for _, ship in pairs(menu.modeparam[2]) do
								local paintmod = ffi.new("UIPaintMod")
								if C.GetInstalledPaintMod(ship, paintmod) then
									if entry.ware ~= ffi.string(paintmod.Ware) then
										missingcount = missingcount + 1
									end
								else
									missingcount = missingcount + 1
								end
							end
							if (not entry.isdefault) and (missingcount > entry.amount) then
								active = false
								overridecolor = Helper.color.red
							end
						end

						local installicon, installcolor = "", Helper.color.white
						if entry.ware == menu.selectedPaintMod.ware then
							installicon = "be_upgrade_installed"
							installcolor = Helper.color.green
						elseif menu.installedPaintMod and (entry.ware == menu.installedPaintMod.ware) then
							installicon = "be_upgrade_uninstalled"
							installcolor = Helper.color.red
						end

						row[col]:setColSpan(3):createButton({
							width = columnWidths[i],
							height = maxColumnWidth,
							bgColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor,
							highlightColor = active and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
						}):setIcon(entry.ware):setIcon2(installicon, { color = installcolor }):setText((entry.amount and (entry.amount > 0)) and (ReadText(1001, 42) .. " " .. entry.amount) or "", { x = Helper.scaleX(Helper.configButtonBorderSize), y = - maxColumnWidth / 2 + Helper.standardTextHeight / 2 + Helper.configButtonBorderSize, halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize), color = overridecolor })
						if active then
							row[col].handlers.onClick = function () return menu.buttonSelectPaintMod(entry, row.index, col) end
						end

						local untruncatedExtraText = entry.isdefault and ReadText(1001, 8516) or entry.name
						local extraText = TruncateText(untruncatedExtraText, Helper.standardFont, menu.extraFontSize, columnWidths[i] - 2 * Helper.borderSize)
						row2[col]:setColSpan(3):createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, color = overridecolor, boxColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor, mouseOverText = (extraText ~= untruncatedExtraText) and untruncatedExtraText or "" })
					end
				end
			else
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
				row[1]:setColSpan(9):createText("  " .. Helper.modQualities[categoryQuality].paintnonetext, { color = Helper.modQualities[categoryQuality].color })
			end
		end

		ftable:setTopRow(menu.topRows.slots)
		ftable:setSelectedRow(menu.selectedRows.slots)
		ftable:setSelectedCol(menu.selectedCols.slots or 0)

		ftable.properties.nextTable = buttontable.index
		buttontable.properties.prevTable = ftable.index
	end
	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil

end

function menu.displayModSlot(ftable, type, modclass, slot, slotdata, isgroup)
	local upgradetype
	if type ~= "ship" then
		upgradetype = Helper.findUpgradeType(type)
	end
	
	local isexpanded = menu.isModSlotExpanded(type, slot)
	if (type == "ship") or (upgradetype and upgradetype.mergeslots) then
		isexpanded = true
	end

	local turretcomponent
	local installedmod = {}
	local hasinstalledmod = false
	if type == "engine" then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object)
	elseif type == "shield" then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object, slotdata.context, slotdata.group)
	elseif (type == "turret") and isgroup then
		local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", slotdata.context, "", slotdata.group, "turret")
		turretcomponent = groupinfo.currentcomponent
		if turretcomponent == 0 then
			-- Nothing to mod here
			return
		end
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object, slotdata.context, slotdata.group, isgroup)
	elseif type == "ship" then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object)
	elseif (type == "weapon") or (type == "turret") then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, slotdata.component)
	end

	local row = ftable:addRow({ slot }, { scaling = true })
	if slot == menu.currentSlot then
		menu.selectedRows.slots = row.index
	end
	if (type ~= "ship") and ((not upgradetype) or (not upgradetype.mergeslots)) then
		row[1]:setBackgroundColSpan(1):createButton({ active = true }):setText(isexpanded and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function() return menu.expandModSlot(type, slot, row.index) end
		row[2]:setBackgroundColSpan(7)
	end
	if type == "ship" then
		if hasinstalledmod then
			row[2]:setColSpan(6)
			row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
		else
			row[2]:setColSpan(7)
		end
		row[2]:createText(ffi.string(C.GetComponentName(menu.object)) .. " (" .. ReadText(1001, 8008) .. ReadText(1001, 120) .. " " .. GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"), "name") .. ")")
	elseif type == "shield" then
		if (slotdata.context == menu.object) and (slotdata.group == "") then
			if hasinstalledmod then
				row[2]:setColSpan(6)
				row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
			else
				row[2]:setColSpan(7)
			end

			local name = upgradetype.text.default
			if slotdata.slotsize ~= "" then
				name = upgradetype.text[slotdata.slotsize]
			end
			row[2]:createText(slotdata.count .. "x " .. name)
		else
			if hasinstalledmod then
				row[6]:setColSpan(2)
				row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
			else
				row[6]:setColSpan(3)
			end
			row[2]:setColSpan(4):createText(GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(slotdata.component)), "macro"), "name"))
			row[6]:createText("[" .. ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(slotdata.slotsize) .. slotdata.sizecount .. " (" .. menu.getUpgradeTypeText(slotdata.upgradetype) .. ")]")
		end
	elseif (type == "turret") and isgroup then
		if (slotdata.context ~= menu.object) or (slotdata.group ~= "") then
			if hasinstalledmod then
				row[6]:setColSpan(2)
				row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
			else
				row[6]:setColSpan(3)
			end
			row[2]:setColSpan(4):createText(GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(turretcomponent)), "macro"), "name"))
			row[6]:createText("[" .. ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(slotdata.slotsize) .. slotdata.sizecount .. "]")
		end
	else
		if hasinstalledmod then
			row[6]:setColSpan(2)
			row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]")
		else
			row[6]:setColSpan(3)
		end
		
		row[2]:setColSpan(4):createText(GetMacroData(slotdata.currentmacro, "name"))
		if (not uprgadetype) or (not upgradetype.mergeslots) then
			row[6]:createText("[" .. ReadText(1001, 66) .. " " .. slot .. "]", { halign = "right" })
		end
	end

	if isexpanded then
		if hasinstalledmod then
			-- name
			local color = Helper.modQualities[installedmod.Quality].color
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			row[2]:setColSpan(5):createText(installedmod.Name, { color = color })
			row[7]:setColSpan(2):createText(ReadText(1001, 8033), { halign = "right", color = color })
			-- Effects
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			row[2]:setColSpan(7):createText("   " .. ReadText(1001, 8034) .. ReadText(1001, 120))
			-- default property
			for i, property in ipairs(Helper.modProperties[modclass]) do
				if property.key == installedmod.PropertyType then
					if installedmod[property.key] ~= property.basevalue then
						local effectcolor
						if installedmod[property.key] > property.basevalue then
							effectcolor = property.pos_effect and Helper.color.green or Helper.color.red
						else
							effectcolor = property.pos_effect and Helper.color.red or Helper.color.green
						end
						local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
						row[2]:setColSpan(5):createText("      " .. property.text, { font = Helper.standardFontBold })
						row[7]:setColSpan(2):createText(property.eval(installedmod[property.key]), { font = Helper.standardFontBold, halign = "right", color = effectcolor })
					end
					break
				end
			end
			-- other properties
			for i, property in ipairs(Helper.modProperties[modclass]) do
				if property.key ~= installedmod.PropertyType then
					if installedmod[property.key] ~= property.basevalue then
						local effectcolor
						if installedmod[property.key] > property.basevalue then
							effectcolor = property.pos_effect and Helper.color.green or Helper.color.red
						else
							effectcolor = property.pos_effect and Helper.color.red or Helper.color.green
						end
						local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
						row[2]:setColSpan(5):createText("      " .. property.text)
						row[7]:setColSpan(2):createText(property.eval(installedmod[property.key]), { halign = "right", color = effectcolor })
					end
				end
			end
			-- dismantle
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			row[1]:setColSpan(4)
			row[5]:setColSpan(4):createButton({  }):setText(ReadText(1001, 6601), { halign = "center" })
			if (type == "ship") or (type == "engine") then
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, menu.object) end
			elseif (type == "turret") and isgroup then
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, menu.object, slotdata.context, slotdata.group) end
			elseif type == "shield" then
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, menu.object, slotdata.context, slotdata.group) end
			else
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, slotdata.component) end
			end
		else
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			row[2]:setColSpan(7):createText(ReadText(1001, 8032))
		end

		-- available mods
		local categoryQuality = menu.getModQuality(menu.modCategory)
		if not categoryQuality then
			DebugError(string.format("Could not resolve mod category '%s' to quality level. Check Helper.modQualities [Florian]", menu.modCategory))
			return
		end
		local found = false
		if menu.modwares[modclass] then
			for _, entry in ipairs(menu.modwares[modclass]) do
				if entry.quality == categoryQuality then
					if (type == "turret") and isgroup then
						if C.CheckWeaponModCompatibility(turretcomponent, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware, isgroup)
						end
					elseif modclass == "weapon" then
						if C.CheckWeaponModCompatibility(slotdata.component, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
						end
					elseif modclass == "shield" then
						if C.CheckGroupedShieldModCompatibility(menu.object, slotdata.context, slotdata.group, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
						end
					elseif modclass == "ship" then
						if C.CheckShipModCompatibility(menu.object, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
						end
					else
						found = true
						menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
					end
				end
			end
		end
		if not found then
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			row[2]:setColSpan(7):createText(" " .. Helper.modQualities[categoryQuality].nonetext, { color = Helper.modQualities[categoryQuality].color })
		end
	end
end

function menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, moddata, hasinstalledmod, installedmodware, isgroup)
	local isexpanded = menu.isModSlotExpanded(type, slot .. moddata.ware)
	-- mod name
	local propertymodname = ffi.string(C.GetEquipmentModPropertyName(moddata.ware))
	local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
	row[1]:setBackgroundColSpan(1):createButton({ active = true }):setText(isexpanded and "-" or "+", { halign = "center" })
	row[1].handlers.onClick = function() return menu.expandModSlot(type, slot .. moddata.ware, row.index) end
	row[2]:setBackgroundColSpan(6):setColSpan(5):createText(" " .. GetWareData(moddata.ware, "shortname") .. ((propertymodname ~= "") and (" (" .. propertymodname .. ")") or ""), { color = Helper.modQualities[moddata.quality].color })
	row[7]:setColSpan(2):createText(ReadText(1001, 42) .. " " .. moddata.craftableamount, { halign = "right" })

	if isexpanded then
		-- Resources
		for _, resource in ipairs(moddata.resources) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			local color = (resource.data.amount < resource.data.needed) and Helper.color.grey or Helper.color.white
			-- name
			row[2]:setColSpan(5):createText("      " .. resource.data.name, { color = color })
			-- amount
			row[7]:setColSpan(2):createText(resource.data.amount .. " / " .. resource.data.needed, { halign = "right", color = color })
		end
		-- Effects
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
		row[2]:setColSpan(7):createText("   " .. ReadText(1001, 8034) .. ReadText(1001, 120))
		-- Property
		local moddef = C.GetEquipmentModInfo(moddata.ware)
		local propertytype = ffi.string(moddef.PropertyType)
		for i, property in ipairs(Helper.modProperties[modclass]) do
			if property.key == propertytype then
				local minvalue = moddef["MinValue" .. property.type]
				local mineffectcolor = Helper.color.white
				if minvalue > property.basevalue then
					mineffectcolor = property.pos_effect and Helper.color.green or Helper.color.red
				elseif minvalue < property.basevalue then
					mineffectcolor = property.pos_effect and Helper.color.red or Helper.color.green
				end

				local maxvalue = moddef["MaxValue" .. property.type]
				local maxeffectcolor = Helper.color.white
				if maxvalue > property.basevalue then
					maxeffectcolor = property.pos_effect and Helper.color.green or Helper.color.red
				elseif maxvalue < property.basevalue then
					maxeffectcolor = property.pos_effect and Helper.color.red or Helper.color.green
				end

				local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
				row[2]:setColSpan(4):createText("      " .. property.text, { font = Helper.standardFontBold })
				if property.pos_effect and (minvalue < maxvalue) or (minvalue > maxvalue) then
					row[6]:setColSpan(3):createText(property.eval2(minvalue, mineffectcolor, maxvalue, maxeffectcolor), { font = Helper.standardFontBold, halign = "right" })
				else
					row[6]:setColSpan(3):createText(property.eval2(maxvalue, maxeffectcolor, minvalue, mineffectcolor), { font = Helper.standardFontBold, halign = "right" })
				end
				break
			end
		end
		-- Bonus properties
		if moddef.BonusMax > 0 then
			local mouseovertext = ReadText(1026, 8005) .. ReadText(1001, 120)
			for n = 1, moddef.BonusMax do
				-- n < n_max:
				-- p_n = p^n * (1-p)
				-- n == n_max:
				-- p_n_max = p^n_max
				local probability = ((moddef.BonusChance ^ n) * ((n ~= moddef.BonusMax) and (1 - moddef.BonusChance) or 1))
				mouseovertext = mouseovertext .. "\n" .. string.format("%+d %s%s %4.1f%%", n, ReadText(1001, 6602), ReadText(1001, 120), probability * 100)
			end

			local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
			row[2]:setColSpan(5):createText("      " .. ((moddef.BonusMax == 1) and ReadText(1001, 8039) or string.format(ReadText(1001, 8040), moddef.BonusMax)), { mouseOverText = mouseovertext })
			row[7]:setColSpan(2):createText("???", { halign = "right" })
		end
		-- Install
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent, scaling = true })
		row[1]:setColSpan(4)
		local playermoney = GetPlayerMoney()
		local text = menu.isplayerowned and ReadText(1001, 4803) or string.format(ReadText(1001, 8043) .. " " .. ReadText(1001, 101), ConvertMoneyString(Helper.modQualities[moddata.quality].price * menu.moddingdiscounts.totalfactor, false, true, 0, true, false))
		local active = true
		local mouseovertext = ""
		local dismantle = false

		local hasmoney = menu.isplayerowned or (playermoney >= Helper.modQualities[moddata.quality].price * menu.moddingdiscounts.totalfactor)
		if hasinstalledmod then
			if (moddata.ware == installedmodware) then
				if (moddata.normalcraftableamount > 0) and hasmoney then
					text = menu.isplayerowned and ReadText(1001, 6608) or string.format(ReadText(1001, 6609) .. " " .. ReadText(1001, 101), ConvertMoneyString(Helper.modQualities[moddata.quality].price * menu.moddingdiscounts.totalfactor, false, true, 0, true, false))
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ReadText(1026, 6601)
					dismantle = true
				end
			else
				active = false
				if mouseovertext ~= "" then
					mouseovertext = mouseovertext .. "\n"
				end
				mouseovertext = mouseovertext .. ReadText(1026, 8006)
			end
		end
		if (not dismantle) and (moddata.craftableamount == 0) then
			active = false
			if mouseovertext ~= "" then
				mouseovertext = mouseovertext .. "\n"
			end
			mouseovertext = mouseovertext .. ReadText(1026, 8007)
		end
		if not hasmoney then
			active = false
			if mouseovertext ~= "" then
				mouseovertext = mouseovertext .. "\n"
			end
			mouseovertext = mouseovertext .. ReadText(1026, 8008)
		end
		if not dismantle then
			if mouseovertext ~= "" then
				mouseovertext = "\27R" .. mouseovertext
			end
		end
		row[5]:setColSpan(4):createButton({ active = active, mouseOverText = mouseovertext }):setText(text, { halign = "center" })
		if (type == "ship") or (type == "engine") then
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, menu.object, moddata.ware, Helper.modQualities[moddata.quality].price, nil, nil, dismantle) end
		elseif (type == "turret") and isgroup then
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, menu.object, moddata.ware, Helper.modQualities[moddata.quality].price, slotdata.context, slotdata.group, dismantle) end
		elseif type == "shield" then
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, menu.object, moddata.ware, Helper.modQualities[moddata.quality].price, slotdata.context, slotdata.group, dismantle) end
		else
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, slotdata.component, moddata.ware, Helper.modQualities[moddata.quality].price, nil, nil, dismantle) end
		end
	end
end

function menu.displayEmptySlots(frame)
	local ftable = frame:addTable(1, { tabOrder = 1, width = menu.slotData.width, height = 0, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = true, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })

	local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:createText(ReadText(1001, 7935), menu.headerTextProperties)

	row = ftable:addRow(false, { scaling = true, bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 8013))

	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil
end

function menu.checkLicence(macro, rawicon, issoftware, rawmouseovertext)
	local haslicence = true
	local icon
	local overridecolor = Helper.color.white
	local mouseovertext = ""
	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		if macro ~= "" then
			local ware
			if issoftware then
				ware = macro
			else
				ware = GetMacroData(macro, "ware")
			end
			local tradelicence, isblueprintsaleonly, researchprecursors = GetWareData(ware, "tradelicence", "isblueprintsaleonly", "productionresearchprecursors")
			local alreadyinshoppinglist = false
			for i, entry in ipairs(menu.shoppinglist) do
				if i ~= menu.editingshoppinglist then
					if entry.macro == macro then
						alreadyinshoppinglist = true
					end
				end
			end

			if (not menu.isplayerowned) and isblueprintsaleonly then
				haslicence = false
				icon = "menu_locked"
				mouseovertext = ReadText(1026, 8019)
			elseif researchprecursors and (#researchprecursors > 0) then
				mouseovertext = ReadText(1026, 8023) .. " "
				local first = true
				for _, research in ipairs(researchprecursors) do
					if (not C.HasResearched(research)) or alreadyinshoppinglist then
						haslicence = false
						mouseovertext = mouseovertext .. (first and " " or "\n") .. "\27R" .. GetWareData(research, "name") .. "\27X"
					else
						mouseovertext = mouseovertext .. (first and " " or "\n") .. GetWareData(research, "name")
					end
				end
				icon = "gamestart_custom_research"
			else
				if tradelicence ~= "" then
					haslicence = HasLicence("player", tradelicence, menu.containerowner)
					local licenceinfo = ffi.new("LicenceInfo")
					if C.GetLicenceInfo(licenceinfo, menu.containerowner, tradelicence) then
						icon = ffi.string(licenceinfo.icon)
						if icon ~= "" then
							if not rawicon then
								icon = "\27[" .. icon .. "]"
							end
							mouseovertext = (rawmouseovertext and "" or (haslicence and "" or "\27R")) .. string.format(ReadText(1026, 8003), ffi.string(licenceinfo.name))
						end
					end
				end
			end
			if not haslicence then
				overridecolor = Helper.color.red
			end
		end
	end

	return haslicence, icon, overridecolor, mouseovertext
end

function menu.checkMod(type, component, isgroup)
	local hasmod, modicon = false, ""
	if component then
		if (type == "turret") and isgroup then
			local shieldgroup = ffi.new("ShieldGroup")
			local found = C.GetShieldGroup(shieldgroup, menu.object, component)
			if found then
				local buf = ffi.new("UIWeaponMod")
				hasmod = C.GetInstalledGroupedWeaponMod(menu.object, shieldgroup.context, shieldgroup.group, buf)
				if hasmod then
					modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
				end
			end
		elseif (type == "weapon") or (type == "turret") then
			local buf = ffi.new("UIWeaponMod")
			hasmod = C.GetInstalledWeaponMod(component, buf)
			if hasmod then
				modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
			end
		elseif type == "engine" then
			local buf = ffi.new("UIEngineMod")
			hasmod = C.GetInstalledEngineMod(menu.object, buf)
			if hasmod then
				modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
			end
		elseif type == "shield" then
			local shieldgroup = ffi.new("ShieldGroup")
			local found = C.GetShieldGroup(shieldgroup, menu.object, component)
			if found then
				local buf = ffi.new("UIShieldMod")
				hasmod = C.GetInstalledShieldMod(menu.object, shieldgroup.context, shieldgroup.group, buf)
				if hasmod then
					modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
				end
			end
		end
	end

	return hasmod, modicon
end

function menu.checkEquipment(removedEquipment, currentEquipment, newEquipment, repairedEquipment, data, object)
	local canequip = true
	if menu.mode == "upgrade" then
		if not menu.isReadOnly then
			canequip = C.CanContainerEquipShip(menu.container, object or menu.object)
		end
	end
	local hasupgrades, hasrepairs = false, false
	local objectEquipment = {
		removed = {},
		current = {},
		new = {},
		repaired = {},
	}

	local groups   = data and data.groups   or menu.groups
	local slots    = data and data.slots    or menu.slots
	local ammo     = data and data.ammo     or menu.ammo
	local software = data and data.software or menu.software
	-- Equipment
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		local upgradeplanslots = menu.upgradeplan[upgradetype.type]
		local first = true
		for slot, macro in pairs(upgradeplanslots) do
			if first or (not upgradetype.mergeslots) then
				first = false
				if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
					local data = macro
					local oldslotdata = groups[slot][upgradetype.grouptype]

					if canequip then
						if data.macro ~= "" then
							local i = menu.findUpgradeMacro(upgradetype.grouptype, data.macro)
							if not i then
								break
							end
							local upgradeware = menu.upgradewares[upgradetype.grouptype][i]

							if oldslotdata.currentmacro ~= "" then
								local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
								if not j then
									break
								end
								local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

								if data.macro == oldslotdata.currentmacro then
									if upgradetype.mergeslots then
										menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count))
									else
										if oldslotdata.count < data.count then
											menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, oldslotdata.count)
											menu.insertWare(newEquipment, objectEquipment.new, upgradetype.grouptype, upgradeware.ware, data.count - oldslotdata.count, "normal")
											hasupgrades = true
										elseif oldslotdata.count > data.count then
											menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, data.count)
											menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.grouptype, upgradeware.ware, oldslotdata.count - data.count, "normal")
											hasupgrades = true
										else
											menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count))
										end
									end
								else
									menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.grouptype, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or oldslotdata.count), "normal")
									menu.insertWare(newEquipment, objectEquipment.new, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count), "normal")
									hasupgrades = true
								end
							else
								menu.insertWare(newEquipment, objectEquipment.new, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count), "normal")
								hasupgrades = true
							end
						elseif oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

							menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.grouptype, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or oldslotdata.count), "normal")
							hasupgrades = true
						end
					else
						if oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

							menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or oldslotdata.count), "normal")
						end
					end
				elseif (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					local data = macro
					local oldslotdata = slots[upgradetype.type][slot]
					if oldslotdata == nil then
						-- for catching a rare bug
						print(upgradetype.type, slot)
						for k, v in pairs(slots[upgradetype.type]) do
							print(k .. ": " .. tostring(v))
						end
					end
					if canequip then
						if data.macro ~= "" then
							local i = menu.findUpgradeMacro(upgradetype.type, data.macro)
							if not i then
								break
							end
							local upgradeware = menu.upgradewares[upgradetype.type][i]

							if oldslotdata.currentmacro ~= "" then
								local j = menu.findUpgradeMacro(upgradetype.type, oldslotdata.currentmacro)
								if not j then
									break
								end
								local oldupgradeware = menu.upgradewares[upgradetype.type][j]

								if data.macro == oldslotdata.currentmacro then
									menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.type, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1))
								else
									menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.type, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
									menu.insertWare(newEquipment, objectEquipment.new, upgradetype.type, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
									hasupgrades = true
								end
							else
								menu.insertWare(newEquipment, objectEquipment.new, upgradetype.type, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
								hasupgrades = true
							end
						elseif oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.type, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.type][j]

							menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.type, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
							hasupgrades = true
						end
					else
						if oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

							menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.type, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
						end
					end
				elseif upgradetype.supertype == "ammo" then
					if ammo[upgradetype.type][slot] then
						local current = ammo[upgradetype.type][slot]
						local new = macro
						local macro = slot
						if (current > 0) or (current ~= new) then
							local j = menu.findUpgradeMacro(upgradetype.type, macro)
							if not j then
								break
							end
							local upgradeware = menu.upgradewares[upgradetype.type][j]

							if current < new then
								if current > 0 then
									menu.insertWare(currentEquipment, objectEquipment.current, "consumables", upgradeware.ware, current)
								end
								menu.insertWare(newEquipment, objectEquipment.new, "consumables", upgradeware.ware, new - current, "normal")
								hasupgrades = true
							elseif current > new then
								if new > 0 then
									menu.insertWare(currentEquipment, objectEquipment.current, "consumables", upgradeware.ware, new)
								end
								menu.insertWare(removedEquipment, objectEquipment.removed, "consumables", upgradeware.ware, current - new, "normal")
								hasupgrades = true
							elseif current > 0 then
								menu.insertWare(currentEquipment, objectEquipment.current, "consumables", upgradeware.ware, current)
							end
						end
					end
				elseif upgradetype.supertype == "software" then
					local newware = macro
					local oldware = software[upgradetype.type][slot].currentsoftware
					if oldware ~= newware then
						if oldware ~= "" then
							menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.supertype, oldware, 1, "software")
							hasupgrades = true
						end
						if newware ~= "" then
							menu.insertWare(newEquipment, objectEquipment.new, upgradetype.supertype, newware, 1, "software")
							hasupgrades = true
						end
					elseif newware ~= "" then
						menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.supertype, newware, 1)
					end
				end
			end
		end
	end

	-- Crew
	if menu.objectgroup == nil then
		if menu.crew.hired > 0 then
			local color = Helper.color.green

			menu.insertWare(newEquipment, objectEquipment.new, "crew", menu.crew.ware, menu.crew.hired, "crew")
			hasupgrades = true
			if menu.crew.total - #menu.crew.fired > 0 then
				menu.insertWare(currentEquipment, objectEquipment.current, "crew", menu.crew.ware, menu.crew.total - #menu.crew.fired)
			end
			if #menu.crew.fired > 0 then
				menu.insertWare(removedEquipment, objectEquipment.removed, "crew", menu.crew.ware, #menu.crew.fired, "crew")
				hasupgrades = true
			end
		elseif #menu.crew.fired > 0 then
			menu.insertWare(removedEquipment, objectEquipment.removed, "crew", menu.crew.ware, #menu.crew.fired, "crew")
			hasupgrades = true
			if (menu.crew.total - #menu.crew.fired) > 0 then
				menu.insertWare(currentEquipment, objectEquipment.current, "crew", menu.crew.ware, menu.crew.total - #menu.crew.fired)
			end
		elseif menu.crew.total > 0 then
			menu.insertWare(currentEquipment, objectEquipment.current, "crew", menu.crew.ware, menu.crew.total)
		end
	end

	-- Repair
	local objectidstring = tostring(object or menu.object)
	if menu.repairplan and menu.repairplan[objectidstring] then
		for componentidstring in pairs(menu.repairplan[objectidstring]) do
			if componentidstring ~= "processed" then
				menu.insertComponent(repairedEquipment, objectEquipment.repaired, componentidstring, "normal")
				hasrepairs = true
			end
		end
	end

	local totalprice = 0
	local totalcrewprice = 0
	if not menu.isplayerowned then
		if menu.object == 0 then
			if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				totalprice = totalprice + tonumber(C.GetBuildWarePrice(menu.container, GetMacroData(menu.macro, "ware") or ""))
			end
		end
		for _, data in pairs(removedEquipment) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					totalcrewprice = totalcrewprice - entry.amount * entry.price
				else
					totalprice = totalprice - entry.amount * entry.price
				end
			end
		end
		for _, data in pairs(newEquipment) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					totalcrewprice = totalcrewprice + entry.amount * entry.price
				else
					totalprice = totalprice + entry.amount * entry.price
				end
			end
		end
		for _, entry in ipairs(repairedEquipment) do
			totalprice = totalprice + entry.price
		end
	end
	local objectprice = 0
	local objectcrewprice = 0
	if not menu.isplayerowned then
		if menu.object == 0 then
			if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				objectprice = objectprice + tonumber(C.GetBuildWarePrice(menu.container, GetMacroData(menu.macro, "ware") or ""))
			end
		end
		for _, data in pairs(objectEquipment.removed) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					objectcrewprice = objectcrewprice - entry.amount * entry.price
				else
					objectprice = objectprice - entry.amount * entry.price
				end
			end
		end
		for _, data in pairs(objectEquipment.new) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					objectcrewprice = objectcrewprice + entry.amount * entry.price
				else
					objectprice = objectprice + entry.amount * entry.price
				end
			end
		end
		for _, entry in ipairs(objectEquipment.repaired) do
			objectprice = objectprice + entry.price
		end
	end

	return RoundTotalTradePrice(totalprice), RoundTotalTradePrice(totalcrewprice), hasupgrades, hasrepairs, RoundTotalTradePrice(objectprice), RoundTotalTradePrice(objectcrewprice)
end

function menu.getAddedPeopleFromBuildTask(container, taskid)
	local result = 0

	local numcrewentries = C.GetNumBuildTaskCrewTransferInfo(container, taskid)
	local crewtransferinfo = ffi.new("CrewTransferInfo2")
	crewtransferinfo.numadded = numcrewentries.numadded
	crewtransferinfo.added = Helper.ffiNewHelper("CrewTransferContainer2[?]", numcrewentries.numadded)
	crewtransferinfo.numremoved = numcrewentries.numremoved
	crewtransferinfo.removed = Helper.ffiNewHelper("CrewTransferContainer2[?]", numcrewentries.numremoved)
	crewtransferinfo.numtransferred = numcrewentries.numtransferred
	crewtransferinfo.transferred = Helper.ffiNewHelper("CrewTransferContainer2[?]", numcrewentries.numtransferred)

	C.GetBuildTaskCrewTransferInfo2(crewtransferinfo, container, taskid)
	for j = 0, crewtransferinfo.numadded - 1 do
		result = result + crewtransferinfo.added[j].amount
	end

	return result
end

function menu.warningColor(normalcolor)
	local color = normalcolor

	local curtime = getElapsedTime()
	if menu.warningShown and (curtime < menu.warningShown + 2) then
		-- number between 0 and 1, duration 1s
		local x = curtime % 1

		normalcolor = normalcolor or Helper.color.orange
		overridecolor = Helper.color.white
		color = {
			r = (1 - x) * overridecolor.r + x * normalcolor.r,
			g = (1 - x) * overridecolor.g + x * normalcolor.g,
			b = (1 - x) * overridecolor.b + x * normalcolor.b,
			a = (1 - x) * overridecolor.a + x * normalcolor.a,
		}
	end
	return color
end

function menu.displayPlan(frame)
	-- errors & warnings
	menu.criticalerrors = {}
	menu.errors = {}
	menu.warnings = {}

	if (menu.mode == "purchase") or (menu.mode == "upgrade") then
		if menu.container and ((menu.object ~= 0) or (menu.macro ~= "")) then
			if not C.HasSuitableBuildModule(menu.container, menu.object, menu.macro) then
				menu.errors[4] = menu.objectgroup and ReadText(1001, 8572) or ReadText(1001, 8563)
			end
		end
	end

	if (menu.mode == "purchase") and (menu.macro ~= "") then
		if not menu.validLicence then
			local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(menu.macro, true, nil, true)
			menu.errors[2] = mouseovertext
		end
		if not menu.validLoadoutPossible then
			menu.criticalerrors[5] = ReadText(1001, 8528)
		end
	end

	if ((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0) then
		if menu.tasks[tostring(menu.object)] then
			menu.errors[3] = function (_, notime)
				local timestring
				if (not notime) and (type(menu.tasks[tostring(menu.object)]) == "userdata") then
					timestring = "--:--"
					local buildtask = ConvertIDTo64Bit(menu.tasks[tostring(menu.object)])
					local buildtaskinfo = C.GetBuildTaskInfo(buildtask)
					if buildtaskinfo.buildingcontainer ~= 0 then
						if (buildtaskinfo.queueposition == 0) and (buildtaskinfo.buildercomponent ~= 0) then
							timestring = ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(buildtaskinfo.buildercomponent), "%h:%M:%S")
						end
					end
				end
				return ReadText(1001, 8521) .. (timestring and (" (" .. ReadText(1001, 2923) .. ReadText(1001, 120) .. " " .. timestring .. ")") or "")
			end
		end
	end

	for _, upgradetype in ipairs(Helper.upgradetypes) do
		local slots = menu.upgradeplan[upgradetype.type]
		for slot, macro in pairs(slots) do
			-- current allowempty warning
			local allowempty
			if upgradetype.supertype == "macro" then
				local data = macro
				if data.macro == "" then
					allowempty = upgradetype.allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, slot))
				end
			elseif upgradetype.supertype == "virtualmacro" then
				local data = macro
				if data.macro == "" then
					allowempty = upgradetype.allowempty
				end
			else
				if macro == "" then
					allowempty = upgradetype.allowempty
				end
			end
			if allowempty == false then
				if (menu.mode == "customgamestart") or (menu.mode == "comparison") then
					menu.criticalerrors[2] = ReadText(1001, 8020)
				else
					menu.errors[1] = menu.objectgroup and ReadText(1001, 8568) or ReadText(1001, 8020)
				end
				break
			end
		end
		-- missing software
		if upgradetype.supertype == "software" then
			if menu.software[upgradetype.type] then
				for slot, slotdata in ipairs(menu.software[upgradetype.type]) do
					if #slotdata.possiblesoftware > 0 then
						if (slotdata.defaultsoftware ~= 0) and (menu.upgradeplan[upgradetype.type][slot] == "") then
							if (menu.mode == "customgamestart") or (menu.mode == "comparison") then
								menu.criticalerrors[2] = ReadText(1001, 8020)
							else
								menu.errors[1] = menu.objectgroup and ReadText(1001, 8568) or ReadText(1001, 8020)
							end
							break
						end
					end
				end
			end
		end
		-- missing captain
		if (menu.mode == "purchase") and (not menu.captainSelected) then
			menu.errors[1] = ReadText(1001, 8020)
		end
		-- current ammo warning
		if upgradetype.supertype == "ammo" then
			local total, capacity = menu.getAmmoUsage(upgradetype.type)
			if total > capacity then
				menu.warnings[2] = menu.objectgroup and ReadText(1001, 8569) or ReadText(1001, 8021)
			end
		end
	end
	-- current crew warning
	if #menu.crew.unassigned > 0 then
		menu.warnings[3] = ReadText(1001, 8022)
	end
	-- resource warning
	if menu.mode == "purchase" then
		local considerCurrent = false
		if (menu.macro ~= "") and (menu.editingshoppinglist == nil) then
			considerCurrent = true
		end
		local numorders = #menu.shoppinglist + (considerCurrent and 1 or 0)
		local buildorders = ffi.new("UIBuildOrderList[?]", numorders)
		for i, entry in ipairs(menu.shoppinglist) do
			buildorders[i - 1].shipid = 0
			buildorders[i - 1].macroname = Helper.ffiNewString(entry.macro)
			buildorders[i - 1].loadout = Helper.callLoadoutFunction(entry.upgradeplan, nil, function (loadout, _) return loadout end, false)
			buildorders[i - 1].amount = entry.amount
		end
		if considerCurrent then
			local index = #menu.shoppinglist
			buildorders[index].shipid = 0
			buildorders[index].macroname = Helper.ffiNewString(menu.macro)
			buildorders[index].loadout = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return loadout end, false)
			buildorders[index].amount = 1
		end

		menu.missingResources = {}
		if not menu.errors[4] then
			local n = C.GetNumMissingBuildResources2(menu.container, buildorders, numorders, true)
			local buf = ffi.new("UIWareInfo[?]", n)
			n = C.GetMissingBuildResources(buf, n)
			for i = 0, n - 1 do
				table.insert(menu.missingResources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		if (not menu.isReadOnly) and (#menu.missingResources > 0) then
			menu.warnings[4] = ReadText(1001, 8018)
		end
	elseif menu.mode == "upgrade" then
		local considerCurrent = false
		if (menu.object ~= 0) and (menu.editingshoppinglist == nil) then
			considerCurrent = true
		end
		local numorders = considerCurrent and 1 or 0
		for i, entry in ipairs(menu.shoppinglist) do
			if entry.objectgroup then
				local groupentry = menu.shipgroups[entry.objectgroup]
				numorders = numorders + #groupentry.ships
			else
				numorders = numorders + 1
			end
		end
		local buildorders = ffi.new("UIBuildOrderList[?]", numorders)
		local i = 0
		for _, entry in ipairs(menu.shoppinglist) do
			if entry.objectgroup then
				local groupentry = menu.shipgroups[entry.objectgroup]
				for _, ship in ipairs(groupentry.ships) do
					buildorders[i].shipid = ship.ship
					buildorders[i].macroname = ""
					buildorders[i].loadout = Helper.callLoadoutFunction(entry.upgradeplan, nil, function (loadout, _) return loadout end, false)
					buildorders[i].amount = 1
					i = i + 1
				end
			else
				buildorders[i].shipid = entry.object
				buildorders[i].macroname = ""
				buildorders[i].loadout = Helper.callLoadoutFunction(entry.upgradeplan, nil, function (loadout, _) return loadout end, false)
				buildorders[i].amount = entry.amount
				i = i + 1
			end
		end
		if considerCurrent then
			local index = numorders - 1
			buildorders[index].shipid = menu.object
			buildorders[index].macroname = ""
			buildorders[index].loadout = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return loadout end, false)
			buildorders[index].amount = 1
		end

		menu.missingResources = {}
		if menu.container then
			local n = C.GetNumMissingLoadoutResources2(menu.container, buildorders, numorders, true)
			local buf = ffi.new("UIWareInfo[?]", n)
			n = C.GetMissingLoadoutResources(buf, n)
			for i = 0, n - 1 do
				table.insert(menu.missingResources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		if (not menu.isReadOnly) and (#menu.missingResources > 0) then
			menu.warnings[4] = ReadText(1001, 8018)
		end
	end

	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		menu.addedCrewByPlayerBuildTasks = 0
		local constructions = {}
		-- current builds
		local n = C.GetNumBuildTasks(menu.container, 0, true, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.container, 0, true, true)
		menu.buildInProgress = n
		for i = 0, n - 1 do
			menu.addedCrewByPlayerBuildTasks = menu.addedCrewByPlayerBuildTasks + menu.getAddedPeopleFromBuildTask(menu.container, buf[i].id)
		end
		-- other builds
		n = C.GetNumBuildTasks(menu.container, 0, false, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.container, 0, false, true)
		for i = 0, n - 1 do
			local factionid = ffi.string(buf[i].factionid)
			table.insert(constructions, { id = buf[i].id, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, inprogress = false })
			if factionid == "player" then
				menu.addedCrewByPlayerBuildTasks = menu.addedCrewByPlayerBuildTasks + menu.getAddedPeopleFromBuildTask(menu.container, buf[i].id)
			end
		end
		menu.queuePosition = #constructions + 1
		for i, construction in ipairs(constructions) do
			if (not construction.inprogress) and (construction.factionid ~= "player") then
				menu.queuePosition = i
				break
			end
		end
		Helper.ffiClearNewHelper()
	end

	menu.shoppinglisttotal = 0
	menu.shoppinglistrefund = 0
	menu.timetotal = 0
	for i, entry in ipairs(menu.shoppinglist) do
		entry.color = menu.warnings[4] and Helper.color.orange or Helper.color.white
		if i ~= menu.editingshoppinglist then
			local object = entry.object
			local groupamount = 1
			if entry.objectgroup then
				local groupentry = menu.shipgroups[entry.objectgroup]
				object = groupentry.ships[1].ship
				groupamount = #groupentry.ships
			end
			menu.timetotal = menu.timetotal + math.ceil(entry.amount * groupamount / C.GetNumSuitableBuildProcessors(menu.container, object, entry.macro)) * entry.duration
			menu.shoppinglisttotal = menu.shoppinglisttotal + entry.amount * (entry.price + entry.crewprice)
			if (entry.price + entry.crewprice) < 0 then
				menu.shoppinglistrefund = menu.shoppinglistrefund + entry.amount * (entry.price + entry.crewprice)
			end
			-- ammo error
			if entry.warnings[2] then
				entry.color = Helper.color.red
				menu.criticalerrors[3] = ReadText(1001, 8016)
			end
			-- crew error
			if #entry.crew.unassigned > 0 then
				entry.color = Helper.color.red
				menu.criticalerrors[4] = ReadText(1001, 8017)
			end
		end
		for _, upgradetype in ipairs(Helper.upgradetypes) do
			local slots = entry.upgradeplan[upgradetype.type]
			for slot, macro in pairs(slots) do
				-- allowempty error
				local allowempty
				if (upgradetype.supertype == "macro") and (upgradetype.supertype == "virtualmacro") then
					local data = macro
					if data.macro == "" then
						allowempty = upgradetype.allowempty and (not C.IsSlotMandatory(entry.object, 0, entry.macro, false, upgradetype.type, slot))
					end
				else
					if macro == "" then
						allowempty = upgradetype.allowempty
					end
				end
				if allowempty == false then
					if i ~= menu.editingshoppinglist then
						entry.color = Helper.color.red
						menu.criticalerrors[2] = ReadText(1001, 8015)
					end
					break
				end
			end
		end
	end
	-- money error
	local playerMoney = GetPlayerMoney()
	if (not menu.isplayerowned) and (menu.shoppinglisttotal - menu.shoppinglistrefund > playerMoney) then
		menu.criticalerrors[1] = ReadText(1001, 8014)
		if menu.shoppinglistrefund < 0 then
			menu.criticalerrors[1] = menu.criticalerrors[1] .. " (" .. string.format(ReadText(1001, 8547), ConvertMoneyString(menu.shoppinglisttotal - menu.shoppinglistrefund, false, true, 0, true, false) .. " " .. ReadText(1001, 101)) .. ")"
		end
	end
	-- selling parts, not getting money immediately
	if menu.shoppinglistrefund < 0 then
		menu.warnings[6] = ReadText(1001, 8546)
	end

	Helper.ffiClearNewHelper()
	if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		-- edit warning
		if (menu.macro ~= "") or (menu.object ~= 0) then
			menu.warnings[5] = menu.objectgroup and ReadText(1001, 8567) or ReadText(1001, 8019)
		end
	end

	-- BUTTONS
	local buttontable = frame:addTable(2, { tabOrder = 6, width = menu.planData.width, height = Helper.scaleY(Helper.standardButtonHeight), x = menu.planData.offsetX, y = 0, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
	local row

	local infoCount = 0
	local visibleHeight

	if not menu.isReadOnly then
		if menu.mode == "comparison" then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(2):createText(ReadText(1001, 3701), menu.headerTextProperties)
		elseif menu.mode == "customgamestart" then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(2):createText(ReadText(1001, 2302), menu.headerTextProperties)

			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9923))
			row[2]:createText(ConvertMoneyString((menu.macro ~= "") and tonumber(Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.GetShipValue(menu.macro, loadout) end, nil, "UILoadout2")) or 0, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })

			if not menu.modeparam.creative then
				local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 9929))

				local value = 0
				if menu.macro ~= "" then
					value = value + tonumber(C.GetCustomGameStartShipPeopleValue2(menu.modeparam.gamestartid, menu.macro, menu.customgamestartpeopledef, menu.customgamestartpeoplefillpercentage))

					if next(menu.customgamestartpilot) then
						local skills = {}
						for skill, value in pairs(menu.customgamestartpilot.skills or {}) do
							table.insert(skills, { id = skill, value = value })
						end
						local buf = ffi.new("CustomGameStartPersonEntry")
						buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
						buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
						buf.numskills = #skills
						buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
						for i, entry in ipairs(skills) do
							buf.skills[i - 1].id = Helper.ffiNewString(entry.id)
							buf.skills[i - 1].value = entry.value
						end
						value = value + tonumber(C.GetCustomGameStartShipPersonValue(menu.modeparam.gamestartid, buf))
					end
				end

				row[2]:createText(ConvertIntegerString(value, true, 0, true)  .. " " .. Helper.convertColorToText(Helper.color.red) .. "\27[gamestart_custom_people]", { halign = "right" })
			end
		else
			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(2):createText(menu.container and string.format(ReadText(1001, 8531), (menu.isplayerowned and Helper.convertColorToText(Helper.color.green) or "") .. ffi.string(C.GetComponentName(menu.container))) or ReadText(1001, 8012), menu.headerTextProperties)

			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 8522))
			row[2]:createText(menu.buildInProgress, { halign = "right" })
			infoCount = infoCount + 1

			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 8523))
			row[2]:createText(menu.queuePosition - 1, { halign = "right" })
			infoCount = infoCount + 1

			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 8509))
			row[2]:createText("#" .. menu.queuePosition .. " - " .. (menu.warnings[4] and "--:--" or ConvertTimeString(menu.timetotal, (menu.timetotal >= 3600) and "%h:%M:%S" or "%M:%S")), { halign = "right" })
			infoCount = infoCount + 1

			if not menu.isplayerowned then
				local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 2927))
				row[2]:createText(ConvertMoneyString(menu.shoppinglisttotal, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
				infoCount = infoCount + 1

				local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 2003))
				row[2]:createText(function () return ConvertMoneyString(GetPlayerMoney(), false, true, 0, true, false) .. " " .. ReadText(1001, 101) end, { halign = "right" })
				infoCount = infoCount + 1

				local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 2004))
				row[2]:createText(function () return ConvertMoneyString(GetPlayerMoney() - menu.shoppinglisttotal, false, true, 0, true, false) .. " " .. ReadText(1001, 101) end, { halign = "right", color = function () return GetPlayerMoney() - menu.shoppinglisttotal < 0 and Helper.color.red or Helper.color.white end })
				infoCount = infoCount + 1
			end
		end
	end

	if menu.isReadOnly then
		row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[2]:createButton({ }):setText(ReadText(1001, 8035), { halign = "center" })
		row[2].handlers.onClick = function () return menu.closeMenu("back") end
	else
		row = buttontable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		local button = row[1]:createButton({ active = ((#menu.shoppinglist > (menu.editingshoppinglist and 1 or 0)) or (menu.mode == "customgamestart") or ((menu.mode == "comparison") and (menu.macro ~= ""))) and (next(menu.criticalerrors) == nil) }):setText(((menu.mode == "customgamestart") or (menu.mode == "comparison")) and ReadText(1001, 2821) or ReadText(1001, 8011), { halign = "center" })
		if (menu.object == 0) and (menu.macro == "") then
			button:setHotkey("INPUT_STATE_DETAILMONITOR_X", { displayIcon = true })
		end
		row[1].handlers.onClick = menu.buttonConfirm
		row[2]:createButton({  }):setText(((menu.mode == "customgamestart") or (menu.mode == "comparison")) and ReadText(1001, 64) or ReadText(1001, 8010), { halign = "center" })
		row[2].handlers.onClick = function () return menu.closeMenu("back") end
	end
	buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - menu.planData.offsetY

	-- STATUS
	local statustable, resourcetable
	if not menu.isReadOnly then
		if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			if #menu.missingResources > 0 then
				resourcetable = frame:addTable(2, { tabOrder = 8, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = true, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })

				local row = resourcetable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(2):createText(ReadText(1001, 8046), menu.headerWarningTextProperties)
				-- disable blink effect
				row[1].properties.color = Helper.color.orange

				local visibleHeight
				for i, entry in ipairs(menu.missingResources) do
					local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:createText(GetWareData(entry.ware, "name"), { color = Helper.color.orange })
					row[2]:createText(ConvertIntegerString(entry.amount, true, 0, true), { halign = "right", color = Helper.color.orange })
					if i == 5 then
						visibleHeight = resourcetable:getFullHeight()
					end
				end

				if visibleHeight then
					resourcetable.properties.maxVisibleHeight = visibleHeight
				else
					resourcetable.properties.maxVisibleHeight = resourcetable:getFullHeight()
				end
				resourcetable.properties.y = buttontable.properties.y - resourcetable:getVisibleHeight() - 2 * Helper.borderSize
			end
		end

		if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
			if not menu.warningShown then
				PlaySound("ui_notification_pickup_fail")
			end
			menu.warningShown = menu.warningShown or getElapsedTime()
			local iconfactor = 1.6
			local iconsize = iconfactor * Helper.headerRow1Height

			statustable = frame:addTable(4, { tabOrder = 7, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = false, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			statustable:setColWidth(1, iconsize)
			statustable:setColWidth(4, iconsize)

			local row = statustable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setBackgroundColSpan(4):createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
			row[1].properties.fontsize = iconfactor * row[1].properties.fontsize
			row[1].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))
			row[2]:setColSpan(2):createText(ReadText(1001, 8342), menu.headerWarningTextProperties)
			row[4]:createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
			row[4].properties.fontsize = iconfactor * row[4].properties.fontsize
			row[4].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))

			for _, errorentry in Helper.orderedPairs(menu.criticalerrors) do
				row = statustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(4):createText(errorentry, { color = Helper.color.red, wordwrap = true })
				infoCount = infoCount + 1
				if infoCount == config.maxStatusRowCount then
					visibleHeight = statustable:getFullHeight()
				end
			end
			for _, errorentry in Helper.orderedPairs(menu.errors) do
				row = statustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(4):createText(errorentry, { color = Helper.color.red, wordwrap = true })
				infoCount = infoCount + 1
				if infoCount == config.maxStatusRowCount then
					visibleHeight = statustable:getFullHeight()
				end
			end
			for _, warningentry in Helper.orderedPairs(menu.warnings) do
				row = statustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(4):createText(warningentry, { color = Helper.color.orange, wordwrap = true })
				infoCount = infoCount + 1
				if infoCount == config.maxStatusRowCount then
					visibleHeight = statustable:getFullHeight()
				end
			end

			if visibleHeight then
				statustable.properties.maxVisibleHeight = visibleHeight
			else
				statustable.properties.maxVisibleHeight = statustable:getFullHeight()
			end
			if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (#menu.missingResources > 0) then
				statustable.properties.y = resourcetable.properties.y - statustable:getVisibleHeight() - 2 * Helper.borderSize
			else
				statustable.properties.y = buttontable.properties.y - statustable:getVisibleHeight() - 2 * Helper.borderSize
			end
		else
			menu.warningShown = nil
		end
	end

	-- SHOPPINGLIST
	local maxVisibleHeight = buttontable.properties.y - menu.planData.offsetY
	if (not menu.isReadOnly) then
		if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
			maxVisibleHeight = statustable.properties.y - menu.planData.offsetY
		elseif (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (#menu.missingResources > 0) then
			maxVisibleHeight = resourcetable.properties.y - menu.planData.offsetY
		end
	end
	local ftable = frame:addTable(5, { tabOrder = 3, width = menu.planData.width, maxVisibleHeight = maxVisibleHeight, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
	local iconwidth = 5 * Helper.scaleY(Helper.standardTextHeight) + 4 * Helper.borderSize
	local dropdownWidth = 0.2 * menu.planData.width
	local valueWidth = (menu.planData.width - iconwidth - Helper.borderSize) / 2
	ftable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
	ftable:setColWidth(2, iconwidth - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidth(4, valueWidth - dropdownWidth - Helper.borderSize, false)
	ftable:setColWidth(5, dropdownWidth, false)

	-- currently editing
	local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(5):createText(menu.isReadOnly and ReadText(1001, 8045) or ReadText(1001, 8005), menu.headerTextProperties)

	if (menu.object ~= 0) or (menu.macro ~= "") then
		local removedEquipment = {}
		local currentEquipment = {}
		local newEquipment = {}
		local repairedEquipment = {}
		if menu.objectgroup then
			for i = 1, #menu.objectgroup.ships do
				local total, crewtotal, hasupgrades, hasrepairs, objecttotal, objectcrewtotal = menu.checkEquipment(removedEquipment, currentEquipment, newEquipment, repairedEquipment, menu.objectgroup.shipdata[i], menu.objectgroup.ships[i].ship)
				menu.objectgroup.states[i] = {
					hasupgrades = hasupgrades,
					hasrepairs = hasrepairs,
					price = objecttotal,
					crewprice = objectcrewtotal,
				}
				-- menu.checkEquipment() sums up the value of all changes
				menu.total = total
				menu.crewtotal = crewtotal
			end
		else
			menu.total, menu.crewtotal = menu.checkEquipment(removedEquipment, currentEquipment, newEquipment, repairedEquipment)
		end

		local buildorder = ffi.new("UIBuildOrderList")
		buildorder.shipid = menu.object
		buildorder.macroname = Helper.ffiNewString(menu.macro)
		buildorder.loadout = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return loadout end)
		buildorder.amount = 1
		if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			menu.duration = (not menu.errors[4]) and C.GetBuildDuration(menu.container, buildorder) or 0
		end

		local colspan = 2
		if menu.isReadOnly then
			colspan = 4
		end

		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		local name = ""
		if menu.object ~= 0 then
			name = ffi.string(C.GetComponentName(menu.object))
		else
			name = GetMacroData(menu.macro, "name")
		end

		if menu.objectgroup then
			row[1]:setColSpan(colspan + 1):createText(#menu.objectgroup.ships .. ReadText(1001, 42) .. " " .. GetMacroData(menu.objectgroup.macro, "name"))
		elseif (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			menu.customShipNameEditBox = row[1]:setColSpan(colspan + 1):createEditBox({ description = ReadText(1001, 8537), height = Helper.standardTextHeight }):setText((menu.customshipname ~= "") and menu.customshipname or name, { halign = "left" })
			row[1].handlers.onTextChanged = menu.editboxCustomShipName
			row[1].handlers.onEditBoxDeactivated = menu.editboxCustomShipNameDeactivated

			if not menu.isplayerowned then
				row[4]:setColSpan(2):createText(ConvertMoneyString(menu.total + menu.crewtotal, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
			end

			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(function () return menu.useloadoutname end, { active = menu.loadoutName ~= "" })
			row[1].handlers.onClick = menu.checkboxLoadoutName
			row[2]:setColSpan(4):createText(function () return ReadText(1001, 8536) .. ((menu.loadoutName ~= "") and (" - " .. menu.getCustomShipName()) or "") end, { color = function () return (menu.loadoutName ~= "") and Helper.color.white or Helper.color.grey end })

			local row = ftable:addRow(false, { bgColor = Helper.color.unselectable })
			row[1]:setBackgroundColSpan(5)
			if (next(removedEquipment) == nil) and (next(newEquipment) == nil) and (#repairedEquipment > 0) then
				row[2]:setColSpan(2):createText(ReadText(1001, 8535))
			else
				row[2]:setColSpan(2):createText(ReadText(1001, 8508))
			end
			row[4]:setColSpan(2):createText((menu.warnings[4] and "--:--" or ConvertTimeString(menu.duration, (menu.duration >= 3600) and "%h:%M:%S" or "%M:%S")), { halign = "right" })
		else
			row[1]:setColSpan(colspan + 1):createText((menu.customshipname ~= "") and menu.customshipname or name)
		end

		if next(removedEquipment) or next(currentEquipment) or next(newEquipment) or (#repairedEquipment > 0) or (menu.object == 0) then
			-- chassis
			if menu.object == 0 then
				local ware = GetMacroData(menu.macro, "ware")
				local isextended = menu.isUpgradeExpanded(menu.currentIdx, ware, "chassis")
				local name = GetWareData(ware, "name")
				local resources = menu.getBuildResources(ware)

				row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				if (resources ~= nil) and (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
					row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, ware, "chassis", row.index) end
				end
				row[2]:setColSpan(colspan):createText(ReadText(1001, 8008), { color = Helper.color.green })
				if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
					row[4]:setColSpan(2):createText(ConvertMoneyString(tonumber(C.GetBuildWarePrice(menu.container, ware or "")), false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Helper.color.green })
				end
				if resources and (#resources > 0) and isextended then
					menu.displayUpgradeResources(ftable, resources, 1)
				end
			end
			for _, entry in ipairs(config.leftBar) do
				if removedEquipment[entry.mode] or currentEquipment[entry.mode] or newEquipment[entry.mode] then
					row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(4):createText(entry.name,{ font = Helper.standardFontBold, titleColor = Helper.defaultSimpleBackgroundColor })
				end
				-- removed
				if removedEquipment[entry.mode] then
					for _, entry in ipairs(removedEquipment[entry.mode]) do
						local isextended = menu.isUpgradeExpanded(menu.currentIdx, entry.ware, "removed")
						local name = GetWareData(entry.ware, "name")
						local resources = menu.getBuildResources(entry.ware)
						local mouseOverText = (name or "") .. "\n" .. string.format(ReadText(1026, 8010), ConvertMoneyString(-entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101))
						row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						if (resources ~= nil) and (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
							row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
							row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, entry.ware, "removed", row.index) end
						end
						row[2]:setColSpan(colspan):createText(entry.amount .. ReadText(1001, 42) .. " " .. (name or ""), { color = Helper.color.red, mouseOverText = mouseOverText })
						if entry.price and (entry.price > 0) and (not menu.isplayerowned) then
							row[4]:setColSpan(2):createText(ConvertMoneyString(-entry.amount * entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Helper.color.red, mouseOverText = mouseOverText })
						end
						if resources and (#resources > 0) and isextended then
							menu.displayUpgradeResources(ftable, resources, entry.amount)
						end
					end
				end
				-- current
				if currentEquipment[entry.mode] then
					for _, entry in ipairs(currentEquipment[entry.mode]) do
						local isextended = menu.isUpgradeExpanded(menu.currentIdx, entry.ware, "current")
						local name = GetWareData(entry.ware, "name")
						local resources = menu.getBuildResources(entry.ware)
						row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(colspan):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"), { mouseOverText = name })
						if resources and (#resources > 0) and isextended then
							menu.displayUpgradeResources(ftable, resources, entry.amount)
						end
					end
				end
				-- new
				if newEquipment[entry.mode] then
					for _, entry in ipairs(newEquipment[entry.mode]) do
						local isextended = menu.isUpgradeExpanded(menu.currentIdx, entry.ware, "new")
						local name = GetWareData(entry.ware, "name")
						local resources = menu.getBuildResources(entry.ware)
						local mouseOverText = (name or "") .. "\n" .. string.format(ReadText(1026, 8010), ConvertMoneyString(entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101))
						row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						if (resources ~= nil) and (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
							row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
							row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, entry.ware, "new", row.index) end
						end
						row[2]:setColSpan(colspan):createText(entry.amount .. ReadText(1001, 42) .. " " .. (name or ""), { color = Helper.color.green, mouseOverText = mouseOverText })
						if entry.price and (entry.price > 0) and (not menu.isplayerowned) then
							row[4]:setColSpan(2):createText(ConvertMoneyString(entry.amount * entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Helper.color.green, mouseOverText = mouseOverText })
						end
						if resources and (#resources > 0) and isextended then
							menu.displayUpgradeResources(ftable, resources, entry.amount)
						end
					end
				end
			end
			-- repaired
			if #repairedEquipment > 0 then
				row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(4):createText(ReadText(1001, 3000),{ font = Helper.standardFontBold, titleColor = Helper.defaultSimpleBackgroundColor })
			end
			for _, entry in ipairs(repairedEquipment) do
				local repaircomponent = ConvertStringTo64Bit(entry.component)
				local isextended = menu.isUpgradeExpanded(menu.currentIdx, repaircomponent, "repair")
				local name = ffi.string(C.GetComponentName(repaircomponent)) .. " (" .. ffi.string(C.GetObjectIDCode(repaircomponent)) .. ")"

				local resources = {}
				local n = C.GetNumRepairResources2(menu.container, menu.object, repaircomponent)
				local buf = ffi.new("UIWareInfo[?]", n)
				n = C.GetRepairResources2(buf, n, menu.container, menu.object, repaircomponent)
				for i = 0, n - 1 do
					local amount = buf[i].amount
					if amount > 0 then
						table.insert(resources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
					end
				end
				
				row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				if (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
					row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, repaircomponent, "repair", row.index) end
				end
				row[2]:setColSpan(colspan):createText(ReadText(1001, 4217) .. ReadText(1001, 120) .. " " .. name, { color = Helper.color.green, mouseOverText = name })
				if not menu.isplayerowned then
					row[4]:setColSpan(2):createText(ConvertMoneyString(tonumber(C.GetRepairPrice(repaircomponent, menu.container) * menu.repairdiscounts.totalfactor), false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Helper.color.green })
				end
				if (#resources > 0) and isextended then
					menu.displayUpgradeResources(ftable, resources, 1)
				end
			end
		else
			row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createText("--- " .. ReadText(1001, 7936) .. " ---", { halign = "center" } )
		end

		if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			local hasupgrades = (next(removedEquipment) ~= nil) or (next(newEquipment) ~= nil) or (#menu.crew.transferdetails > 0)
			local hasrepairs = (#repairedEquipment > 0)
			local mouseovertext = ""
			for i, error in Helper.orderedPairs(menu.errors) do
				if (i >= 1) and (i <= 3) then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					else
						mouseovertext = "\27R"
					end
					mouseovertext = mouseovertext .. ((type(error) == "function") and error(nil, true) or error)
				end
			end
			local button = row[3]:setColSpan(3):createButton({ active = (not menu.errors[1]) and (not menu.errors[2]) and (not menu.errors[3]) and (hasupgrades or hasrepairs), mouseOverText = mouseovertext }):setText(ReadText(1001, 8006), { halign = "center" })
			if (menu.object ~= 0) or (menu.macro ~= "") then
				button:setHotkey("INPUT_STATE_DETAILMONITOR_X", { displayIcon = true })
			end
			row[3].handlers.onClick = menu.editingshoppinglist and function () menu.buttonConfirmPurchaseEdit(hasupgrades, hasrepairs) end or function () menu.buttonAddPurchase(hasupgrades, hasrepairs) end
		end
	else
		-- nothing selected
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[2]:setColSpan(4):createText(ReadText(1001, 8007))

		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[3]:setColSpan(3):createButton({ active = false }):setText(ReadText(1001, 8006), { halign = "center" })
	end

	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		-- shoppinglist
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(5):createText(ReadText(1001, 8009), menu.headerTextProperties)

		if next(menu.shoppinglist) then
			for i, entry in ipairs(menu.shoppinglist) do
				if i ~= menu.editingshoppinglist then
					-- name & icon
					local name, icon
					if entry.objectgroup then
						local groupentry = menu.shipgroups[entry.objectgroup]
						name = #groupentry.ships .. ReadText(1001, 42) .. " " .. GetMacroData(groupentry.macro, "name")
						icon = C.IsIconValid("ship_" .. groupentry.macro) and ("ship_" .. groupentry.macro) or "ship_notfound"
					elseif entry.object ~= 0 then
						name = ffi.string(C.GetComponentName(entry.object)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.object)) .. ")"
						local macro = GetComponentData(ConvertStringTo64Bit(tostring(entry.object)), "macro")
						icon = C.IsIconValid("ship_" .. macro) and ("ship_" .. macro) or "ship_notfound"
					else
						name = GetMacroData(entry.macro, "name")
						icon = C.IsIconValid("ship_" .. entry.macro) and ("ship_" .. entry.macro) or "ship_notfound"
					end
					local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(2):createIcon(icon, { width = iconwidth, height = iconwidth, scaling = false, affectRowHeight = false, y = (iconwidth - Helper.scaleY(Helper.standardTextHeight)) / 2 })
					row[3]:setColSpan(3):createText((entry.customshipname ~= "") and entry.customshipname or name, { color = entry.color, font = Helper.standardFontBold, mouseOverText = menu.getLoadoutSummary(entry.upgradeplan, entry.crew, menu.repairplan and menu.repairplan[tostring(entry.object)]) })
					-- amount
					local researchprecursors
					if menu.mode == "purchase" then
						local ware = GetMacroData(entry.macro, "ware")
						researchprecursors = GetWareData(ware, "productionresearchprecursors")
					end
					if (menu.mode == "purchase") and ((not researchprecursors) or (#researchprecursors == 0)) then
						local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						row[3]:setColSpan(2):createText(ReadText(1001, 1202) .. ReadText(1001, 120))
						local options = {}
						for i = 1, 20 do
							local active = menu.isplayerowned or (playerMoney - menu.shoppinglisttotal - (i - entry.amount) * entry.price > 0)
							table.insert(options, { id = i, text = i, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ("\27R" .. ReadText(1026, 8016)) })
						end
						for i = 30, 100, 10 do
							local active = menu.isplayerowned or (playerMoney - menu.shoppinglisttotal - (i - entry.amount) * entry.price > 0)
							table.insert(options, { id = i, text = i, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ("\27R" .. ReadText(1026, 8016)) })
						end
						row[5]:createDropDown(options, { startOption = entry.amount }):setTextProperties({ halign = "right", x = Helper.standardTextOffsetx })
						row[5].handlers.onDropDownConfirmed = function (_, amountstring) return menu.dropdownChangePurchaseAmount(i, amountstring) end
					else
						local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
						row[1]:setColSpan(5):createText(" ")
					end
					-- price
					if not menu.isplayerowned then
						local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
						row[3]:createText(ReadText(1001, 2927) .. ReadText(1001, 120))
						row[4]:setColSpan(2):createText(ConvertMoneyString(entry.amount * (entry.price and (entry.price + entry.crewprice) or 0), false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
					end
					-- Time estimate
					local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					row[3]:createText(ReadText(1001, 8508) .. ReadText(1001, 120))
					local object = entry.object
					local groupamount = 1
					if entry.objectgroup then
						local groupentry = menu.shipgroups[entry.objectgroup]
						object = groupentry.ships[1].ship
						groupamount = #groupentry.ships
					end
					local duration = math.ceil(entry.amount * groupamount / C.GetNumSuitableBuildProcessors(menu.container, object, entry.macro)) * entry.duration
					row[4]:setColSpan(2):createText((menu.warnings[4] and "- -:- -" or ConvertTimeString(duration, (duration >= 3600) and "%h:%M:%S" or "%M:%S")), { halign = "right" })
					-- edit & remove
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[3]:createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 8529), { halign = "center" })
					row[3].handlers.onClick = function () return menu.buttonEditPurchase(i) end
					row[4]:setColSpan(2):createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 8530), { halign = "center" })
					row[4].handlers.onClick = function () return menu.buttonRemovePurchase(i) end
					if i ~= #menu.shoppinglist then
						local row = ftable:addRow(false, { bgColor = Helper.defaultSimpleBackgroundColor })
						row[1]:setColSpan(5):createText(" ", { height = 2, fontsize = 1 })
					end
				end
			end
		else
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[2]:setColSpan(4):createText("--- " .. ReadText(1001, 34) .. " ---")
		end
	end

	menu.topRows.plan = nil
	menu.selectedRows.plan = nil
	menu.selectedCols.plan = nil
end

function menu.getBuildResources(ware)
	local resources = {}
	if menu.container and (not menu.errors[4]) then
		local n = C.GetNumBuildResources(menu.container, menu.object, menu.macro, ware)
		local buf = ffi.new("UIWareInfo[?]", n)
		n = C.GetBuildResources(buf, n, menu.container, menu.object, menu.macro, ware)
		for i = 0, n - 1 do
			local amount = buf[i].amount
			if amount > 0 then
				table.insert(resources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
	end
	return resources
end

function menu.displayUpgradeResources(ftable, resources, upgradeamount)
	local colspan = 3
	if menu.isReadOnly then
		colspan = 6
	end

	for _, resource in ipairs(resources) do
		local ismissing = false
		for _, entry in ipairs(menu.missingResources) do
			if entry.ware == resource.ware then
				ismissing = true
				break
			end
		end
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		local color = Helper.color.white
		if ismissing then
			color = Helper.color.red
		end
		row[2]:setColSpan(colspan):createText("   " .. upgradeamount * resource.amount .. ReadText(1001, 42) .. " " .. GetWareData(resource.ware, "name"), { color = color, mouseOverText = mouseOverText })
	end
end

function menu.displayModifyPlan(frame)
	-- errors & warnings
	menu.criticalerrors = {}
	menu.errors = {}
	if menu.upgradetypeMode == "paintmods" then
		menu.warnings = {}

		local isdefaultpaintmod = false
		local buf = ffi.new("UIPaintMod")
		if (menu.object ~= 0) or (menu.macro ~= "") then
			if C.GetPlayerPaintThemeMod(menu.object, menu.macro, buf) then
				if menu.installedPaintMod and (ffi.string(buf.Ware) == menu.installedPaintMod.ware) then
					isdefaultpaintmod = true
				end
			end
		end
		if not isdefaultpaintmod then
			menu.warnings = {
				[1] = ReadText(1001, 8518)
			}
		end
	else
		menu.warnings = {}
		if not menu.isplayerowned then
			menu.warnings[1] = ReadText(1001, 8036)
		end
	end

	menu.shoppinglisttotal = 0

	-- BUTTONS
	local buttontable = frame:addTable(2, { tabOrder = 6, width = menu.planData.width, height = Helper.scaleY(Helper.standardButtonHeight), x = menu.planData.offsetX, y = Helper.viewHeight - Helper.scaleY(Helper.standardButtonHeight) - menu.planData.offsetY, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })

	if not menu.isplayerowned then
		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(2):createText(menu.container and string.format(ReadText(1001, 8531), (menu.isplayerowned and Helper.convertColorToText(Helper.color.green) or "") .. ffi.string(C.GetComponentName(menu.container))) or ReadText(1001, 8012), menu.headerTextProperties)

		local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 2003))
		row[2]:createText(function () return ConvertMoneyString(GetPlayerMoney(), false, true, 0, true, false) .. " " .. ReadText(1001, 101) end, { halign = "right" })
	end
	
	local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton({ }):setText(ReadText(1001, 8035), { halign = "center" })
	row[2].handlers.onClick = function () return menu.closeMenu("back") end

	buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - menu.planData.offsetY

	-- STATUS
	local infoCount = 0
	local visibleHeight

	local statustable
	if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
		if not menu.warningShown then
			PlaySound("ui_notification_pickup_fail")
		end
		menu.warningShown = menu.warningShown or getElapsedTime()

		local iconfactor = 1.6
		local iconsize = iconfactor * Helper.headerRow1Height

		statustable = frame:addTable(4, { tabOrder = 7, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = false, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		statustable:setColWidth(1, iconsize)
		statustable:setColWidth(4, iconsize)

		local row = statustable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setBackgroundColSpan(4):createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
		row[1].properties.fontsize = iconfactor * row[1].properties.fontsize
		row[1].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))
		row[2]:setColSpan(2):createText(ReadText(1001, 8342), menu.headerWarningTextProperties)
		row[4]:createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
		row[4].properties.fontsize = iconfactor * row[4].properties.fontsize
		row[4].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))

		for _, errorentry in Helper.orderedPairs(menu.criticalerrors) do
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(errorentry, { color = Helper.color.red, wordwrap = true })
			infoCount = infoCount + 1
			if infoCount == 4 then
				visibleHeight = statustable:getFullHeight()
			end
		end
		for _, errorentry in Helper.orderedPairs(menu.errors) do
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(errorentry, { color = Helper.color.red, wordwrap = true })
			infoCount = infoCount + 1
			if infoCount == 4 then
				visibleHeight = statustable:getFullHeight()
			end
		end
		for _, warningentry in Helper.orderedPairs(menu.warnings) do
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(warningentry, { color = Helper.color.orange, wordwrap = true })
			infoCount = infoCount + 1
			if infoCount == 4 then
				visibleHeight = statustable:getFullHeight()
			end
		end

		if visibleHeight then
			statustable.properties.maxVisibleHeight = visibleHeight
		else
			statustable.properties.maxVisibleHeight = statustable:getFullHeight()
		end
		statustable.properties.y = buttontable.properties.y - statustable:getVisibleHeight() - 2 * Helper.borderSize
	else
		menu.warningShown = nil
	end

	-- PRICE LIST
	local maxVisibleHeight = buttontable.properties.y - menu.planData.offsetY
	if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
		maxVisibleHeight = statustable.properties.y - menu.planData.offsetY
	end
	local ftable = frame:addTable(2, { tabOrder = 0, width = menu.planData.width, maxVisibleHeight = maxVisibleHeight, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
	ftable:setColWidth(2, 0.3 * menu.planData.width)

	if not menu.isplayerowned then
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(2):createText(ReadText(1001, 8037), menu.headerTextProperties)
	
		if menu.upgradetypeMode == "paintmods" then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8517))
		else
			for i = #Helper.modQualities, 1, -1 do
				local entry = Helper.modQualities[i]
				local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:createText(entry.name)
				row[2]:createText(ConvertMoneyString(entry.price * menu.moddingdiscounts.totalfactor, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
			end

			if #menu.moddingdiscounts > 0 then
				ftable:addEmptyRow()

				local row = ftable:addRow(nil, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(2):createText(ReadText(1001, 2819), menu.subHeaderTextProperties)

				for _, entry in ipairs(menu.moddingdiscounts) do
					local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
					row[1]:createText(entry.name)
					row[2]:createText(entry.amount .. " %", { halign = "right" })
				end
			end
		end
	end

	-- SELECTEDSHIPS
	if menu.modeparam[1] then
		local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:setColSpan(2):createText(ReadText(1001, 8519), menu.headerTextProperties)
		for _, ship in pairs(menu.modeparam[2]) do
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:createText(ffi.string(C.GetComponentName(ship)) .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")", { color = Helper.color.green })
			local paintmod = ffi.new("UIPaintMod")
			if C.GetInstalledPaintMod(ship, paintmod) then
				row[2]:createText(ffi.string(paintmod.Name), { color = Helper.modQualities[paintmod.Quality].color, halign = "right" })
			end
		end
	end

	menu.topRows.plan = nil
	menu.selectedRows.plan = nil
	menu.selectedCols.plan = nil
end

function menu.displayStats(frame)	
	-- title
	local titletable = frame:addTable(5, { tabOrder = 19, width = menu.statsData.width, x = menu.statsData.offsetX, y = 0, reserveScrollBar = false, skipTabChange = true })
	local title = ReadText(1001, 8534)
	local titlewidth = C.GetTextWidth(title, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)) + 2 * (Helper.headerRow1Offsetx + Helper.borderSize)
	local checkboxwidth = Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize
	titletable:setColWidth(2, checkboxwidth, false)
	titletable:setColWidth(3, titlewidth, false)
	titletable:setColWidth(4, checkboxwidth, false)

	local row = titletable:addRow(true, { fixed = true, bgColor = Helper.color.transparent, borderBelow = false })
	row[2]:setBackgroundColSpan(2):createCheckBox(menu.showStats, { height = checkboxwidth, scaling = false })
	row[2].handlers.onClick = menu.buttonShowStats
	row[3]:createButton({ bgColor = Helper.color.transparent, height = Helper.headerRow1Height }):setText(title, { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety, halign = "left" })
	row[3].handlers.onClick = menu.buttonShowStats
	if menu.showStats then
		local row = titletable:addRow(false, { fixed = true, bgColor = Helper.defaultSimpleBackgroundColor })
		row[1]:setColSpan(5):createText(" ", { fontsize = 1, height = 2 })

		local loadoutstats, currentloadoutstats
		if menu.usemacro then
			local ffiloadoutstats = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.GetLoadoutStatistics4(0, menu.macro, loadout) end)
			loadoutstats = Helper.convertLoadoutStats(ffiloadoutstats)

			currentloadoutstats = Helper.convertLoadoutStats(ffi.new("UILoadoutStatistics4", 0))
		elseif menu.mode == "upgrade" then
			local ffiloadoutstats = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.GetLoadoutStatistics4(menu.object, "", loadout) end)
			loadoutstats = Helper.convertLoadoutStats(ffiloadoutstats)

			local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
			currentloadoutstats = Helper.convertLoadoutStats(fficurrentloadoutstats)
		elseif menu.mode == "modify" then
			local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics4(menu.object)
			loadoutstats = Helper.convertLoadoutStats(fficurrentloadoutstats)

			currentloadoutstats = menu.initialLoadoutStatistics
		end

		local ffimaxloadoutstats = C.GetMaxLoadoutStatistics4(menu.object, menu.macro)
		local maxloadoutstats = Helper.convertLoadoutStats(ffimaxloadoutstats)

		local ftable = frame:addTable(6, { tabOrder = 0, width = menu.statsData.width, x = menu.statsData.offsetX, y = titletable:getFullHeight() + Helper.borderSize, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		ftable:setColWidthPercent(2, 10)
		ftable:setColWidthPercent(5, 10)

		local iscapship = false
		-- If we have an object or a macro use its size information
		if menu.object ~= 0 then
			iscapship = C.IsComponentClass(menu.object, "ship_l") or C.IsComponentClass(menu.object, "ship_xl")
		elseif menu.macro ~= "" then
			iscapship = IsMacroClass(menu.macro, "ship_l") or IsMacroClass(menu.macro, "ship_xl")
		end

		local numRows = math.ceil(#config.stats / 2)
		for i = 1, numRows do
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			local entry = config.stats[i]

			local id = entry.id
			if entry.capshipid ~= nil then
				id = iscapship and entry.capshipid or id
			end

			if id ~= "" then
				row[1]:createText(entry.name .. ((entry.unit ~= "") and (" (" .. entry.unit .. ")") or ""), { mouseOverText = entry.mouseovertext })
				local color = Helper.color.white
				if loadoutstats[id] > currentloadoutstats[id] then
					color = entry.inverted and (menu.usemacro and Helper.color.white or Helper.color.red) or Helper.color.green
				elseif loadoutstats[id] < currentloadoutstats[id] then
					color = entry.inverted and Helper.color.green or Helper.color.red
				end
				local value
				if entry.type == "UINT" then
					value = ConvertIntegerString(Helper.round(loadoutstats[id], 0), true, 0, true, false)
				elseif (entry.type == "float") or (entry.type == "double") then
					local int, frac = math.modf(Helper.round(loadoutstats[id], entry.accuracy))
					value = ConvertIntegerString(int, true, 0, true, false)
					if entry.accuracy > 0 then
						frac = Helper.round(math.abs(frac or 0) * (10 ^ entry.accuracy))
						value = value .. ReadText(1001, 105) .. string.format("%0".. (entry.accuracy) .."d", frac)
					end
				end
				row[2]:createText(value, { halign = "right", color = color })
					local posChangeColor, negChangeColor
					if entry.inverted then
						if menu.usemacro then
							posChangeColor = Helper.defaultStatusBarValueColor
						else
							posChangeColor = Helper.defaultStatusBarNegChangeColor
						end
						negChangeColor = Helper.defaultStatusBarPosChangeColor
					end
				row[3]:createStatusBar({ current = loadoutstats[id], start = currentloadoutstats[id], max = maxloadoutstats[id], cellBGColor = Helper.color.transparent60, posChangeColor = posChangeColor, negChangeColor = negChangeColor })
			else
				row[1]:createText("")
			end
			if i + numRows <= #config.stats then
				local entry2 = config.stats[i + numRows]

				local id2 = entry2.id
				if entry2.capshipid ~= nil then
					id2 = iscapship and entry2.capshipid or id2
				end

				if id2 ~= "" then
					row[4]:createText(entry2.name .. ((entry2.unit ~= "") and (" (" .. entry2.unit .. ")") or ""))
					local color = Helper.color.white
					if loadoutstats[id2] > currentloadoutstats[id2] then
						color = entry2.inverted and (menu.usemacro and Helper.color.white or Helper.color.red) or Helper.color.green
					elseif loadoutstats[id2] < currentloadoutstats[id2] then
						color = entry2.inverted and Helper.color.green or Helper.color.red
					end
					local value
					if entry2.type == "UINT" then
						value = ConvertIntegerString(Helper.round(loadoutstats[id2], 0), true, 0, true, false)
					elseif (entry2.type == "float") or (entry2.type == "double") then
						local int, frac = math.modf(Helper.round(loadoutstats[id2], entry2.accuracy))
						value = ConvertIntegerString(int, true, 0, true, false)
						if entry2.accuracy > 0 then
							frac = Helper.round(math.abs(frac or 0) * (10 ^ entry2.accuracy))
							value = value .. ReadText(1001, 105) .. string.format("%0".. (entry2.accuracy) .."d", frac)
						end
					end
					row[5]:createText(value, { halign = "right", color = color })
					local posChangeColor, negChangeColor
					if entry2.inverted then
						if menu.usemacro then
							posChangeColor = Helper.defaultStatusBarValueColor
						else
							posChangeColor = Helper.defaultStatusBarNegChangeColor
						end
						negChangeColor = Helper.defaultStatusBarPosChangeColor
					end
					row[6]:createStatusBar({ current = loadoutstats[id2], start = currentloadoutstats[id2], max = maxloadoutstats[id2], cellBGColor = Helper.color.transparent60, posChangeColor = posChangeColor, negChangeColor = negChangeColor })
				else
					row[4]:createText("")
				end
			end
		end

		titletable.properties.y = Helper.viewHeight - titletable:getFullHeight() - Helper.borderSize - ftable:getVisibleHeight() - menu.statsData.offsetY
		ftable.properties.y = titletable.properties.y + ftable.properties.y
	else
		titletable.properties.y = Helper.viewHeight - titletable:getFullHeight() - menu.statsData.offsetY
	end

	menu.statsTableOffsetY = titletable.properties.y
end

function menu.evaluateShipOptions()
	local classOptions = {}
	for _, class in ipairs(config.classorder) do
		if menu.usemacro then
			if menu.availableshipmacrosbyclass[class] then
				table.insert(classOptions, { id = class, text = ReadText(1001, 8026) .. " " .. Helper.getClassText(class), icon = "", displayremoveoption = false })
			end
		elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
			if menu.selectableshipsbyclass[class] then
				table.insert(classOptions, { id = class, text = ReadText(1001, 8026) .. " " .. Helper.getClassText(class), icon = "", displayremoveoption = false })
			end
		end
	end

	local shipOptions = {}
	local curShipOption
	if menu.usemacro then
		if menu.class ~= "" then
			for _, macro in ipairs(menu.availableshipmacrosbyclass[menu.class]) do
				local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(macro, true)
				local name, infolibrary, shiptypename, primarypurpose, shipicon = GetMacroData(macro, "name", "infolibrary", "shiptypename", "primarypurpose", "icon")

				table.insert(shipOptions, { id = macro, text = "\27[" .. shipicon .. "] " .. name .. " - " .. shiptypename, icon = icon or "", displayremoveoption = false, overridecolor = overridecolor, mouseovertext = mouseovertext, name = name .. " - " .. shiptypename, objectid = "", class = menu.class, purpose = primarypurpose })
				AddKnownItem(infolibrary, macro)
			end
		end
		curShipOption = menu.macro
		table.sort(shipOptions, Helper.sortShipsByClassAndPurpose)
	elseif menu.class ~= "" then
		if menu.mode == "upgrade" then
			for _, entry in ipairs(menu.selectableshipsbyclass[menu.class] or {}) do
				if entry.group then
					local groupentry = menu.shipgroups[entry.group]
					local name = GetMacroData(groupentry.macro, "name")

					local icon = ""
					for i, shoppinglistentry in ipairs(menu.shoppinglist) do
						if shoppinglistentry.objectgroup == entry.group then
							icon = "menu_shoppingcart"
							break
						end
					end

					local mouseovertext = ""
					for i, ship in ipairs(groupentry.ships) do
						if i ~= 1 then
							mouseovertext = mouseovertext .. "\n"
						end
						mouseovertext = mouseovertext .. "\27[" .. ship.icon .. "] " .. ship.name .. " (" .. ship.objectid .. ")"
					end
					table.insert(shipOptions, { id = groupentry.macro, text = "\27[" .. groupentry.ships[1].icon .. "] " .. #groupentry.ships .. ReadText(1001, 42) .. " " .. name, icon = icon, displayremoveoption = false, mouseovertext = mouseovertext })
				elseif entry.grouped ~= nil then
					local icon = ""
					local active = true
					local mouseovertext = ""
					for i, shoppinglistentry in ipairs(menu.shoppinglist) do
						if shoppinglistentry.objectgroup == entry.groupidx then
							icon = "menu_shoppingcart"
							if entry.grouped then
								active = false
								mouseovertext = ReadText(1026, 8025)
							end
							break
						elseif shoppinglistentry.object == entry.ship.ship then
							icon = "menu_shoppingcart"
							break
						end
					end

					table.insert(shipOptions, { id = tostring(entry.ship.ship), text = (entry.grouped and "       " or "") .. "\27[" .. entry.ship.icon .. "] " .. entry.ship.name .. " (" .. entry.ship.objectid .. ")", icon = icon, displayremoveoption = false, active = active, mouseovertext = mouseovertext })
				else
					local icon = ""
					for i, shoppinglistentry in ipairs(menu.shoppinglist) do
						if shoppinglistentry.object == entry.ship then
							icon = "menu_shoppingcart"
							break
						end
					end

					table.insert(shipOptions, { id = tostring(entry.ship), text = "\27[" .. entry.icon .. "] " .. entry.name .. " (" .. entry.objectid .. ")", icon = icon, displayremoveoption = false })
				end
			end
			if menu.objectgroup then
				curShipOption = menu.objectgroup.macro
			else
				curShipOption = tostring(menu.object)
			end
		elseif menu.mode == "modify" then
			for _, ship in ipairs(menu.selectableshipsbyclass[menu.class] or {}) do
				local name = ffi.string(C.GetComponentName(ship))
				local idcode = ffi.string(C.GetObjectIDCode(ship))
				local primarypurpose, icon = GetComponentData(ConvertStringTo64Bit(tostring(ship)), "primarypurpose", "icon")

				table.insert(shipOptions, { id = tostring(ship), text = "\27[" .. icon .. "] " .. name .. " (" .. idcode .. ")", icon = "", displayremoveoption = false, name = name, objectid = idcode, class = menu.class, purpose = primarypurpose })
			end
			table.sort(shipOptions, Helper.sortShipsByClassAndPurpose)
			curShipOption = tostring(menu.object)
		end
	end

	local loadoutOptions = {}
	if next(menu.loadouts) then
		for _, loadout in ipairs(menu.loadouts) do
			table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
		end
	end

	return classOptions, shipOptions, curShipOption, loadoutOptions
end

function menu.createTitleBar(frame)
	local classOptions, shipOptions, curShipOption, loadoutOptions = menu.evaluateShipOptions()

	if menu.mode == "modify" then
		local ftable = frame:addTable(5, { tabOrder = 4, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
		ftable:setColWidth(1, menu.titleData.dropdownWidth)
		ftable:setColWidth(2, menu.titleData.dropdownWidth)
		ftable:setColWidth(3, menu.titleData.height)
		ftable:setColWidth(4, menu.titleData.height)
		ftable:setColWidth(5, menu.titleData.height)

		local row = ftable:addRow(true, { fixed = true })
		-- class
		row[1]:createDropDown(classOptions, { startOption = menu.class, active = (not menu.isReadOnly) and (#classOptions > 0), optionWidth = menu.titleData.dropdownWidth }):setTextProperties(config.dropDownTextProperties)
		row[1].handlers.onDropDownConfirmed = menu.dropdownShipClass
		-- ships
		local dropDownIconProperties = {
			width = menu.titleData.height / 2,
			height = menu.titleData.height / 2,
			x = menu.titleData.dropdownWidth - 1.5 * menu.titleData.height,
			y = 0,
			scaling = false,
		}

		row[2]:createDropDown(shipOptions, { startOption = curShipOption, active = (not menu.isReadOnly) and (menu.class ~= ""), optionWidth = menu.titleData.dropdownWidth, optionHeight = (menu.statsTableOffsetY or Helper.viewHeight) - menu.titleData.offsetY - Helper.frameBorder }):setTextProperties(config.dropDownTextProperties):setIconProperties(dropDownIconProperties)
		row[2].properties.text.halign = "left"
		row[2].handlers.onDropDownConfirmed = menu.dropdownShip
		-- reset camera
		row[3]:createButton({ active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[3].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		row[4]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex < #menu.undoStack) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[4].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		row[5]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex > 1) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[5].handlers.onClick = function () return menu.undoHelper(false) end
	else
		local ftable = frame:addTable(7, { tabOrder = 4, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
		if ((menu.macro == "") and (menu.object == 0)) then
			ftable.properties.defaultInteractiveObject = true
		end
		ftable:setColWidth(1, config.dropdownRatios.class * menu.titleData.dropdownWidth)
		ftable:setColWidth(2, config.dropdownRatios.ship * menu.titleData.dropdownWidth)
		ftable:setColWidth(3, menu.titleData.dropdownWidth)
		ftable:setColWidth(4, menu.titleData.height)
		ftable:setColWidth(5, menu.titleData.height)
		ftable:setColWidth(6, menu.titleData.height)
		ftable:setColWidth(7, menu.titleData.height)

		local row = ftable:addRow(true, { fixed = true })
		-- class
		row[1]:createDropDown(classOptions, { startOption = menu.class, active = (not menu.isReadOnly) and (#classOptions > 0) }):setTextProperties(config.dropDownTextProperties)
		row[1].handlers.onDropDownConfirmed = menu.dropdownShipClass
		-- ships
		local dropDownIconProperties = {
			width = menu.titleData.height / 2,
			height = menu.titleData.height / 2,
			x = config.dropdownRatios.ship * menu.titleData.dropdownWidth - 1.5 * menu.titleData.height,
			y = 0,
			scaling = false,
		}
		
		local dropdown = row[2]:createDropDown(shipOptions, { startOption = curShipOption, active = (not menu.isReadOnly) and (menu.class ~= ""), optionHeight = (menu.statsTableOffsetY or Helper.viewHeight) - menu.titleData.offsetY - Helper.frameBorder }):setTextProperties(config.dropDownTextProperties):setIconProperties(dropDownIconProperties)
		row[2].properties.text.halign = "left"
		row[2].handlers.onDropDownConfirmed = menu.dropdownShip
		local active = true
		if (menu.mode == "purchase") and (menu.macro ~= "") and (not menu.validLicence) then
			active = false
			local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(menu.macro, true)
			dropdown.properties.text.color = overridecolor
			dropdown.properties.icon.color = overridecolor
		end
		if (menu.mode == "upgrade") and (not menu.isReadOnly) and (menu.object ~= 0) then
			if not C.CanContainerEquipShip(menu.container, menu.object) then
				active = false
			end
		end

		-- loadout
		row[3]:createDropDown(loadoutOptions, { textOverride = ReadText(1001, 7905), active = (not menu.isReadOnly) and active and ((menu.object ~= 0) or (menu.macro ~= "")) and (next(menu.loadouts) ~= nil), optionWidth = menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize, optionHeight = (menu.statsTableOffsetY or Helper.viewHeight) - menu.titleData.offsetY - Helper.frameBorder, mouseOverText = (menu.mode == "customgamestart") and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8022)) or "" }):setTextProperties(config.dropDownTextProperties)
		row[3].handlers.onDropDownConfirmed = menu.dropdownLoadout
		row[3].handlers.onDropDownRemoved = menu.dropdownLoadoutRemoved
		-- save
		row[4]:createButton({ active = (not menu.isReadOnly) and active and ((menu.object ~= 0) or (menu.macro ~= "")), height = menu.titleData.height, mouseOverText = ReadText(1026, 7905) }):setIcon("menu_save")
		row[4].handlers.onClick = menu.buttonTitleSave
		-- reset camera
		row[5]:createButton({ active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[5].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		row[6]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex < #menu.undoStack) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[6].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		row[7]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex > 1) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[7].handlers.onClick = function () return menu.undoHelper(false) end
	end

	menu.topRows.ship = nil
	menu.selectedRows.ship = nil
	menu.selectedCols.ship = nil
end

function menu.displayMenu(firsttime)
	-- Remove possible button scripts from previous view
	Helper.removeAllWidgetScripts(menu, config.infoLayer)
	Helper.currentTableRow = {}

	menu.infoFrame = Helper.createFrameHandle(menu, {
		layer = config.infoLayer,
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- title bar
	menu.createTitleBar(menu.infoFrame)

	menu.displayLeftBar(menu.infoFrame)
	
	if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") and (menu.object ~= 0)) then
		menu.displaySlots(menu.infoFrame, firsttime)
	elseif menu.mode == "modify" then
		if menu.upgradetypeMode == "paintmods" then
			menu.displayModifyPaintSlots(menu.infoFrame)
		else
			menu.displayModifySlots(menu.infoFrame)
		end
	else
		menu.displayEmptySlots(menu.infoFrame)
	end
	
	if menu.usemacro or (menu.mode == "upgrade") then
		menu.displayPlan(menu.infoFrame)
	elseif menu.mode == "modify" then
		menu.displayModifyPlan(menu.infoFrame)
	end

	menu.statsTableOffsetY = nil
	if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0) then
		menu.displayStats(menu.infoFrame)
	end

	menu.infoFrame:display()
end

function menu.displayContextMenu()
	-- Remove possible button scripts from previous view
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local width = 0
	local setup = Helper.createTableSetup(menu)

	if menu.contextMode == 1 then
		width = 300

		local upgradetype = Helper.findUpgradeType(menu.contextData.upgradetype)
		local upgradetype2 = Helper.findUpgradeTypeByGroupType(upgradetype.type)
		local slotdata
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			slotdata = menu.groups[menu.currentSlot][upgradetype2.grouptype]
		else
			slotdata = menu.slots[upgradetype.type][menu.contextData.slot]
		end
		local plandata
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			plandata = menu.upgradeplan[upgradetype2.type][menu.currentSlot].macro
		else
			plandata = menu.upgradeplan[upgradetype.type][menu.contextData.slot].macro
		end
		local prefix = ""
		if upgradetype.mergeslots then
			prefix = #menu.slots[upgradetype.type] .. ReadText(1001, 42) .. " "
		end

		local hasmod, modicon = false, ""
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			hasmod, modicon = menu.checkMod(upgradetype2.grouptype, slotdata.currentcomponent, true)
		else
			hasmod, modicon = menu.checkMod(upgradetype.type, slotdata.component)
		end

		local canequip = not menu.isReadOnly
		if (menu.mode == "upgrade") and (not menu.isReadOnly) and (menu.object ~= 0) then
			canequip = C.CanContainerEquipShip(menu.container, menu.object)
		end

		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local name = upgradetype2.text.default
			if plandata == "" then
				if slotdata.slotsize ~= "" then
					name = upgradetype2.text[slotdata.slotsize]
				end
			else
				name = GetMacroData(plandata, "name")
			end
			if not upgradetype2.mergeslots then
				local minselect = (plandata == "") and 0 or 1
				local maxselect = (plandata == "") and 0 or slotdata.total

				local scale = {
					min       = 0,
					minselect = minselect,
					max       = slotdata.total,
					maxselect = maxselect,
					step      = 1,
					suffix    = "",
					exceedmax = false,
					readonly = canequip and (hasmod or menu.isReadOnly),
				}

				-- handle already installed equipment
				local haslicence = menu.checkLicence(plandata)
				if (plandata == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) and (not haslicence) then
					scale.maxselect = math.min(scale.maxselect, slotdata.count)
				end
				local j = menu.findUpgradeMacro(upgradetype2.grouptype, plandata)
				if j then
					local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]
					if not upgradeware.isFromShipyard then
						scale.maxselect = menu.objectgroup and 0 or math.min(scale.maxselect, slotdata.count)
						if menu.objectgroup then
							scale.minselect = 0
						end
					end
				end
				scale.start = math.max(scale.minselect, math.min(scale.maxselect, menu.upgradeplan[upgradetype2.type][menu.currentSlot].count))

				local mouseovertext = ""
				if hasmod then
					mouseovertext = "\27R" .. ReadText(1026, 8009) .. "\27X"
				end

				setup:addSimpleRow({
					Helper.createSliderCell(Helper.createTextInfo(name, "left", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), false, 0, 0, 0, Helper.standardTextHeight, nil, Helper.color.slidervalue, scale, mouseovertext)
				}, nil, {1})
			else
				setup:addSimpleRow({
					Helper.createFontString(name, false, "left", 255, 255, 255, 100)
				}, nil, {1})
			end
		end

		for k, macro in ipairs(slotdata.possiblemacros) do
			local name = prefix .. GetMacroData(macro, "name")

			local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(macro, true)
			local icondesc
			if icon and (icon ~= "") then
				icondesc = Helper.createButtonIcon(icon, "", overridecolor.r, overridecolor.g, overridecolor.b, overridecolor.a, Helper.standardTextHeight, Helper.standardTextHeight, width - Helper.standardTextHeight, 0)
			end

			-- handle already installed equipment
			if (macro == slotdata.currentmacro) and (not haslicence) then
				haslicence = true
				mouseovertext = mouseovertext .. "\n" .. "\27G" .. ReadText(1026, 8004)
			end

			if hasmod then
				mouseovertext = "\27R" .. ReadText(1026, 8009) .. "\27X\n" .. mouseovertext
			end

			mouseovertext = name .. "\n" .. mouseovertext

			local bgcolor = Helper.defaultButtonBackgroundColor
			if not haslicence then
				bgcolor = Helper.color.darkgrey
			end
				
			local color = Helper.color.white
			if (macro == slotdata.currentmacro) and (macro ~= plandata) then
				color = Helper.color.red
			elseif (macro == plandata) then
				color = Helper.color.green
				if hasmod then
					name = name .. " " .. modicon
				end
			end

			local hasstock = false
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				local j = menu.findUpgradeMacro(upgradetype2.grouptype, macro)
				if j then
					local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]
					hasstock = upgradeware.isFromShipyard or ((slotdata.currentmacro == macro) and (slotdata.hasstock ~= false))
				end
			else
				local j = menu.findUpgradeMacro(upgradetype.type, macro)
				if j then
					local upgradeware = menu.upgradewares[upgradetype.type][j]
					hasstock = upgradeware.isFromShipyard or ((slotdata.currentmacro == macro) and (slotdata.hasstock ~= false))
				end
			end

			setup:addSimpleRow({
				Helper.createButton(Helper.createTextInfo(name, "left", Helper.standardFont, Helper.standardFontSize, color.r, color.g, color.b, color.a, Helper.standardTextOffsetx), icondesc, false, canequip and ((macro == plandata) or (not hasmod)) and hasstock, 0, 0, width, Helper.standardTextHeight, bgcolor, nil, nil, mouseovertext)
			}, nil, {1})
		end
		
		local allowempty = upgradetype.allowempty
		if upgradetype.supertype == "macro" then
			allowempty = allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type,  menu.contextData.slot))
		end
		if allowempty then
			local name = ReadText(1001, 7906)

			local mouseovertext = ""
			if hasmod then
				mouseovertext = "\27R" .. ReadText(1026, 8009) .. "\27X"
			end

			local color = Helper.color.white
			if ("" == slotdata.currentmacro) and ("" ~= plandata) then
				color = Helper.color.red
			elseif ("" == plandata) then
				color = Helper.color.green
			end

			setup:addSimpleRow({
				Helper.createButton(Helper.createTextInfo(name, "left", Helper.standardFont, Helper.standardFontSize, color.r, color.g, color.b, color.a, Helper.standardTextOffsetx), nil, false, canequip and (not hasmod), 0, 0, width, Helper.standardTextHeight, nil, nil, nil, mouseovertext)
			}, nil, {1})
		end
	end

	local contextdesc = setup:createCustomWidthTable({width}, false, true, true, 4, 0, menu.contextData.offsetX, menu.contextData.offsetY, 0, true, menu.topRows.context, menu.selectedRows.context, nil, nil, "off")
	menu.topRows.context = nil
	menu.selectedRows.context = nil
	menu.selectedCols.context = nil

	Helper.displayFrame(menu, {contextdesc}, false, "", "", { close = true }, nil, config.contextLayer)
end

function menu.setUpContextMenuScripts(uitable)
	local nooflines = 1

	if menu.contextMode == 1 then
		local upgradetype = Helper.findUpgradeType(menu.contextData.upgradetype)
		local upgradetype2 = Helper.findUpgradeTypeByGroupType(upgradetype.type)
		local slotdata
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			slotdata = menu.groups[menu.currentSlot][upgradetype2.grouptype]
		else
			slotdata = menu.slots[upgradetype.type][menu.contextData.slot]
		end

		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			if not upgradetype.mergeslots then
				local line = nooflines
				Helper.setSliderCellScript(menu, nil, uitable, nooflines, 1, function (_, ...) return menu.slidercellSelectGroupAmount(upgradetype2.type, menu.currentSlot, nil, line, ...) end)
			end
			nooflines = nooflines + 1
		end

		for k, macro in ipairs(slotdata.possiblemacros) do
			local line = nooflines
			local haslicence = menu.checkLicence(macro)
			-- handle already installed equipment
			if (macro == slotdata.currentmacro) and (not haslicence) then
				haslicence = true
			end
			if haslicence then
				if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
					Helper.setButtonScript(menu, nil, uitable, nooflines, 1, function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, macro, nil, nil, line) end)
				else
					Helper.setButtonScript(menu, nil, uitable, nooflines, 1, function () return menu.buttonSelectUpgradeMacro(upgradetype.type, menu.contextData.slot, macro, nil, nil, line, (menu.mode == "customgamestart") or (menu.mode == "comparison")) end)
				end
			end
			nooflines = nooflines + 1
		end

		local allowempty = upgradetype.allowempty
		if upgradetype.supertype == "macro" then
			allowempty = allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type,  menu.contextData.slot))
		end
		if allowempty then
			local line = nooflines
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				Helper.setButtonScript(menu, nil, uitable, nooflines, 1, function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, "", nil, nil, line) end)
			else
				Helper.setButtonScript(menu, nil, uitable, nooflines, 1, function () return menu.buttonSelectUpgradeMacro(upgradetype.type, menu.contextData.slot, "", nil, nil, line, (menu.mode == "customgamestart") or (menu.mode == "comparison")) end)
			end
			nooflines = nooflines + 1
		end
	end
end

function menu.displayContextFrame(mode, width, x, y, issilent)
	if not issilent then
		PlaySound("ui_positive_click")
	end
	menu.contextMode = { mode = mode, width = width, x = x, y = y }
	if mode == "saveLoadout" then
		menu.createLoadoutSaveContext()
	elseif mode == "equipment" then
		menu.createEquipmentContext()
	elseif mode == "userquestion" then
		menu.createUserQuestionContext()
	elseif mode == "equipmentfilter" then
		menu.createEquipmentFilterContext()
	end
end

function menu.createUserQuestionContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	if menu.contextData.mode == "removevolatile" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 8561), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 8562), { wordwrap = true })
	elseif menu.contextData.mode == "replacesingleshoppinglistentry" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 8574), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 8575), { wordwrap = true })
	end

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText("")

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
	if menu.contextData.mode == "removevolatile" then
		row[2].handlers.onClick = function () return menu.buttonSelectUpgradeMacro(menu.contextData.type, menu.contextData.slot, menu.contextData.macro, menu.contextData.row, menu.contextData.col, false, true) end
	elseif menu.contextData.mode == "replacesingleshoppinglistentry" then
		row[2].handlers.onClick = function () return menu.buttonDiscardShoppingListAndEditGroup(menu.contextData.group, menu.contextData.shipid) end
	end
	row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
	row[4].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.createEquipmentContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(menu.selectedUpgrade.name, menu.subHeaderTextProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = true, bgColor = Helper.color.transparent }):setText(ReadText(1001, 2400), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonContextEncyclopedia(menu.selectedUpgrade) end

	menu.contextFrame:display()
end

function menu.checkLoadoutNameID()
	local canoverwrite = false
	local cansaveasnew = false
	if menu.loadout then
		local found = false
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.id == menu.loadout then
				menu.loadoutName = loadout.name
				menu.setCustomShipName()
				break
			end
		end
		if not found then
			menu.loadout = nil
		end
	end
	if (not menu.loadout) and menu.loadoutName and (menu.loadoutName ~= "") then
		cansaveasnew = true
		for _, loadout in ipairs(menu.loadouts) do
			if (not loadout.preset) and (not loadout.mission) and (loadout.name == menu.loadoutName) then
				canoverwrite = true
				cansaveasnew = false
				menu.loadout = loadout.id
				break
			end
		end
	end

	return canoverwrite, cansaveasnew
end

function menu.createLoadoutSaveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 5, scaling = false, borderEnabled = false, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()

	local row = ftable:addRow(true, { fixed = true })
	menu.contextMode.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = menu.titleData.height, description = ReadText(1001, 9413) }):setText(menu.loadoutName or "", { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize) })
	row[1].handlers.onTextChanged = menu.editboxLoadoutNameUpdateText

	if menu.mode == "customgamestart" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1026, 8021), { color = Helper.color.warningorange, wordwrap = true, scaling = true })
	end

	local row = ftable:addRow(true, { scaling = true, fixed = true })
	row[1]:createButton({ active = menu.checkLoadoutOverwriteActive, mouseOverText = ReadText(1026, 7908) }):setText(ReadText(1001, 7908), {  })
	row[1].handlers.onClick = function () return menu.buttonSave(true) end
	row[2]:createButton({ active = menu.checkLoadoutSaveNewActive, mouseOverText = ReadText(1026, 7909) }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonSave(false) end

	menu.contextFrame:display()
end

function menu.checkLoadoutOverwriteActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return canoverwrite
end

function menu.checkLoadoutSaveNewActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return cansaveasnew
end

function menu.createEquipmentFilterContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 6, reserveScrollBar = false })
	ftable:setColWidth(1, Helper.standardTextHeight)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createCheckBox(menu.checkAllRacesSelected, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = menu.checkboxSelectAllRaces
	row[2]:createText(ReadText(1001, 11912), Helper.headerRowCenteredProperties)

	local isgenericselected
	if menu.equipmentfilter_races.generic then
		isgenericselected = menu.equipmentfilter_races.generic.selected
	end
	-- remove generic and re-add it later after the sort
	menu.equipmentfilter_races.generic = nil
	local races = {}
	for id, racedata in pairs(menu.equipmentfilter_races) do
		racedata.id = id
		table.insert(races, racedata)
	end
	table.sort(races, Helper.sortName)
	menu.equipmentfilter_races.generic = { id = "generic", name = ReadText(1001, 8579), selected = isgenericselected }
	table.insert(races, 1, menu.equipmentfilter_races.generic)

	local color
	for _, racedata in ipairs(races) do
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(function () return menu.checkRacesSelected(racedata) end, { height = Helper.standardTextHeight })
		row[1].handlers.onClick = function(_, checked) menu.checkboxSelectRace(racedata, checked) end
		if racedata.id == "generic" or (menu.equipmentfilter_races[racedata.id].upgradeTypes and menu.equipmentfilter_races[racedata.id].upgradeTypes[menu.upgradetypeMode]) then
			color = Helper.color.standardColor
		else
			color = Helper.color.grey
		end
		row[2]:createText(racedata.name, { color = color })
	end

	menu.contextFrame:display()
end

function menu.checkRacesSelected(race)
	for _, racedata in pairs(menu.equipmentfilter_races) do
		if racedata.id == race.id then
			return racedata.selected == true
		end
	end
	return false
end

function menu.checkAllRacesSelected()
	for i, racedata in pairs(menu.equipmentfilter_races) do
		if not racedata.selected then
			return false
		end
	end
	return true
end

function menu.checkboxSelectRace(race, checked)
	race.selected = checked
	local found = false
	for j, text in ipairs(menu.equipmentsearchtext) do
		if text.race == race.id then
			found = true
			if not checked then
				table.remove(menu.equipmentsearchtext, j)
			end
			break
		end
	end
	if checked and (not found) then
		table.insert(menu.equipmentsearchtext, { text = race.name, race = race.id })
	end
	menu.displayMenu()
end

function menu.checkboxSelectAllRaces(_, checked)
	for _, racedata in pairs(menu.equipmentfilter_races) do
		racedata.selected = checked
		local found = false
		for j, text in ipairs(menu.equipmentsearchtext) do
			if text.race == racedata.id then
				found = true
				if not checked then
					table.remove(menu.equipmentsearchtext, j)
				end
				break
			end
		end
		if checked and (not found) then
			table.insert(menu.equipmentsearchtext, { text = racedata.name, race = racedata.id })
		end
	end
	menu.displayMenu()
end

function menu.buttonRemoveSearchEntry(index)
	if menu.equipmentsearch_editboxrow > 0 then
		Helper.cancelEditBoxInput(menu.slottable, menu.equipmentsearch_editboxrow, 1)
	end

	if menu.equipmentsearchtext[index].race then
		for _, racedata in pairs(menu.equipmentfilter_races) do
			if racedata.id == menu.equipmentsearchtext[index].race then
				racedata.selected = nil
				break
			end
		end
	end
	table.remove(menu.equipmentsearchtext, index)

	menu.displayMenu()
end

function menu.viewCreated(layer, ...)
	if layer == config.mainLayer then
		menu.map = ...

		if menu.activatemap == nil then
			menu.activatemap = true
		end
	elseif layer == config.infoLayer then
		if menu.upgradetypeMode == "paintmods" then
			menu.titlebartable, menu.leftbartable, menu.buttontable, menu.slottable, menu.plantable = ...
		else
			menu.titlebartable, menu.leftbartable, menu.slottable, menu.plantable = ...
		end

		if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			menu.updateMoney = GetCurRealTime()
		end
	elseif layer == config.contextLayer then
		menu.contexttable = ...

		menu.setUpContextMenuScripts(menu.contexttable)
	end

	-- clear descriptors again
	Helper.releaseDescriptors()
end

menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = GetCurRealTime()

	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.mapData.width / menu.mapData.height, 1)
			if (menu.usemacro and (menu.macro ~= "")) or (((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0)) then
				if menu.holomap and (menu.holomap ~= 0) then
					menu.currentIdx = menu.currentIdx + 1
					Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.ShowObjectConfigurationMap2(menu.holomap, menu.object, 0, menu.macro, false, loadout, 0) end)
					if menu.installedPaintMod then
						C.SetMapPaintMod(menu.holomap, menu.installedPaintMod.ware)
					end
					menu.selectMapMacroSlot()
					
					if menu.mapstate then
						C.SetMapState(menu.holomap, menu.mapstate)
						menu.mapstate = nil
					end
				end
			end

			menu.activatemap = false
		end
	end
	
	if menu.map and menu.holomap ~= 0 then
		local x, y = GetRenderTargetMousePosition(menu.map)
		C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
	end

	if menu.holomap and (menu.holomap ~= 0) then
		if menu.picking ~= menu.pickstate then
			menu.pickstate = menu.picking
			C.SetMapPicking(menu.holomap, menu.pickstate)
		end
	end

	if menu.contextMode and (type(menu.contextMode) == "table") and menu.contextMode.nameEditBox then
		ActivateEditBox(menu.contextMode.nameEditBox.id)
		menu.contextMode.nameEditBox = nil
	end

	if menu.noupdate then
		return
	end

	if (menu.object ~= 0) and (not IsValidComponent(ConvertStringTo64Bit(tostring(menu.object)))) then
		menu.object = 0
		menu.damagedcomponents = {}
		menu.selectableships = {}
		menu.selectableshipsbyclass = {}
		menu.modeparam[2] = {}
		menu.macro = ""
		menu.customshipname = ""
		menu.useloadoutname = false
		menu.loadoutName = ""
		menu.playershipname = nil
		menu.clearUndoStack()
		menu.getDataAndDisplay()
		return
	end

	local refresh, newdatarefresh = false, false

	-- update player money
	if menu.updateMoney and (menu.updateMoney + 1 < curtime) then
		menu.updateMoney = curtime
		local currentplayermoney = GetPlayerMoney()
		if menu.shoppinglisttotal > currentplayermoney then
			if not menu.criticalerrors[1] then
				refresh = true
			end
		else
			if menu.criticalerrors[1] then
				refresh = true
			end
		end
	end
	-- update previous upgrades
	if (menu.mode == "upgrade") or (menu.mode == "modify") then
		if menu.object ~= 0 then
			menu.checkCurrentBuildTasks()
			if not menu.tasks[tostring(menu.object)] and menu.errors[3] then
				newdatarefresh = true
			end
		end
	end

	-- do this after the build task check, so there is no error for already finished tasks in menu.errors[3]
	menu.mainFrame:update()
	menu.infoFrame:update()
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if newdatarefresh then
		menu.getDataAndDisplay(menu.upgradeplan, menu.crew, nil, nil, true)
	elseif refresh then
		menu.displayMenu()
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	if menu.mode == "modify" then
		if uitable == menu.slottable then
			if type(rowdata) == "table" then
				menu.currentSlot = rowdata[1]
				menu.selectMapMacroSlot()
			end
		end
	end
end

function menu.onSelectElement()
end

-- rendertarget selections
function menu.onRenderTargetSelect()
	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.2 seconds and the mouse was moved more than a distance of 2px
	if menu.leftdown and (menu.leftdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.leftdown.position, offset, 2)) then
		menu.closeContextMenu()
		if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") and (menu.object ~= 0)) then
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, pickedslot) then
				local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, pickedslot.upgradetype, pickedslot.slot)

				if (ffi.string(groupinfo.path) ~= "..") or (ffi.string(groupinfo.group) ~= "") then
					menu.upgradetypeMode, menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
				else
					menu.upgradetypeMode = ffi.string(pickedslot.upgradetype)
					menu.currentSlot = tonumber(pickedslot.slot)
				end
				menu.selectMapMacroSlot()
				menu.displayMenu(true)
			end
		elseif ((menu.mode == "modify") and (menu.object ~= 0)) then
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, pickedslot) then
				local mode = menu.getModUpgradeMode(ffi.string(pickedslot.upgradetype))
				if mode then
					if next(menu.groups) and ((mode == "shieldmods") or (mode == "turretmods")) then
						local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, pickedslot.upgradetype, pickedslot.slot)
						for i, entry in ipairs(menu.shieldgroups) do
							if ffi.string(groupinfo.group) == entry.group then
								menu.currentSlot = i
								break
							end
						end
					else
						menu.currentSlot = tonumber(pickedslot.slot)
					end
					menu.upgradetypeMode = mode
					menu.selectMapMacroSlot()
					menu.displayMenu()
				end
			end
		end
	end

	menu.leftdown = nil
end

function menu.selectMapMacroSlot()
	if menu.holomap and (menu.holomap ~= 0) then
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local group = menu.groups[menu.currentSlot]
			if group then
				C.SetSelectedMapGroup(menu.holomap, menu.object, menu.macro, group.path, group.group)
			end
		elseif menu.upgradetypeMode == "repair" then
			if menu.repairslots then
				local group = math.ceil(menu.currentSlot / 3)
				local loccol = menu.currentSlot - ((group - 1) * 3)

				if menu.repairslots[group] and menu.repairslots[group][loccol] then
					local component = menu.repairslots[group][loccol][4]
					local macro = menu.repairslots[group][loccol][2]
					local slot = menu.repairslots[group][loccol][1]

					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if menu.slots[upgradetype.type] and menu.slots[upgradetype.type][slot] and menu.slots[upgradetype.type][slot].component == component then
							C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, macro, false, upgradetype.type, slot)
							break
						end
					end

				else
					C.ClearSelectedMapMacroSlots(menu.holomap)
				end
			else
				C.ClearSelectedMapMacroSlots(menu.holomap)
			end
		elseif menu.upgradetypeMode == "settings" then
			C.ClearSelectedMapMacroSlots(menu.holomap)
		elseif menu.mode == "modify" then
			local entry = menu.getLeftBarEntry(menu.upgradetypeMode)
			if next(entry) then
				if (entry.upgrademode == "ship") or (entry.upgrademode == "paint") then
					C.ClearSelectedMapMacroSlots(menu.holomap)
				elseif next(menu.groups) and ((entry.upgrademode == "shield") or (entry.upgrademode == "turret")) then
					local shieldgroup = menu.shieldgroups[menu.currentSlot]
					if shieldgroup then
						C.SetSelectedMapGroup(menu.holomap, menu.object, menu.macro, "..", shieldgroup.group)
					end
				else
					local upgradetype = Helper.findUpgradeType(entry.upgrademode)
					if upgradetype.supertype == "macro" then
						if upgradetype.mergeslots then
							C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, entry.upgrademode, 0)
						else
							C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, entry.upgrademode, menu.currentSlot)
						end
					else
						C.ClearSelectedMapMacroSlots(menu.holomap)
					end
				end
			end
		elseif menu.upgradetypeMode and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") then
			local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
			if upgradetype.supertype == "macro" then
				if upgradetype.mergeslots then
					C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, menu.upgradetypeMode, 0)
				else
					C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, menu.upgradetypeMode, menu.currentSlot)
				end
			else
				C.ClearSelectedMapMacroSlots(menu.holomap)
			end
		else
			C.ClearSelectedMapMacroSlots(menu.holomap)
		end
	end
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown()
	C.StartPanMap(menu.holomap)
	menu.leftdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()) }
end

function menu.onRenderTargetMouseUp()
	C.StopPanMap(menu.holomap)
end

function menu.onRenderTargetRightMouseDown()
	C.StartRotateMap(menu.holomap)
	menu.rightdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()) }
end

function menu.onRenderTargetRightMouseUp()
	C.StopRotateMap(menu.holomap)
	if not menu.isReadOnly then
		local offset = table.pack(GetLocalMousePosition())
		-- Check if the mouse button was down less than 0.2 seconds and the mouse was moved more than a distance of 2px
		if (menu.rightdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.rightdown.position, offset, 2)) then
			menu.closeContextMenu()
			if (menu.usemacro and (menu.macro ~= "")) or (menu.mode == "upgrade") then
				local pickedslot = ffi.new("UILoadoutSlot")
				if C.GetPickedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, pickedslot) then
					local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, pickedslot.upgradetype, pickedslot.slot)
					if (ffi.string(groupinfo.path) ~= "..") or (ffi.string(groupinfo.group) ~= "") then
						menu.upgradetypeMode, menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
					else
						menu.upgradetypeMode = ffi.string(pickedslot.upgradetype)
						menu.currentSlot = tonumber(pickedslot.slot)
					end
					menu.selectMapMacroSlot()
					menu.displayMenu()

					menu.contextMode = 1
					menu.contextData = { offsetX = offset[1] + Helper.viewWidth / 2, offsetY = Helper.viewHeight / 2 - offset[2], upgradetype = ffi.string(pickedslot.upgradetype), slot = tonumber(pickedslot.slot) }
					menu.displayContextMenu()
				end
			end
		end
	end
	menu.rightdown = nil
end

function menu.onRenderTargetCombinedScrollDown(step)
	C.ZoomMap(menu.holomap, step)
end

function menu.onRenderTargetCombinedScrollUp(step)
	C.ZoomMap(menu.holomap, -step)
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if (menu.mode ~= "modify") and (menu.mode ~= "customgamestart") then
		local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
		if uitable == menu.slottable then
			if type(rowdata) == "table" then
				menu.selectedUpgrade = rowdata
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.displayContextFrame("equipment", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		end
	end
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
	end

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
	end
	return state
end

function menu.onRestoreState(state)
	if state.map then
		local offset = ffi.new("UIPosRot", {
			x = state.map.offset.x, 
			y = state.map.offset.y, 
			z = state.map.offset.z, 
			yaw = state.map.offset.yaw, 
			pitch = state.map.offset.pitch, 
			roll = state.map.offset.roll
		})
		menu.mapstate = ffi.new("HoloMapState", {
			offset = offset, 
			cameradistance = state.map.cameradistance
		})
	end

	local upgradeplan, crew
	for _, key in ipairs(config.stateKeys) do
		if key[1] == "upgradeplan" then
			upgradeplan = state[key[1]]
		elseif key[1] == "crew" then
			crew = state[key[1]]
		elseif key[1] == "shoppinglist" then
			menu.shoppinglist = state[key[1]]
			for i, entry in ipairs(menu.shoppinglist) do
				menu.shoppinglist[i].object = ffi.new("UniverseID", ConvertIDTo64Bit(entry.object))
				menu.shoppinglist[i].hasupgrades = entry.hasupgrades ~= 0
				menu.shoppinglist[i].useloadoutname = entry.useloadoutname ~= 0
			end
		else
			if key[2] == "UniverseID" then
				menu[key[1]] = ffi.new("UniverseID", ConvertIDTo64Bit(state[key[1]]))
			elseif key[2] == "bool" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		end
	end

	return upgradeplan, crew
end

function menu.closeMenu(dueToClose)
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer)
	if menu.contextMode then
		menu.closeContextMenu()
		if (dueToClose == "back") or (layer == config.contextLayer) then
			return
		end
	end

	if menu.upgradetypeMode and (dueToClose == "back") and ((menu.mode ~= "modify") or (not menu.modeparam[1])) then
		menu.deactivateUpgradeMode()
		return
	end

	menu.closeMenu((menu.mode == "customgamestart") and "back" or dueToClose)
end

function menu.closeContextMenu()
	Helper.clearFrame(menu, config.contextLayer)
	menu.contextFrame = nil
	menu.contextMode = nil
end

function menu.getAmmoUsage(type)
	local capacity = 0
	if type == "missile" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = C.GetDefaultMissileStorageCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				capacity = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "missilecapacity")
			end
		end
		for slot, data in pairs(menu.upgradeplan.weapon) do
			local currentmacro = menu.slots.weapon[slot].currentmacro
			if currentmacro ~= data.macro then
				if currentmacro ~= "" then
					capacity = capacity - C.GetMacroMissileCapacity(currentmacro)
				end
				if data.macro ~= "" then
					capacity = capacity + C.GetMacroMissileCapacity(data.macro)
				end
			end
		end
		for slot, data in pairs(menu.upgradeplan.turret) do
			local currentmacro = menu.slots.turret[slot].currentmacro
			if currentmacro ~= data.macro then
				if currentmacro ~= "" then
					capacity = capacity - C.GetMacroMissileCapacity(currentmacro)
				end
				if data.macro ~= "" then
					capacity = capacity + C.GetMacroMissileCapacity(data.macro)
				end
			end
		end
		for slot, groupdata in pairs(menu.upgradeplan.turretgroup) do
			local currentmacro = menu.groups[slot].turret.currentmacro
			local currentoperational = menu.groups[slot].turret.operational
			if currentmacro ~= groupdata.macro then
				if currentmacro ~= "" then
					capacity = capacity - currentoperational * C.GetMacroMissileCapacity(currentmacro)
				end
				if groupdata.macro ~= "" then
					capacity = capacity + groupdata.count * C.GetMacroMissileCapacity(groupdata.macro)
				end
			end
		end
	elseif type == "drone" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = GetMacroUnitStorageCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				if C.IsComponentClass(menu.object, "defensible") then
					capacity = GetUnitStorageData(ConvertStringTo64Bit(tostring(menu.object))).capacity
				else
					capacity = GetMacroUnitStorageCapacity(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
				end
			end
		end
	elseif type == "deployable" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = C.GetMacroDeployableCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				capacity = C.GetDefensibleDeployableCapacity(ConvertStringTo64Bit(tostring(menu.object)))
			end
		end
	elseif type == "countermeasure" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = C.GetDefaultCountermeasureStorageCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				if C.IsComponentClass(menu.object, "defensible") then
					capacity = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "countermeasurecapacity") or 0
				else
					capacity = C.GetDefaultCountermeasureStorageCapacity(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
				end
			end
		end
	end

	local total = 0
	for macro, amount in pairs(menu.upgradeplan[type]) do
		local volume = 1
		if type == "missile" then
			local ware = menu.upgradewares[type][menu.findUpgradeMacro(type, macro)]
			if ware.ware then
				volume = GetWareData(ware.ware, "volume")
			end
		end
		total = total + amount * volume
	end

	return total or 0, capacity or 0
end

function menu.isAmmoCompatible(type, ammomacro)
	if ammomacro ~= "" then
		if type == "missile" then
			for slot, data in pairs(menu.upgradeplan.weapon) do
				if data.macro ~= "" then
					if C.IsAmmoMacroCompatible(data.macro, ammomacro) then
						return true
					end
				end
			end
			for slot, data in pairs(menu.upgradeplan.turret) do
				if data.macro ~= "" then
					if C.IsAmmoMacroCompatible(data.macro, ammomacro) then
						return true
					end
				end
			end
			for slot, groupdata in pairs(menu.upgradeplan.turretgroup) do
				if groupdata.macro ~= "" then
					if C.IsAmmoMacroCompatible(groupdata.macro, ammomacro) then
						return true
					end
				end
			end
		elseif type == "drone" then
			return C.IsUnitMacroCompatible(menu.object, menu.macro, ammomacro)
		elseif type == "deployable" then
			return C.IsDeployableMacroCompatible(menu.object, menu.macro, ammomacro)
		elseif type == "countermeasure" then
			if menu.macro ~= "" then
				return (C.GetDefaultCountermeasureStorageCapacity(menu.macro) > 0)
			elseif menu.object ~= 0 then
				return (GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "countermeasurecapacity") > 0)
			end
		end
	end

	return false
end

function menu.filterUpgradeByText(upgrade, texts)
	local hasracefilter, racematch = false, false
	if menu.upgradetypeMode ~= "crew" and menu.upgradetypeMode ~= "repair" and menu.upgradetypeMode ~= "settings" and menu.upgradetypeMode ~= "software" then
		for _, textentry in ipairs(texts) do
			if textentry.race then
				hasracefilter = true
				local makerraces = GetMacroData(upgrade, "makerraceid")
				if (textentry.race == "generic") and (#makerraces == 0) then
					racematch = true
				end
				for _, makerrace in ipairs(makerraces) do
					if makerrace == textentry.race then
						racematch = true
						break
					end
				end
				if racematch then
					break
				end
			end
		end
	end

	local hasadditionalfilter, filtermatch = false, false
	for _, textentry in ipairs(texts) do
		if not textentry.race then
			hasadditionalfilter = true
			text = utf8.lower(textentry.text)

			if menu.upgradetypeMode == "software" then
				filtermatch = menu.filterSoftwareByText(upgrade, text)
			else
				local shortname, makerracenames = GetMacroData(upgrade, "shortname", "makerracename")
				if string.find(utf8.lower(shortname), text, 1, true) then
					filtermatch = true
				end
				for _, makerracename in ipairs(makerracenames) do
					if string.find(utf8.lower(makerracename), text, 1, true) then
						filtermatch = true
						break
					end
				end
			end
			if filtermatch then
				break
			end
		end
	end

	return ((not hasracefilter) or racematch) and ((not hasadditionalfilter) or filtermatch)
end

function menu.filterSoftwareByText(software, text)
	text = utf8.lower(text)

	local name = GetWareData(software, "name")
	if name and string.find(utf8.lower(name), text, 1, true) then
		return true
	end

	return false
end

function menu.findGroupIndex(path, group)
	for i, groupinfo in ipairs(menu.groups) do
		if (groupinfo.path == path) and (groupinfo.group == group) then
			local mode = "turretgroup"
			if groupinfo["engine"].total > 0 then
				mode = "enginegroup"
			end
			return mode, i
		end
	end
end

function menu.getLeftBarEntry(mode)
	local leftBar = config.leftBar
	if menu.mode == "modify" then
		leftBar = config.leftBarMods
	end

	for i, entry in ipairs(leftBar) do
		if entry.mode == mode then
			return entry
		end
	end

	return {}
end

function menu.prepareComponentUpgradeSlots(object, slots, ammo, software, changeupgradeplan)
	local canequip = menu.container and C.CanContainerEquipShip(menu.container, object)
	-- for all members of set upgradetypes,
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		-- with supertype "macro" (there should be 4)
		if upgradetype.supertype == "macro" then
			-- initialize an entry in table slots with key upgradetype.type
			slots[upgradetype.type] = {}
			-- and for all slots in the object,
			for j = 1, tonumber(C.GetNumUpgradeSlots(object, "", upgradetype.type)) do
				local groupinfo = C.GetUpgradeSlotGroup(object, "", upgradetype.type, j)
				if upgradetype.pseudogroup or ((ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "")) then
					slots[upgradetype.type][j] = { currentmacro = ffi.string(C.GetUpgradeSlotCurrentMacro(object, 0, upgradetype.type, j)), possiblemacros = {}, component = nil }
					if changeupgradeplan then
						local macro = slots[upgradetype.type][j].currentmacro
						local checkforeignmacro
						if canequip then
							if menu.objectgroup then
								local wareidx = menu.findUpgradeMacro(upgradetype.type, slots[upgradetype.type][j].currentmacro)
								if not wareidx then
									checkforeignmacro = true
								else
									local upgradeware = menu.upgradewares[upgradetype.type][wareidx]
									if not upgradeware.isFromShipyard then
										checkforeignmacro = true
									end
								end
							end
						end
						menu.upgradeplan[upgradetype.type][j] = { macro = macro, ammomacro = "", weaponmode = "", checkforeignmacro = checkforeignmacro }
					end
				else
					slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {}, component = nil }
					if changeupgradeplan then
						menu.upgradeplan[upgradetype.type][j] = { macro = "", ammomacro = "", weaponmode = "" }
					end
				end

				local currentcomponent = C.GetUpgradeSlotCurrentComponent(object, upgradetype.type, j)
				if currentcomponent ~= 0 then
					slots[upgradetype.type][j].component = currentcomponent
					if changeupgradeplan then
						if C.IsComponentClass(currentcomponent, "weapon") then
							menu.upgradeplan[upgradetype.type][j].weaponmode = ffi.string(C.GetWeaponMode(currentcomponent))
							if C.IsComponentClass(currentcomponent, "missilelauncher") then
								menu.upgradeplan[upgradetype.type][j].ammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(currentcomponent))
							end
						end
					end
				end
			end
		elseif upgradetype.supertype == "ammo" then
			ammo[upgradetype.type] = {}

			local ammoentry = {}
			if upgradetype.type == "missile" then
				local n = C.GetNumAllMissiles(object)
				local buf = ffi.new("AmmoData[?]", n)
				n = C.GetAllMissiles(buf, n, object)
				for j = 0, n - 1 do
					local entry = {}
					entry.macro = ffi.string(buf[j].macro)
					entry.amount = buf[j].amount
					table.insert(ammoentry, entry)
				end
			elseif upgradetype.type == "drone" then
				local n = C.GetNumAllUnits(object, false)
				local buf = ffi.new("UnitData[?]", n)
				n = C.GetAllUnits(buf, n, object, false)
				for j = 0, n - 1 do
					local entry = {}
					entry.macro = ffi.string(buf[j].macro)
					entry.category = ffi.string(buf[j].category)
					entry.amount = buf[j].amount
					table.insert(ammoentry, entry)
				end
			elseif upgradetype.type == "deployable" then
				local numlasertowers = C.GetNumAllLaserTowers(object)
				local lasertowers = ffi.new("AmmoData[?]", numlasertowers)
				numlasertowers = C.GetAllLaserTowers(lasertowers, numlasertowers, object)
				for j = 0, numlasertowers - 1 do
					local entry = {}
					entry.macro = ffi.string(lasertowers[j].macro)
					entry.amount = lasertowers[j].amount
					table.insert(ammoentry, entry)
				end

				local numsatellites = C.GetNumAllSatellites(object)
				local satellites = ffi.new("AmmoData[?]", numsatellites)
				numsatellites = C.GetAllSatellites(satellites, numsatellites, object)
				for j = 0, numsatellites - 1 do
					local entry = {}
					entry.macro = ffi.string(satellites[j].macro)
					entry.amount = satellites[j].amount
					table.insert(ammoentry, entry)
				end

				local nummines = C.GetNumAllMines(object)
				local mines = ffi.new("AmmoData[?]", nummines)
				nummines = C.GetAllMines(mines, nummines, object)
				for j = 0, nummines - 1 do
					local entry = {}
					entry.macro = ffi.string(mines[j].macro)
					entry.amount = mines[j].amount
					table.insert(ammoentry, entry)
				end

				local numnavbeacons = C.GetNumAllNavBeacons(object)
				local navbeacons = ffi.new("AmmoData[?]", numnavbeacons)
				numnavbeacons = C.GetAllNavBeacons(navbeacons, numnavbeacons, object)
				for j = 0, numnavbeacons - 1 do
					local entry = {}
					entry.macro = ffi.string(navbeacons[j].macro)
					entry.amount = navbeacons[j].amount
					table.insert(ammoentry, entry)
				end

				local numresourceprobes = C.GetNumAllResourceProbes(object)
				local resourceprobes = ffi.new("AmmoData[?]", numresourceprobes)
				numresourceprobes = C.GetAllResourceProbes(resourceprobes, numresourceprobes, object)
				for j = 0, numresourceprobes - 1 do
					local entry = {}
					entry.macro = ffi.string(resourceprobes[j].macro)
					entry.amount = resourceprobes[j].amount
					table.insert(ammoentry, entry)
				end
			elseif upgradetype.type == "countermeasure" then
				local n = C.GetNumAllCountermeasures(object)
				local buf = ffi.new("AmmoData[?]", n)
				n = C.GetAllCountermeasures(buf, n, object)
				local totalnumcountermeasures = 0
				for j = 0, n - 1 do
					local entry = {}
					entry.macro = ffi.string(buf[j].macro)
					entry.amount = buf[j].amount
					table.insert(ammoentry, entry)
				end
			end

			for _, item in ipairs(ammoentry) do
				local isexcluded = false
				for _, exclusion in ipairs(upgradetype.exclude) do
					if item.category == exclusion then
						isexcluded = true
						break
					end
				end
				if not isexcluded then
					ammo[upgradetype.type][item.macro] = item.amount
				end
				if changeupgradeplan then
					menu.upgradeplan[upgradetype.type][item.macro] = item.amount
				end
			end
		elseif upgradetype.supertype == "software" then
			software[upgradetype.type] = {}
			local n = C.GetNumSoftwareSlots(object, "")
			local buf = ffi.new("SoftwareSlot[?]", n)
			n = C.GetSoftwareSlots(buf, n, object, "")
			for j = 0, n - 1 do
				local entry = {}
				entry.maxsoftware = ffi.string(buf[j].max)
				entry.currentsoftware = ffi.string(buf[j].current)
				if changeupgradeplan then
					table.insert(menu.upgradeplan[upgradetype.type], entry.currentsoftware)
				end
				table.insert(software[upgradetype.type], entry)
			end
		elseif upgradetype.supertype == "virtualmacro" then
			slots[upgradetype.type] = {}
			for j = 1, tonumber(C.GetNumVirtualUpgradeSlots(object, "", upgradetype.type)) do
				-- convert index from lua to C-style
				slots[upgradetype.type][j] = { currentmacro = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(object, upgradetype.type, j)), possiblemacros = {} }
				if changeupgradeplan then
					local macro = slots[upgradetype.type][j].currentmacro
					local checkforeignmacro
					if canequip then
						if menu.objectgroup then
							local wareidx = menu.findUpgradeMacro(upgradetype.type, slots[upgradetype.type][j].currentmacro)
							if not wareidx then
								checkforeignmacro = true
							end
						end
					end
					menu.upgradeplan[upgradetype.type][j] = { macro = macro, ammomacro = "", weaponmode = "", checkforeignmacro = checkforeignmacro }
				end
			end
		end
	end

	-- add installed components in menu.upgradewares
	for type, slotsentry in pairs(slots) do
		for _, slot in ipairs(slotsentry) do
			if slot.currentmacro and (slot.currentmacro ~= "") then
				local i = menu.findUpgradeMacro(type, slot.currentmacro)
				if i then
					menu.upgradewares[type][i].objectamount = menu.upgradewares[type][i].objectamount + 1
				else
					table.insert(menu.upgradewares[type], { ware = GetMacroData(slot.currentmacro, "ware"), macro = slot.currentmacro, objectamount = 1, isFromShipyard = false })
				end
			end
		end
	end

	-- add installed ammo in menu.upgradewares
	for type, ammoentry in pairs(ammo) do
		for macro, amount in pairs(ammoentry) do
			local i = menu.findUpgradeMacro(type, macro)
			if i then
				menu.upgradewares[type][i].objectamount = menu.upgradewares[type][i].objectamount + amount
			else
				table.insert(menu.upgradewares[type], { ware = GetMacroData(macro, "ware"), macro = macro, objectamount = amount, isFromShipyard = false })
			end
		end
	end

	-- assemble possible ammo
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "ammo" then
			if ((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0) then
				if menu.upgradewares[upgradetype.type] then
					for _, upgradeware in ipairs(menu.upgradewares[upgradetype.type]) do
						if not ammo[upgradetype.type][upgradeware.macro] then
							ammo[upgradetype.type][upgradeware.macro] = 0
							if changeupgradeplan then
								menu.upgradeplan[upgradetype.type][upgradeware.macro] = 0
							end
						end
					end
				end
			end
		end
	end
end

function menu.prepareMacroUpgradeSlots(macro)
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			menu.slots[upgradetype.type] = {}
			for j = 1, tonumber(C.GetNumUpgradeSlots(0, macro, upgradetype.type)) do
				-- convert index from lua to C-style
				menu.slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {} }
				menu.upgradeplan[upgradetype.type][j] = { macro = "", ammomacro = "", weaponmode = "" }
			end
		elseif upgradetype.supertype == "ammo" then
			menu.ammo[upgradetype.type] = {}
		elseif upgradetype.supertype == "software" then
			menu.software[upgradetype.type] = {}
			local n = C.GetNumSoftwareSlots(0, macro)
			local buf = ffi.new("SoftwareSlot[?]", n)
			n = C.GetSoftwareSlots(buf, n, 0, macro)
			for j = 0, n - 1 do
				local entry = {}
				entry.maxsoftware = ffi.string(buf[j].max)
				entry.currentsoftware = ffi.string(buf[j].current)
				table.insert(menu.upgradeplan[upgradetype.type], entry.currentsoftware)
				table.insert(menu.software[upgradetype.type], entry)
			end
		elseif upgradetype.supertype == "virtualmacro" then
			menu.slots[upgradetype.type] = {}
			for j = 1, tonumber(C.GetNumVirtualUpgradeSlots(0, macro, upgradetype.type)) do
				-- convert index from lua to C-style
				menu.slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {} }
				menu.upgradeplan[upgradetype.type][j] = { macro = "", ammomacro = "", weaponmode = "" }
			end
		end
	end

	-- assemble possible ammo
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "ammo" then
			if menu.upgradewares[upgradetype.type] then
				for _, upgradeware in ipairs(menu.upgradewares[upgradetype.type]) do
					if not menu.ammo[upgradetype.type][upgradeware.macro] then
						menu.ammo[upgradetype.type][upgradeware.macro] = 0
						menu.upgradeplan[upgradetype.type][upgradeware.macro] = 0
					end
				end
			end
		end
	end
end

function menu.prepareComponentCrewInfo(object)
	local n = C.GetNumAllRoles()
	local buf = ffi.new("PeopleInfo[?]", n)
	n = C.GetPeople2(buf, n, object, true)
	local numhireable = 0
	for i = 0, n - 1 do
		if buf[i].canhire then
			numhireable = numhireable + 1
			menu.crew.roles[numhireable] = { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), desc = ffi.string(buf[i].desc), total = buf[i].amount, wanted = buf[i].amount, tiers = {}, canhire = buf[i].canhire }
			menu.crew.total = menu.crew.total + buf[i].amount
		
			local numtiers = buf[i].numtiers
			local buf2 = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(buf2, numtiers, object, menu.crew.roles[numhireable].id)
			for j = 0, numtiers - 1 do
				menu.crew.roles[numhireable].tiers[j + 1] = { skilllevel = buf2[j].skilllevel, name = ffi.string(buf2[j].name), total = buf2[j].amount, wanted = buf2[j].amount, npcs = {}, currentnpcs = {} }

				local numnpcs = buf2[j].amount
				local buf3 = ffi.new("NPCSeed[?]", numnpcs)
				numnpcs = C.GetRoleTierNPCs(buf3, numnpcs, object, menu.crew.roles[numhireable].id, menu.crew.roles[numhireable].tiers[j + 1].skilllevel)
				for k = 0, numnpcs - 1 do
					table.insert(menu.crew.roles[numhireable].tiers[j + 1].npcs, buf3[k])
					table.insert(menu.crew.roles[numhireable].tiers[j + 1].currentnpcs, buf3[k])
				end
			end
			if numtiers == 0 then
				menu.crew.roles[numhireable].tiers[1] = { skilllevel = 0, hidden = true, total = buf[i].amount, wanted = buf[i].amount, npcs = {}, currentnpcs = {} }
				local numnpcs = buf[i].amount
				local buf3 = ffi.new("NPCSeed[?]", numnpcs)
				numnpcs = C.GetRoleTierNPCs(buf3, numnpcs, object, menu.crew.roles[numhireable].id, 0)
				for k = 0, numnpcs - 1 do
					table.insert(menu.crew.roles[numhireable].tiers[1].npcs, buf3[k])
					table.insert(menu.crew.roles[numhireable].tiers[1].currentnpcs, buf3[k])
				end
			end
		end
	end

	menu.crew.capacity = C.GetPeopleCapacity(menu.object, menu.macro, false)
end

function menu.prepareMacroCrewInfo(macro)
	local n = C.GetNumAllRoles()
	local buf = ffi.new("PeopleInfo[?]", n)
	n = C.GetAllRoles(buf, n)
	local numhireable = 0
	for i = 0, n - 1 do
		if buf[i].canhire then
			numhireable = numhireable + 1
			menu.crew.roles[numhireable] = { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), desc = ffi.string(buf[i].desc), total = buf[i].amount, wanted = buf[i].amount, tiers = {}, canhire = buf[i].canhire }
			menu.crew.roles[numhireable].tiers[1] = { skilllevel = 0, hidden = true, total = buf[i].amount, wanted = buf[i].amount, npcs = {}, currentnpcs = {} }
			menu.crew.total = menu.crew.total + buf[i].amount
		end
	end

	menu.crew.capacity = C.GetPeopleCapacity(menu.object, menu.macro, false)
end

function menu.prepareModWares()
	menu.inventory = GetPlayerInventory()

	menu.modwares = {}
	local n = C.GetNumAvailableEquipmentMods()
	local buf = ffi.new("UIEquipmentMod[?]", n)
	n = C.GetAvailableEquipmentMods(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.ware = ffi.string(buf[i].Ware)

		local modclass, modquality, rawresources = GetWareData(entry.ware, "modclass", "modquality", "resources")
		entry.quality = modquality

		entry.resources = {}
		for _, resource in ipairs(rawresources or {}) do
			local resourcedata = menu.inventory[resource.ware]
			if resourcedata then
				local isprimarymodpart = GetWareData(resource.ware, "isprimarymodpart")
				local maxcraftable = math.floor(resourcedata.amount / resource.amount)
				entry.craftableamount = entry.craftableamount and math.min(maxcraftable, entry.craftableamount) or maxcraftable
				if not isprimarymodpart then
					entry.normalcraftableamount = entry.normalcraftableamount and math.min(maxcraftable, entry.normalcraftableamount) or maxcraftable
				end
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcedata.name, amount = resourcedata.amount, price = resourcedata.price, needed = resource.amount } })
			else
				local resourcename, resourcebuyprice, isprimarymodpart = GetWareData(resource.ware, "name", "buyprice", "isprimarymodpart")
				entry.craftableamount = 0
				if not isprimarymodpart then
					entry.normalcraftableamount = 0
				end
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcename, amount = 0, price = resourcebuyprice, needed = resource.amount } })
			end
		end

		if menu.modwares[modclass] then
			table.insert(menu.modwares[modclass], entry)
		else
			menu.modwares[modclass] = { entry }
		end
	end

	n = C.GetNumInventoryPaintMods()
	buf = ffi.new("UIPaintMod[?]", n)
	n = C.GetInventoryPaintMods(buf, n);
	for i = 0, n - 1 do
		local entry = {}
		entry.name = ffi.string(buf[i].Name)
		entry.ware = ffi.string(buf[i].Ware)
		entry.quality = buf[i].Quality
		entry.amount = buf[i].Amount

		if menu.modwares["paint"] then
			table.insert(menu.modwares["paint"], entry)
		else
			menu.modwares["paint"] = { entry }
		end
	end
end

function menu.determineNeededRepairs(ship)
	local damagedcomponents = {}

	Helper.ffiVLA(damagedcomponents, "UniverseID", C.GetNumSubComponents, C.GetDamagedSubComponents, ship)

	local hullpercent = GetComponentData(ConvertStringToLuaID(tostring(ship)), "hullpercent")
	if hullpercent < 100 then
		-- NB: we want this to be the last entry so that it will appear first because we then go over damagedcomponents in reverse order.
		table.insert(damagedcomponents, ship)
	end

	return damagedcomponents
end

function menu.findWareIdx(array, ware)
	for i, v in ipairs(array) do
		if v.ware == ware then
			return i
		end
	end
end

function menu.insertWare(array, objectarray, category, ware, count, pricetype)
	local array2 = array
	if category then
		array[category] = array[category] or {}
		array2 = array[category]
	end
	local objectarray2 = objectarray
	if objectarray then
		if category then
			objectarray[category] = objectarray[category] or {}
			objectarray2 = objectarray[category]
		end
	end
	local price = 0
	local i = menu.findWareIdx(array2, ware)
	if i then
		array2[i].amount = array2[i].amount + count
	else
		if menu.container then
			if pricetype == "normal" then
				local isvolatile = GetWareData(ware, "volatile")
				price = isvolatile and 0 or tonumber(C.GetBuildWarePrice(menu.container, ware))
			elseif pricetype == "software" then
				price = C.GetContainerBuildPriceFactor(menu.container) * GetContainerWarePrice(ConvertStringToLuaID(tostring(menu.container)), ware, false)
			elseif pricetype == "crew" then
				price = menu.crew.price
			end
		end
		table.insert(array2, { ware = ware, amount = count, price = price })
	end
	if objectarray then
		local i = menu.findWareIdx(objectarray2, ware)
		if i then
			objectarray2[i].amount = objectarray2[i].amount + count
		else
			if menu.container and (price == 0) then
				if pricetype == "normal" then
					local isvolatile = GetWareData(ware, "volatile")
					price = isvolatile and 0 or tonumber(C.GetBuildWarePrice(menu.container, ware))
				elseif pricetype == "software" then
					price = C.GetContainerBuildPriceFactor(menu.container) * GetContainerWarePrice(ConvertStringToLuaID(tostring(menu.container)), ware, false)
				elseif pricetype == "crew" then
					price = menu.crew.price
				end
			end
			table.insert(objectarray2, { ware = ware, amount = count, price = price })
		end
	end
end

function menu.insertComponent(array, objectarray, component, pricetype)
	local price
	if pricetype == "normal" then
		price = tonumber(C.GetRepairPrice(ConvertStringTo64Bit(component), menu.container)) * menu.repairdiscounts.totalfactor
	end
	table.insert(array, { component = component, price = price })
	table.insert(objectarray, { component = component, price = price })
end

function menu.getLoadoutSummary(upgradeplan, crew, repairplan)
	local wareAmounts = {}

	for i, upgradetype in ipairs(Helper.upgradetypes) do
		local slots = upgradeplan[upgradetype.type]
		local first = true
		for slot, macro in pairs(slots) do
			if first or (not upgradetype.mergeslots) then
				first = false
				if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
					local data = macro
					if data.macro ~= "" then
						local upgradeware = GetMacroData(data.macro, "ware")
						menu.insertWare(wareAmounts, nil, nil, upgradeware, (upgradetype.mergeslots and #slots or data.count))
					end
				elseif (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					local data = macro
					if data.macro ~= "" then
						local upgradeware = GetMacroData(data.macro, "ware")
						menu.insertWare(wareAmounts, nil, nil, upgradeware, (upgradetype.mergeslots and #slots or 1))
					end
				elseif upgradetype.supertype == "ammo" then
					local new = macro
					local macro = slot
					if new > 0 then
						local upgradeware = GetMacroData(macro, "ware")
						menu.insertWare(wareAmounts, nil, nil, upgradeware, new)
					end
				elseif upgradetype.supertype == "software" then
					local newware = macro
					if newware ~= "" then
						menu.insertWare(wareAmounts, nil, nil, newware, 1)
					end
				end
			end
		end
	end

	-- Crew
	if (crew.total + crew.hired - #crew.fired) > 0 then
		menu.insertWare(wareAmounts, nil, nil, crew.ware, crew.total + crew.hired - #crew.fired)
	end

	local summary = ReadText(1001, 7935) .. ReadText(1001, 120)
	for _, entry in ipairs(wareAmounts) do
		summary = summary .. "\n" .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
	end

	-- Repair
	if repairplan then
		for componentidstring in pairs(repairplan) do
			if componentidstring ~= "processed" then
				summary = summary .. "\n" .. ReadText(1001, 4217) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(ConvertStringTo64Bit(componentidstring))) .. " (" .. (100 - GetComponentData(ConvertStringTo64Bit(componentidstring), "hullpercent")) .. "% " .. ReadText(1001, 1) .. ")"
			end
		end
	end

	return summary
end

function menu.getModUpgradeMode(upgradetype)
	for i, entry in ipairs(config.leftBarMods) do
		if entry.upgrademode == upgradetype then
			return entry.mode
		end
	end
end

function menu.sortAmmo(a, b)
	local atype, btype = "", ""
	if IsMacroClass(a, "satellite") then
		atype = "satellite"
	elseif IsMacroClass(a, "navbeacon") then
		atype = "navbeacon"
	elseif IsMacroClass(a, "resourceprobe") then
		atype = "resourceprobe"
	elseif IsMacroClass(a, "mine") then
		atype = "mine"
	elseif GetMacroData(a, "islasertower") then
		atype = "lasertower"
	end
	if IsMacroClass(b, "satellite") then
		btype = "satellite"
	elseif IsMacroClass(b, "navbeacon") then
		btype = "navbeacon"
	elseif IsMacroClass(b, "resourceprobe") then
		btype = "resourceprobe"
	elseif IsMacroClass(b, "mine") then
		btype = "mine"
	elseif GetMacroData(b, "islasertower") then
		btype = "lasertower"
	end

	if atype == btype then
		return Helper.sortMacroName(a, b)
	end
	return config.deployableOrder[atype] < config.deployableOrder[btype]
end

function menu.findMacroIdx(array, macro)
	for i, v in ipairs(array) do
		if v.macro == macro then
			return i
		end
	end
end

function menu.setupGroupData(object, macro, groups, changeupgradeplan)
	local sizecounts = { engine = {}, turret = {} }
	local n = C.GetNumUpgradeGroups(object, macro)
	local buf = ffi.new("UpgradeGroup[?]", n)
	n = C.GetUpgradeGroups(buf, n, object, macro)
	for i = 0, n - 1 do
		if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
			table.insert(groups, { path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) })
			local group = groups[#groups]
			for j, upgradetype in ipairs(Helper.upgradetypes) do
				if upgradetype.supertype == "group" then
					local groupinfo = C.GetUpgradeGroupInfo(object, macro, group.path, group.group, upgradetype.grouptype)
					local currentmacro = ffi.string(groupinfo.currentmacro)
					local slotsize = ffi.string(groupinfo.slotsize)

					local compatibilities
					local n_comp = C.GetNumUpgradeGroupCompatibilities(object, macro, 0, group.path, group.group, upgradetype.grouptype)
					if n_comp > 0 then
						compatibilities = {}
						local buf_comp = ffi.new("EquipmentCompatibilityInfo[?]", n)
						n_comp = C.GetUpgradeGroupCompatibilities(buf_comp, n_comp, object, macro, 0, group.path, group.group, upgradetype.grouptype)
						for k = 0, n_comp - 1 do
							compatibilities[ffi.string(buf_comp[k].tag)] = ffi.string(buf_comp[k].name)
						end
					end

					groups[#groups][upgradetype.grouptype] = { count = groupinfo.count, operational = groupinfo.operational, total = groupinfo.total, slotsize = slotsize, compatibilities = compatibilities, currentcomponent = (groupinfo.currentcomponent ~= 0) and groupinfo.currentcomponent or nil, currentmacro = currentmacro, possiblemacros = {} }
					if upgradetype.grouptype ~= "shield" then
						groups[#groups].slotsize = slotsize
						groups[#groups].compatibilities = compatibilities

						if groups[#groups][upgradetype.grouptype].total > 0 then
							groups[#groups].groupname = #groups
							if slotsize ~= "" then
								if sizecounts[upgradetype.grouptype][slotsize] then
									sizecounts[upgradetype.grouptype][slotsize] = sizecounts[upgradetype.grouptype][slotsize] + 1
								else
									sizecounts[upgradetype.grouptype][slotsize] = 1
								end
								groups[#groups].groupname = upgradetype.shorttext[slotsize] .. sizecounts[upgradetype.grouptype][slotsize]
							end
						end
					end
					if changeupgradeplan then
						local weaponmode = ""
						if object ~= 0 then
							weaponmode = ffi.string(C.GetTurretGroupMode2(object, 0, group.path, group.group))
						end
						menu.upgradeplan[upgradetype.type][#groups] = { macro = currentmacro, count = groupinfo.count, path = group.path, group = group.group, ammomacro = "", weaponmode = weaponmode }
						if currentmacro ~= "" then
							local i = menu.findUpgradeMacro(upgradetype.grouptype, currentmacro)
							if i then
								if menu.objectgroup then
									if not menu.upgradewares[upgradetype.grouptype][i].isFromShipyard then
										menu.upgradeplan[upgradetype.type][#groups].checkforeignmacro = true
									end
								end
								menu.upgradewares[upgradetype.grouptype][i].objectamount = menu.upgradewares[upgradetype.grouptype][i].objectamount + groupinfo.count
							else
								if menu.objectgroup then
									menu.upgradeplan[upgradetype.type][#groups].checkforeignmacro = true
								end
								table.insert(menu.upgradewares[upgradetype.grouptype], { ware = GetMacroData(currentmacro, "ware"), macro = currentmacro, objectamount = groupinfo.count, isFromShipyard = false })
							end
						end
					end
				end
			end
		end
	end
end

function menu.repairandupgrade(shoppinglistentry, object, macro, hasupgrades, haspaid, objectprice, objectcrewprice)
	local objectstring = tostring(object)
	if (object ~= 0) and menu.repairplan[objectstring] and next(menu.repairplan[objectstring]) and (not menu.repairplan[objectstring]["processed"]) then
		local skip = menu.checkCommanderRepairOrders(objectstring)
		if not skip then
			--print("pilot: " .. tostring(GetComponentData(ConvertStringTo64Bit(objectstring), "pilot")) .. ", cond: " .. tostring( (object == C.GetPlayerOccupiedShipID()) or not GetComponentData(ConvertStringTo64Bit(objectstring), "pilot") ) .. " cond1: " .. tostring(object == C.GetPlayerOccupiedShipID()) .. " cond2: " .. tostring(not GetComponentData(ConvertStringTo64Bit(objectstring), "pilot")))
			if (C.GetTopLevelContainer(object) == menu.container) then
				local damagedcomponents = {}
				for componentidstring, _ in pairs(menu.repairplan[objectstring]) do
					if componentidstring ~= "processed" and componentidstring ~= objectstring then
						table.insert(damagedcomponents, ConvertStringToLuaID(componentidstring))
					end
				end

				-- signal received in build.shiptrader
				-- param = "'repairs_initiate'", param2 = $shiptoberepaired, param3 = [hullpercent(int), damagedcomponents(list)]
				--print("signalling " .. ffi.string(C.GetComponentName(menu.container)) .. " to repair " .. ffi.string(C.GetComponentName(object)) .. " " .. objectstring)
				SignalObject(menu.container, "repairs_initiate", ConvertStringToLuaID(objectstring), {100, damagedcomponents})
			else
				local orderindex = C.CreateOrder(object, "Repair", false)
				if orderindex > 0 then
					menu.processRepairsFor(objectstring, orderindex)

					-- in this case, signal is sent from order.repair
					if not C.EnableOrder(object, orderindex) then
						print("ERROR: Order to initiate repairs for " .. ffi.string(C.GetComponentName(entry.object)) .. " was not enabled.")
					end
				end
			end
		end
	end

	if hasupgrades then
		for i = 1, shoppinglistentry.amount do
			local numblacklisttypes = 0
			for _ in pairs(shoppinglistentry.settings.blacklists) do
				numblacklisttypes = numblacklisttypes + 1
			end
			local blacklists = ffi.new("BlacklistTypeID[?]", numblacklisttypes)
			local i = 0
			for blacklisttype, id in pairs(shoppinglistentry.settings.blacklists) do
				blacklists[i].type = blacklisttype
				blacklists[i].id = id
				i = i + 1
			end

			local numfightruletypes = 0
			for _ in pairs(shoppinglistentry.settings.fightrules) do
				numfightruletypes = numfightruletypes + 1
			end
			local fightrules = ffi.new("FightRuleTypeID[?]", numfightruletypes)
			local i = 0
			for fightruletype, id in pairs(shoppinglistentry.settings.fightrules) do
				fightrules[i].type = fightruletype
				fightrules[i].id = id
				print(id)
				i = i + 1
			end

			local additionalinfo = ffi.new("AddBuildTask5Container", {
				blacklists = blacklists,
				numblacklists = numblacklisttypes,
				fightrules = fightrules,
				numfightrules = numfightruletypes
			})

			local buildtaskid = Helper.callLoadoutFunction(shoppinglistentry.upgradeplan, shoppinglistentry.crew, function (loadout, crewtransfer) return C.AddBuildTask5(menu.container, object, macro, loadout, menu.isplayerowned and 0 or (objectprice or shoppinglistentry.price), crewtransfer, menu.immediate, shoppinglistentry.customshipname, additionalinfo) end, nil, "UILoadout2")
			if (buildtaskid ~= 0) and haspaid then
				C.SetBuildTaskTransferredMoney(buildtaskid, objectprice and (objectprice + objectcrewprice) or haspaid)
			end
		end
	end
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- displaySlots_on_before_create_button_mouseovertext ()
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuertee end

init()
﻿-- section == cArch_configureStation
-- param == { 0, 0, container }
 
-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t TradeID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* tag;
		const char* name;
	} EquipmentCompatibilityInfo;
	typedef struct {
		const char* id;
		const char* name;
		int32_t state;
		const char* requiredversion;
		const char* installedversion;
	} InvalidPatchInfo;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		const char* name;
		const char* id;
		const char* source;
		bool deleteable;
	} UIConstructionPlan;
	typedef struct {
		const char* filename;
		const char* name;
		const char* id;
	} UIConstructionPlanInfo;
	typedef struct {
		const char* macro;
		uint32_t amount;
		bool optional;
	} UILoadoutAmmoData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
	} UILoadoutGroupData;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
	} UILoadoutMacroData;
	typedef struct {
		const char* ware;
	} UILoadoutSoftwareData;
	typedef struct {
		const char* macro;
		bool optional;
	} UILoadoutVirtualMacroData;
	typedef struct {
		uint32_t numweapons;
		uint32_t numturrets;
		uint32_t numshields;
		uint32_t numengines;
		uint32_t numturretgroups;
		uint32_t numshieldgroups;
		uint32_t numammo;
		uint32_t numunits;
		uint32_t numsoftware;
	} UILoadoutCounts;
	typedef struct {
		UILoadoutMacroData* weapons;
		uint32_t numweapons;
		UILoadoutMacroData* turrets;
		uint32_t numturrets;
		UILoadoutMacroData* shields;
		uint32_t numshields;
		UILoadoutMacroData* engines;
		uint32_t numengines;
		UILoadoutGroupData* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
	} UILoadout;
	typedef struct {
		const char* id;
		const char* name;
		const char* iconid;
		bool deleteable;
	} UILoadoutInfo;
	typedef struct {
		const char* upgradetype;
		size_t slot;
	} UILoadoutSlot;
	typedef struct {
		const char* macro;
		uint32_t amount;
	} UIMacroCount;
	typedef struct {
		const float x;
		const float y;
		const float z;
		const float yaw;
		const float pitch;
		const float roll;
	} UIPosRot;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* path;
		const char* group;
	} UpgradeGroup;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		UniverseID reserverid;
		const char* ware;
		uint32_t amount;
		bool isbuyreservation;
		double eta;
		TradeID tradedealid;
		MissionID missionid;
		bool isvirtual;
		bool issupply;
	} WareReservationInfo2;

	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	void AddFloatingSequenceToConstructionPlan(UniverseID holomapid);
	void AddCopyToConstructionMap(UniverseID holomapid, size_t cp_idx, bool copysequence);
	void AddMacroToConstructionMap(UniverseID holomapid, const char* macroname, bool startdragging);
	bool AreConstructionPlanLoadoutsCompatible(const char* constructionplanid);
	bool CanBuildLoadout(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	bool CancelPlayerInvolvedTradeDeal(UniverseID containerid, TradeID tradeid, bool checkonly);
	bool CanOpenWebBrowser(void);
	bool CheckConstructionPlanForMacros(const char* constructionplanid, const char** macroids, uint32_t nummacroids);
	void ClearBuildMapSelection(UniverseID holomapid);
	bool CompareMapConstructionSequenceWithPlanned(UniverseID holomapid, UniverseID defensibleid, bool usestoredplan);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	void DeselectMacroForConstructionMap(UniverseID holomapid);
	bool DoesConstructionSequenceRequireBuilder(UniverseID containerid);
	void ExportMapConstructionPlan(UniverseID holomapid, const char* filename, const char* id, bool overwrite, const char* name, const char* desc);
	void ForceBuildCompletion(UniverseID containerid);
	void GenerateModuleLoadout(UILoadout* result, UniverseID holomapid, size_t cp_idx, UniverseID defensibleid, float level);
	void GenerateModuleLoadoutCounts(UILoadoutCounts* result, UniverseID holomapid, size_t cp_idx, UniverseID defensibleid, float level);
	uint32_t GetAssignedConstructionVessels(UniverseID* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	size_t GetBuildMapConstructionPlan(UniverseID holomapid, UniverseID defensibleid, bool usestoredplan, UIConstructionPlanEntry* result, uint32_t resultlen);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetCargo(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, const char* tags);
	uint32_t GetConstructionPlanInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, const char* constructionplanid);
	uint32_t GetConstructionPlans(UIConstructionPlan* result, uint32_t resultlen);
	void GetConstructionMapItemLoadout2(UILoadout* result, UniverseID holomapid, size_t itemidx, UniverseID defensibleid, UniverseID moduleid);
	void GetConstructionMapItemLoadoutCounts2(UILoadoutCounts* result, UniverseID holomapid, size_t itemidx, UniverseID defensibleid, UniverseID moduleid);
	size_t GetConstructionMapVenturePlatform(UniverseID holomapid, size_t venturedockidx);
	float GetContainerGlobalPriceFactor(UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	uint32_t GetContainerWareReservations2(WareReservationInfo2* result, uint32_t resultlen, UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	float GetCurrentBuildProgress(UniverseID containerid);
	void GetCurrentLoadout(UILoadout* result, UniverseID defensibleid, UniverseID moduleid);
	void GetCurrentLoadoutCounts(UILoadoutCounts* result, UniverseID defensibleid, UniverseID moduleid);
	float GetDefensibleLoadoutLevel(UniverseID defensibleid);
	const char* GetGameStartName();
	uint32_t GetImportableConstructionPlans(UIConstructionPlanInfo* result, uint32_t resultlen);
	void GetLoadout(UILoadout* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutCounts(UILoadoutCounts* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutsInfo(UILoadoutInfo* result, uint32_t resultlen, UniverseID componentid, const char* macroname);
	const char* GetMissingConstructionPlanBlueprints3(UniverseID containerid, UniverseID holomapid, const char* constructionplanid, bool useplanned);
	uint32_t GetNumAssignedConstructionVessels(UniverseID containerid);
	uint32_t GetNumBlueprints(const char* set, const char* category, const char* macroname);
	size_t GetNumBuildMapConstructionPlan(UniverseID holomapid, bool usestoredplan);
	uint32_t GetNumCargo(UniverseID containerid, const char* tags);
	uint32_t GetNumConstructionMapVenturePlatformDocks(UniverseID holomapid, size_t ventureplatformidx);
	uint32_t GetNumConstructionPlans(void);
	uint32_t GetNumContainerWareReservations2(UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	uint32_t GetNumImportableConstructionPlans();
	uint32_t GetNumLoadoutsInfo(UniverseID componentid, const char* macroname);
	uint32_t GetNumPlannedLimitedModules(const char* constructionplanid);
	uint32_t GetNumRemovedConstructionPlanModules2(UniverseID holomapid, UniverseID defensibleid, uint32_t* newIndex, bool usestoredplan, uint32_t* numChangedIndices, bool checkupgrades);
	uint32_t GetNumUpgradeGroupCompatibilities(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumUsedLimitedModules(UniverseID excludedstationid);
	uint32_t GetNumUsedLimitedModulesFromSubsequence(UniverseID holomapid, size_t cp_idx);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	const char* GetObjectIDCode(UniverseID objectid);
	bool GetPickedBuildMapEntry2(UniverseID holomapid, UniverseID defensibleid, UIConstructionPlanEntry* result, bool requirecomponentid);
	void SelectPickedBuildMapEntry(UniverseID holomapid);
	bool GetPickedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadoutSlot* result);
	uint32_t GetPlannedLimitedModules(UIMacroCount* result, uint32_t resultlen, const char* constructionplanid);
	uint32_t GetRemovedConstructionPlanModules2(UniverseID* result, uint32_t resultlen, uint32_t* changedIndices, uint32_t* numChangedIndices);
	size_t GetSelectedBuildMapEntry(UniverseID holomapid);
	uint32_t GetUpgradeGroupCompatibilities(EquipmentCompatibilityInfo* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	UpgradeGroupInfo GetUpgradeGroupInfo(UniverseID destructibleid, const char* macroname, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups(UpgradeGroup* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	const char* GetUpgradeSlotCurrentMacro(UniverseID objectid, UniverseID moduleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	uint32_t GetUsedLimitedModules(UIMacroCount* result, uint32_t resultlen, UniverseID excludedstationid);
	uint32_t GetUsedLimitedModulesFromSubsequence(UIMacroCount* result, uint32_t resultlen, UniverseID holomapid, size_t cp_idx);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	void ImportMapConstructionPlan(const char* filename, const char* id);
	bool IsBuildWaitingForSecondaryComponentResources(UniverseID containerid);
	bool IsConstructionPlanValid(const char* constructionplanid, uint32_t* numinvalidpatches);
	bool IsLoadoutCompatible(const char* macroname, const char* loadoutid);
	bool IsLoadoutValid(UniverseID defensibleid, const char* macroname, const char* loadoutid, uint32_t* numinvalidpatches);
	bool IsIconValid(const char* iconid);
	bool IsMasterVersion(void);
	bool IsNextStartAnimationSkipped(bool reset);
	bool IsPlayerTradeRuleDefault(TradeRuleID id, const char* ruletype);
	bool IsUpgradeGroupMacroCompatible(UniverseID destructibleid, const char* macroname, const char* path, const char* group, const char* upgradetypename, const char* upgrademacroname);
	bool IsUpgradeMacroCompatible(UniverseID objectid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool IsValidTrade(TradeID tradeid);
	bool IsVentureExtensionSupported(void);
	bool IsVentureSeasonSupported(void);
	void OpenWebBrowser(const char* url);
	void ReleaseConstructionMapState(void);
	bool RemoveConstructionPlan(const char* source, const char* id);
	void RemoveFloatingSequenceFromConstructionPlan(UniverseID holomapid);
	void RemoveItemFromConstructionMap2(UniverseID holomapid, size_t itemidx, bool removesequence);
	bool RemoveOrder2(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly, bool onlyimmediate);
	void ResetConstructionMapModuleRotation(UniverseID holomapid, size_t cp_idx);
	void ResetMapPlayerRotation(UniverseID holomapid);
	void SaveLoadout(const char* macroname, UILoadout uiloadout, const char* source, const char* id, bool overwrite, const char* name, const char* desc);
	void SaveMapConstructionPlan(UniverseID holomapid, const char* source, const char* id, bool overwrite, const char* name, const char* desc);
	void SelectBuildMapEntry(UniverseID holomapid, size_t cp_idx);
	void SetConstructionMapBuildAngleStep(UniverseID holomapid, float angle);
	void SetConstructionMapCollisionDetection(UniverseID holomapid, bool value);
	void SetConstructionMapRenderSectorBackground(UniverseID holomapid, bool value);
	void SetConstructionSequenceFromConstructionMap(UniverseID containerid, UniverseID holomapid);
	void SetContainerGlobalPriceFactor(UniverseID containerid, float value);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetFocusMapConstructionPlanEntry(UniverseID holomapid, size_t cp_idx, bool resetplayerpan);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetSelectedMapGroup(UniverseID holomapid, UniverseID destructibleid, const char* macroname, const char* path, const char* group);
	void SetSelectedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	void SetupConstructionSequenceModulesCache(UniverseID holomapid, UniverseID defensibleid, bool enable);
	void ShowConstructionMap(UniverseID holomapid, UniverseID stationid, const char* constructionplanid, bool restore);
	void ShowObjectConfigurationMap2(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout, size_t cp_idx);
	bool ShuffleMapConstructionPlan(UniverseID holomapid, bool checkonly);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void StoreConstructionMapState(UniverseID holomapid);
	void UpdateConstructionMapItemLoadout(UniverseID holomapid, size_t itemidx, UniverseID defensibleid, UILoadout uiloadout);
	void UpdateObjectConfigurationMap(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout);
	void ZoomMap(UniverseID holomapid, float zoomstep);
	bool CanUndoConstructionMapChange(UniverseID holomapid);
	void UndoConstructionMapChange(UniverseID holomapid);
	bool CanRedoConstructionMapChange(UniverseID holomapid);
	void RedoConstructionMapChange(UniverseID holomapid);

	uint32_t PrepareBuildSequenceResources2(UniverseID holomapid, UniverseID stationid, bool useplanned);
	uint32_t GetBuildSequenceResources(UIWareInfo* result, uint32_t resultlen);
	uint32_t GetNumModuleRecycledResources(UniverseID moduleid);
	uint32_t GetModuleRecycledResources(UIWareInfo* result, uint32_t resultlen, UniverseID moduleid);
	uint32_t GetNumModuleNeededResources(UniverseID holomapid, size_t cp_idx);
	uint32_t GetModuleNeededResources(UIWareInfo* result, uint32_t resultlen, UniverseID holomapid, size_t cp_idx);
	void SetContainerBuildMethod(UniverseID containerid, const char* buildmethodid);
]]

local utf8 = require("utf8")

local menu = {
	name = "StationConfigurationMenu",
	newWareReservationWares = {},
	externalUsedLimitedModules = {},
	usedLimitedModules = {},
	currentConstructions = {},
	dirtyreservations = {},
}

local config = {
	mainLayer = 5,
	infoLayer = 4,
	contextLayer = 2,
	leftBar = {
		{ name = ReadText(1001, 2421),	icon = "stationbuildst_production",		mode = "moduletypes_production",	helpOverlayID = "stationbuildst_production",	helpOverlayText = ReadText(1028, 3250) },
		{ name = ReadText(1001, 2439),	icon = "stationbuildst_buildmodule",	mode = "moduletypes_build",			helpOverlayID = "stationbuildst_buildmodule",	helpOverlayText = ReadText(1028, 3251) },
		{ name = ReadText(1001, 2422),	icon = "stationbuildst_storage",		mode = "moduletypes_storage",		helpOverlayID = "stationbuildst_storage",		helpOverlayText = ReadText(1028, 3252) },
		{ name = ReadText(1001, 2451),	icon = "stationbuildst_habitation",		mode = "moduletypes_habitation",	helpOverlayID = "stationbuildst_habitation",	helpOverlayText = ReadText(1028, 3253) },
		{ name = ReadText(1001, 9620),	icon = "stationbuildst_welfare",		mode = "moduletypes_welfare",		helpOverlayID = "stationbuildst_welfare",		helpOverlayText = ReadText(1028, 3258) },
		{ name = ReadText(1001, 2452),	icon = "stationbuildst_dock",			mode = "moduletypes_dock",			helpOverlayID = "stationbuildst_dock",			helpOverlayText = ReadText(1028, 3254) },
		{ name = ReadText(1001, 2424),	icon = "stationbuildst_defense",		mode = "moduletypes_defence",		helpOverlayID = "stationbuildst_defense",		helpOverlayText = ReadText(1028, 3255) },
		{ name = ReadText(1001, 9621),	icon = "stationbuildst_processing",		mode = "moduletypes_processing",	helpOverlayID = "stationbuildst_processing",	helpOverlayText = ReadText(1028, 3259) },
		{ name = ReadText(1001, 2453),	icon = "stationbuildst_other",			mode = "moduletypes_other",			helpOverlayID = "stationbuildst_other",			helpOverlayText = ReadText(1028, 3256) },
		{ name = ReadText(1001, 2454),	icon = "stationbuildst_venture",		mode = "moduletypes_venture",		helpOverlayID = "stationbuildst_venture",		helpOverlayText = ReadText(1028, 3257),		condition = C.IsVentureSeasonSupported },
	},
	leftBarLoadout = {
		{ name = ReadText(1001, 7901),	icon = "shipbuildst_turretgroups",		mode = "turretgroup" },
	},
	equipmentBlueprintGroups = {
		{ type = "turret", library = "weapons_turrets" },
		{ type = "turret", library = "weapons_missileturrets" },
		{ type = "shield", library = "shieldgentypes" },
	},
	dropDownTextProperties = {
		halign = "center",
		font = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Helper.color.white,
		x = 0,
		y = 0
	},
	scaleSize = 2,
	stateKeys = {
		{ "container", "UniverseID" },
		{ "buildstorage", "UniverseID" },
		{ "loadoutModuleIdx" },
		{ "modulesMode", },
		-- { "upgradeplan" }, -- reserved for loadoutModuleIdx information
		{ "origDefaultLoadout", "bool" },
	},
	sizeSorting = {
		["small"] = 1,
		["medium"] = 2,
		["large"] = 3,
		["extralarge"] = 4,
	},
	maxSidePanelWidth = 800,
	maxCenterPanelWidth = 1600,
	fileExtension = ".xml",
	slotSizeOrder = {
		["extralarge"]	= 1,
		["large"]		= 2,
		["medium"]		= 3,
		["small"]		= 4,
	},
	compatibilityFontSize = 5,
	mapfilterversion = 1,
	discreteAngleSlider = {
		min = 5,
		max = 180,
		step = 5,
	},
	moduleFilterWidth = 300,
}

__CORE_DETAILMONITOR_STATIONBUILD = __CORE_DETAILMONITOR_STATIONBUILD or {
	version = config.mapfilterversion,
	["discreteanglestep"] = 15.,
	["moduleoverlap"] = false,
	["environment"] = true,
}

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	menu.extendedentries = {}
	menu.extendedresourceentries = {}

	if __CORE_DETAILMONITOR_STATIONBUILD.version < config.mapfilterversion then
		menu.upgradeSettingsVersion()
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_station_configuration.xpl.init - kuertee")
end
-- kuertee end

function menu.cleanup()
	UnregisterEvent("newWareReservation", menu.newWareReservationCallback)

	menu.container = nil
	menu.buildstorage = nil
	menu.modules = {}
	menu.modulesMode = nil
	menu.planMode = nil
	menu.searchtext = ""
	menu.modulesearchtext = {}
	menu.loadoutName = ""
	menu.loadout = nil
	menu.activatemap = nil
	menu.constructionplan = {}
	menu.constructionplans = {}
	menu.groupedmodules = {}
	menu.groupedupgrades = {}
	menu.groupedslots = {}
	menu.loadoutMode = nil
	menu.loadoutPlanMode = nil
	menu.loadoutModule = {}
	menu.upgradetypeMode = nil
	menu.currentSlot = nil
	menu.slots = {}
	menu.groups = {}
	menu.newAccountValue = nil
	menu.newWareReservation = nil
	menu.newWareReservationWares = {}
	menu.selectedModule = nil
	menu.newSelectedModule = nil
	menu.externalUsedLimitedModules = {}
	menu.usedLimitedModules = {}
	menu.haschanges = nil
	menu.hasconstructionchanges = nil
	menu.currentConstructions = {}
	menu.defaultLoadout = nil
	menu.origDefaultLoadout = nil

	menu.picking = true
	menu.cancelRequested = nil
	menu.noupdate = nil
	menu.allowpanning = nil
	menu.allowrotating = nil

	SetMouseOverOverride(menu.map, nil)

	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end

	menu.frameworkData = {}
	menu.modulesData = {}
	menu.planData = {}
	menu.titleData = {}
	menu.mapData = {}

	menu.leftbartable = nil
	menu.rightbartable = nil
	menu.titlebartable = nil
	menu.map = nil
	menu.moduletable = nil
	menu.plantable = nil
	menu.contextFrame = nil
	menu.contextMode = nil

	menu.currentCPID = nil
	menu.currentCPName = nil
	menu.canundo = nil
	menu.canredo = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	
	UnregisterAddonBindings("ego_detailmonitor", "undo")

	-- kuertee start: callback
	if callbacks ["cleanup"] then
		for _, callback in ipairs (callbacks ["cleanup"]) do
			callback ()
		end
	end
	-- kuertee end: callback
end

-- button scripts

function menu.buttonLeftBar(mode, row)
	menu.prevModulesMode = menu.modulesMode
	AddUITriggeredEvent(menu.name, mode, menu.modulesMode == mode and "off" or "on")
	if menu.modulesMode == mode then
		PlaySound("ui_negative_back")
		menu.modulesMode = nil
	else
		menu.setdefaulttable = true
		PlaySound("ui_positive_select")
		menu.modulesMode = mode
	end
	
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonLeftBarLoadout(mode, row)
	menu.prevUpgradetypeMode = menu.upgradetypeMode
	AddUITriggeredEvent(menu.name, mode, menu.upgradetypeMode == mode and "off" or "on")
	if menu.upgradetypeMode == mode then
		PlaySound("ui_negative_back")
		menu.upgradetypeMode = nil
	else
		menu.setdefaulttable = true
		PlaySound("ui_positive_select")
		menu.upgradetypeMode = mode
	end
	menu.determineInitialSlot()

	if menu.upgradetypeMode == "turretgroup" then
		local group = menu.groups[menu.currentSlot]
		C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
	else
		C.ClearSelectedMapMacroSlots(menu.holomap)
	end

	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.deactivateModulesMode()
	menu.prevModulesMode = menu.modulesMode
	PlaySound("ui_negative_back")
	menu.modulesMode = nil
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.deactivateUpgradetypeMode()
	menu.prevUpgradetypeMode = menu.upgradetypeMode
	PlaySound("ui_negative_back")
	menu.upgradetypeMode = nil
	menu.determineInitialSlot()
	C.ClearSelectedMapMacroSlots(menu.holomap)
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonRightBar(newmenu, params)
	menu.state = menu.onSaveState()
	Helper.registerStationEditorState(menu)

	Helper.closeMenuAndOpenNewMenu(menu, newmenu, params, true)
	menu.cleanup()
end

function menu.buttonRightBarSelf()
	if not menu.loadoutMode then
		if menu.planMode then
			menu.planMode = nil
		else
			menu.planMode = "construction"
		end
	else
		if menu.loadoutPlanMode then
			menu.loadoutPlanMode = nil
		else
			menu.loadoutPlanMode = "normal"
		end
	end
	menu.displayMenu()
end

function menu.buttonSelectSlot(slot, row, col)
	if menu.currentSlot ~= slot then
		menu.currentSlot = slot
	end
	
	if menu.upgradetypeMode == "turretgroup" then
		local group = menu.groups[menu.currentSlot]
		C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
	end
	
	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = row
	menu.selectedCols.modules = col
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonSelectGroupUpgrade(type, group, macro, row, col, keepcontext)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if macro ~= menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].macro then
			menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].macro = macro
			if (macro ~= "") and (menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count == 0) then
				menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count = 1
			elseif (macro == "") and (menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count ~= 0) then
				menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count = 0
			end
			
			menu.topRows.modules = GetTopRow(menu.moduletable)
			menu.selectedRows.modules = row
			menu.selectedCols.modules = col
			menu.storePlanTableState()
			menu.refreshPlan()
			menu.displayMenu()
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextMenu()
	end
end

function menu.buttonClearEditbox(row)
	Helper.cancelEditBoxInput(menu.moduletable, row, 1)
	menu.searchtext = ""

	menu.displayMenu()
end

function menu.buttonExtendEntry(index, row)
	menu.extendEntry(menu.container, index)
	
	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
	menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
	menu.storePlanTableState()
	menu.selectedRows.plan = row
	menu.displayMenu()
end

function menu.buttonExtendResourceEntry(index, row)
	menu.extendResourceEntry(index)
	
	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
	menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
	menu.storePlanTableState()
	menu.selectedRows.planresources = row
	menu.displayMenu()
end

function menu.buttonAddModule(macro, row, col)
	C.AddMacroToConstructionMap(menu.holomap, macro, true)
	menu.floatingNewModule = macro
	SetMouseCursorOverride("crossarrows")
	SelectRow(menu.moduletable, row)
	SelectColumn(menu.moduletable, col)
	AddUITriggeredEvent(menu.name, "moduleadded", macro)
	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
end

function menu.buttonRemoveModule(module, removesequence)
	C.RemoveItemFromConstructionMap2(menu.holomap, module.idx, removesequence)
	menu.closeContextMenu()
	
	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
	menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
	menu.storePlanTableState()
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.buttonCopyModule(module, copysequence)
	C.AddCopyToConstructionMap(menu.holomap, module.idx, copysequence)
	menu.floatingCopyModule = module.macro
	menu.closeContextMenu()
end

function menu.buttonResetModuleRotation(module)
	C.ResetConstructionMapModuleRotation(menu.holomap, module.idx)
	menu.closeContextMenu()
end

function menu.determineInitialSlot()
	menu.currentSlot = 1
	if menu.upgradetypeMode == "turretgroup" then
		local curslotsizepriority
		for i, group in ipairs(menu.groups) do
			if group.slotsize and (group.slotsize ~= "") then
				local sizeorder = config.slotSizeOrder[group.slotsize] or 0
				if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
					curslotsizepriority = sizeorder
					menu.currentSlot = i
				end
			end
		end
	end
end

function menu.buttonEditLoadout(module)
	local found
	for i, entry in ipairs(menu.constructionplan) do
		if entry.idx == module.idx then
			found = i
		end
	end

	if found then
		if not menu.loadoutMode then
			menu.hasconstructionchanges = menu.haschanges
			C.StoreConstructionMapState(menu.holomap)
			menu.mapstate = ffi.new("HoloMapState")
			C.GetMapState(menu.holomap, menu.mapstate)
		end
		menu.loadoutMode = found
		menu.loadoutModule = module
		menu.extendEntry(menu.container, tonumber(module.idx) + 1, true)

		Helper.callLoadoutFunction(module.upgradeplan, nil, function (loadout, _) return C.ShowObjectConfigurationMap2(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout, module.idx) end)

		menu.getUpgradeData(module.upgradeplan)
		menu.upgradetypeMode = "turretgroup"

		menu.determineInitialSlot()

		if menu.groups[menu.currentSlot] then
			local group = menu.groups[menu.currentSlot]
			C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
		end

		menu.closeContextMenu()

		menu.displayMainFrame()
		menu.displayMenu()
	end
end

function menu.buttonConfirmMoney()
	if menu.newAccountValue then
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.buildstorage))
		local buildstoragemoney = GetComponentData(convertedComponent, "money")
		local amount = menu.newAccountValue - buildstoragemoney
		if amount > 0 then
			TransferPlayerMoneyTo(amount, convertedComponent)
		else
			TransferMoneyToPlayer(-amount, convertedComponent)
		end
		menu.newAccountValue = nil

		menu.storePlanTableState()
		menu.displayMenu()
	end
end

function menu.buttonSetMoneyToEstimate()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.buildstorage))
	local buildstoragemoney = GetComponentData(convertedComponent, "money")
	local amount = menu.totalprice - buildstoragemoney
	if amount > 0 then
		TransferPlayerMoneyTo(amount, convertedComponent)
	else
		TransferMoneyToPlayer(-amount, convertedComponent)
	end
	menu.newAccountValue = nil

	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonConfirm()
	C.SetConstructionSequenceFromConstructionMap(menu.container, menu.holomap)
	menu.updatePlan = getElapsedTime() + 0.1
end

function menu.buttonCancel()
	if menu.haschanges then
		menu.cancelRequested = true
		menu.storePlanTableState()
		menu.displayMenu()
	else
		if not menu.loadoutMode then
			-- nothing to do
		else
			 menu.buttonCancelLoadout()
		end
	end
end

function menu.buttonForceBuild()
	C.ForceBuildCompletion(menu.container)
	menu.updatePlan = getElapsedTime() + 0.1
end

function menu.resetDefaultLoadout()
	if menu.origDefaultLoadout ~= menu.defaultLoadout then
		C.SetDefensibleLoadoutLevel(menu.container, menu.origDefaultLoadout)
		menu.defaultLoadout = menu.origDefaultLoadout
	end
end

function menu.buttonCancelConfirm()
	menu.resetDefaultLoadout()
	C.ShowConstructionMap(menu.holomap, menu.container, "", false)
	menu.applySettings()
	menu.refreshPlan()
	menu.cancelRequested = nil
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonCancelCancel()
	menu.cancelRequested = nil
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.showConstructionMap()
	C.ShowConstructionMap(menu.holomap, menu.container, "", true)
	menu.applySettings()
	if menu.mapstate then
		C.SetMapState(menu.holomap, menu.mapstate)
		menu.mapstate = nil
	end
end

function menu.buttonConfirmLoadout()
	menu.showConstructionMap()

	Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateConstructionMapItemLoadout(menu.holomap, menu.loadoutModule.idx, menu.container, loadout) end)
	menu.defaultLoadout = -1

	menu.loadoutMode = nil
	menu.loadoutModule = {}
	menu.loadout = nil
	menu.hasconstructionchanges = nil

	menu.closeContextMenu()

	menu.displayMainFrame()
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.buttonCancelLoadout()
	menu.cancelRequested = nil

	menu.showConstructionMap()

	menu.loadoutMode = nil
	menu.loadoutModule = {}
	menu.loadout = nil
	menu.hasconstructionchanges = nil

	menu.closeContextMenu()
	
	menu.displayMainFrame()
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.buttonContextEncyclopedia(selectedUpgrade)
	if selectedUpgrade.type == "module" then
		local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Stations", library, selectedUpgrade.macro })
		menu.cleanup()
	else
		local upgradetype = Helper.findUpgradeType(selectedUpgrade.type)

		if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") or (upgradetype.supertype == "group") then
			local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
			Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, library, selectedUpgrade.macro })
			menu.cleanup()
		elseif upgradetype.supertype == "software" then
			-- selectedUpgrade.software
		elseif upgradetype.supertype == "ammo" then
			local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
			if upgradetype.emode then
				Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, library, selectedUpgrade.macro })
				menu.cleanup()
			end
		end
	end
end

function menu.buttonInteract(selectedData, button, row, col, posx, posy)
	menu.selectedUpgrade = selectedData
	local x, y = GetLocalMousePosition()
	if x == nil then
		-- gamepad case
		x = posx
		y = -posy
	end
	menu.displayContextFrame("equipment", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
end

function menu.buttonConstructionCommunity()
	if C.CanOpenWebBrowser() then
		C.OpenWebBrowser(ReadText(1001, 7976))
	end
end

function menu.buttonEditTradeRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.buttonCancelTradeActive(tradeid)
	if not C.IsValidTrade(tradeid) then
		menu.refresh = getElapsedTime()
		return
	end
	return C.CancelPlayerInvolvedTradeDeal(menu.container, tradeid, true)
end

function menu.buttonCancelTrade(tradeid)
	if C.CancelPlayerInvolvedTradeDeal(menu.container, tradeid, false) then
		-- The ware reservation is only implicitly removed after the trade was purged which only happens with a delay in gametime. To avoid no change in the menu after pressing the button, we hide the reservation now.
		menu.dirtyreservations[tostring(tradeid)] = true
	end
	menu.displayMenu()
end

function menu.onDropDownActivated()
	menu.closeContextMenu()
end

function menu.dropdownLoad(_, id)
	if id ~= nil then
		C.ShowConstructionMap(menu.holomap, menu.container, id, false)
		menu.applySettings()
		menu.currentCPID = id
		menu.closeContextMenu()

		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		menu.topRows.plan = 1
		menu.selectedRows.plan = nil
		menu.refreshPlan()
		menu.displayMenu()
	end
end

function menu.dropdownRemovedCP(_, id)
	C.RemoveConstructionPlan("local", id)
	if id == menu.currentCPID then
		menu.currentCPID = nil
		menu.currentCPName = nil
	end
	for i, plan in ipairs(menu.constructionplans) do
		if plan.id == id then
			table.remove(menu.constructionplans, i)
			break
		end
	end
end

function menu.dropdownLoadout(_, loadoutid)
	if loadoutid ~= nil then
		if menu.loadout ~= loadoutid then
			menu.loadout = loadoutid
			local preset
			for _, loadout in ipairs(menu.loadouts) do
				if loadout.id == menu.loadout then
					menu.loadoutName = loadout.name
					if loadout.preset then
						preset = loadout.preset
						menu.loadout = nil
						menu.loadoutName = ""
					end
					break
				end
			end
			local loadout
			if preset then
				loadout = Helper.getLoadoutHelper(C.GenerateModuleLoadout, C.GenerateModuleLoadoutCounts, menu.holomap, menu.loadoutModule.idx, menu.container, preset)
			else
				loadout = Helper.getLoadoutHelper(C.GetLoadout, C.GetLoadoutCounts, 0, menu.loadoutModule.macro, loadoutid)
			end
			local upgradeplan = Helper.convertLoadout(menu.loadoutModule.component, menu.loadoutModule.macro, loadout, nil)
			menu.getUpgradeData(upgradeplan)

			if menu.holomap and (menu.holomap ~= 0) then
				Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout) end)
			end

			menu.displayMenu()
		end
	end
end

function  menu.dropdownRemovedLoadout(_, loadoutid)
	local macro = (menu.loadoutModule.macro ~= "") and menu.loadoutModule.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.loadoutModule.component)), "macro")
	C.RemoveLoadout("local", macro, loadoutid)
	if loadoutid == menu.loadout then
		menu.loadout = nil
		menu.loadoutName = nil
	end
	for i, loadout in ipairs(menu.loadouts) do
		if loadout.id == loadoutid then
			table.remove(menu.loadouts, i)
			break
		end
	end
end

function menu.dropdownDefaultLoadout(_, level)
	menu.defaultLoadout = tonumber(level)
	C.SetDefensibleLoadoutLevel(menu.container, menu.defaultLoadout)

	if menu.defaultLoadout ~= -1 then
		C.SetupConstructionSequenceModulesCache(menu.holomap, menu.container, true)
		for i, entry in ipairs(menu.constructionplan) do
			local active = false
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				if upgradetype.supertype == "macro" then
					if C.GetNumUpgradeSlots(entry.component, entry.macro, upgradetype.type) > 0 then
						active = true
						break
					end
				end
			end
			if active then
				local loadout = Helper.getLoadoutHelper(C.GenerateModuleLoadout, C.GenerateModuleLoadoutCounts, menu.holomap, entry.idx, menu.container, menu.defaultLoadout)
				local upgradeplan = Helper.convertLoadout(entry.component, entry.macro, loadout, nil)
				Helper.callLoadoutFunction(upgradeplan, nil, function (loadout, _) return C.UpdateConstructionMapItemLoadout(menu.holomap, entry.idx, menu.container, loadout) end)
			end
		end
		C.SetupConstructionSequenceModulesCache(menu.holomap, menu.container, false)
		menu.refreshPlan()
		menu.displayMenu()
	end
end

function  menu.dropdownTradeRule(container, type, id, ware, refresh)
	if type == "trade" then
		C.SetContainerTradeRule(container, tonumber(id), "buy",  ware or "", true)
		C.SetContainerTradeRule(container, tonumber(id), "sell", ware or "", true)
	else
		C.SetContainerTradeRule(container, tonumber(id), type, ware or "", true)
	end

	if refresh then
		menu.storePlanTableState()
		menu.displayMenu()
	end
end

function menu.buttonTitleSave()
	if menu.contextMode and (menu.contextMode.mode == "saveCP") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("saveCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleImport()
	if menu.contextMode and (menu.contextMode.mode == "importCP") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.contextData = {}
		menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleExport()
	if menu.contextMode and (menu.contextMode.mode == "exportCP") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("exportCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleSaveLoadout()
	if menu.contextMode and (menu.contextMode.mode == "saveLoadout") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("saveLoadout", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleSettings()
	if menu.contextMode and (menu.contextMode.mode == "settings") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("settings", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonModuleFilter(offsety)
	if menu.contextMode and (menu.contextMode.mode == "modulefilter") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("modulefilter", Helper.scaleX(config.moduleFilterWidth), menu.modulesData.offsetX + menu.modulesData.width + Helper.borderSize, offsety)
	end
end

function menu.buttonSave(overwrite)
	local source, id
	if overwrite then
		_, _, source = menu.checkCPNameID()
		id = menu.currentCPID
	end

	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
	C.SaveMapConstructionPlan(menu.holomap, source or "local", id or "player", id ~= nil, menu.currentCPName, "")
	menu.closeContextMenu()
	menu.refreshTitleBar()
end

function menu.buttonExport(checked)
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	if canoverwrite and (not checked) then
		menu.contextData = menu.contextData or {}
		menu.contextData.mode = "export"
		menu.displayContextFrame("overwritequestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	else
		local id = menu.currentCPID
		local filename = utf8.gsub(menu.currentCPName, "[^%w_%-%() ]", "_")
		C.ExportMapConstructionPlan(menu.holomap, filename, id or "", id ~= nil, menu.currentCPName, "")
		menu.closeContextMenu()
		menu.refreshTitleBar()
	end
end

function menu.buttonImport(checked)
	local id = menu.contextData.selectedEntry.id
	if menu.constructionplansbyID[id] and (not checked) then
		menu.contextData = menu.contextData or {}
		menu.contextData.mode = "import"
		menu.displayContextFrame("overwritequestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	else
		if menu.constructionplansbyID[id] then
			C.RemoveConstructionPlan("local", id)
		end
		local filename = utf8.gsub(menu.contextData.selectedEntry.filename, "[^%w_%-%() ]", "_")
		C.ImportMapConstructionPlan(filename, id)
		menu.refreshTitleBar()
		menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonReloadImportable()
	menu.getImportablePlans()
	menu.refreshTitleBar()
	menu.contextData = {}
	menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
end

function menu.buttonSaveLoadout(overwrite)
	local loadoutid
	if overwrite then
		loadoutid = menu.loadout
	end

	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
	local macro = (menu.loadoutModule.macro ~= "") and menu.loadoutModule.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.loadoutModule.component)), "macro")
	if macro ~= "" then
		Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.SaveLoadout(macro, loadout, "local", loadoutid or "player", loadoutid ~= nil, menu.loadoutName, "") end)
		menu.getPresetLoadouts()
	end
	menu.closeContextMenu()
	menu.refreshTitleBar()
end

function menu.buttonAssignConstructionVessel()
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "selectCV", { ConvertStringToLuaID(tostring(menu.container)) } })
	menu.cleanup()
end

function menu.buttonFireConstructionVessel(builder, orderidx)
	C.RemoveOrder2(builder, orderidx, true, false, true)
	menu.displayMenu()
	menu.refresh = getElapsedTime() + 1.0
end

function menu.buttonRemoveSearchEntry(index)
	Helper.cancelEditBoxInput(menu.moduletable, 2, 1)

	if menu.modulesearchtext[index].race then
		for i, race in ipairs(menu.races) do
			if race.id == menu.modulesearchtext[index].race then
				menu.races[i].selected = nil
				break
			end
		end
	end
	table.remove(menu.modulesearchtext, index)

	menu.displayMenu()
end

-- editbox scripts
function menu.onEditBoxActivated(_, oldtext)
	menu.oldEditBoxContent = oldtext
end

function menu.editboxSearchUpdateText(_, text, textchanged)
	if textchanged then
		menu.searchtext = text
	end

	menu.displayMenu()
end

function menu.editboxModuleSearchUpdateText(widget, text, textchanged)
	if textchanged then
		table.insert(menu.modulesearchtext, { text = text })
	end

	C.SetEditBoxText(widget, "")
	menu.displayMenu()
end

function menu.editboxNameUpdateText(_, text, textchanged)
	if textchanged then
		local name = text
		if name == "" then
			name = menu.oldEditBoxContent
		end
		SetComponentName(ConvertStringToLuaID(tostring(menu.container)), name)
	end
	if text == "" then
		Helper.removeEditBoxScripts(menu, menu.titlebartable, 1, 1)
		SetCellContent(menu.titlebartable, Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false), 1, 1)
		Helper.setEditBoxScript(menu, nil, menu.titlebartable, 1, 1, menu.editboxNameUpdateText)
	end
end

function menu.editboxCPNameUpdateText(_, text)
	menu.currentCPName = text
	menu.currentCPID = nil
end

function menu.editboxLoadoutNameUpdateText(_, text)
	menu.loadoutName = text
	menu.loadout = nil
end

function menu.slidercellSelectAmount(type, group, row, keepcontext, value)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if value ~= menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count then
			menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count = value

			menu.selectedRows.modules = row
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextMenu()
	end
end

function menu.slidercellMoney(_, value)
	menu.newAccountValue = value
end

function menu.slidercellWarePriceOverride(ware, row, value)
	SetContainerWarePriceOverride(menu.buildstorage, ware, true, value)
	C.SetContainerGlobalPriceFactor(menu.buildstorage, -1)
	menu.storePlanTableState()
	menu.selectedRows.plan = row
end

function menu.slidercellGlobalWarePriceFactor(row, value)
	local modifier = Helper.round(value / 100, 2)
	C.SetContainerGlobalPriceFactor(menu.buildstorage, modifier)
	for _, ware in ipairs(menu.tradewares) do
		local newprice = ware.minprice + (ware.maxprice - ware.minprice) * modifier
		SetContainerWarePriceOverride(menu.buildstorage, ware.ware, true, newprice)
		if ware.row then
			Helper.setSliderCellValue(menu.plantable, ware.row, 3, newprice)
		end
	end
	menu.storePlanTableState()
	menu.selectedRows.plan = row
end

function menu.onSliderCellConfirm()
	if not menu.selectedRows.plan then
		menu.storePlanTableState()
	end
	menu.refreshPlan()
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.checkboxToggleGlobalWarePriceModifier()
	C.SetContainerGlobalPriceFactor(menu.buildstorage, (menu.globalpricefactor >= 0) and -1 or 1)
	if menu.globalpricefactor < 0 then
		for _, ware in ipairs(menu.tradewares) do
			SetContainerWarePriceOverride(menu.buildstorage, ware.ware, true, ware.maxprice)
		end
	end

	menu.storePlanTableState()
	menu.displayMenu()
end
	 
function menu.checkboxSetTradeRuleOverride(container, type, checked, ware)
	if type == "trade" then
		if checked then 
			C.SetContainerTradeRule(container, -1, "buy",  ware or "", false)
			C.SetContainerTradeRule(container, -1, "sell", ware or "", false)
		else 
			local currentid = C.GetContainerTradeRuleID(container, "buy", ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "buy",  ware or "", true)
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "sell", ware or "", true)
		end
	else
		if checked then 
			C.SetContainerTradeRule(container, -1, type, ware or "", false)
		else 
			local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware or "", true)
		end
	end

	menu.storePlanTableState()
	menu.displayMenu()
end

-- Menu member functions

function menu.hotkey(action)
	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_UNDO" then
		menu.undoHelper(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REDO" then
		menu.undoHelper(false)
	end
end

function menu.undoHelper(undo)
	if undo then
		C.UndoConstructionMapChange(menu.holomap)
	else
		C.RedoConstructionMapChange(menu.holomap)
	end
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.sorterModules(type, a, b)
	local aname, amakerrace, atier, asize, awaregroup = GetMacroData(a, "shortname", "makerrace", "tier", "size", "waregroup")
	local bname, bmakerrace, btier, bsize, bwaregroup = GetMacroData(b, "shortname", "makerrace", "tier", "size", "waregroup")
	atier = atier or 0
	btier = btier or 0
	if #amakerrace > 0 then
		amakerrace = amakerrace[1]
	else
		amakerrace = ""
	end
	if #bmakerrace > 0 then
		bmakerrace = bmakerrace[1]
	else
		bmakerrace = ""
	end

	if atier == btier then
		if type == "moduletypes_production" then
			if awaregroup == bwaregroup then
				if aname == bname then
					return amakerrace < bmakerrace
				end
				return aname < bname
			end
			return awaregroup < bwaregroup
		else
			if amakerrace == bmakerrace then
				local asizesort = config.sizeSorting[asize] or 0
				local bsizesort = config.sizeSorting[bsize] or 0
				if asizesort == bsizesort then
					return aname < bname
				end
				return asizesort < bsizesort
			end
			return amakerrace < bmakerrace
		end
	end
	return atier < btier
end

function menu.newWareReservationCallback(_, data)
	local containerid, ware, reserverid = string.match(data, "(.+);(.+);(.+)")
	if menu.buildstorage == ConvertStringTo64Bit(containerid) then
		PlaySound("notification_achievement")
		menu.newWareReservation = (menu.newWareReservation or 0) + 1
		if menu.newWareReservationWares[ware] then
			menu.newWareReservationWares[ware][reserverid] = true
		else
			menu.newWareReservationWares[ware] = { [reserverid] = true }
		end
		menu.storePlanTableState()
		menu.displayMenu()
	end
end

function menu.onShowMenu(state)
	-- layout
	menu.scaleSize = Helper.scaleX(config.scaleSize)
	menu.frameworkData = {
		sidebarWidth = Helper.scaleX(Helper.sidebarWidth),
		offsetX = Helper.frameBorder,
		offsetY = Helper.frameBorder + 20,
	}
	local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
	local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
	reservedSidePanelWidth = reservedSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize
	menu.modulesData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetX = menu.frameworkData.sidebarWidth + menu.frameworkData.offsetX + 2 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}
	menu.planData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}

	local reserverdCenterPanelWidth = Helper.viewWidth - 2 * menu.modulesData.offsetX - 2 * reservedSidePanelWidth - 4 * Helper.borderSize
	local actualCenterPanelWidth = math.min(reserverdCenterPanelWidth, Helper.scaleX(config.maxCenterPanelWidth))
	menu.statsData = {
		width = actualCenterPanelWidth / 2,
		offsetX = menu.modulesData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth / 2) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData = {
		width = actualCenterPanelWidth,
		height = Helper.scaleY(40),
		dropdownWidth = 6 * menu.frameworkData.sidebarWidth,
		offsetX = menu.modulesData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData.nameWidth = menu.titleData.width - 7 * (menu.titleData.height + Helper.borderSize) - menu.titleData.dropdownWidth - Helper.borderSize
	if menu.titleData.nameWidth < 200 then
		menu.titleData.height = math.floor(menu.titleData.height * 2 / 3)
		menu.titleData.dropdownWidth = 5 * menu.titleData.height
		menu.titleData.nameWidth = math.max(20, menu.titleData.width - 7 * (menu.titleData.height + Helper.borderSize) - menu.titleData.dropdownWidth - Helper.borderSize)
	end
	menu.planData.offsetX = Helper.viewWidth - actualSidePanelWidth + Helper.borderSize
	menu.mapData = {
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		offsetX = 0,
		offsetY = 0
	}

	menu.headerTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
		titleColor = Helper.defaultSimpleBackgroundColor,
	}

	menu.headerCenteredTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		halign = "center",
		cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
		titleColor = Helper.defaultSimpleBackgroundColor,
	}

	menu.slidercellTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
	}

	menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)

	-- parameters
	menu.container = ConvertIDTo64Bit(menu.param[3])
	menu.buildstorage = ConvertIDTo64Bit(GetComponentData(menu.container, "buildstorage")) or 0

	menu.defaultLoadout = Helper.round(C.GetDefensibleLoadoutLevel(menu.container), 1)
	menu.origDefaultLoadout = menu.defaultLoadout

	RegisterEvent("newWareReservation", menu.newWareReservationCallback)

	menu.initExtendedEntry(menu.container)

	local sets = GetComponentData(menu.container, "modulesets")
	menu.set = sets[1] or ""

	-- prepare modules
	menu.modules = {}
	local races = {}
	for _, entry in ipairs(config.leftBar) do
		menu.modules[entry.mode] = {}
		local n = C.GetNumBlueprints(menu.set, entry.mode, "")
		local buf = ffi.new("UIBlueprint[?]", n)
		n = C.GetBlueprints(buf, n, menu.set, entry.mode, "")
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			local makerrace, makerracename = GetMacroData(macro, "makerraceid", "makerracename")
			for i, race in ipairs(makerrace) do
				races[race] = makerracename[i]
			end
			table.insert(menu.modules[entry.mode], macro)
		end
		table.sort(menu.modules[entry.mode], function (a, b) return menu.sorterModules(entry.mode, a, b) end)
		entry.active = n > 0
	end

	menu.races = {}
	for race, name in pairs(races) do
		table.insert(menu.races, { id = race, name = name })
	end
	table.sort(menu.races, Helper.sortName)
	table.insert(menu.races, 1, { id = "generic", name = ReadText(1001, 11916) })

	-- assemble possible upgrades (wares, macros)
	menu.upgradewares = {}
	for _, blueprintGroup in ipairs(config.equipmentBlueprintGroups) do
		local n = C.GetNumBlueprints(menu.set, blueprintGroup.library, "")
		local buf = ffi.new("UIBlueprint[?]", n)
		n = C.GetBlueprints(buf, n, menu.set, blueprintGroup.library, "")
		for i = 0, n - 1 do
			local entry = {}
			entry.macro = ffi.string(buf[i].macro)
			entry.ware = ffi.string(buf[i].ware)
			if menu.upgradewares[blueprintGroup.type] then
				table.insert(menu.upgradewares[blueprintGroup.type], entry)
			else
				menu.upgradewares[blueprintGroup.type] = { entry }
			end
		end
	end

	-- check for limited modules
	menu.externalUsedLimitedModules = {}
	local n = C.GetNumUsedLimitedModules(menu.container)
	if n > 0 then
		local buf = ffi.new("UIMacroCount[?]", n)
		n = C.GetUsedLimitedModules(buf, n, menu.container)
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			menu.externalUsedLimitedModules[macro] = buf[i].amount
		end
	end

	-- trade rules
	Helper.updateTradeRules()

	menu.searchtext = ""
	menu.modulesearchtext = {}
	menu.loadoutName = ""
	menu.modulesMode = "moduletypes_production"
	menu.upgradetypeMode = "turretgroup"
	menu.planMode = "construction"
	menu.loadoutPlanMode = "normal"

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	if state then
		menu.state = state
	end

	-- we are (again) in the station config menu, menu keeps track of changes itself
	Helper.unregisterStationEditorChanges()

	menu.displayMainFrame()
	
	RegisterAddonBindings("ego_detailmonitor", "undo")
	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onShowMenuSound()
	if not C.IsNextStartAnimationSkipped(false) then
		PlaySound("ui_config_station_open")
	else
		PlaySound("ui_menu_changed")
	end
end

function menu.displayLeftBar(frame)
	local maxSlotWidth = math.floor((menu.modulesData.width - 8 * Helper.borderSize) / 9)

	local leftBar = config.leftBar
	local offsety = menu.frameworkData.offsetY
	if menu.loadoutMode then
		leftBar = config.leftBarLoadout
		offsety = menu.modulesData.offsetY + menu.titleData.height + 2 * Helper.borderSize + maxSlotWidth
	end

	local ftable = frame:addTable(1, { tabOrder = 2, width = menu.frameworkData.sidebarWidth, height = 0, x = menu.frameworkData.offsetX, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false })

	local found = true
	for _, entry in ipairs(leftBar) do
		local active = true
		local selected = false
		local prevSelected = false
		local mouseovertext = entry.name
		if menu.loadoutMode then
			selected = entry.mode == menu.upgradetypeMode
			prevSelected = entry.mode == menu.prevUpgradetypeMode
			if entry.mode == "turretgroup" then
				active = active and (#menu.groups > 0)
			end
		else
			active = entry.active and ((not entry.condition) or entry.condition())
			if entry.mode == "moduletypes_venture" then
				if entry.condition and (not entry.condition()) then
					mouseovertext = mouseovertext .. "\n\27R" .. ReadText(1026, 7930)
				end
			end
			selected = entry.mode == menu.modulesMode
			prevSelected = entry.mode == menu.prevModulesMode
		end
		local row = ftable:addRow(active, { fixed = true })

		-- if nothing selected yet, select this one if active
		if (not found) and active then
			found = true
			menu.modulesMode = entry.mode
		end

		-- if selected, but not active, select next active entry
		if selected and (not active) then
			found = false
			selected = false
		end

		if selected then
			menu.selectedRows.left = row.index
		elseif prevSelected then
			menu.selectedRows.left = row.index
		end
		row[1]:createButton({helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText,  active = active, height = menu.frameworkData.sidebarWidth, mouseOverText = mouseovertext, bgColor = selected and Helper.defaultArrowRowBackgroundColor or Helper.defaultButtonBackgroundColor}):setIcon(entry.icon)
		if not menu.loadoutMode then
			row[1].handlers.onClick = function () return menu.buttonLeftBar(entry.mode, row.index) end
		else
			row[1].handlers.onClick = function () return menu.buttonLeftBarLoadout(entry.mode, row.index) end
		end
	end
	ftable:setTopRow(menu.topRows.left)
	ftable:setSelectedRow(menu.selectedRows.left)
	menu.topRows.left = nil
	menu.selectedRows.left = nil
end

function menu.updateConstructionPlans()
	menu.constructionplans = {}
	menu.constructionplansbyID = {}
	local n = C.GetNumConstructionPlans()
	local buf = ffi.new("UIConstructionPlan[?]", n)
	n = C.GetConstructionPlans(buf, n)
	local ischeatversion = IsCheatVersion()
	for i = 0, n - 1 do
		local source = ffi.string(buf[i].source)
		if (source == "local") or ischeatversion then
			local id = ffi.string(buf[i].id)
			local active = false
			local mouseovertext
			local numinvalidpatches = ffi.new("uint32_t[?]", 1)
			if not C.IsConstructionPlanValid(id, numinvalidpatches) then
				local numpatches = numinvalidpatches[0]
				local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
				numpatches = C.GetConstructionPlanInvalidPatches(patchbuf, numpatches, id)
				mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
				for j = 0, numpatches - 1 do
					if j > 3 then
						mouseovertext = mouseovertext .. "\n- ..."
						break
					end
					mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
					if patchbuf[j].state == 2 then
						mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
					elseif patchbuf[j].state == 3 then
						mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
					elseif patchbuf[j].state == 4 then
						mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
					end
				end
			elseif not C.AreConstructionPlanLoadoutsCompatible(id) then
				mouseovertext = ReadText(1026, 7929)
			else
				local result = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, 0, id, false))
				active = result == ""
				if menu.set == "headquarters_player" then
					local macros = { "landmarks_player_hq_01_research_macro" }
					local hasmacros = Helper.textArrayHelper(macros, function (numtexts, texts) return C.CheckConstructionPlanForMacros(id, texts, numtexts) end)
					active = active and hasmacros
					if not hasmacros then
						mouseovertext = ReadText(1026, 7919)
					end
				end
				local missingmacros = {}
				if (not active) and (string.find(result, "error") ~= 1) then
					for macro in string.gmatch(result, "([^;]+);") do
						missingmacros[macro] = true
					end
				end
				local missingmacronames = {}
				for macro, v in pairs(missingmacros) do
					table.insert(missingmacronames, GetMacroData(macro, "name"))
				end
				table.sort(missingmacronames)
				local blueprinttext = ""
				for _, name in ipairs(missingmacronames) do
					blueprinttext = blueprinttext .. "\n· " .. name
				end

				local hasmissinglimitedmodules = false
				local limitedmoduletext = ""
				local n = C.GetNumPlannedLimitedModules(id)
				local macrocounts = ffi.new("UIMacroCount[?]", n)
				n = C.GetPlannedLimitedModules(macrocounts, n, id)
				for j = 0, n - 1 do
					local macro = ffi.string(macrocounts[j].macro)
					local ware = GetMacroData(macro, "ware")
					if macrocounts[j].amount > OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) then
						active = false
						hasmissinglimitedmodules = true
						limitedmoduletext = limitedmoduletext .. "\n· " .. GetMacroData(macro, "name")
					end
				end

				if (not active) and (mouseovertext == nil) then
					mouseovertext = ReadText(1026, 7912) .. blueprinttext .. (hasmissinglimitedmodules and ("\n" .. ReadText(1026, 7915) .. limitedmoduletext) or "")
				end
			end

			table.insert(menu.constructionplans, { id = id, name = ffi.string(buf[i].name), source = source, deleteable = buf[i].deleteable, active = active, mouseovertext = mouseovertext })
			menu.constructionplansbyID[id] = { name = ffi.string(buf[i].name), source = source }
		end
	end
end

function menu.getImportablePlans()
	menu.importableplans = {}
	menu.importableplansbyfile = {}
	local n = C.GetNumImportableConstructionPlans()
	local buf = ffi.new("UIConstructionPlanInfo[?]", n)
	n = C.GetImportableConstructionPlans(buf, n)
	for i = 0, n - 1 do
		local filename = ffi.string(buf[i].filename)
		local id = ffi.string(buf[i].id)
		local name = ffi.string(buf[i].name)

		table.insert(menu.importableplans, { id = id, name = name, filename = filename, imported = menu.constructionplansbyID[id] ~= nil })
		menu.importableplansbyfile[filename] = { id = id, name = name }
	end
	table.sort(menu.importableplans, Helper.sortName)
end

function menu.createTitleBar(frame)
	menu.updateConstructionPlans()
	menu.getImportablePlans()

	local ftable = frame:addTable(9, { tabOrder = 5, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
	ftable:setColWidth(1, menu.titleData.nameWidth)
	ftable:setColWidth(2, menu.titleData.dropdownWidth)
	ftable:setColWidth(3, menu.titleData.height)
	ftable:setColWidth(4, menu.titleData.height)
	ftable:setColWidth(5, menu.titleData.height)
	ftable:setColWidth(6, menu.titleData.height)
	ftable:setColWidth(7, menu.titleData.height)
	ftable:setColWidth(8, menu.titleData.height)
	ftable:setColWidth(9, menu.titleData.height)
	
	local row = ftable:addRow(true, { fixed = true })
	if not menu.loadoutMode then
		-- name
		row[1]:createEditBox({ scaling = true }):setText(ffi.string(C.GetComponentName(menu.container)), { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
		row[1].handlers.onEditBoxDeactivated = menu.editboxNameUpdateText
		-- load
		local loadOptions = {}
		for _, plan in ipairs(menu.constructionplans) do
			table.insert(loadOptions, { id = plan.id, text = plan.name, icon = "", displayremoveoption = plan.deleteable, active = plan.active, mouseovertext = plan.mouseovertext })
		end
		table.sort(loadOptions, function (a, b) return a.text < b.text end)
		row[2]:createDropDown(loadOptions, { textOverride = ReadText(1001, 7904), optionWidth = menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize }):setTextProperties(config.dropDownTextProperties)
		row[2].handlers.onDropDownConfirmed = menu.dropdownLoad
		row[2].handlers.onDropDownRemoved = menu.dropdownRemovedCP
		-- save
		row[3]:createButton({ helpOverlayID = "save_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7901) }):setIcon("menu_save")
		row[3].handlers.onClick = menu.buttonTitleSave
		-- Import
		row[4]:createButton({ helpOverlayID = "import_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7916) }):setIcon("menu_import")
		row[4].handlers.onClick = menu.buttonTitleImport
		-- Export
		row[5]:createButton({ helpOverlayID = "export_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7917) }):setIcon("menu_export")
		row[5].handlers.onClick = menu.buttonTitleExport
		-- reset camera
		row[6]:createButton({ helpOverlayID = "reset_topview", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[6].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		menu.canundo = false
		if menu.holomap and (menu.holomap ~= 0) then
			menu.canundo = C.CanUndoConstructionMapChange(menu.holomap)
		end
		row[7]:createButton({ helpOverlayID = "undo_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = menu.canundo, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[7].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		menu.canredo = false
		if menu.holomap and (menu.holomap ~= 0) then
			menu.canredo = C.CanRedoConstructionMapChange(menu.holomap)
		end
		row[8]:createButton({ helpOverlayID = "redo_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = menu.canredo, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[8].handlers.onClick = function () return menu.undoHelper(false) end
		-- settings
		row[9]:createButton({ helpOverlayID = "settings", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height }):setIcon("menu_options")
		row[9].handlers.onClick = menu.buttonTitleSettings
	else
		-- name
		row[1]:createEditBox({ scaling = true }):setText(ffi.string(C.GetComponentName(menu.container)), { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
		row[1].handlers.onEditBoxDeactivated = menu.editboxNameUpdateText
		-- load
		local loadoutOptions = {}
		if next(menu.loadouts) then
			for _, loadout in ipairs(menu.loadouts) do
				table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
			end
		end
		row[2]:setColSpan(6):createDropDown(loadoutOptions, { textOverride = ReadText(1001, 7905), optionWidth = menu.titleData.dropdownWidth + 6 * (menu.titleData.height + Helper.borderSize) }):setTextProperties(config.dropDownTextProperties)
		row[2].handlers.onDropDownConfirmed = menu.dropdownLoadout
		row[2].handlers.onDropDownRemoved = menu.dropdownRemovedLoadout
		-- save
		row[8]:createButton({ helpOverlayID = "save_loadout", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7905) }):setIcon("menu_save")
		row[8].handlers.onClick = menu.buttonTitleSaveLoadout
		-- reset camera
		row[9]:createButton({ helpOverlayID = "reset_topview", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[9].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
	end
end

function menu.refreshTitleBar()
	local text = {
		alignment = "center",
		fontname = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Helper.color.white,
		x = 0,
		y = 0
	}

	menu.updateConstructionPlans()
	menu.getImportablePlans()

	if not menu.loadoutMode then
		text.override = ReadText(1001, 7904)
		local loadOptions = {}
		for _, plan in ipairs(menu.constructionplans) do
			table.insert(loadOptions, { id = plan.id, text = plan.name, icon = "", displayremoveoption = plan.deleteable, active = plan.active, mouseovertext = plan.mouseovertext })
		end
		table.sort(loadOptions, function (a, b) return a.text < b.text end)
		
		-- editbox
		Helper.removeEditBoxScripts(menu, menu.titlebartable, 1, 1)
		SetCellContent(menu.titlebartable, Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false), 1, 1)
		Helper.setEditBoxScript(menu, nil, menu.titlebartable, 1, 1, menu.editboxNameUpdateText)
		-- dropdown
		Helper.removeDropDownScripts(menu, menu.titlebartable, 1, 2)
		SetCellContent(menu.titlebartable, Helper.createDropDown(loadOptions, "", text, nil, true, true, 0, 0, 0, 0, nil, nil, "", menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize), 1, 2)
		Helper.setDropDownScript(menu, nil, menu.titlebartable, 1, 2, nil, menu.dropdownLoad, menu.dropdownRemovedCP)
		-- save
		Helper.removeButtonScripts(menu, menu.titlebartable, 1, 3)
		SetCellContent(menu.titlebartable, Helper.createButton(nil, Helper.createButtonIcon("menu_save", nil, 255, 255, 255, 100), true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7901)), 1, 3)
		Helper.setButtonScript(menu, nil, menu.titlebartable, 1, 3, menu.buttonTitleSave)
	else
		text.override = ReadText(1001, 7905)
		local loadoutOptions = {}
		if next(menu.loadouts) then
			for _, loadout in ipairs(menu.loadouts) do
				table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
			end
		end
		
		-- editbox
		Helper.removeEditBoxScripts(menu, menu.titlebartable, 1, 1)
		SetCellContent(menu.titlebartable, Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false), 1, 1)
		Helper.setEditBoxScript(menu, nil, menu.titlebartable, 1, 1, menu.editboxNameUpdateText)
		-- dropdown
		Helper.removeDropDownScripts(menu, menu.titlebartable, 1, 2)
		SetCellContent(menu.titlebartable, Helper.createDropDown(loadoutOptions, "", text, nil, true, next(menu.loadouts) ~= nil, 0, 0, 0, 0, nil, nil, "", menu.titleData.dropdownWidth + 4 * (menu.titleData.height + Helper.borderSize)), 1, 2)
		Helper.setDropDownScript(menu, nil, menu.titlebartable, 1, 2, nil, menu.dropdownLoadout, menu.dropdownRemovedLoadout)
		-- save
		Helper.removeButtonScripts(menu, menu.titlebartable, 1, 8)
		SetCellContent(menu.titlebartable, Helper.createButton(nil, Helper.createButtonIcon("menu_save", nil, 255, 255, 255, 100), true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7905)), 1, 8)
		Helper.setButtonScript(menu, nil, menu.titlebartable, 1, 8, menu.buttonTitleSaveLoadout)
	end
end

function menu.getPresetLoadouts()
	-- presets
	menu.loadouts = {}

	local currentmacro = (menu.loadoutModule.macro ~= "") and menu.loadoutModule.macro or GetComponentData(ConvertStringTo64Bit(tostring(menu.loadoutModule.component)), "macro")
	local n = C.GetNumLoadoutsInfo(menu.loadoutModule.component, menu.loadoutModule.macro)
	local buf = ffi.new("UILoadoutInfo[?]", n)
	n = C.GetLoadoutsInfo(buf, n, menu.loadoutModule.component, menu.loadoutModule.macro)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		local active = false
		local mouseovertext = ""
		local numinvalidpatches = ffi.new("uint32_t[?]", 1)
		if not C.IsLoadoutValid(0, menu.loadoutModule.macro, id, numinvalidpatches) then
			local numpatches = numinvalidpatches[0]
			local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
			numpatches = C.GetLoadoutInvalidPatches(patchbuf, numpatches, 0, menu.loadoutModule.macro, id)
			mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
			for j = 0, numpatches - 1 do
				if j > 3 then
					mouseovertext = mouseovertext .. "\n- ..."
					break
				end
				mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
				if patchbuf[j].state == 2 then
					mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
				elseif patchbuf[j].state == 3 then
					mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
				elseif patchbuf[j].state == 4 then
					mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
				end
			end
		elseif not C.IsLoadoutCompatible(currentmacro, id) then
			mouseovertext = ReadText(1026, 8024)
		else
			active = C.CanBuildLoadout(menu.buildstorage, 0, menu.loadoutModule.macro, id)
			if not active then
				mouseovertext = ReadText(1026, 8011)
			end
		end

		table.insert(menu.loadouts, { id = id, name = ffi.string(buf[i].name), icon = ffi.string(buf[i].iconid), deleteable = buf[i].deleteable, active = active, mouseovertext = mouseovertext })
	end
	table.sort(menu.loadouts, function (a, b) return a.name < b.name end)
	table.insert(menu.loadouts, 1, { id = "empty", name = ReadText(1001, 7990), icon = "", deleteable = false, preset = 0 })
	table.insert(menu.loadouts, 2, { id = "low", name = ReadText(1001, 7910), icon = "", deleteable = false, preset = 0.1 })
	table.insert(menu.loadouts, 3, { id = "medium", name = ReadText(1001, 7911), icon = "", deleteable = false, preset = 0.5 })
	table.insert(menu.loadouts, 4, { id = "high", name = ReadText(1001, 7912), icon = "", deleteable = false, preset = 1.0 })
end

function menu.getUpgradeData(upgradeplan)
	-- get preset loadouts
	menu.getPresetLoadouts()

	-- init upgradeplan
	menu.constructionplan[menu.loadoutMode].upgradeplan = {}
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type] = {}
	end

	-- assemble available slots/ammo/software
	menu.slots = {}
	if menu.loadoutModule.component ~= 0 then
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				menu.slots[upgradetype.type] = {}
				for j = 1, tonumber(C.GetNumUpgradeSlots(menu.loadoutModule.component, "", upgradetype.type)) do
					-- convert index from lua to C-style
					menu.slots[upgradetype.type][j] = { currentmacro = ffi.string(C.GetUpgradeSlotCurrentMacro(menu.container, menu.loadoutModule.component, upgradetype.type, j)), possiblemacros = {} }
					menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][j] = menu.slots[upgradetype.type][j].currentmacro
				end
			end
		end
	else
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				menu.slots[upgradetype.type] = {}
				for j = 1, tonumber(C.GetNumUpgradeSlots(0, menu.loadoutModule.macro, upgradetype.type)) do
					-- convert index from lua to C-style
					menu.slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {} }
					menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][j] = ""
				end
			end
		end
	end

	menu.groups = {}
	local n = C.GetNumUpgradeGroups(menu.loadoutModule.component, menu.loadoutModule.macro)
	local buf = ffi.new("UpgradeGroup[?]", n)
	n = C.GetUpgradeGroups(buf, n, menu.loadoutModule.component, menu.loadoutModule.macro)
	for i = 0, n - 1 do
		table.insert(menu.groups, { path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) })
		local group = menu.groups[#menu.groups]
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local groupinfo = C.GetUpgradeGroupInfo(menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group, upgradetype.grouptype)
				local slotsize = ffi.string(groupinfo.slotsize)

				local compatibilities
				local n_comp = C.GetNumUpgradeGroupCompatibilities(menu.loadoutModule.component, menu.loadoutModule.macro, 0, group.path, group.group, upgradetype.grouptype)
				if n_comp > 0 then
					compatibilities = {}
					local buf_comp = ffi.new("EquipmentCompatibilityInfo[?]", n)
					n_comp = C.GetUpgradeGroupCompatibilities(buf_comp, n_comp, menu.loadoutModule.component, menu.loadoutModule.macro, 0, group.path, group.group, upgradetype.grouptype)
					for k = 0, n_comp - 1 do
						compatibilities[ffi.string(buf_comp[k].tag)] = ffi.string(buf_comp[k].name)
					end
				end

				menu.groups[#menu.groups][upgradetype.grouptype] = { count = groupinfo.count, total = groupinfo.total, slotsize = slotsize, compatibilities = compatibilities, currentmacro = ffi.string(groupinfo.currentmacro), possiblemacros = {} }
				if upgradetype.grouptype ~= "shield" then
					menu.groups[#menu.groups].slotsize = slotsize
					menu.groups[#menu.groups].compatibilities = compatibilities
				end
				menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][#menu.groups] = { macro = ffi.string(groupinfo.currentmacro), count = groupinfo.count, path = group.path, group = group.group }
			end
		end
	end

	-- assemble possible upgrades per slot
	for type, slots in pairs(menu.slots) do
		for i, slot in ipairs(slots) do
			local wares = menu.upgradewares[type] or {}
			for _, upgradeware in ipairs(wares) do
				if upgradeware.macro ~= "" then
					if C.IsUpgradeMacroCompatible(menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, type, i, upgradeware.macro) then
						table.insert(slot.possiblemacros, upgradeware.macro)
					end
				end
			end
			table.sort(slot.possiblemacros, Helper.sortMacroRaceAndShortname)
		end
	end

	for i, group in ipairs(menu.groups) do
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local wares = menu.upgradewares[upgradetype.grouptype] or {}
				for _, upgradeware in ipairs(wares) do
					if upgradeware.macro ~= "" then
						if C.IsUpgradeGroupMacroCompatible(menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group, upgradetype.grouptype, upgradeware.macro) then
							table.insert(menu.groups[i][upgradetype.grouptype].possiblemacros, upgradeware.macro)
						end
					end
				end
				table.sort(menu.groups[i][upgradetype.grouptype].possiblemacros, Helper.sortMacroRaceAndShortname)
			end
		end
	end

	if upgradeplan then
		for type, upgradelist in pairs(menu.constructionplan[menu.loadoutMode].upgradeplan) do
			local upgradetype = Helper.findUpgradeType(type)
			for key, upgrade in pairs(upgradelist) do
				if upgradetype.supertype == "group" then
					local found = false
					for key2, upgrade2 in pairs(upgradeplan[type]) do
						if (upgrade2.path == upgrade.path) and (upgrade2.group == upgrade.group) then
							found = true
							menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].macro = upgrade2.macro or ""
							menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].count = upgrade2.count or 0
							break
						end
					end
					if not found then
						menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].macro = ""
						menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].count = 0
					end
				else
					menu.constructionplan[menu.loadoutMode].upgradeplan[type][key] = upgradeplan[type][key] or ""
				end
			end
		end
	end
end

function menu.ventureModuleUnavailableMouseOverText()
	local mouseovertext = "\27R" .. ReadText(1026, 7913)
	if not C.IsVentureExtensionSupported() then
		mouseovertext = "\27R" .. ReadText(1026, 7930)
	elseif not OnlineHasSession() then
		mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7921)
	end
	return mouseovertext
end

function menu.sortSlots(a, b)
	local asize = config.slotSizeOrder[a[4]] or 0
	local bsize = config.slotSizeOrder[b[4]] or 0
	if asize == bsize then
		return a[1] < b[1]
	end
	return asize < bsize
end

function menu.displayModules(frame, firsttime)
	if firsttime then
		AddUITriggeredEvent(menu.name, menu.modulesMode, "on")
	end

	local count = 1
	local hasventureplatform = false
	if not menu.loadoutMode then
		local modules = menu.modules[menu.modulesMode] or {}
		menu.groupedmodules = {}
		local ventureplatformmacros = {}
		for i, module in ipairs(modules) do
			if menu.modulesMode == "moduletypes_venture" then
				if IsMacroClass(module, "ventureplatform") then
					table.insert(ventureplatformmacros, module)
				end
			end

			if (#menu.modulesearchtext == 0) or menu.filterModuleByText(module, menu.modulesearchtext) then
				local group = math.ceil(count / 3)
				menu.groupedmodules[group] = menu.groupedmodules[group] or {}
				table.insert(menu.groupedmodules[group], module)
				count = count + 1
			end
		end

		for _, macro in ipairs(ventureplatformmacros) do
			if (menu.usedLimitedModules[macro] or 0) > 0 then
				hasventureplatform = true
				break
			end
		end
	else
		if menu.upgradetypeMode == "turretgroup" then
			local upgradegroup = menu.groups[menu.currentSlot]

			menu.groupedupgrades = {}
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				local upgradegroupcount = 1
				if upgradetype.supertype == "group" then
					menu.groupedupgrades[upgradetype.grouptype] = {}
					if upgradegroup then
						for i, macro in ipairs(upgradegroup[upgradetype.grouptype].possiblemacros) do
							if (menu.searchtext == "") or menu.filterUpgradeByText(macro, menu.searchtext) then
								local group = math.ceil(upgradegroupcount / 3)
								menu.groupedupgrades[upgradetype.grouptype][group] = menu.groupedupgrades[upgradetype.grouptype][group] or {}
								table.insert(menu.groupedupgrades[upgradetype.grouptype][group], { macro = macro, icon = (C.IsIconValid("upgrade_" .. macro) and ("upgrade_" .. macro) or "upgrade_notfound"), name = GetMacroData(macro, "name") })
								upgradegroupcount = upgradegroupcount + 1
							end
						end
					end

					if upgradetype.allowempty then
						local group = math.ceil(upgradegroupcount / 3)
						menu.groupedupgrades[upgradetype.grouptype][group] = menu.groupedupgrades[upgradetype.grouptype][group] or {}
						table.insert(menu.groupedupgrades[upgradetype.grouptype][group], { macro = "", icon = "upgrade_empty", name = ReadText(1001, 7906) })
						upgradegroupcount = upgradegroupcount + 1
					end
				end
				count = count + upgradegroupcount - 1
			end
			count = count + 1
		end
	end
	count = count - 1
	
	local editboxheight = math.max(23, Helper.scaleY(Helper.standardTextHeight))

	if not menu.loadoutMode then
		if menu.modulesMode then
			local maxColumnWidth = math.floor((menu.modulesData.width - 2 * Helper.borderSize) / 3)
			local columnWidth = maxColumnWidth - math.floor(((count / 3 > 6) and Helper.scrollbarWidth or 0) / 3)

			local ftable = frame:addTable(5, { tabOrder = 1, width = menu.modulesData.width, height = 0, x = menu.modulesData.offsetX, y = menu.modulesData.offsetY, scaling = false, reserveScrollBar = false, highlightMode = "column", backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			if menu.setdefaulttable then
				ftable.properties.defaultInteractiveObject = true
				menu.setdefaulttable = nil
			end
			ftable:setColWidth(1, columnWidth)
			ftable:setColWidth(2, columnWidth)
			ftable:setColWidth(4, editboxheight)
			ftable:setColWidth(5, editboxheight)
			ftable:setDefaultColSpan(3, 3)

			local name = menu.getLeftBarEntry(menu.modulesMode).name or ""
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(name, menu.headerTextProperties)

			local rowy = ftable:getFullHeight()
			local row = ftable:addRow(true, { fixed = true })
			row[1]:setColSpan(4):createEditBox({ defaultText = ReadText(1001, 3250), scaling = true }):setText("", { x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
			row[1].handlers.onEditBoxDeactivated = menu.editboxModuleSearchUpdateText
			row[5]:createButton({ height = editboxheight }):setIcon("menu_filter")
			row[5].handlers.onClick = function () return menu.buttonModuleFilter(menu.modulesData.offsetY + rowy + Helper.borderSize) end

			local row = ftable:addRow((#menu.modulesearchtext > 0), { fixed = true, bgColor = Helper.color.transparent })
			local searchindex = 0
			for i = 1, math.min(3, #menu.modulesearchtext) do
				local col = i
				searchindex = searchindex + 1
				local truncatedString = TruncateText(menu.modulesearchtext[i].text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), row[col]:getWidth() - 2 * Helper.scaleX(10))
				row[col]:setColSpan(1):createButton({ scaling = true, height = Helper.standardTextHeight, mouseOverText = (truncatedString ~= menu.modulesearchtext[i].text) and menu.modulesearchtext[i].text or "" }):setText(truncatedString, { halign = "center" }):setText2("X", { halign = "right" })
				if menu.modulesearchtext[i].race then
					row[col]:setIcon("menu_filter", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				end
				row[col].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
			end
			if #menu.modulesearchtext > 3 then
				row[4]:setColSpan(2):createText(string.format("%+d", #menu.modulesearchtext - 3), { scaling = true })
			end

			local row = ftable:addEmptyRow(editboxheight / 2)
			row.properties.fixed = true

			if next(menu.groupedmodules) then
				local storagecounter_solid, dockareacounter, storagecounter_container, counter_shipyard, counter_wharf, counter_pier, counter_struct = 0, 0, 0, 0, 0, 0, 0
				for _, group in ipairs(menu.groupedmodules) do
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
					local row2 = ftable:addRow(false, { bgColor = Helper.color.transparent })
					for i = 1, 3 do
						if group[i] then
							local shortname, makericon, infolibrary, canclaimownership = GetMacroData(group[i], "shortname", "makericon", "infolibrary", "canclaimownership")
							AddKnownItem(infolibrary, group[i])
							local icon = C.IsIconValid("module_" .. group[i]) and ("module_" .. group[i]) or "module_notfound"
							local active = true
							row[i]:createButton({ width = columnWidth, height = columnWidth, active = active }):setIcon(icon)

							-- Tutorial solar panels (shared)
							if group[i] == "prod_gen_energycells_macro" then
								row[i].properties.helpOverlayID = "stationbuildst_production_energycells"
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial solid storage (any race)
							if	(group[i] == "storage_arg_s_solid_01_macro") or (group[i] == "storage_arg_m_solid_01_macro") or (group[i] == "storage_arg_l_solid_01_macro") or
								(group[i] == "storage_par_s_solid_01_macro") or (group[i] == "storage_par_m_solid_01_macro") or (group[i] == "storage_par_l_solid_01_macro") or
								(group[i] == "storage_spl_s_solid_01_macro") or (group[i] == "storage_spl_m_solid_01_macro") or (group[i] == "storage_spl_l_solid_01_macro") or
								(group[i] == "storage_tel_s_solid_01_macro") or (group[i] == "storage_tel_m_solid_01_macro") or (group[i] == "storage_tel_l_solid_01_macro") or
								(group[i] == "storage_ter_s_solid_01_macro") or (group[i] == "storage_ter_m_solid_01_macro") or (group[i] == "storage_ter_l_solid_01_macro")
							then
								storagecounter_solid = storagecounter_solid + 1
								row[i].properties.helpOverlayID = "stationbuildst_storage_solid" .. storagecounter_solid
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial container storage (any race)
							if	(group[i] == "storage_arg_s_container_01_macro") or (group[i] == "storage_arg_m_container_01_macro") or (group[i] == "storage_arg_l_container_01_macro") or
								(group[i] == "storage_par_s_container_01_macro") or (group[i] == "storage_par_m_container_01_macro") or (group[i] == "storage_par_l_container_01_macro") or
								(group[i] == "storage_spl_s_container_01_macro") or (group[i] == "storage_spl_m_container_01_macro") or (group[i] == "storage_spl_l_container_01_macro") or
								(group[i] == "storage_tel_s_container_01_macro") or (group[i] == "storage_tel_m_container_01_macro") or (group[i] == "storage_tel_l_container_01_macro") or
								(group[i] == "storage_ter_s_container_01_macro") or (group[i] == "storage_ter_m_container_01_macro") or (group[i] == "storage_ter_l_container_01_macro")
							then
								storagecounter_container = storagecounter_container + 1
								row[i].properties.helpOverlayID = "stationbuildst_storage_container" .. storagecounter_container
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial shipyard buildmodules
							if	(group[i] == "buildmodule_gen_ships_l_macro") or (group[i] == "buildmodule_gen_ships_xl_macro") or (group[i] == "buildmodule_ter_ships_l_macro") or (group[i] == "buildmodule_ter_ships_xl_macro") 
							then
								counter_shipyard = counter_shipyard + 1
								row[i].properties.helpOverlayID = "stationbuildst_build_shipyard" .. counter_shipyard
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial wharf buildmodules
							if	(group[i] == "buildmodule_gen_ships_m_dockarea_01_macro") or (group[i] == "buildmodule_ter_ships_m_dockarea_01_macro") 
							then
								counter_wharf = counter_wharf + 1
								row[i].properties.helpOverlayID = "stationbuildst_build_wharf" .. counter_wharf
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial Dockarea (any race)
							if	(group[i] == "dockarea_arg_m_station_01_hightech_macro") or (group[i] == "dockarea_arg_m_station_01_lowtech_macro") or (group[i] == "dockarea_arg_m_station_01_macro") or
								(group[i] == "dockarea_arg_m_station_02_hightech_macro") or (group[i] == "dockarea_arg_m_station_02_lowtech_macro") or (group[i] == "dockarea_arg_m_station_02_macro") or
								(group[i] == "dockarea_int_m_station_01_macro") or (group[i] == "dockarea_par_m_station_01_macro") or (group[i] == "dockarea_tel_m_station_01_macro") or (group[i] == "dockarea_ter_m_station_01_hightech_macro") 
							then
								dockareacounter = dockareacounter + 1
								row[i].properties.helpOverlayID = "stationbuildst_dock_dockarea" .. dockareacounter
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial Pier (any race)
							if	(group[i] == "pier_arg_harbor_01_macro") or (group[i] == "pier_arg_harbor_02_macro") or (group[i] == "pier_arg_harbor_03_macro") or
								(group[i] == "pier_par_harbor_01_macro") or (group[i] == "pier_par_harbor_02_macro") or (group[i] == "pier_par_harbor_03_macro") or
								(group[i] == "pier_spl_harbor_01_macro") or (group[i] == "pier_spl_harbor_02_macro") or (group[i] == "pier_spl_harbor_03_macro") or 
								(group[i] == "pier_tel_harbor_01_macro") or (group[i] == "pier_tel_harbor_02_macro") or (group[i] == "pier_tel_harbor_03_macro") or
								(group[i] == "pier_ter_harbor_01_macro") or (group[i] == "pier_ter_harbor_02_macro") or (group[i] == "pier_ter_harbor_03_macro") or (group[i] == "pier_ter_harbor_04_macro") 
							then
								counter_pier = counter_pier + 1
								row[i].properties.helpOverlayID = "stationbuildst_dock_pier" .. counter_pier
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							-- Tutorial Connections (any race)
							if	(group[i] == "struct_arg_base_01_macro")		or (group[i] == "struct_arg_base_02_macro")		or (group[i] == "struct_arg_base_03_macro")		or
								(group[i] == "struct_arg_cross_01_macro")		or (group[i] == "struct_arg_vertical_01_macro") or (group[i] == "struct_arg_vertical_02_macro") or
								(group[i] == "struct_par_base_01_macro")		or (group[i] == "struct_par_base_02_macro")		or (group[i] == "struct_par_base_03_macro")		or 
								(group[i] == "struct_par_cross_01_macro")		or (group[i] == "struct_par_cross_02_macro")	or (group[i] == "struct_par_cross_03_macro")	or
								(group[i] == "struct_par_vertical_01_macro")	or (group[i] == "struct_spl_base_01_macro")		or (group[i] == "struct_spl_base_02_macro")		or
								(group[i] == "struct_spl_base_03_macro")		or (group[i] == "struct_spl_cross_01_macro")	or (group[i] == "struct_spl_vertical_01_macro") or
								(group[i] == "struct_spl_vertical_02_macro")	or (group[i] == "struct_tel_base_01_macro")		or (group[i] == "struct_tel_base_02_macro")		or
								(group[i] == "struct_tel_base_03_macro")		or (group[i] == "struct_tel_cross_01_macro")	or (group[i] == "struct_tel_vertical_01_macro") or
								(group[i] == "struct_tel_vertical_02_macro")	or (group[i] == "struct_ter_base_01_macro")		or (group[i] == "struct_ter_base_02_macro")		or
								(group[i] == "struct_ter_base_03_macro")		or (group[i] == "struct_ter_cross_01_macro")	or (group[i] == "struct_ter_vertical_01_macro") or
								(group[i] == "struct_ter_vertical_02_macro")
							then
								counter_struct = counter_struct + 1
								row[i].properties.helpOverlayID = "stationbuildst_other_struct" .. counter_struct
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end 

							if menu.modulesMode == "moduletypes_production" then
								local icon = GetMacroData(group[i], "waregroupicon")
								if icon ~= "" then
									row[i]:setIcon2(icon, { color = Helper.defaultSliderCellValueColor })
								end
							elseif (menu.modulesMode == "moduletypes_storage") or (menu.modulesMode == "moduletypes_habitation") then
								local icon = "be_upgrade_size_" .. GetMacroData(group[i], "size")
								row[i]:setIcon2(icon, { color = Helper.defaultSliderCellValueColor })
							elseif canclaimownership then
								row[i]:setIcon2("be_upgrade_claiming", { color = Helper.defaultSliderCellValueColor })
							end
							if #makericon > 0 then
								local makertext = ""
								for i, icon in ipairs(makericon) do
									makertext = makertext .. ((i == 1) and "" or "\n") .. "\27[" .. icon .. "]"
								end
								local fontsize = Helper.scaleFont(Helper.standardFont, Helper.largeIconFontSize)
								local y = columnWidth / 2 - Helper.scaleY(Helper.largeIconTextHeight) / 2 - Helper.configButtonBorderSize
								row[i]:setText(makertext, { y = y, halign = "right", color = Helper.defaultSliderCellValueColor, fontsize = fontsize })
							end
							if menu.modulesMode == "moduletypes_venture" then
								local amount
								local isventureplatform = IsMacroClass(group[i], "ventureplatform")
								if isventureplatform or IsMacroClass(group[i], "dockarea") then
									local ware = GetMacroData(group[i], "ware")
									amount = math.max(0, OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[group[i]] or 0) - (menu.usedLimitedModules[group[i]] or 0))
								end
								row[i]:setText2(amount and (ReadText(1001, 42) .. " " .. amount) or "", { x = Helper.scaleX(Helper.configButtonBorderSize), y = - maxColumnWidth / 2 + Helper.standardTextHeight / 2 + Helper.configButtonBorderSize, halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize) })
								active = ((not amount) or (amount > 0)) and (isventureplatform or hasventureplatform)
								row[i].properties.active = active
								if not active then
									if (not isventureplatform) and (not hasventureplatform) then
										row[i].properties.mouseOverText = ReadText(1026, 7931)
									else
										row[i].properties.mouseOverText = menu.ventureModuleUnavailableMouseOverText()
									end
								else
									if not isventureplatform then
										row[i].properties.mouseOverText = ReadText(1026, 7922)
									end
								end
							end
							row[i].handlers.onClick = function () return menu.buttonAddModule(group[i], row.index, i) end
							if group[i] ~= "" then
								row[i].handlers.onRightClick = function (...) return menu.buttonInteract({ type = "module", name = GetMacroData(group[i], "name"), macro = group[i] }, ...) end
							end
							local extraText = TruncateText(shortname, Helper.standardFont, menu.extraFontSize, columnWidth - 2 * Helper.borderSize)
							row2[i]:createBoxText(extraText, { width = columnWidth, fontsize = menu.extraFontSize, boxColor = active and Helper.defaultButtonBackgroundColor or Helper.defaultUnselectableButtonBackgroundColor, mouseOverText = (extraText ~= shortname) and shortname or "" })
						end
					end
				end
			end

			ftable:setTopRow(menu.topRows.modules)
			ftable:setSelectedRow(menu.selectedRows.modules)
			ftable:setSelectedCol(menu.selectedCols.modules or 0)
		end
		menu.topRows.modules = nil
		menu.selectedRows.modules = nil
		menu.selectedCols.modules = nil
	else
		if menu.upgradetypeMode then
			local maxSlotWidth = math.floor((menu.modulesData.width - 8 * Helper.borderSize) / 9)
			local slotWidth = maxSlotWidth - math.floor(((count / 3 > 6) and Helper.scrollbarWidth or 0) / 9)
			local extraPixels = (menu.modulesData.width - 8 * Helper.borderSize) % 9
			local slotWidths = { slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth }
			if extraPixels > 0 then
				for i = 1, extraPixels do
					slotWidths[i] = slotWidths[i] + 1
				end
			end
			local columnWidths = {}
			local maxColumnWidth = 0
			for i = 1, 3 do
				columnWidths[i] = slotWidths[(i - 1) * 3 + 1] + slotWidths[(i - 1) * 3 + 2] + slotWidths[(i - 1) * 3 + 3] + 2 * Helper.borderSize
				maxColumnWidth = math.max(maxColumnWidth, columnWidths[i])
			end
			local slidercellWidth = menu.modulesData.width - math.floor((count / 3 > 6) and Helper.scrollbarWidth or 0)

			local ftable = frame:addTable(10, { tabOrder = 1, width = menu.modulesData.width, height = 0, x = menu.modulesData.offsetX, y = menu.modulesData.offsetY, scaling = false, reserveScrollBar = false, highlightMode = "column", backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			if menu.setdefaulttable then
				ftable.properties.defaultInteractiveObject = true
				menu.setdefaulttable = nil
			end
			for i = 1, 8 do
				ftable:setColWidth(i, slotWidths[i])
			end
			ftable:setColWidth(10, editboxheight)
			ftable:setDefaultColSpan(1, 3)
			ftable:setDefaultColSpan(4, 3)
			ftable:setDefaultColSpan(7, 4)

			local currentSlotInfo = {}

			local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)

			local name = menu.getLeftBarLoadoutEntry(menu.upgradetypeMode).name or ""
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(10):createText(name, menu.headerTextProperties)

			if menu.upgradetypeMode == "turretgroup" then
				local groupcount = 1
				local sizecounts = {}
				local groupedslots = {}
				for i, upgradegroup in ipairs(menu.groups) do
					local groupname = groupcount
					local slotsize = upgradegroup[upgradetype.grouptype].slotsize
					if slotsize ~= "" then
						if sizecounts[slotsize] then
							sizecounts[slotsize] = sizecounts[slotsize] + 1
						else
							sizecounts[slotsize] = 1
						end
						groupname = upgradetype.shorttext[slotsize] .. sizecounts[slotsize]
					end

					local compatibilities = upgradegroup[upgradetype.grouptype].compatibilities

					if i == menu.currentSlot then
						currentSlotInfo.slotsize = slotsize
						currentSlotInfo.compatibilities = compatibilities
					end

					table.insert(groupedslots, { i, upgradegroup, groupname, slotsize, compatibilities = compatibilities })
					groupcount = groupcount + 1
				end
				table.sort(groupedslots, menu.sortSlots)
				menu.groupedslots = {}
				for i, entry in ipairs(groupedslots) do
					local group = math.ceil(i / 9)
					menu.groupedslots[group] = menu.groupedslots[group] or {}
					table.insert(menu.groupedslots[group], entry)
				end
			end

			for _, group in ipairs(menu.groupedslots) do
				local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				for i = 1, 9 do
					if group[i] then
						local colspan = (i == 9) and 2 or 1

						local bgcolor = Helper.defaultTitleBackgroundColor
						if group[i][1] == menu.currentSlot then
							bgcolor = Helper.defaultArrowRowBackgroundColor
						end

						local count, total = 0, 0
						if menu.upgradetypeMode == "turretgroup" then
							for _, upgradetype2 in ipairs(Helper.upgradetypes) do
								if upgradetype2.supertype == "group" then
									if menu.groups[group[i][1]][upgradetype2.grouptype].total > 0 then
										if upgradetype2.mergeslots then
											count = count + ((menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype2.type][group[i][1]].count > 0) and 1 or 0)
											total = total + 1
										else
											count = count + menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype2.type][group[i][1]].count
											total = total + menu.groups[group[i][1]][upgradetype2.grouptype].total
										end
									end
								end
							end
						end

						local mouseovertext = ""
						if upgradetype then
							mouseovertext = ReadText(1001, 66) .. " " .. group[i][1]
						else
							mouseovertext = ReadText(1001, 8023) .. " " .. group[i][1]
						end

						row[i]:setColSpan(colspan):createButton({ height = slotWidths[i], bgColor = bgcolor, mouseOverText = mouseovertext }):setText(group[i][3], { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
						if total > 0 then
							local width = math.max(1, math.floor(count * (slotWidths[i] - 2 * menu.scaleSize) / total))
							row[i]:setIcon("solid", { color = Helper.color.white, width = width + 2 * Helper.configButtonBorderSize, height = menu.scaleSize + 2 * Helper.configButtonBorderSize, x = menu.scaleSize - Helper.configButtonBorderSize, y = slotWidths[i] - 2 * menu.scaleSize - Helper.configButtonBorderSize })
						end
						if group[i].compatibilities then
							local compatibilitytext = ""
							local j = 0
							for _, entry in ipairs(Helper.equipmentCompatibilities) do
								if group[i].compatibilities[entry.tag] then
									compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. "\27[menu_weaponslot]"
									j = j + 1
								end
								if (j > 0) and (j % 4 == 0) then
									compatibilitytext = compatibilitytext .. "\n"
								end
							end
							-- slotwidth is based on Helper.viewWidth but limited, so we need to reflect that here
							local fontsize = math.floor(config.compatibilityFontSize * Helper.viewWidth / 1920)
							local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
							local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
							fontsize = fontsize * actualSidePanelWidth / reservedSidePanelWidth

							local compatibilityTextHeight = math.ceil(C.GetTextHeight(compatibilitytext, Helper.standardFont, fontsize, 0)) + 2 * Helper.borderSize
							row[i]:setText2(compatibilitytext, { halign = "center", fontsize = fontsize, y = (slotWidths[i] - compatibilityTextHeight) / 2 })
						end
						row[i].handlers.onClick = function () return menu.buttonSelectSlot(group[i][1], row.index, i) end
					end
				end
			end

			if currentSlotInfo.compatibilities then
				local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent, scaling = true })
				row[1]:setBackgroundColSpan(10):setColSpan(5):createText(ReadText(1001, 8548) .. ReadText(1001, 120))
				local compatibilitytext = ""
				for _, entry in ipairs(Helper.equipmentCompatibilities) do
					if currentSlotInfo.compatibilities[entry.tag] then
						compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. currentSlotInfo.compatibilities[entry.tag]
					end
				end
				row[6]:setColSpan(5):createText(compatibilitytext, { halign = "right" })
			end

			if next(menu.groupedupgrades) then
				if menu.upgradetypeMode == "turretgroup" then
					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "group" then
							if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype.grouptype].total > 0) then
								local plandata = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][menu.currentSlot]
								local slotsize = menu.groups[menu.currentSlot][upgradetype.grouptype].slotsize

								local name = upgradetype.headertext.default
								if slotsize ~= "" then
									name = upgradetype.headertext[slotsize]
								end

								local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent, scaling = true })
								row[1]:setBackgroundColSpan(10):setColSpan(5):createText(name .. ReadText(1001, 120))
								row[6]:setColSpan(5):createText(plandata.count .. " / " .. menu.groups[menu.currentSlot][upgradetype.grouptype].total, { halign = "right" })
							end
						end
					end
				end
			end

			ftable:addEmptyRow(Helper.standardTextHeight / 2)

			local row = ftable:addRow(true, { fixed = true })
			row[1]:setColSpan(9):createEditBox({ defaultText = ReadText(1001, 3250), scaling = true }):setText(menu.searchtext, { x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
			row[1].handlers.onEditBoxDeactivated = menu.editboxSearchUpdateText
			row[10]:createButton({ height = editboxheight }):setText("X", { halign = "center", font = Helper.standardFontBold })
			row[10].handlers.onClick = function () return menu.buttonClearEditbox(row.index) end

			if next(menu.groupedupgrades) then
				if menu.upgradetypeMode == "turretgroup" then
					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "group" then
							if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype.grouptype].total > 0) then
								local plandata = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][menu.currentSlot]
								local scale = {
									min       = 0,
									minSelect = (plandata.macro == "") and 0 or 1,
									max       = menu.groups[menu.currentSlot][upgradetype.grouptype].total,
								}
								scale.maxSelect = (plandata.macro == "") and 0 or scale.max
								scale.start = math.max(scale.minSelect, math.min(scale.maxSelect, plandata.count))

								local slotsize = menu.groups[menu.currentSlot][upgradetype.grouptype].slotsize

								local row = ftable:addRow(true, {  })
								local name = upgradetype.text.default
								if plandata.macro == "" then
									if slotsize ~= "" then
										name = upgradetype.text[slotsize]
									end
								else
									name = GetMacroData(plandata.macro, "name")
								end

								local sizeicon
								if slotsize ~= "" then
									sizeicon = "be_upgrade_size_" .. slotsize
								end

								row[1]:setColSpan(10):createSliderCell({ width = slidercellWidth, height = Helper.headerRow1Height, valueColor = Helper.color.slidervalue, min = scale.min, minSelect = scale.minSelect, max = scale.max, maxSelect = scale.maxSelect, start = scale.start }):setText(name, menu.slidercellTextProperties)
								row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectAmount(upgradetype.type, menu.currentSlot, row.index, false, ...) end
								row[1].handlers.onSliderCellActivated = function() menu.noupdate = true end
								row[1].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

								for _, group in ipairs(menu.groupedupgrades[upgradetype.grouptype]) do
									local row = ftable:addRow(true, { bgColor = Helper.color.transparent, borderBelow = false })
									local row2 = ftable:addRow(false, { bgColor = Helper.color.transparent })
									for i = 1, 3 do
										if group[i] then
											local installicon, installcolor = (group[i].macro ~= "") and (sizeicon or "") or ""
											if (group[i].macro ~= "") then
												if (group[i].macro == menu.groups[menu.currentSlot][upgradetype.grouptype].currentmacro) and (group[i].macro ~= plandata.macro) then
													installicon = "be_upgrade_uninstalled"
													installcolor = Helper.color.red
												elseif (group[i].macro == plandata.macro) then
													installicon = "be_upgrade_installed"
													installcolor = Helper.color.green
												end
											end

											local weaponicon, compatibility = GetMacroData(group[i].macro, "ammoicon", "compatibility")
											if weaponicon and (weaponicon ~= "") and C.IsIconValid(weaponicon) then
												weaponicon = "\27[" .. weaponicon .. "]"
											else
												weaponicon = ""
											end
											if compatibility then
												local color = Helper.color.white
												for _, entry in ipairs(Helper.equipmentCompatibilities) do
													if entry.tag == compatibility then
														color = entry.color
														break
													end
												end
												weaponicon = Helper.convertColorToText(color) .. "\27[menu_weaponmount]\27X" .. weaponicon
											end

											local column = i * 3 - 2
											row[column]:createButton({ width = columnWidths[i], height = maxColumnWidth }):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor }):setText2(weaponicon, { x = 3, y = -maxColumnWidth / 2 + Helper.scaleY(Helper.standardTextHeight) / 2 + Helper.configButtonBorderSize, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
											row[column].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype.type, menu.currentSlot, group[i].macro, row.index, column) end
											if group[i].macro ~= "" then
												row[column].handlers.onRightClick = function (...) return menu.buttonInteract({ type = upgradetype.type, name = group[i].name, macro = group[i].macro }, ...) end
											end

											local extraText = ""
											local untruncatedExtraText = ""
											if group[i].macro ~= "" then
												local shortname, makerrace, infolibrary = GetMacroData(group[i].macro, "shortname", "makerrace", "infolibrary")
												extraText = TruncateText(shortname, Helper.standardFont, menu.extraFontSize, columnWidths[i] - 2 * Helper.borderSize)
												if extraText ~= shortname then
													untruncatedExtraText = shortname
												end
												for i, racestring in ipairs(makerrace) do
													extraText = extraText .. ((i == 1) and "\n" or " - ") .. racestring
													if untruncatedExtraText ~= "" then
														untruncatedExtraText = untruncatedExtraText .. ((i == 1) and "\n" or " - ") .. racestring
													end
												end
												AddKnownItem(infolibrary, group[i].macro)
											else
												local truncatedtext = TruncateText(group[i].name, Helper.standardFont, menu.extraFontSize, columnWidths[i] - 2 * Helper.borderSize)
												extraText = truncatedtext .. "\n"
												if truncatedtext ~= group[i].name then
													untruncatedExtraText = group[i].name .. "\n"
												end
											end
											row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, mouseOverText = untruncatedExtraText })
										end
									end
								end
							end
						end
					end
				end
			end

			ftable:setTopRow(menu.topRows.modules)
			ftable:setSelectedRow(menu.selectedRows.modules)
			ftable:setSelectedCol(menu.selectedCols.modules or 0)
		end
		menu.topRows.modules = nil
		menu.selectedRows.modules = nil
		menu.selectedCols.modules = nil
	end
end

function menu.refreshPlan()
	-- do not refresh the plan while we are in loadout edit mode -> no construction map to get data from
	if not menu.loadoutMode then
		menu.neededresources = {}
		local numTotalResources = C.PrepareBuildSequenceResources2(menu.holomap, menu.container, true)
		if numTotalResources > 0 then
			local buf = ffi.new("UIWareInfo[?]", numTotalResources)
			numTotalResources = C.GetBuildSequenceResources(buf, numTotalResources)
			for i = 0, numTotalResources - 1 do
				table.insert(menu.neededresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		table.sort(menu.neededresources, menu.wareNameSorter)

		menu.buildstorageresources = {}
		local n = C.GetNumCargo(menu.buildstorage, "stationbuilding")
		local buf = ffi.new("UIWareInfo[?]", n)
		n = C.GetCargo(buf, n, menu.buildstorage, "stationbuilding")
		for i = 0, n - 1 do
			table.insert(menu.buildstorageresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
		end

		C.PrepareBuildSequenceResources2(menu.holomap, menu.container, false)
		menu.constructionplan = {}
		menu.removedModules = {}
		if menu.holomap ~= 0 then
			local n = C.GetNumBuildMapConstructionPlan(menu.holomap, false)
			local buf = ffi.new("UIConstructionPlanEntry[?]", n)
			n = tonumber(C.GetBuildMapConstructionPlan(menu.holomap, menu.container, false, buf, n))
			for i = 0, n - 1 do
				local entry = {}
				entry.idx                   = buf[i].idx
				entry.macro                 = ffi.string(buf[i].macroid)
				entry.component             = buf[i].componentid
				entry.offset                = buf[i].offset
				entry.connection            = ffi.string(buf[i].connectionid)
				entry.predecessoridx        = buf[i].predecessoridx
				entry.predecessorconnection = ffi.string(buf[i].predecessorconnectionid)
				entry.isfixed               = buf[i].isfixed

				local loadout = Helper.getLoadoutHelper(C.GetConstructionMapItemLoadout2, C.GetConstructionMapItemLoadoutCounts2, menu.holomap, entry.idx, menu.container, entry.component)
				entry.upgradeplan           = Helper.convertLoadout(entry.component, entry.macro, loadout, nil)

				entry.resources = {}
				local numModuleResources = C. GetNumModuleNeededResources(menu.holomap, buf[i].idx)
				if numModuleResources > 0 then
					local resourceBuffer = ffi.new("UIWareInfo[?]", numModuleResources)
					numModuleResources = C.GetModuleNeededResources(resourceBuffer, numModuleResources, menu.holomap, buf[i].idx)
					for j = 0, numModuleResources - 1 do
						table.insert(entry.resources, { ware = ffi.string(resourceBuffer[j].ware), amount = resourceBuffer[j].amount })
					end
					table.sort(entry.resources, menu.wareNameSorter)
				end

				table.insert(menu.constructionplan, entry)
			end
			local newIndex = ffi.new("uint32_t[1]", 0)
			local numChangedIndices = ffi.new("uint32_t[1]", 0)
			local n = C.GetNumRemovedConstructionPlanModules2(menu.holomap, menu.container, newIndex, false, numChangedIndices, true)
			menu.newModulesIndex = tonumber(newIndex[0]) + 1
			menu.changedModulesIndices = {}
			local buf = ffi.new("UniverseID[?]", n)
			local changedIndicesBuf = ffi.new("uint32_t[?]", numChangedIndices[0])
			n = tonumber(C.GetRemovedConstructionPlanModules2(buf, n, changedIndicesBuf, numChangedIndices))
			if n > 0 then
				for i = 0, n - 1 do
					local compID = ConvertStringToLuaID(tostring(buf[i]))
					local loadout = Helper.getLoadoutHelper(C.GetCurrentLoadout, C.GetCurrentLoadoutCounts, menu.container, buf[i])

					local resources = {}
					local numModuleResources = C.GetNumModuleRecycledResources(buf[i])
					if numModuleResources > 0 then
						local resourceBuffer = ffi.new("UIWareInfo[?]", numModuleResources)
						numModuleResources = C.GetModuleRecycledResources(resourceBuffer, numModuleResources, buf[i])
						for j = 0, numModuleResources - 1 do
							table.insert(resources, { ware = ffi.string(resourceBuffer[j].ware), amount = -resourceBuffer[j].amount })
						end
						table.sort(resources, menu.wareNameSorter)
					end

					table.insert(menu.removedModules, { macro = GetComponentData(compID, "macro"), component = buf[i], upgradeplan = Helper.convertLoadout(buf[i], "", loadout, nil), resources = resources })
				end
			end
			if numChangedIndices[0] > 0 then
				for i = 0, numChangedIndices[0] - 1 do
					menu.changedModulesIndices[changedIndicesBuf[i]] = true
				end
			end

			-- limited module check
			menu.usedLimitedModules = {}
			for _, entry in ipairs(menu.constructionplan) do
				if IsMacroClass(entry.macro, "ventureplatform") or (IsMacroClass(entry.macro, "dockarea") and GetMacroData(entry.macro, "isventuremodule")) then
					if menu.usedLimitedModules[entry.macro] then
						menu.usedLimitedModules[entry.macro] = menu.usedLimitedModules[entry.macro] + 1
					else
						menu.usedLimitedModules[entry.macro] = 1
					end
				end
			end

			-- errors & warnings
			menu.criticalmoduleerrors = {}
			menu.moduleerrors = {}
			menu.modulewarnings = {}
			menu.criticalerrors = {}
			menu.errors = {}
			menu.warnings = {}
			menu.haschanges = not C.CompareMapConstructionSequenceWithPlanned(menu.holomap, menu.container, false)

			if not GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "isplayerowned") then
				menu.moduleerrors[2] = ReadText(1001, 7962)
			end

			if (menu.newModulesIndex > 0) and (menu.newModulesIndex <= #menu.constructionplan) then
				local immediateresources = {}
				for i, resource in ipairs(menu.constructionplan[menu.newModulesIndex].resources) do
					immediateresources[i] = { ware = resource.ware, amount = resource.amount }
				end
				for i = #immediateresources, 1, -1 do
					local entry = immediateresources[i]
					local idx = menu.findWareIdx(menu.buildstorageresources, entry.ware)
					if idx then
						entry.amount = entry.amount - menu.buildstorageresources[idx].amount
						if entry.amount <= 0 then
							table.remove(immediateresources, i)
						end
					end
				end
				if #immediateresources > 0 then
					for i = #immediateresources, 1, -1 do
						local entry = immediateresources[i]
						for _, removedModule in ipairs(menu.removedModules) do
							local idx = menu.findWareIdx(removedModule.resources, entry.ware)
							if idx then
								entry.amount = entry.amount + removedModule.resources[idx].amount
								if entry.amount <= 0 then
									table.remove(immediateresources, i)
									break
								end
							end
						end
					end
					if #immediateresources > 0 then
						menu.warnings[1] = ReadText(1001, 7913)
					end
				end
			end

			menu.constructionvessels = {}
			Helper.ffiVLA(menu.constructionvessels, "UniverseID", C.GetNumAssignedConstructionVessels, C.GetAssignedConstructionVessels, menu.buildstorage)
			if #menu.constructionvessels == 0 then
				if C.DoesConstructionSequenceRequireBuilder(menu.container) then
					menu.errors[1] = ReadText(1001, 7914)
				end
			end

			local haspier, hasdock, ismissingventureplatform, ismissingventuredocks, haswaveprotection = false, false, false, false, false
			for idx, entry in ipairs(menu.constructionplan) do
				local data = GetLibraryEntry(GetMacroData(entry.macro, "infolibrary"), entry.macro)
				if IsMacroClass(entry.macro, "pier") then
					haspier = true
				elseif IsMacroClass(entry.macro, "dockarea") then
					hasdock = true
					if GetMacroData(entry.macro, "isventuremodule") then
						ismissingventureplatform = ismissingventureplatform or (C.GetConstructionMapVenturePlatform(menu.holomap, idx) == 0)
					end
				elseif IsMacroClass(entry.macro, "ventureplatform") then
					ismissingventuredocks = ismissingventuredocks or (C.GetNumConstructionMapVenturePlatformDocks(menu.holomap, idx) == 0)
				elseif IsMacroClass(entry.macro, "buildmodule") then
					if (data.docks_m > 0) or (data.docks_s > 0) then
						hasdock = true
					end
				end
				haswaveprotection = haswaveprotection or GetMacroData(entry.macro, "haswaveprotection")
			end

			local mapresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, menu.holomap, nil, false))
			local plannedresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, 0, nil, true))

			local missingmapblueprints = {}
			for macro in string.gmatch(mapresult, "([%w_]*);") do
				missingmapblueprints[macro] = (missingmapblueprints[macro] or 0) + 1
			end
			local missingplannedblueprints = {}
			for macro in string.gmatch(plannedresult, "([%w_]*);") do
				missingplannedblueprints[macro] = (missingplannedblueprints[macro] or 0) + 1
			end

			local missingblueprintmodulemismatch = ""
			for k, v in pairs(missingmapblueprints) do
				if v < (missingplannedblueprints[k] or 0) then
					missingblueprintmodulemismatch = missingblueprintmodulemismatch .. "\n· " .. GetMacroData(k, "name")
				end
			end

			if (not haspier) and (not hasdock) then
				menu.moduleerrors[1] = ReadText(1001, 7958)
			elseif not hasdock then
				menu.modulewarnings[2] = ReadText(1001, 7916)
			elseif not haspier then
				menu.modulewarnings[3] = ReadText(1001, 7917)
			end
			if ismissingventureplatform then
				menu.modulewarnings[4] = ReadText(1001, 7960)
			end
			if ismissingventuredocks then
				menu.modulewarnings[5] = ReadText(1001, 7959)
			end
			if not haswaveprotection then
				local sector = GetComponentData(menu.container, "sectorid")
				if GetComponentData(sector, "containsthewave") then
					menu.modulewarnings[6] = ReadText(1001, 11917)
				end
			end
			if missingblueprintmodulemismatch ~= "" then
				menu.modulewarnings[7] = ReadText(1001, 11921) .. missingblueprintmodulemismatch
			end
		end
	end
end

function menu.etaSorter(a, b)
	if (a.eta < 0) then
		return false
	elseif (b.eta < 0) then
		return true
	end
	return a.eta < b.eta
end

function menu.moduleSorter(a, b)
	local aname = GetMacroData(a.macro, "name")
	local bname = GetMacroData(b.macro, "name")
	return aname < bname
end

function menu.moduleHeightHelper(ftable, prevfullheight)
	if prevfullheight < ftable.properties.maxVisibleHeight then
		local fullheight = ftable:getFullHeight()
		if fullheight > ftable.properties.maxVisibleHeight then
			ftable.properties.maxVisibleHeight = prevfullheight
		end
		return fullheight
	end
	return prevfullheight
end

function menu.displayPlan(frame)
	if not menu.loadoutMode then
		local ftable, modulestatustable, resourcetable
		local statusBars = {}
		if menu.planMode == "construction" then
			-- MODULE CHANGES
			ftable = frame:addTable(5, { tabOrder = 3, width = menu.planData.width, maxVisibleHeight = 0.4 * Helper.viewHeight, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			ftable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
			ftable:setColWidth(2, Helper.scaleY(Helper.standardTextHeight), false)
			ftable:setColWidth(4, 0.25 * menu.planData.width, false)
			ftable:setColWidth(5, Helper.scaleY(Helper.standardTextHeight), false)

			local prevfullheight = 0
			-- modules
			local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor, fixed = true })
			row[1]:setColSpan(5):createText(ReadText(1001, 7924), menu.headerTextProperties)
			-- unchanged modules
			local sortedModules = {}
			local changedCount = 0
			local habitationadded = 0
			local workforceneedadded = 0
			for i = 1, #menu.constructionplan do
				local infolibrary = GetMacroData(menu.constructionplan[i].macro, "infolibrary")
				if not menu.changedModulesIndices[i] then
					if sortedModules[infolibrary] then
						table.insert(sortedModules[infolibrary], menu.constructionplan[i])
					else
						sortedModules[infolibrary] = { menu.constructionplan[i] }
					end
				else
					changedCount = changedCount + 1
					if infolibrary == "moduletypes_habitation" then
						habitationadded = habitationadded + GetMacroData(menu.constructionplan[i].macro, "workforcecapacity")
					elseif infolibrary == "moduletypes_production" then
						workforceneedadded = workforceneedadded + GetMacroData(menu.constructionplan[i].macro, "maxworkforce")
					end
				end
			end
			for _, entry in ipairs(config.leftBar) do
				if sortedModules[entry.mode] then
					local isextended = menu.isEntryExtended(menu.container, entry.mode)

					local row = ftable:addRow(true, { bgColor = Helper.defaultTitleBackgroundColor })
					row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.buttonExtendEntry(entry.mode, row.index) end
					row[2]:setColSpan(2):setBackgroundColSpan(4):createText(entry.name, Helper.subHeaderTextProperties)
					row[4]:setColSpan(2):createText(#sortedModules[entry.mode], Helper.subHeaderTextProperties)
					row[4].properties.halign = "right"
					prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)

					if isextended then
						table.sort(sortedModules[entry.mode], menu.moduleSorter)
						for i = 1, #sortedModules[entry.mode] do
							local row = menu.displayModuleRow(ftable, i .. "entry.mode", sortedModules[entry.mode][i], false, false)
							prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
						end

						if entry.mode == "moduletypes_habitation" then
							local workforceinfo = C.GetWorkForceInfo(menu.container, "");

							ftable:addEmptyRow()
							local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
							row[2]:setColSpan(2):createText("   " .. ReadText(1001, 9611))
							row[4]:createText(ConvertIntegerString(workforceinfo.capacity, true, 0, true, false) .. ((habitationadded > 0) and (" (" .. ConvertIntegerString(workforceinfo.capacity + habitationadded, true, 0, true, false) .. ")") or ""), { halign = "right" })
							local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
							row[2]:setColSpan(2):createText("   " .. ReadText(1001, 8412))
							row[4]:createText(ConvertIntegerString(workforceinfo.current, true, 0, true, false), { halign = "right" })
							local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
							row[2]:setColSpan(2):createText("   " .. ReadText(1001, 8413))
							row[4]:createText(ConvertIntegerString(workforceinfo.optimal, true, 0, true, false) .. ((workforceneedadded > 0) and (" (" .. ConvertIntegerString(workforceinfo.optimal + workforceneedadded, true, 0, true, false) .. ")") or ""), { halign = "right" })
						end
					end
				end
			end
			-- removed modules
			if #menu.removedModules > 0 then
				local isextended = menu.isEntryExtended(menu.container, "removed")

				local row = ftable:addRow(true, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendEntry("removed", row.index) end
				row[2]:setColSpan(2):setBackgroundColSpan(4):createText(ReadText(1001, 7964), Helper.subHeaderTextProperties)
				row[2].properties.color = Helper.color.red
				row[4]:setColSpan(2):createText(#menu.removedModules, Helper.subHeaderTextProperties)
				row[4].properties.halign = "right"
				prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
				if isextended then
					for i, entry in ipairs(menu.removedModules) do
						menu.displayModuleRow(ftable, i, entry, false, true)
						prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
					end
				end
			end
			-- changed or new modules
			if changedCount > 0 then
				local isextended = menu.isEntryExtended(menu.container, "planned")

				local row = ftable:addRow(true, { bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendEntry("planned", row.index) end
				row[2]:setColSpan(2):setBackgroundColSpan(4):createText(ReadText(1001, 7963), Helper.subHeaderTextProperties)
				row[2].properties.color = Helper.color.green
				row[4]:setColSpan(2):createText(changedCount, Helper.subHeaderTextProperties)
				row[4].properties.halign = "right"
				prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
				if isextended then
					for i = 1, #menu.constructionplan do
						if menu.changedModulesIndices[i] then
							local row = menu.displayModuleRow(ftable, i, menu.constructionplan[i], true, false)
							if (not menu.selectedRows.plan) then
								menu.selectedRows.plan = row.index
							end
							prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
						end
					end
				end
			end
			menu.totalprice = GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "wantedmoney")

			if menu.selectedRows.plan == "last" then
				menu.selectedRows.plan = ftable.rows[#ftable.rows].index
			end
			if menu.selectedRows.plan == "first" then
				menu.selectedRows.plan = 2
			else
				local numdisplayedlines = math.floor((ftable:getVisibleHeight() - menu.titleData.height) / (Helper.scaleY(Helper.subHeaderHeight) + Helper.borderSize))
				if menu.topRows.plan and menu.selectedRows.plan then
					if menu.topRows.plan + numdisplayedlines - 1 < menu.selectedRows.plan then
						menu.topRows.plan = menu.selectedRows.plan - numdisplayedlines + 3
					elseif menu.selectedRows.plan < menu.topRows.plan then
						menu.topRows.plan = menu.selectedRows.plan
					end
				elseif menu.selectedRows.plan then
					menu.topRows.plan = menu.selectedRows.plan - numdisplayedlines + 3
				end
			end
			ftable:setTopRow(menu.topRows.plan)
			ftable:setSelectedRow(menu.selectedRows.plan)
			menu.topRows.plan = nil
			menu.selectedRows.plan = nil

			-- MODULE LOADOUTS & STATUS
			local yoffset = ftable.properties.y + ftable:getVisibleHeight() + 2 * Helper.borderSize
			modulestatustable = frame:addTable(6, { tabOrder = 4, width = menu.planData.width, x = menu.planData.offsetX, y = yoffset, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			local smallColWidth = Helper.scaleY(Helper.standardTextHeight)
			modulestatustable:setColWidth(1, smallColWidth, false)
			modulestatustable:setColWidth(2, smallColWidth, false)
			modulestatustable:setColWidth(3, 0.5 * menu.planData.width - 2 * smallColWidth, false)
			modulestatustable:setColWidth(5, 0.3 * menu.planData.width, false)
			modulestatustable:setColWidth(6, smallColWidth, false)

			-- station-wide loadout
			local row = modulestatustable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(6):createText(ReadText(1001, 7966), menu.headerTextProperties)
			-- selection
			local row = modulestatustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 7967) .. ReadText(1001, 120))
			local loadoutOptions = {
				{ id = 0,	text = ReadText(1001, 7990), icon = "", displayremoveoption = false },
				{ id = 0.1,	text = ReadText(1001, 7910), icon = "", displayremoveoption = false },
				{ id = 0.5,	text = ReadText(1001, 7911), icon = "", displayremoveoption = false },
				{ id = 1.0,	text = ReadText(1001, 7912), icon = "", displayremoveoption = false },
				{ id = -1,	text = ReadText(1001, 7968), icon = "", displayremoveoption = false },
			}
			row[5]:setColSpan(2):createDropDown(loadoutOptions, { startOption = function () return tostring(menu.defaultLoadout) end }):setTextProperties({ halign = "center" })
			row[5].handlers.onDropDownConfirmed = menu.dropdownDefaultLoadout

			-- preferred build method
			local row = modulestatustable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(6):createText(ReadText(1001, 11298), menu.headerTextProperties)

			local cursetting = ffi.string(C.GetContainerBuildMethod(menu.buildstorage))
			local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
					if id == curglobalsetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				curglobalsetting = "default"
			end
			local hasownsetting = cursetting ~= ""

			local rowdata = "info_buildrule_global"
			local row = modulestatustable:addRow({ rowdata }, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText(ReadText(1001, 8367))
			row[6]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[6].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(menu.buildstorage, checked, curglobalsetting) end

			local row = modulestatustable:addRow("info_buildrule", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(6):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(menu.buildstorage, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			-- module status here
			local row = modulestatustable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(6):createText(ReadText(1001, 7991), menu.headerTextProperties)
		
			local infoCount = 0
			local visibleHeight
			for _, errorentry in Helper.orderedPairs(menu.criticalmoduleerrors) do
				row = modulestatustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(6):createText(errorentry, { color = Helper.color.red, wordwrap = true })
			end
			for _, errorentry in Helper.orderedPairs(menu.moduleerrors) do
				row = modulestatustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(6):createText(errorentry, { color = Helper.color.red, wordwrap = true })
			end
			for _, warningentry in Helper.orderedPairs(menu.modulewarnings) do
				row = modulestatustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(6):createText(warningentry, { color = Helper.color.orange, wordwrap = true })
			end
			if (not next(menu.criticalmoduleerrors)) and (not next(menu.moduleerrors)) and (not next(menu.modulewarnings)) then
				row = modulestatustable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(6):createText(ReadText(1001, 7923), { color = Helper.color.green })
			end

			-- BUTTONS
			if menu.cancelRequested then
				local row = modulestatustable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(6):createText(ReadText(1001, 9705), menu.headerTextProperties)

				local row = modulestatustable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
				row[1]:setColSpan(3):createButton({  }):setText(ReadText(1001, 2617), { halign = "center" })
				row[1].handlers.onClick = menu.buttonCancelConfirm
				row[4]:setColSpan(3):createButton({  }):setText(ReadText(1001, 2618), { halign = "center" })
				row[4].handlers.onClick = menu.buttonCancelCancel
			else
				local row = modulestatustable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
				if (ffi.string(C.GetGameStartName()) == "x4ep1_gamestart_workshop") and (not menu.confirmModuleChangesActive()) and ((C.GetCurrentBuildProgress(menu.container) >= 0) or C.IsBuildWaitingForSecondaryComponentResources(menu.container)) then
					row[1]:setColSpan(3):createButton({ helpOverlayID = "force_modulechanges", helpOverlayText = " ",  helpOverlayHighlightOnly = true, active = true }):setText(ReadText(1001, 11919), { halign = "center" })
					row[1].handlers.onClick = menu.buttonForceBuild
				else
					row[1]:setColSpan(3):createButton({ helpOverlayID = "confirm_modulechanges", helpOverlayText = " ",  helpOverlayHighlightOnly = true, active = menu.confirmModuleChangesActive }):setText(ReadText(1001, 7919), { halign = "center" })
					row[1].handlers.onClick = menu.buttonConfirm
					row[1].properties.uiTriggerID = "confirmmodulechanges"
				end
				row[4]:setColSpan(3):createButton({ helpOverlayID = "cancel_modulechanges", helpOverlayText = " ",  helpOverlayHighlightOnly = true, active = menu.haschanges }):setText(ReadText(1001, 7918), { halign = "center" })
				row[4].handlers.onClick = menu.buttonCancel
				row[4].properties.uiTriggerID = "cancelmodulechanges"
			end

			-- BUILD RESOURCES
			local yoffset = modulestatustable.properties.y + modulestatustable:getVisibleHeight() + 2 * Helper.borderSize
			resourcetable = frame:addTable(6, { tabOrder = 5, width = menu.planData.width, x = menu.planData.offsetX, y = yoffset, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			resourcetable:setColWidth(1, smallColWidth, false)
			resourcetable:setColWidth(2, smallColWidth, false)
			resourcetable:setColWidth(3, 0.5 * menu.planData.width - 2 * smallColWidth, false)
			resourcetable:setColWidth(5, 0.3 * menu.planData.width, false)
			resourcetable:setColWidth(6, smallColWidth, false)

			menu.tradewares = {}
			local n = C.GetNumWares("stationbuilding", false, "", "")
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWares(buf, n, "stationbuilding", false, "", "")
			for i = 0, n - 1 do
				table.insert(menu.tradewares, { ware = ffi.string(buf[i]) })
			end

			-- resources
			local row = resourcetable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(6):createText(ReadText(1001, 7925), menu.headerTextProperties)
			-- have
			local row = resourcetable:addRow(true, { bgColor = Helper.defaultTitleBackgroundColor })
			if not menu.selectedRows.planresources then
				menu.selectedRows.planresources = row.index
			end
			local isextended = menu.isResourceEntryExtended("buildstorage")
			row[1]:createButton({ helpOverlayID = "plot_resources_available", helpOverlayText = " ",  helpOverlayHighlightOnly = true  }):setText(isextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendResourceEntry("buildstorage", row.index) end
			row[2]:setColSpan(5):createText(ReadText(1001, 7927) .. (menu.newWareReservation and " \27G[+" .. menu.newWareReservation .. "]" or ""), Helper.subHeaderTextProperties)

			if isextended then
				-- reservations
				local reservations = {}
				local n = C.GetNumContainerWareReservations2(menu.buildstorage, false, false, true)
				local buf = ffi.new("WareReservationInfo2[?]", n)
				n = C.GetContainerWareReservations2(buf, n, menu.buildstorage, false, false, true)
				for i = 0, n - 1 do
					local ware = ffi.string(buf[i].ware)
					local tradedeal = buf[i].tradedealid
					if not menu.dirtyreservations[tostring(tradedeal)] then
						if reservations[ware] then
							table.insert(reservations[ware], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal })
						else
							reservations[ware] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal } }
						end
					end
				end
				for _, data in pairs(reservations) do
					table.sort(data, menu.etaSorter)
				end

				local resources = {}
				for _, resource in ipairs(menu.neededresources) do
					if resource.amount > 0 then
						local current = 0
						local idx = menu.findWareIdx(menu.buildstorageresources, resource.ware)
						if idx then
							current =  menu.buildstorageresources[idx].amount
						end

						local reserved = 0
						if reservations[resource.ware] then
							for _, reservation in ipairs(reservations[resource.ware]) do
								reserved = reserved + reservation.amount
							end
						end

						table.insert(resources, { ware = resource.ware, name = GetWareData(resource.ware, "name"), needed = resource.amount, current = current, reserved = reserved })
					end
				end
				for _, resource in ipairs(menu.buildstorageresources) do
					local idx = menu.findWareIdx(resources, resource.ware)
					if not idx then
						local needed = 0
						local idx = menu.findWareIdx(menu.neededresources, resource.ware)
						if idx then
							needed =  menu.neededresources[idx].amount
						end

						local reserved = 0
						if reservations[resource.ware] then
							for _, reservation in ipairs(reservations[resource.ware]) do
								reserved = reserved + reservation.amount
							end
						end

						table.insert(resources, { ware = resource.ware, name = GetWareData(resource.ware, "name"), needed = needed, current = resource.amount, reserved = reserved })
					end
				end
				for ware, reservationentry in pairs(reservations) do
					local idx = menu.findWareIdx(resources, ware)
					if not idx then
						local current = 0
						local idx = menu.findWareIdx(menu.buildstorageresources, ware)
						if idx then
							current =  menu.buildstorageresources[idx].amount
						end

						local needed = 0
						local idx = menu.findWareIdx(menu.neededresources, ware)
						if idx then
							needed =  menu.neededresources[idx].amount
						end

						local reserved = 0
						if reservationentry then
							for _, reservation in ipairs(reservations[ware]) do
								reserved = reserved + reservation.amount
							end
						end

						table.insert(resources, { ware = ware, name = GetWareData(ware, "name"), needed = needed, current = current, reserved = reserved })
					end
				end
				table.sort(resources, Helper.sortName)

				for i, resource in ipairs(resources) do
					local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
					local xoffset = row[1]:getWidth() + row[2]:getWidth() + row[3]:getWidth() + 3 * Helper.borderSize
					statusBars[i] = row[1]:createStatusBar({ current = resource.current + resource.reserved, start = resource.current, max = resource.needed, cellBGColor = Helper.color.transparent, valueColor = Helper.defaultSliderCellValueColor, posChangeColor = Helper.defaultSimpleBackgroundColor, width = menu.planData.width - xoffset, x = xoffset, scaling = false })
					row[2]:setColSpan(2):createText(GetWareData(resource.ware, "name"))
					row[4]:setColSpan(3):createText(((resource.current < resource.needed) and "\27R" or "") .. ConvertIntegerString(resource.current, true, 0, true) .. "\27X" .. ((resource.reserved > 0) and (" (\27G+" .. ConvertIntegerString(resource.reserved, true, 0, true) .. "\27X)") or "") .. " / " .. ConvertIntegerString(resource.needed, true, 0, true), { halign = "right", cellBGColor = Helper.color.darkgrey })
				end

				menu.newWareReservation = nil
				if next(reservations) then
					local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(6):createText(ReadText(1001, 7946), Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
					for _, ware in ipairs(menu.tradewares) do
						if reservations[ware.ware] then
							local isextended = menu.isResourceEntryExtended("reservation" .. ware.ware, true)
							local titlerow = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
							titlerow[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
							titlerow[1].handlers.onClick = function () return menu.buttonExtendResourceEntry("reservation" .. ware.ware, titlerow.index) end
							local color = Helper.color.white
							if menu.newWareReservationWares[ware.ware] then
								color = Helper.color.green
							end
							titlerow[2]:setColSpan(3):createText(GetWareData(ware.ware, "name"), { color = color })
							local total = 0
							for _, reservation in ipairs(reservations[ware.ware]) do
								total = total + reservation.amount
								if isextended then
									local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
									local reserverid = ConvertStringTo64Bit(tostring(reservation.reserver))
									local name = ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")"
									local colorprefix = GetComponentData(reserverid, "isplayerowned") and "\27G" or ""

									-- kuertee start: callback
									-- row[2]:setColSpan(3):createText(function () return Helper.getETAString(colorprefix .. name, reservation.eta) end, { font = Helper.standardFontMono })
									if callbacks ["displayPlan_render_incoming_ware"] then
										for _, callback in ipairs (callbacks ["displayPlan_render_incoming_ware"]) do
											isbreak = callback (row, colorprefix, name, reservation)
											if isbreak then
												break
											end
										end
									else
										row[2]:setColSpan(3):createText(function () return Helper.getETAString(colorprefix .. name, reservation.eta) end, { font = Helper.standardFontMono })
									end
									-- kuertee end: callback

									local color = Helper.color.white
									if menu.newWareReservationWares[ware.ware] and menu.newWareReservationWares[ware.ware][tostring(reserverid)] then
										color = Helper.color.green
									end
									row[5]:createText(ConvertIntegerString(reservation.amount, true, 0, false), { halign = "right", color = color })
									row[6]:createButton({ active = function () return menu.buttonCancelTradeActive(reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
									row[6].handlers.onClick = function () return menu.buttonCancelTrade(reservation.tradedeal) end
								end
							end
							titlerow[5]:setColSpan(2):createText(ConvertIntegerString(total, true, 0, false), { halign = "right" })
						end
					end
				end
				resourcetable:addEmptyRow(Helper.standardTextHeight / 2)
				menu.newWareReservationWares = {}
			end

			-- config
			local row = resourcetable:addRow(true, { bgColor = Helper.defaultTitleBackgroundColor })
			local isextended = menu.isResourceEntryExtended("resourceconfig")
			row[1]:createButton({ helpOverlayID = "plot_resources_buyoffers", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(isextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendResourceEntry("resourceconfig", row.index) end
			row[1].properties.uiTriggerID = "extendresourceentry"
			row[2]:setColSpan(5):createText(ReadText(1001, 7928), Helper.subHeaderTextProperties)
			if isextended then
				local row = resourcetable:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(ReadText(1001, 7944), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"

				-- trade rule
				local hasownlist = C.HasContainerOwnTradeRule(menu.buildstorage, "buy", "") or C.HasContainerOwnTradeRule(menu.buildstorage, "sell", "")
				local traderuleid = C.GetContainerTradeRuleID(menu.buildstorage, "buy", "")
				if traderuleid ~= C.GetContainerTradeRuleID(menu.buildstorage, "sell", "") then
					DebugError("Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(menu.buildstorage, "sell", "")))
				end
				local row = resourcetable:addRow(nil, { bgColor = Helper.color.unselectable })
				row[1].properties.cellBGColor = Helper.color.transparent
				row[2]:setColSpan(5):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
				-- global
				local row = resourcetable:addRow("order_wares_global", { bgColor = Helper.color.transparent })
				row[2]:setColSpan(4):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
				row[6]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
				row[6].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.buildstorage, "trade", checked) end
				-- current
				local row = resourcetable:addRow("order_wares_current", { bgColor = Helper.color.transparent })
				row[2]:setColSpan(4):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
				row[2].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.buildstorage, "trade", id, "", true) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				row[6]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
				row[6].handlers.onClick = menu.buttonEditTradeRule

				resourcetable:addEmptyRow()

				-- global price modifier
				local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
				menu.globalpricefactor = C.GetContainerGlobalPriceFactor(menu.buildstorage)
				local hasvalidmodifier = menu.globalpricefactor >= 0
				row[2]:createCheckBox(hasvalidmodifier, { })
				row[2].handlers.onClick = menu.checkboxToggleGlobalWarePriceModifier
				row[3]:setColSpan(4):createText(ReadText(1001, 7945))
				local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
				local currentfactor = menu.globalpricefactor * 100
				row[2]:setColSpan(5):createSliderCell({ height = Helper.standardTextHeight, valueColor = hasvalidmodifier and Helper.color.slidervalue or Helper.color.grey, min = 0, max = 100, start = hasvalidmodifier and currentfactor or 100, suffix = "%", readOnly = not hasvalidmodifier, hideMaxValue = true }):setText(ReadText(1001, 2808))
				row[2].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellGlobalWarePriceFactor(row.index, ...) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				-- trade restrictions
				local row = resourcetable:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(ReadText(1001, 7931), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"

				for i, ware in ipairs(menu.tradewares) do
					local isextended = menu.isResourceEntryExtended("resourceconfig" .. ware.ware)
					local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
					row[2]:createButton({ helpOverlayID = "plot_resources_resourceconfig" .. ware.ware, helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(isextended and "-" or "+", { halign = "center" })
					row[2].handlers.onClick = function () return menu.buttonExtendResourceEntry("resourceconfig" .. ware.ware, row.index) end
					row[2].properties.uiTriggerID = "extendresourceentry" .. ware.ware
					
					-- kuertee start: callback
					-- row[3]:setColSpan(2):createText(GetWareData(ware.ware, "name"))
					if callbacks ["displayPlan_getWareName"] then
						local name
						for _, callback in ipairs (callbacks ["displayPlan_getWareName"]) do
							name = callback (ware.ware, name)
						end
						if name then
							row[3]:setColSpan(2):createText(name)
						else
							row[3]:setColSpan(2):createText(GetWareData(ware.ware, "name"))
						end
					end
					-- kuertee end: callback

					if C.GetContainerTradeRuleID(menu.buildstorage, "buy", ware.ware) > 0 then
						row[5]:setColSpan(2):createText("\27[lso_error]", { halign = "right", color = Helper.color.warningorange, mouseOverText = ReadText(1026, 8404) })
					end
				
					ware.minprice, ware.maxprice = GetWareData(ware.ware, "minprice", "maxprice")
					if isextended then
						-- trade rule
						local hasownlist = C.HasContainerOwnTradeRule(menu.buildstorage, "buy", ware.ware) or C.HasContainerOwnTradeRule(menu.buildstorage, "sell", ware.ware)
						local traderuleid = C.GetContainerTradeRuleID(menu.buildstorage, "buy", ware.ware)
						if traderuleid ~= C.GetContainerTradeRuleID(menu.buildstorage, "sell", ware.ware) then
							DebugError("Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(menu.buildstorage, "sell", ware.ware)))
						end
						local row = resourcetable:addRow(nil, { bgColor = Helper.color.unselectable })
						row[1].properties.cellBGColor = Helper.color.transparent
						row[2].properties.cellBGColor = Helper.color.transparent
						row[3]:setColSpan(4):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
						-- global
						local row = resourcetable:addRow("order_wares_global", { bgColor = Helper.color.transparent })
						row[3]:setColSpan(3):createText(ReadText(1001, 11033) .. ReadText(1001, 120), textproperties)
						row[6]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
						row[6].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.buildstorage, "trade", checked, ware.ware) end
						-- current
						local row = resourcetable:addRow("order_wares_current", { bgColor = Helper.color.transparent })
						row[3]:setColSpan(3):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
						row[3].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.buildstorage, "trade", id, ware.ware, true) end
						row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
						row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
						row[6]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
						row[6].handlers.onClick = menu.buttonEditTradeRule

						resourcetable:addEmptyRow(Helper.standardTextHeight / 2)

						local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
						ware.row = row.index
						local currentprice = math.max(ware.minprice, math.min(ware.maxprice, GetContainerWarePrice(menu.buildstorage, ware.ware, true, true)))
						row[3]:setColSpan(4):createSliderCell({ height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = ware.minprice, max = ware.maxprice, start = currentprice, suffix = ReadText(1001, 101), readOnly = restricted, hideMaxValue = true }):setText(ReadText(1001, 2808))
						row[3].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellWarePriceOverride(ware.ware, row.index, ...) end
						row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
						row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

						if i ~= #menu.tradewares then
							resourcetable:addEmptyRow()
						end
					end
				end
				-- price
				local row = resourcetable:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(ReadText(1001, 7929), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"
				local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(ConvertMoneyString(menu.totalprice, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				-- account
				local row = resourcetable:addRow(false, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(5):createText(ReadText(1001, 7930), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"
				row[2].properties.helpOverlayID = "construction_available_funds"
				row[2].properties.helpOverlayText = " "
				row[2].properties.helpOverlayHighlightOnly = true
				local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
				local buildstoragemoney = GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "money")
				local playermoney = GetPlayerMoney()
				local min = 0
				local max = buildstoragemoney + playermoney
				local start = math.max(min, math.min(max, menu.newAccountValue or buildstoragemoney))
				row[2]:setColSpan(5):createSliderCell({ height = Helper.standardTextHeight, valueColor = Helper.color.slidervalue, min = min, max = max, start = start, suffix = ReadText(1001, 101), hideMaxValue = true })
				row[2].handlers.onSliderCellChanged = menu.slidercellMoney
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				local row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
				row[2]:setColSpan(3):createButton({ helpOverlayID = "confirm_credits", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = function () return (menu.newAccountValue ~= nil) and (menu.newAccountValue ~= buildstoragemoney) and GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "isplayerowned") end }):setText(ReadText(1001, 2821), { halign = "center" })
				row[2].handlers.onClick = menu.buttonConfirmMoney
				row[2].properties.uiTriggerID = "confirmcredits"
				row[5]:setColSpan(2):createButton({ active = function () local money, isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "money", "isplayerowned"); return ((money + GetPlayerMoney()) > menu.totalprice) and isplayerowned end }):setText(ReadText(1001, 7965), { halign = "center" })
				row[5].handlers.onClick = menu.buttonSetMoneyToEstimate
			end

			-- CVs
			local row = resourcetable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(6):createText(ReadText(1001, 7932), menu.headerTextProperties)
			row[1].properties.halign = "center"
			row[1].properties.helpOverlayID = "construction_builders_header"
			row[1].properties.helpOverlayText = " "
			row[1].properties.helpOverlayHighlightOnly = true

			if #menu.constructionvessels > 0 then
				for _, component in ipairs(menu.constructionvessels) do
					row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(6):createText(ffi.string(C.GetComponentName(component)) .. " (" .. ffi.string(C.GetObjectIDCode(component)) .. ")")
				end
			else
				row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(6):createText(ReadText(1001, 7933))
			end
			row = resourcetable:addRow(true, { bgColor = Helper.color.transparent })
			if #menu.constructionvessels == 0 then
				local active = C.DoesConstructionSequenceRequireBuilder(menu.container)
				row[1]:setColSpan(6):createButton({ active = active, helpOverlayID = "assign_hire_builder", helpOverlayText = " ",  helpOverlayHighlightOnly = true, mouseOverText = active and "" or ReadText(1026, 7923) }):setText(ReadText(1001, 7934), { halign = "center" })
				row[1].handlers.onClick = menu.buttonAssignConstructionVessel
				row[1].properties.uiTriggerID = "assignhirebuilder"
			else
				local deployorderidx
				local numorders = C.GetNumOrders(menu.constructionvessels[1])
				local currentorders = ffi.new("Order[?]", numorders)
				numorders = C.GetOrders(currentorders, numorders, menu.constructionvessels[1])
				for i = 1, numorders do
					if ffi.string(currentorders[i - 1].orderdef) == "DeployToStation" then
						deployorderidx = i
						break
					end
				end

				row[1]:setColSpan(5):createButton({ active = (deployorderidx ~= nil) and C.RemoveOrder2(menu.constructionvessels[1], deployorderidx, true, true, true) }):setText(ReadText(1001, 7961), { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonFireConstructionVessel(menu.constructionvessels[1], deployorderidx) end
				row[1].properties.uiTriggerID = "firebuilder"
			end

			resourcetable:setTopRow(menu.topRows.planresources)
			resourcetable:setSelectedRow(menu.selectedRows.planresources)
			menu.topRows.planresources = nil
			menu.selectedRows.planresources = nil
		end

		-- STATUS
		local statustable = frame:addTable(2, { tabOrder = 6, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = false, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		statustable:setDefaultColSpan(1, 2)

		local row = statustable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
		row[1]:createText(ReadText(1001, 7922), menu.headerTextProperties)
		
		for _, errorentry in Helper.orderedPairs(menu.criticalerrors) do
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(errorentry, { color = Helper.color.red, wordwrap = true })
		end
		for _, errorentry in Helper.orderedPairs(menu.errors) do
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(errorentry, { color = Helper.color.red, wordwrap = true })
		end
		for _, warningentry in Helper.orderedPairs(menu.warnings) do
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(warningentry, { color = Helper.color.orange, wordwrap = true })
		end
		if (not next(menu.criticalerrors)) and (not next(menu.errors)) and (not next(menu.warnings)) then
			row = statustable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 7923), { color = Helper.color.green })
		end

		local row = statustable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(1)
		row[2]:createButton({ helpOverlayID = "menu_close", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(ReadText(1001, 8035), { halign = "center" })
		row[2].handlers.onClick = function () menu.modulesMode = nil; return menu.onCloseElement("back") end

		statustable.properties.y = Helper.viewHeight - statustable:getFullHeight() - Helper.frameBorder
		if menu.planMode == "construction" then
			resourcetable.properties.maxVisibleHeight = statustable.properties.y - resourcetable.properties.y - 2 * Helper.borderSize
			if resourcetable.properties.maxVisibleHeight < resourcetable:getFullHeight() then
				for _, statusbar in ipairs(statusBars) do
					statusbar.properties.width = statusbar.properties.width - Helper.scrollbarWidth
				end
			end

			ftable:addConnection(1, 4, true)
			modulestatustable:addConnection(2, 4)
			resourcetable:addConnection(3, 4)
			statustable:addConnection(4, 4)
		else
			statustable:addConnection(1, 4, true)
		end

		-- guarantee 20% of height for resourcetable
		local maxmoduletableheight = statustable.properties.y - ftable.properties.y - modulestatustable:getFullHeight() - 2 * Helper.borderSize - 0.2 * Helper.viewHeight
		if maxmoduletableheight < ftable.properties.maxVisibleHeight then
			ftable.properties.maxVisibleHeight = maxmoduletableheight
			modulestatustable.properties.y = ftable.properties.y + ftable:getVisibleHeight() + 2 * Helper.borderSize
			resourcetable.properties.y = modulestatustable.properties.y + modulestatustable:getVisibleHeight() + 2 * Helper.borderSize
			resourcetable.properties.maxVisibleHeight = statustable.properties.y - resourcetable.properties.y - 2 * Helper.borderSize
			if resourcetable.properties.maxVisibleHeight < resourcetable:getFullHeight() then
				for _, statusbar in ipairs(statusBars) do
					statusbar.properties.width = statusbar.properties.width - Helper.scrollbarWidth
				end
			end
		end
	else
		-- BUTTONS
		local buttontable = frame:addTable(2, { tabOrder = 7, width = menu.planData.width, height = Helper.scaleY(Helper.standardButtonHeight), x = menu.planData.offsetX, y = Helper.viewHeight - Helper.scaleY(Helper.standardButtonHeight) - Helper.frameBorder, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
		if menu.cancelRequested then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(2):createText(ReadText(1001, 9705), menu.headerTextProperties)

			local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:createButton({  }):setText(ReadText(1001, 2617), { halign = "center" })
			row[1].handlers.onClick = menu.buttonCancelLoadout
			row[2]:createButton({  }):setText(ReadText(1001, 2618), { halign = "center" })
			row[2].handlers.onClick = menu.buttonCancelCancel
		else
			local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:createButton({  }):setText(ReadText(1001, 7921), { halign = "center" })
			row[1].handlers.onClick = menu.buttonConfirmLoadout
			row[2]:createButton({  }):setText(ReadText(1001, 7920), { halign = "center" })
			row[2].handlers.onClick = menu.buttonCancel
		end
		buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - Helper.frameBorder

		if menu.loadoutPlanMode == "normal" then
			-- EQUIPMENT
			local ftable = frame:addTable(5, { tabOrder = 3, width = menu.planData.width, maxVisibleHeight = buttontable.properties.y - menu.planData.offsetY, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, skipTabChange = true, highlightMode = "off", backgroundID = "solid", backgroundColor = Helper.color.transparent60 })
			ftable:setColWidth(1, Helper.standardTextHeight)
			ftable:setColWidth(2, Helper.standardTextHeight)
			ftable:setColWidth(4, 0.3 * menu.planData.width)
			ftable:setColWidth(5, Helper.standardTextHeight)

			local row = ftable:addRow(false, { bgColor = Helper.defaultTitleBackgroundColor })
			row[1]:setColSpan(5):createText(ReadText(1001, 7935), menu.headerTextProperties)

			local removedEquipment = {}
			local currentEquipment = {}
			local newEquipment = {}
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				local slots = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type]
				local first = true
				for slot, macro in pairs(slots) do
					if first or (not upgradetype.mergeslots) then
						first = false
						if upgradetype.supertype == "group" then
							local data = macro
							local oldslotdata = menu.groups[slot][upgradetype.grouptype]

							if data.macro ~= "" then
								local i = menu.findUpgradeMacro(upgradetype.grouptype, data.macro)
								if not i then
									break
								end
								local upgradeware = menu.upgradewares[upgradetype.grouptype][i]

								if oldslotdata.currentmacro ~= "" then
									local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
									if not j then
										break
									end
									local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

									if data.macro == oldslotdata.currentmacro then
										if upgradetype.mergeslots then
											menu.insertWare(currentEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
										else
											if oldslotdata.count < data.count then
												menu.insertWare(currentEquipment, upgradeware.ware, oldslotdata.count)
												menu.insertWare(newEquipment, upgradeware.ware, data.count - oldslotdata.count)
											elseif oldslotdata.count > data.count then
												menu.insertWare(currentEquipment, upgradeware.ware, data.count)
												menu.insertWare(removedEquipment, upgradeware.ware, oldslotdata.count - data.count)
											else
												menu.insertWare(currentEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
											end
										end
									else
										menu.insertWare(removedEquipment, oldupgradeware.ware, (upgradetype.mergeslots and #slots or oldslotdata.count))
										menu.insertWare(newEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
									end
								else
									menu.insertWare(newEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
								end
							elseif oldslotdata.currentmacro ~= "" then
								local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
								if not j then
									break
								end
								local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

								menu.insertWare(removedEquipment, oldupgradeware.ware, (upgradetype.mergeslots and #slots or oldslotdata.count))
							end
						end
					end
				end
			end

			if (#removedEquipment > 0) or (#newEquipment > 0) then
				menu.haschanges = true
			else
				menu.haschanges = false
			end

			if (#removedEquipment > 0) or (#currentEquipment > 0) or (#newEquipment > 0) then
				for _, entry in ipairs(removedEquipment) do
					row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(5):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"), { color = Helper.color.red })
				end
				for _, entry in ipairs(currentEquipment) do
					row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(5):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"))
				end
				for _, entry in ipairs(newEquipment) do
					row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(5):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"), { color = Helper.color.green })
				end
			else
				row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 7936) .. " ---", { halign = "center" } )
			end

			ftable:addConnection(1, 4, true)
			buttontable:addConnection(2, 4)
		else
			buttontable:addConnection(1, 4, true)
		end
	end
end

function  menu.dropdownBuildRule(container, id)
	C.SetContainerBuildMethod(container, id)
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.checkboxSetBuildRuleOverride(container, checked, curglobal)
	if checked then 
		C.SetContainerBuildMethod(container, "")
	else 
		C.SetContainerBuildMethod(container, curglobal or "default")
	end
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.confirmModuleChangesActive()
	local mapresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, menu.holomap, nil, false))
	local plannedresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, 0, nil, true))

	local missingmapblueprints = {}
	for macro in string.gmatch(mapresult, "([%w_]*);") do
		missingmapblueprints[macro] = (missingmapblueprints[macro] or 0) + 1
	end
	local missingplannedblueprints = {}
	for macro in string.gmatch(plannedresult, "([%w_]*);") do
		missingplannedblueprints[macro] = (missingplannedblueprints[macro] or 0) + 1
	end

	local mismatch = false
	for k, v in pairs(missingmapblueprints) do
		if v > (missingplannedblueprints[k] or 0) then
			mismatch = true
			break
		end
	end

	return (not mismatch) and (#menu.criticalerrors == 0) and menu.haschanges and GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "isplayerowned")
end

function menu.displayModuleInfo(frame)
	local ftable = frame:addTable(2, { tabOrder = 0, width = menu.statsData.width, x = menu.statsData.offsetX, y = 0, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Helper.color.transparent60 })

	local name, infolibrary = GetMacroData(menu.selectedModule.macro, "name", "infolibrary")

	local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(name, menu.headerCenteredTextProperties)

	local data = GetLibraryEntry(infolibrary, menu.selectedModule.macro)

	if ((infolibrary == "moduletypes_production") and data.allowproduction) or (infolibrary == "moduletypes_processing") then
		local queueduration = 0
		for i, proddata in ipairs(data.products) do
			queueduration = queueduration + proddata.cycle
		end
		-- products
		for i, proddata in ipairs(data.products) do
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			local categoryname = ReadText(1001, 1624)
			if #data.products > 1 then
				categoryname = categoryname .. " " .. ReadText(20402, i)
			end
			row[1]:createText(categoryname)
			local amount = (queueduration > 0) and Helper.round(proddata.amount * 3600 / queueduration) or 0
			row[2]:createText(amount .. ReadText(1001, 42) .. " " .. GetWareData(proddata.ware, "name") .. " / " .. ReadText(1001, 102))
			-- resources
			local resources = proddata.resources
			if #resources > 0 then
				for j, resource in ipairs(resources) do
					local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					if j == 1 then
						row[1]:createText("   " .. ReadText(1001, 7403))
					end
					local amount = (queueduration > 0) and Helper.round(resource.amount * 3600 / queueduration) or 0
					row[2]:createText(amount .. ReadText(1001, 42) .. " " .. GetWareData(resource.ware, "name") .. " / " .. ReadText(1001, 102))
				end
			else
				local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:createText("   " .. ReadText(1001, 7403))
				row[2]:createText("---")
			end
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		if infolibrary == "moduletypes_production" then
			-- workforce
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 7992))
			row[2]:createText(ConvertIntegerString(data.maxworkforce, true, 0, true))
		end
	elseif infolibrary == "moduletypes_storage" then
		if data.storagecapacity > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9063))
			row[2]:createText(ConvertIntegerString(data.storagecapacity, true, 0, true) .. " " .. ReadText(1001, 110))
		end
	elseif infolibrary == "moduletypes_habitation" then
		if data.workforcecapacity > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 9611))
			row[2]:createText(ConvertIntegerString(data.workforcecapacity, true, 0, true))
		end
		if #data.workforceresources > 0 then
			for i, resource in ipairs(data.workforceresources) do
				local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
				if i == 1 then
					row[1]:createText(string.format(ReadText(1001, 7957), ConvertIntegerString(data.workforcecapacity, true, 0, true, false)))
				end
				local amount = Helper.round(resource.amount * 3600 / resource.cycle * data.workforcecapacity / data.workforceproductamount)
				row[2]:createText(amount .. ReadText(1001, 42) .. " " .. resource.name .. " / " .. ReadText(1001, 102))
			end
		end
	end
	-- docks
	if (data.docks_xl > 0) or (data.docks_l > 0) or (data.docks_m > 0) or (data.docks_s > 0) then
		local first = true
		if data.docks_xl > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_xl .. ReadText(1001, 42) .. " " .. ReadText(1001, 7950))
		end
		if data.docks_l > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_l .. ReadText(1001, 42) .. " " .. ReadText(1001, 7951))
		end
		if data.docks_m > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_m .. ReadText(1001, 42) .. " " .. ReadText(1001, 7952))
		end
		if data.docks_s > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_s .. ReadText(1001, 42) .. " " .. ReadText(1001, 7953))
		end
	end
	-- launchtubes
	if (data.launchtubes_m > 0) or (data.launchtubes_s > 0) then
		local first = true
		if data.launchtubes_m > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7954))
			end
			row[2]:createText(data.launchtubes_m .. ReadText(1001, 42) .. " " .. ReadText(1001, 7955))
		end
		if data.launchtubes_s > 0 then
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7954))
			end
			row[2]:createText(data.launchtubes_s .. ReadText(1001, 42) .. " " .. ReadText(1001, 7956))
		end
	end
	-- ship storage
	if data.shipstoragecapacity > 0 then
		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 9612))
		row[2]:createText(data.shipstoragecapacity)
	end
	-- turrets
	local numturrets = C.GetNumUpgradeSlots(menu.selectedModule.component, menu.selectedModule.macro, "turret")
	if numturrets > 0 then
		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 1319))
		row[2]:createText(tonumber(numturrets))
	end

	ftable.properties.y = Helper.viewHeight - ftable:getVisibleHeight() - menu.statsData.offsetY
end

function menu.displayModuleRow(ftable, index, entry, added, removed)
	local isextended = menu.isEntryExtended(menu.container, (removed and "rem" or "") .. index)

	local color = Helper.color.white
	if removed then
		color = Helper.color.red
	elseif added then
		color = Helper.color.green
	end

	local row = ftable:addRow({ ismodule = true, idx = entry.idx, module = entry, removed = removed }, { bgColor = Helper.color.transparent })
	if removed or added then
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonExtendEntry((removed and "rem" or "") .. index, row.index) end
	end
	local name = GetMacroData(entry.macro, "name")
	if entry.component ~= 0 then
		name = ffi.string(C.GetComponentName(entry.component))
	end
	row[2]:setColSpan(2):createText("   " .. name, { color = color, mouseOverText = menu.getLoadoutSummary(entry.upgradeplan) })
	local ismissingresources = false
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(entry.component))) then
		local buildingprocessor = GetComponentData(menu.container, "buildingprocessor")
		ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
	end
	row[4]:createText(function () return menu.getBuildProgress(entry.component, added, removed) end, { halign = "right", color = color, mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
	local active = false
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			if C.GetNumUpgradeSlots(entry.component, entry.macro, upgradetype.type) > 0 then
				active = true
				break
			end
		end
	end
	if active and (not removed) then
		row[5]:createButton({ height = Helper.standardTextHeight }):setIcon("menu_edit")
		row[5].handlers.onClick = function () return menu.buttonEditLoadout(entry) end
	end
	if (not removed) and (not added) and (not active) then
		row[1]:setBackgroundColSpan(5)
	elseif (not removed) and (not added) then
		row[1]:setBackgroundColSpan(4)
	elseif (not active) or removed then
		row[2]:setBackgroundColSpan(4)
	else
		row[2]:setBackgroundColSpan(3)
	end

	local ware = GetMacroData(entry.macro, "ware")
	if not ware then
		DebugError("No ware defined for module macro '" .. entry.macro .. "'. [Florian]")
	else
		if removed or added then
			if isextended then
				for _, resource in ipairs(entry.resources) do
					local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[2]:setColSpan(2):createText("      " .. GetWareData(resource.ware, "name"))
					row[4]:setColSpan(2):createText(resource.amount, { halign = "right" })
				end
			end
		end
	end

	return row
end

function menu.findWareIdx(array, ware)
	for i, v in ipairs(array) do
		if v.ware == ware then
			return i
		end
	end
end

function menu.insertWare(array, ware, count)
	local i = menu.findWareIdx(array, ware)
	if i then
		array[i].amount = array[i].amount + count
	else
		table.insert(array, { ware = ware, amount = count })
	end
end

function menu.getLoadoutSummary(upgradeplan)
	local wareAmounts = {}

	for i, upgradetype in ipairs(Helper.upgradetypes) do
		local slots = upgradeplan[upgradetype.type]
		local first = true
		for slot, macro in pairs(slots) do
			if first or (not upgradetype.mergeslots) then
				first = false
				if upgradetype.supertype == "group" then
					local data = macro
					if data.macro ~= "" then
						local i = menu.findUpgradeMacro(upgradetype.grouptype, data.macro)
						if not i then
							break
						end
						local upgradeware = menu.upgradewares[upgradetype.grouptype][i]
						menu.insertWare(wareAmounts, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
					end
				end
			end
		end
	end

	local summary = (#wareAmounts > 0) and (ReadText(1001, 7935) .. ReadText(1001, 120)) or ""
	for _, entry in ipairs(wareAmounts) do
		summary = summary .. "\n" .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
	end
	return summary
end

function menu.getBuildProgress(component, added, removed)
	local buildprogress = (removed or (not added)) and 100 or 0
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(menu.container))
		if removed then
			buildprogress = 100 - buildprogress
			menu.refresh = menu.refresh or (getElapsedTime() + 10.0)
		end
		
		local buildingprocessor = GetComponentData(menu.container, "buildingprocessor")
		local ismissingresources, buildcomponents, recyclingcomponents = GetComponentData(buildingprocessor, "ismissingresources", "buildcomponents", "recyclingcomponents")
		local found = false
		for _, buildcomponent in ipairs(removed and recyclingcomponents or buildcomponents) do
			if ConvertIDTo64Bit(buildcomponent) == component then
				found = true
				break
			end
		end
		if found then
			buildprogress = (ismissingresources and "\27Y\27[warning](" or "(") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(ConvertIDTo64Bit(buildingprocessor)), "%h:%M:%S") .. ")\27X  " .. buildprogress
		else
			buildprogress = "-"
		end
	elseif added then
		if C.IsComponentOperational(component) then
			buildprogress = 100
		else
			buildprogress = "-"
		end
	end

	return buildprogress .. " %"
end

function menu.wareNameSorter(a, b)
	local aname = GetWareData(a.ware, "name")
	local bname = GetWareData(b.ware, "name")

	return aname < bname
end

function menu.displayMainFrame()
	Helper.removeAllWidgetScripts(menu, config.mainLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainLayer,
		standardButtons = { back = true, close = true, help = true  },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- right sidebar
	Helper.createRightSideBar(menu.mainFrame, menu.container, true, "construction", menu.buttonRightBar, menu.buttonRightBarSelf)

	-- title bar
	menu.createTitleBar(menu.mainFrame)

	-- construction map
	menu.mainFrame:addRenderTarget({width = menu.mapData.width, height = menu.mapData.height, x = menu.mapData.offsetX, y = menu.mapData.offsetY, scaling = false, alpha = 100})

	menu.mainFrame:display()
end

function menu.displayContextFrame(mode, width, x, y)
	PlaySound("ui_positive_click")
	menu.contextMode = { mode = mode, width = width, x = x, y = y }
	if mode == "saveCP" then
		menu.createCPSaveContext()
	elseif mode == "importCP" then
		menu.createCPImportContext()
	elseif mode == "exportCP" then
		menu.createCPExportContext()
	elseif mode == "saveLoadout" then
		menu.createLoadoutSaveContext()
	elseif mode == "equipment" then
		menu.createEquipmentContext()
	elseif mode == "module" then
		menu.createModuleContext()
	elseif mode == "userquestion" then
		menu.createUserQuestionContext()
	elseif mode == "overwritequestion" then
		menu.createOverwriteQuestionContext()
	elseif mode == "settings" then
		menu.createSettingsContext()
	elseif mode == "modulefilter" then
		menu.createModuleFilterContext()
	end
end

function menu.createUserQuestionContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText(ReadText(1001, 8035), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText(ReadText(1001, 9705))

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText("")

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
	row[2].handlers.onClick = function () menu.resetDefaultLoadout() return menu.closeMenu(menu.contextData.dueToClose) end
	row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
	row[4].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.createOverwriteQuestionContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText((menu.contextData.mode == "export") and ReadText(1001, 7977) or ReadText(1001, 7985), Helper.headerRowCenteredProperties)

	if menu.contextData.mode == "export" then
		local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
		if canoverwrite then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7978), menu.currentCPName), { wordwrap = true })
		end
		local filename = utf8.gsub(menu.currentCPName, "[^%w_%-%() ]", "_")
		if menu.importableplansbyfile[filename] then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7984), filename), { wordwrap = true })
		end
	else
		local id = menu.contextData.selectedEntry.id
		if menu.constructionplansbyID[id] then
			local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7978), menu.constructionplansbyID[id].name), { wordwrap = true })
		end
	end

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText("")

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton():setText(ReadText(1001, 14), { halign = "center" })
	row[2].handlers.onClick = (menu.contextData.mode == "export") and function () menu.buttonExport(true) end or function () menu.buttonImport(true) end
	row[4]:createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[4].handlers.onClick = function () return menu.displayContextFrame((menu.contextData.mode == "export") and "exportCP" or "importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize) end

	menu.contextFrame:display()
end

function menu.createModuleContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(GetMacroData(ffi.string(menu.contextData.item.macro), "name"), Helper.subHeaderTextProperties)

	local active = false
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			if C.GetNumUpgradeSlots(menu.contextData.item.component, menu.contextData.item.macro, upgradetype.type) > 0 then
				active = true
				break
			end
		end
	end
	if active then
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = true, bgColor = Helper.color.transparent }):setText(ReadText(1001, 7938), { color = Helper.color.white })
		row[1].handlers.onClick = function () return menu.buttonEditLoadout(menu.contextData.item) end
	end

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = not menu.contextData.item.isfixed, bgColor = Helper.color.transparent }):setText(ReadText(1001, 7999), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonResetModuleRotation(menu.contextData.item) end

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	local macro = menu.contextData.item.macro
	local active = not menu.contextData.item.isfixed
	local mouseovertext = ""
	if active then
		if IsMacroClass(macro, "ventureplatform") or (IsMacroClass(macro, "dockarea") and GetMacroData(macro, "isventuremodule")) then
			local ware = GetMacroData(macro, "ware")
			local availableamount = math.max(0, OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) - (menu.usedLimitedModules[macro] or 0))
			if availableamount < 1 then
				active = false
				mouseovertext = menu.ventureModuleUnavailableMouseOverText()
			end
		end
	end
	row[1]:createButton({ active = active, bgColor = Helper.color.transparent, mouseOverText = mouseovertext }):setText(ReadText(1001, 7947), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonCopyModule(menu.contextData.item, false) end

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	local active = not menu.contextData.item.isfixed
	local mouseovertext = ""
	if active then
		local usedLimitedModulesInSequence = {}
		local n = C.GetNumUsedLimitedModulesFromSubsequence(menu.holomap, menu.contextData.item.idx)
		if n > 0 then
			local buf = ffi.new("UIMacroCount[?]", n)
			n = C.GetUsedLimitedModulesFromSubsequence(buf, n, menu.holomap, menu.contextData.item.idx)
			for i = 0, n - 1 do
				local macro = ffi.string(buf[i].macro)
				usedLimitedModulesInSequence[macro] = buf[i].amount
			end
		end

		for macro, amount in pairs(usedLimitedModulesInSequence) do
			local ware = GetMacroData(macro, "ware")
			local availableamount = math.max(0, OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) - (menu.usedLimitedModules[macro] or 0))
			if amount > availableamount then
				active = false
				mouseovertext = menu.ventureModuleUnavailableMouseOverText()
				break
			end
		end
	end
	row[1]:createButton({ active = active, bgColor = Helper.color.transparent, mouseOverText = mouseovertext }):setText(ReadText(1001, 7948), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonCopyModule(menu.contextData.item, true) end

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = not menu.contextData.item.isfixed, bgColor = Helper.color.transparent }):setText(ReadText(1001, 7937), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonRemoveModule(menu.contextData.item, false) end

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = not menu.contextData.item.isfixed, bgColor = Helper.color.transparent }):setText(ReadText(1001, 7995), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonRemoveModule(menu.contextData.item, true) end

	if ftable.properties.y + ftable:getFullHeight() > Helper.viewHeight - menu.contextFrame.properties.y then
		menu.contextFrame.properties.y = Helper.viewHeight - ftable.properties.y - ftable:getFullHeight() - Helper.frameBorder
	end

	menu.contextFrame:display()
end

function menu.createEquipmentContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createText(menu.selectedUpgrade.name, Helper.subHeaderTextProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = true, bgColor = Helper.color.transparent }):setText(ReadText(1001, 2400), { color = Helper.color.white })
	row[1].handlers.onClick = function () return menu.buttonContextEncyclopedia(menu.selectedUpgrade) end

	menu.contextFrame:display()
end

function menu.checkCPNameID()
	local ismasterversion = C.IsMasterVersion()
	local canoverwrite = false
	local cansaveasnew = false
	local source = ""
	if menu.currentCPID then
		local found = false
		for _, plan in ipairs(menu.constructionplans) do
			if plan.id == menu.currentCPID then
				found = true
				source = plan.source
				if (source == "local") or ((source == "library") and (not ismasterversion)) then
					canoverwrite = true
				end
				menu.currentCPName = plan.name
				break
			end
		end
		if not found then
			menu.currentCPID = nil
		end
	end
	if (not menu.currentCPID) and menu.currentCPName and (menu.currentCPName ~= "") then
		cansaveasnew = true
		for _, plan in ipairs(menu.constructionplans) do
			if plan.name == menu.currentCPName then
				source = plan.source
				if (source == "local") or ((source == "library") and (not ismasterversion)) then
					canoverwrite = true
				end
				cansaveasnew = false
				menu.currentCPID = plan.id
				break
			end
		end
	end

	return canoverwrite, cansaveasnew, source
end

function menu.createCPSaveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()

	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 7969), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	menu.contextMode.nameEditBox = row[1]:setColSpan(3):createEditBox({ height = Helper.headerRow1Height, defaultText = ReadText(1001, 7979) }):setText(menu.currentCPName or "", { fontsize = Helper.headerRow1FontSize, x = Helper.standardTextOffsetx })
	row[1].handlers.onTextChanged = menu.editboxCPNameUpdateText

	row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = menu.checkOverwriteActive, mouseOverText = ReadText(1026, 7906) }):setText(ReadText(1001, 7907), {  })
	row[1].handlers.onClick = function () return menu.buttonSave(true) end
	row[2]:createButton({ active = menu.checkSaveNewActive, mouseOverText = ReadText(1026, 7907) }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonSave(false) end
	row[3]:createButton({  }):setText(ReadText(1001, 64))
	row[3].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.createSettingsContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidthPercent(3, 50)
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })

	-- settings
	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 11904), Helper.headerRowCenteredProperties)
	-- environment
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createCheckBox(__CORE_DETAILMONITOR_STATIONBUILD.environment, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function(_, checked) __CORE_DETAILMONITOR_STATIONBUILD.environment = checked; menu.applySettings() end
	row[2]:setColSpan(2):createText(ReadText(1001, 11905), { mouseOverText = ReadText(1026, 7927) })
	-- module overlap
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createCheckBox(__CORE_DETAILMONITOR_STATIONBUILD.moduleoverlap, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function(_, checked) __CORE_DETAILMONITOR_STATIONBUILD.moduleoverlap = checked; menu.applySettings() end
	row[2]:setColSpan(2):createText(ReadText(1001, 11907), { mouseOverText = ReadText(1026, 7928) })
	ftable:addEmptyRow(Helper.standardTextHeight / 2)
	-- rotation angle snap
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createSliderCell({ min = 0, minSelect = config.discreteAngleSlider.min, max = config.discreteAngleSlider.max, start = math.max(config.discreteAngleSlider.min, math.min(config.discreteAngleSlider.max, __CORE_DETAILMONITOR_STATIONBUILD.discreteanglestep)), step = config.discreteAngleSlider.step, mouseOverText = ReadText(1026, 7926), height = Helper.standardTextHeight, suffix = ReadText(1001, 109), hideMaxValue = true }):setText(ReadText(1001, 7998))
	row[1].handlers.onSliderCellChanged = function (_, value) __CORE_DETAILMONITOR_STATIONBUILD.discreteanglestep = value; menu.applySettings() end
	row[1].handlers.onSliderCellActivated = function() menu.noupdate = true end
	row[1].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

	ftable:addEmptyRow()

	-- options
	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 11914), Helper.headerRowCenteredProperties)
	-- shuffle
	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createButton({ helpOverlayID = "shuffle_modules", helpOverlayText = " ", helpOverlayHighlightOnly = true, mouseOverText = ReadText(1026, 7910) }):setText(ReadText(1001, 11911), { halign = "center" })
	row[1].handlers.onClick = function () C.ShuffleMapConstructionPlan(menu.holomap, false); menu.refreshPlan(); menu.displayMenu() end

	menu.contextFrame:display()
end

function menu.createModuleFilterContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 6, reserveScrollBar = false })
	ftable:setColWidth(1, Helper.standardTextHeight)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createCheckBox(menu.checkAllRacesSelected, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = menu.checkboxSelectAllRaces
	row[2]:createText(ReadText(1001, 11912), Helper.headerRowCenteredProperties)

	for i, race in ipairs(menu.races) do
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(function () return menu.checkRacesSelected(race) end, { height = Helper.standardTextHeight })
		row[1].handlers.onClick = function(_, checked) menu.checkboxSelectRace(i, race, checked) end
		row[2]:createText(race.name)
	end

	menu.contextFrame:display()
end

function menu.checkRacesSelected(race)
	for i, raceentry in ipairs(menu.races) do
		if raceentry.id == race.id then
			return raceentry.selected == true
		end
	end
	return false
end

function menu.checkAllRacesSelected()
	for i, race in ipairs(menu.races) do
		if not race.selected then
			return false
		end
	end
	return true
end

function menu.checkboxSelectRace(index, race, checked)
	menu.races[index].selected = checked
	local found = false
	for j, text in ipairs(menu.modulesearchtext) do
		if text.race == race.id then
			found = true
			if not checked then
				table.remove(menu.modulesearchtext, j)
			end
			break
		end
	end
	if checked and (not found) then
		table.insert(menu.modulesearchtext, { text = race.name, race = race.id })
	end
	menu.displayMenu()
end

function menu.checkboxSelectAllRaces(_, checked)
	for i, race in ipairs(menu.races) do
		menu.races[i].selected = checked
		local found = false
		for j, text in ipairs(menu.modulesearchtext) do
			if text.race == race.id then
				found = true
				if not checked then
					table.remove(menu.modulesearchtext, j)
				end
				break
			end
		end
		if checked and (not found) then
			table.insert(menu.modulesearchtext, { text = race.name, race = race.id })
		end
	end
	menu.displayMenu()
end

function menu.checkOverwriteActive()
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	return canoverwrite
end

function menu.checkSaveNewActive()
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	return cansaveasnew
end

function menu.checkExportActive()
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	return canoverwrite or cansaveasnew
end

function menu.checkLoadoutNameID()
	local canoverwrite = false
	local cansaveasnew = false
	if menu.loadout then
		local found = false
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.id == menu.loadout then
				menu.loadoutName = loadout.name
				break
			end
		end
		if not found then
			menu.loadout = nil
		end
	end
	if (not menu.loadout) and menu.loadoutName and (menu.loadoutName ~= "") then
		cansaveasnew = true
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.name == menu.loadoutName then
				canoverwrite = true
				cansaveasnew = false
				menu.loadout = loadout.id
				break
			end
		end
	end

	return canoverwrite, cansaveasnew
end

function menu.createCPImportContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(4, { tabOrder = 6, reserveScrollBar = false, maxVisibleHeight = Helper.viewHeight / 2 })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })
	ftable:setColWidth(2, 0.25 * (menu.contextMode.width - Helper.borderSize), false)
	ftable:setColWidth(3, 0.25 * (menu.contextMode.width - Helper.borderSize) - Helper.scaleY(Helper.standardTextHeight), false)
	ftable:setColWidth(4, math.max(20, Helper.scaleY(Helper.standardTextHeight)), false)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 7971), Helper.headerRowCenteredProperties)
	row[4]:createButton({ width = Helper.standardTextHeight, y = Helper.headerRow1Height - Helper.standardTextHeight }):setIcon("menu_reload")
	row[4].handlers.onClick = menu.buttonReloadImportable

	menu.importableplans = menu.importableplans or {}
	for _, entry in ipairs(menu.importableplans) do
		local row = ftable:addRow(entry, { bgColor = Helper.color.transparent })
		if entry.imported then
			row[1]:setColSpan(2):setBackgroundColSpan(4):createText(entry.name, { mouseOverText = entry.filename .. config.fileExtension })
			row[3]:setColSpan(2):createText("[" .. ReadText(1001, 7983) .. "]", { halign = "right", mouseOverText = entry.filename .. config.fileExtension })
		else
			row[1]:setColSpan(4):createText(entry.name, { mouseOverText = entry.filename .. config.fileExtension })
		end
	end

	ftable:setTopRow(menu.topRows.importCP)
	ftable:setSelectedRow(menu.selectedRows.importCP)
	menu.topRows.importCP = GetTopRow(menu.contexttable)
	menu.selectedRows.importCP = Helper.currentTableRow[menu.contexttable]

	local buttontable = menu.contextFrame:addTable(2, { tabOrder = 7, reserveScrollBar = false })
	buttontable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	buttontable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })
	
	local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(" ")

	local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 7981), { wordwrap = true })

	if menu.contextData.selectedEntry and menu.contextData.selectedEntry.imported then
		buttontable:addEmptyRow(Helper.standardTextHeight / 2)

		local row = buttontable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 7982), { wordwrap = true })
	end

	local row = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = function () return menu.contextData.selectedEntry ~= nil end }):setText(ReadText(1001, 7980), {  })
	row[1].handlers.onClick = function () return menu.buttonImport(false) end
	row[2]:createButton({  }):setText(ReadText(1001, 64))
	row[2].handlers.onClick = menu.closeContextMenu

	local maxVisibleHeight = ftable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
	buttontable.properties.y = buttontable.properties.y + math.min(maxVisibleHeight, ftable:getFullHeight())
	ftable.properties.maxVisibleHeight = buttontable.properties.y - ftable.properties.y

	ftable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = ftable.index

	menu.contextFrame:display()
end

function menu.createCPExportContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 6, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 7972), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	menu.contextMode.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = Helper.headerRow1Height, defaultText = ReadText(1001, 7979) }):setText(menu.currentCPName or "", { fontsize = Helper.headerRow1FontSize, x = Helper.standardTextOffsetx })
	row[1].handlers.onTextChanged = menu.editboxCPNameUpdateText

	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 7973), { wordwrap = true })

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createButton({ active = C.CanOpenWebBrowser(), mouseOverText = ReadText(1026, 7918) }):setText(ReadText(1001, 7974)):setText2("\27[mm_externallink]", { halign = "right" })
	row[1].handlers.onClick = menu.buttonConstructionCommunity

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = menu.checkExportActive }):setText(ReadText(1001, 7975), {  })
	row[1].handlers.onClick = function () return menu.buttonExport(false) end
	row[2]:createButton({  }):setText(ReadText(1001, 64))
	row[2].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.createLoadoutSaveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
		backgroundID = "solid",
		backgroundColor = Helper.color.transparent60,
	})

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	-- magic
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()

	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 7970), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	menu.contextMode.nameEditBox = row[1]:setColSpan(3):createEditBox({ scaling = false, height = menu.titleData.height }):setText(menu.loadoutName or "", { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize) })
	row[1].handlers.onTextChanged = menu.editboxLoadoutNameUpdateText

	row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = menu.checkLoadoutOverwriteActive, mouseOverText = ReadText(1026, 7908) }):setText(ReadText(1001, 7908), {  })
	row[1].handlers.onClick = function () return menu.buttonSaveLoadout(true) end
	row[2]:createButton({ active = menu.checkLoadoutSaveNewActive, mouseOverText = ReadText(1026, 7909) }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonSaveLoadout(false) end
	row[3]:createButton({  }):setText(ReadText(1001, 64))
	row[3].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.checkLoadoutOverwriteActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return canoverwrite
end

function menu.checkLoadoutSaveNewActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return cansaveasnew
end

function menu.displayMenu(firsttime)
	-- Remove possible button scripts from previous view
	Helper.removeAllWidgetScripts(menu, config.infoLayer)
	Helper.currentTableRow = {}
	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)

	menu.infoFrame = Helper.createFrameHandle(menu, {
		layer = config.infoLayer,
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	menu.displayLeftBar(menu.infoFrame)

	menu.displayModules(menu.infoFrame, firsttime)

	menu.displayPlan(menu.infoFrame)

	if menu.selectedModule then
		menu.displayModuleInfo(menu.infoFrame)
	end

	menu.infoFrame:display()
end

function menu.displayContextMenu()
	-- Remove possible button scripts from previous view
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local width = 0
	local setup = Helper.createTableSetup(menu)
	
	if menu.contextMode == 2 then
		width = 300

		local upgradetype = Helper.findUpgradeType(menu.contextData.upgradetype)
		local upgradetype2 = Helper.findUpgradeTypeByGroupType(upgradetype.type)
		local slotdata
		if menu.upgradetypeMode == "turretgroup" then
			slotdata = menu.groups[menu.currentSlot][upgradetype2.grouptype]
		end
		local plandata
		if menu.upgradetypeMode == "turretgroup" then
			plandata = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype2.type][menu.currentSlot]
		end
		local prefix = ""
		if upgradetype.mergeslots then
			prefix = #menu.slots[upgradetype.type] .. ReadText(1001, 42) .. " "
		end

		if menu.upgradetypeMode == "turretgroup" then
			local name = upgradetype2.text.default
			if plandata.macro == "" then
				if slotdata.slotsize ~= "" then
					name = upgradetype2.text[slotdata.slotsize]
				end
			else
				name = GetMacroData(plandata.macro, "name")
			end
			if not upgradetype2.mergeslots then
				local minselect = (plandata.macro == "") and 0 or 1
				local maxselect = (plandata.macro == "") and 0 or slotdata.total

				local scale = {
					min       = 0,
					minselect = minselect,
					max       = slotdata.total,
					maxselect = maxselect,
					start     = math.max(minselect, math.min(maxselect, plandata.count)),
					step      = 1,
					suffix    = "",
					exceedmax = false
				}
				setup:addSimpleRow({
					Helper.createSliderCell(Helper.createTextInfo(name, "left", Helper.headerRow1Font, Helper.headerRow1FontSize, 255, 255, 255, 100), false, 0, 0, 0, Helper.headerRow1Height, nil, Helper.color.slidervalue, scale, "")
				}, nil, {1})
			else
				setup:addSimpleRow({
					Helper.createFontString(name, false, "left", 255, 255, 255, 100)
				}, nil, {1})
			end
		end

		for k, macro in ipairs(slotdata.possiblemacros) do
			local name = prefix .. GetMacroData(macro, "name")

			local color = Helper.color.white
			if (macro == slotdata.currentmacro) and (macro ~= plandata.macro) then
				color = Helper.color.red
			elseif (macro == plandata.macro) then
				color = Helper.color.green
			end

			setup:addSimpleRow({
				Helper.createButton(Helper.createTextInfo(name, "left", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), color.r, color.g, color.b, color.a, Helper.standardTextOffsetx), nil, true, true, 0, 0, width, Helper.standardTextHeight)
			}, nil, {1})
		end

		if upgradetype.allowempty then
			local name = ReadText(1001, 7906)

			local color = Helper.color.white
			if ("" == slotdata.currentmacro) and ("" ~= plandata) then
				color = Helper.color.red
			elseif ("" == plandata) then
				color = Helper.color.green
			end

			setup:addSimpleRow({
				Helper.createButton(Helper.createTextInfo(name, "left", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), color.r, color.g, color.b, color.a, Helper.standardTextOffsetx), nil, true, true, 0, 0, width, Helper.standardTextHeight)
			}, nil, {1})
		end
	end
	
	local contextdesc = setup:createCustomWidthTable({width}, false, true, true, 4, 0, menu.contextData.offsetX, menu.contextData.offsetY, 0, true, menu.topRows.context, menu.selectedRows.context, nil, nil, "off")
	menu.topRows.context = nil
	menu.selectedRows.context = nil

	Helper.displayFrame(menu, {contextdesc}, false, "", "", {}, nil, config.contextLayer)
end

function menu.setUpContextMenuScripts(uitable)
	local nooflines = 1
	if menu.contextMode == 2 then
		local upgradetype = Helper.findUpgradeType(menu.contextData.upgradetype)
		local upgradetype2 = Helper.findUpgradeTypeByGroupType(upgradetype.type)
		local slotdata = menu.slots[upgradetype.type][menu.contextData.slot]

		if menu.upgradetypeMode == "turretgroup" then
			if not upgradetype.mergeslots then
				local line = nooflines
				Helper.setSliderCellScript(menu, nil, uitable, nooflines, 1, function (_, ...) return menu.slidercellSelectAmount(upgradetype2.type, menu.currentSlot, nil, line, ...) end)
			end
			nooflines = nooflines + 1
		end

		for k, macro in ipairs(slotdata.possiblemacros) do
			local line = nooflines
			if menu.upgradetypeMode == "turretgroup" then
				Helper.setButtonScript(menu, nil, uitable, nooflines, 1, function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, macro, nil, nil, line) end)
			end
			nooflines = nooflines + 1
		end

		if upgradetype.allowempty then
			local line = nooflines
			if menu.upgradetypeMode == "turretgroup" then
				Helper.setButtonScript(menu, nil, uitable, nooflines, 1, function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, "", nil, nil, line) end)
			end
		end
	end
end

function menu.viewCreated(layer, ...)
	if layer == config.mainLayer then
		menu.rightbartable, menu.titlebartable, menu.map = ...
	
		if menu.activatemap == nil then
			menu.activatemap = true
		end
	elseif layer == config.infoLayer then
		if not menu.loadoutMode then
			if menu.modulesMode then
				menu.leftbartable, menu.moduletable, menu.plantable, menu.planmodulestatus, menu.planresourcestable, menu.planstatus, menu.moduleinfotable = ...
			else
				menu.leftbartable, menu.plantable, menu.planmodulestatus, menu.planresourcestable, menu.planstatus, menu.moduleinfotable = ...
			end
		else
			if menu.upgradetypeMode then
				menu.leftbartable, menu.moduletable, menu.planbutton, menu.plantable, menu.moduleinfotable = ...
			else
				menu.leftbartable, menu.planbutton, menu.plantable, menu.moduleinfotable = ...
			end
		end
	elseif layer == config.contextLayer then
		menu.contexttable = ...

		menu.setUpContextMenuScripts(menu.contexttable)
	end

	-- clear descriptors again
	Helper.releaseDescriptors()
end

menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = getElapsedTime()

	if menu.updatePlan and (menu.updatePlan < curtime) then
		menu.updatePlan = nil

		C.ShowConstructionMap(menu.holomap, menu.container, "", false)
		menu.applySettings()
		menu.storePlanTableState()
		menu.refreshPlan()
		menu.displayMenu()
	end

	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.mapData.width / menu.mapData.height, 1)
			if menu.holomap ~= 0 then
				menu.showConstructionMap()
			end

			menu.activatemap = false
			menu.refreshPlan()
			local refresh = true
			if menu.state then
				refresh = not menu.onRestoreState(menu.state)
				menu.state = nil
			end
			if refresh then
				menu.displayMainFrame()
				menu.displayMenu(true)
			end
		end
	end

	if (menu.newSelectedModule and ((menu.selectedModule == nil) or (menu.newSelectedModule.idx ~= menu.selectedModule.idx))) or ((menu.newSelectedModule == "clear") and menu.selectedModule) then
		if menu.newSelectedModule == "clear" then
			menu.selectedModule = nil
		else
			menu.selectedModule = menu.newSelectedModule
		end
		menu.newSelectedModule = nil
		menu.refresh = curtime - 1
	end

	for i, entry in ipairs(menu.removedModules) do
		local component = tostring(entry.component)
		if IsComponentConstruction(ConvertStringTo64Bit(component)) then
			if not menu.currentConstructions[component] then
				-- was not in construction before, update menu
				menu.refresh = curtime - 1
			end
			menu.currentConstructions[component] = curtime
		end
	end
	for i = 1, #menu.constructionplan do
		local component = tostring(menu.constructionplan[i].component)
		if IsComponentConstruction(ConvertStringTo64Bit(component)) then
			if not menu.currentConstructions[component] then
				-- was not in construction before, update menu
				menu.refresh = curtime - 1
			end
			menu.currentConstructions[component] = curtime
		end
	end
	for key, timestamp in pairs(menu.currentConstructions) do
		if timestamp < curtime then
			-- no longer in construction, update menu
			menu.currentConstructions[key] = nil
			menu.refresh = curtime - 1
		end
	end

	if menu.contextData and menu.contextData.newSelectedEntry then
		menu.contextData.selectedEntry = menu.contextData.newSelectedEntry
		menu.topRows.importCP = GetTopRow(menu.contexttable)
		menu.selectedRows.importCP = Helper.currentTableRow[menu.contexttable]
		menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
		menu.contextData.newSelectedEntry = nil
	end

	if menu.contextMode and (type(menu.contextMode) == "table") and menu.contextMode.nameEditBox then
		ActivateEditBox(menu.contextMode.nameEditBox.id)
		menu.contextMode.nameEditBox = nil
	end

	if menu.refresh and (menu.refresh < curtime) and (not menu.noupdate) then
		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		menu.refreshPlan()
		menu.displayMenu()
		menu.refresh = nil
		return
	end

	menu.mainFrame:update()
	menu.infoFrame:update()
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if menu.holomap ~= 0 then
		if menu.picking ~= menu.pickstate then
			menu.pickstate = menu.picking
			C.SetMapPicking(menu.holomap, menu.pickstate)
		end

		if menu.map then
			local x, y = GetRenderTargetMousePosition(menu.map)
			C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
		end

		local pickedentry = ffi.new("UIConstructionPlanEntry")
		local haspick = false
		if (GetControllerInfo() ~= "gamepad") or C.IsMouseEmulationActive() then
			haspick = C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false)
		end

		if menu.allowpanning and menu.leftdown then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.leftdown.position, offset, 2) then
				C.StartPanMap(menu.holomap)
				if haspick then
					if menu.selectedModule and (pickedentry.idx == menu.selectedModule.idx) then
						menu.keepcursor = true
					end
				end
				menu.allowpanning = nil
			end
		end
		if menu.allowrotating and menu.rightdown then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.rightdown.position, offset, 2) then
				C.StartRotateMap(menu.holomap)
				menu.allowrotating = nil
			end
		end

		if haspick then
			local macro = ffi.string(pickedentry.macroid)
			if macro ~= menu.mouseOverMacro then
				menu.mouseOverMacro = macro
				SetMouseOverOverride(menu.map, GetMacroData(macro, "name"))
				local selectedIdx = C.GetSelectedBuildMapEntry(menu.holomap)
				if ((pickedentry.idx == selectedIdx) or (pickedentry.idx == #menu.constructionplan)) and (not pickedentry.isfixed) then
					SetMouseCursorOverride("crossarrows")
				end
			end
		elseif menu.mouseOverMacro then
			menu.mouseOverMacro = nil
			SetMouseOverOverride(menu.map, nil)
			if not menu.keepcursor then
				SetMouseCursorOverride("default")
			end
		end

		if not menu.loadoutMode then
			local canundo = C.CanUndoConstructionMapChange(menu.holomap)
			if canundo ~= menu.canundo then
				menu.canundo = canundo
				Helper.removeButtonScripts(menu, menu.titlebartable, 1, 7)
				SetCellContent(menu.titlebartable, Helper.createButton(nil, Helper.createButtonIcon("menu_undo", nil, 255, 255, 255, 100, nil, nil, 0, 0), true, canundo, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278)), 1, 7)
				Helper.setButtonScript(menu, nil, menu.titlebartable, 1, 7, function () return menu.undoHelper(true) end)
			end
			
			local canredo = C.CanRedoConstructionMapChange(menu.holomap)
			if canredo ~= menu.canredo then
				menu.canredo = canredo
				Helper.removeButtonScripts(menu, menu.titlebartable, 1, 8)
				SetCellContent(menu.titlebartable, Helper.createButton(nil, Helper.createButtonIcon("menu_redo", nil, 255, 255, 255, 100, nil, nil, 0, 0), true, canredo, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279)), 1, 8)
				Helper.setButtonScript(menu, nil, menu.titlebartable, 1, 8, function () return menu.undoHelper(false) end)
			end
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	if not menu.loadoutMode then
		if uitable == menu.plantable then
			if menu.holomap ~= 0 then
				if (source ~= "auto") or (menu.selectedModule == nil) then
					if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
						menu.newSelectedModule = rowdata.module
						C.SelectBuildMapEntry(menu.holomap, rowdata.idx)
					elseif menu.selectedModule ~= nil then
						menu.newSelectedModule = "clear"
						C.ClearBuildMapSelection(menu.holomap)
					end
				end
			end
		elseif uitable == menu.contexttable then
			if (source ~= "auto") or (menu.contextData and (menu.contextData.selectedEntry == nil)) then
				if (type(rowdata) == "table") then
					menu.contextData.newSelectedEntry = rowdata
				end
			end
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
	if uitable == menu.plantable then
		if menu.holomap ~= 0 then
			if (source ~= "auto") or (menu.selectedModule == nil) then
				local rowdata = Helper.getCurrentRowData(menu, uitable)
				if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
					C.SetFocusMapConstructionPlanEntry(menu.holomap, rowdata.idx, true)
				end
			end
		end
	end
end

function menu.closeMenu(dueToClose)
	if dueToClose == "back" then
		if menu.loadoutMode then
			menu.buttonCancelLoadout()
			return
		end
	end
	C.ReleaseConstructionMapState()
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer, showinganothermenu)
	if (not showinganothermenu) and menu.contextMode then
		if menu.contextMode.mode == "userquestion" then
			if dueToClose ~= "back" then
				menu.closeContextMenu()
				menu.resetDefaultLoadout()
				menu.closeMenu(dueToClose)
				return
			end
		else
			menu.closeContextMenu()
			if (dueToClose == "back") or (layer == config.contextLayer) then
				return
			end
		end
	end

	if menu.loadoutMode then
		if menu.upgradetypeMode and (dueToClose == "back") then
			menu.deactivateUpgradetypeMode()
			return
		end
	else
		if menu.modulesMode and (dueToClose == "back") then
			menu.deactivateModulesMode()
			return
		end
	end

	if (not showinganothermenu) and menu.haschanges then
		menu.contextData = { dueToClose = dueToClose }
		menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	else
		menu.closeMenu(dueToClose)
	end
end

function menu.closeContextMenu()
	Helper.clearFrame(menu, config.contextLayer)

	-- REMOVE this block once the mouse out/over event order is correct -> This should be unnessecary due to the global tablemouseout event reseting the picking
	if menu.currentMouseOverTable and (
		(menu.currentMouseOverTable == menu.contexttable)
	) then
		menu.picking = true
		menu.currentMouseOverTable = nil
	end
	-- END

	menu.contextFrame = nil
	menu.contextMode = nil
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown()
	menu.leftdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()) }
	menu.allowpanning = true
end

function menu.onRenderTargetMouseUp()
	local refreshplan = false
	local display = false
	local applyDefaultLoadout

	menu.allowpanning = false
	SetMouseCursorOverride("default")
	menu.keepcursor = false
	if C.StopPanMap(menu.holomap) then
		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		refreshplan = true
		display = true
	end

	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.2 seconds and the mouse was not moved more than a distance of 2px
	if (menu.leftdown and menu.leftdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.leftdown.position, offset, 2)) then
		menu.closeContextMenu()
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)

		if not menu.loadoutMode then
			C.SelectPickedBuildMapEntry(menu.holomap)
			C.AddFloatingSequenceToConstructionPlan(menu.holomap)
			local addedNewModule = false
			if menu.floatingNewModule then
				applyDefaultLoadout = menu.floatingNewModule
				menu.floatingNewModule = nil
				addedNewModule = true
			elseif menu.floatingCopyModule then
				menu.floatingCopyModule = nil
				addedNewModule = true
			end
			menu.topRows.modules = GetTopRow(menu.moduletable)
			menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
			menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]

			local newplanrow
			local pickedentry = ffi.new("UIConstructionPlanEntry")
			if C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false) then
				if not pickedentry.isfixed then
					SetMouseCursorOverride("crossarrows")
				end
				local found = false
				for row, rowdata in pairs(menu.rowDataMap[menu.plantable]) do
					if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
						if rowdata.idx == pickedentry.idx then
							menu.selectedModule = rowdata.module
							newplanrow = row
							found = true
							break
						end
					end
				end
				if not found then
					for i, entry in ipairs(menu.constructionplan) do
						if entry.idx == pickedentry.idx then
							menu.selectedModule = entry
							found = true
							break
						end
					end
				end
				if not found then
					menu.selectedModule = { idx = pickedentry.idx, macro = ffi.string(pickedentry.macroid), component = pickedentry.componentid }
				end
				C.SelectBuildMapEntry(menu.holomap, pickedentry.idx)
			else
				menu.selectedModule = nil
				newplanrow = addedNewModule and "last" or "first"
				C.ClearBuildMapSelection(menu.holomap)
			end
			menu.storePlanTableState()
			menu.selectedRows.plan = newplanrow or Helper.currentTableRow[menu.plantable]

			refreshplan = true
			display = true
		else
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, pickedslot) then
				local groupinfo = C.GetUpgradeSlotGroup(menu.loadoutModule.component, menu.loadoutModule.macro, pickedslot.upgradetype, pickedslot.slot)
				menu.upgradetypeMode = "turretgroup"
				menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
				if menu.upgradetypeMode == "turretgroup" then
					local group = menu.groups[menu.currentSlot]
					C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
				end
				display = true
			end
		end
	end
	menu.leftdown = nil

	if refreshplan then
		menu.refreshPlan()
		if applyDefaultLoadout then
			if menu.defaultLoadout ~= -1 then
				local entry = menu.constructionplan[#menu.constructionplan]
				if entry.macro == applyDefaultLoadout then
					local active = false
					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "macro" then
							if C.GetNumUpgradeSlots(entry.component, entry.macro, upgradetype.type) > 0 then
								active = true
								break
							end
						end
					end
					if active then
						local loadout = Helper.getLoadoutHelper(C.GenerateModuleLoadout, C.GenerateModuleLoadoutCounts, menu.holomap, entry.idx, menu.container, menu.defaultLoadout)
						local upgradeplan = Helper.convertLoadout(entry.component, entry.macro, loadout, nil)
						Helper.callLoadoutFunction(upgradeplan, nil, function (loadout, _) return C.UpdateConstructionMapItemLoadout(menu.holomap, entry.idx, menu.container, loadout) end)
					end
					-- again for the new loadout
					menu.refreshPlan()
				end
			end
		end
	end
	if display then
		menu.displayMenu()
	end
end

function menu.onRenderTargetRightMouseDown()
	local pickedentry = ffi.new("UIConstructionPlanEntry")
	local valid = C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false)
	local item = menu.findConstructionPlanEntry(pickedentry.idx)
	if not item then
		item = {}
		valid = false
	end
	menu.rightdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()), item = item, itemvalid = valid }
	menu.allowrotating = true
end

function menu.onRenderTargetRightMouseUp()
	menu.allowrotating = false
	if C.StopRotateMap(menu.holomap) then
		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		menu.refreshPlan()
		menu.displayMenu()
	end

	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.2 seconds and the mouse was moved more than a distance of 2px
	if (menu.rightdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.rightdown.position, offset, 2)) then
		menu.closeContextMenu()

		if not menu.loadoutMode then
			if menu.floatingNewModule or menu.floatingCopyModule then
				C.RemoveFloatingSequenceFromConstructionPlan(menu.holomap)
				menu.floatingNewModule = nil
				menu.floatingCopyModule = nil
			elseif menu.rightdown.itemvalid then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextData = { item = menu.rightdown.item }
				menu.displayContextFrame("module", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		else
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, pickedslot) then
				local groupinfo = C.GetUpgradeSlotGroup(menu.loadoutModule.component, menu.loadoutModule.macro, pickedslot.upgradetype, pickedslot.slot)
				menu.upgradetypeMode = "turretgroup"
				menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
				if menu.upgradetypeMode == "turretgroup" then
					local group = menu.groups[menu.currentSlot]
					C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
				end
				menu.displayMenu()

				menu.contextMode = 2
				menu.contextData = { offsetX = offset[1] + Helper.viewWidth / 2, offsetY = Helper.viewHeight / 2 - offset[2], upgradetype = ffi.string(pickedslot.upgradetype), slot = tonumber(pickedslot.slot) }
				menu.displayContextMenu()
			end
		end
	end
	menu.rightdown = nil
end

function menu.onRenderTargetCombinedScrollDown(step)
	C.ZoomMap(menu.holomap, step)
end

function menu.onRenderTargetCombinedScrollUp(step)
	C.ZoomMap(menu.holomap, -step)
end

function menu.onRenderTargetDoubleClick(modified)
	local pickedentry = ffi.new("UIConstructionPlanEntry")
	local valid = C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false)
	if valid then
		C.SetFocusMapConstructionPlanEntry(menu.holomap, pickedentry.idx, true)
	end
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		if menu.haschanges or menu.hasconstructionchanges then
			Helper.registerStationEditorChanges()
		end
		if not menu.loadoutMode then
			C.StoreConstructionMapState(menu.holomap)
		end
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
	end

	for _, key in ipairs(config.stateKeys) do
		if key[1] == "loadoutModuleIdx" then
			if menu.loadoutMode then
				state[key[1]] = tonumber(menu.loadoutModule.idx)
				state.upgradeplan = menu.constructionplan[menu.loadoutMode].upgradeplan
			end
		else
			state[key[1]] = menu[key[1]]
		end
	end
	return state
end

function menu.onRestoreState(state)
	local mapstate
	if state.map then
		local offset = ffi.new("UIPosRot", {
			x = state.map.offset.x, 
			y = state.map.offset.y, 
			z = state.map.offset.z, 
			yaw = state.map.offset.yaw, 
			pitch = state.map.offset.pitch, 
			roll = state.map.offset.roll
		})
		mapstate = ffi.new("HoloMapState", {
			offset = offset, 
			cameradistance = state.map.cameradistance
		})
	end

	local module
	for _, key in ipairs(config.stateKeys) do
		if key[1] == "loadoutModuleIdx" then
			if state[key[1]] then
				local idx = ConvertStringTo64Bit(tostring(state[key[1]]))
				for i, entry in ipairs(menu.constructionplan) do
					if entry.idx == state[key[1]] then
						entry.upgradeplan = state.upgradeplan
						module = entry
						break
					end
				end
			end
		else
			if key[2] == "UniverseID" then
				menu[key[1]] = ConvertIDTo64Bit(state[key[1]])
			elseif key[2] == "bool" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		end
	end

	local returnvalue
	if module then
		menu.buttonEditLoadout(module)
		returnvalue = true
	end

	if mapstate then
		C.SetMapState(menu.holomap, mapstate)
	end

	return returnvalue
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
	if uitable == menu.plantable then
		if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
			local x, y = GetLocalMousePosition()
			if x == nil then
				-- gamepad case
				x = posx
				y = -posy
			end
			menu.contextData = { item = rowdata.module }
			menu.displayContextFrame("module", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
		end
	end
end

function menu.filterModuleByText(module, texts)
	local hasracefilter, racematch = false, false
	for _, textentry in ipairs(texts) do
		if textentry.race then
			hasracefilter = true
			local makerraces = GetMacroData(module, "makerraceid")
			if (textentry.race == "generic") and (#makerraces == 0) then
				racematch = true
			end
			for _, makerrace in ipairs(makerraces) do
				if makerrace == textentry.race then
					racematch = true
					break
				end
			end
			if racematch then
				break
			end
		end
	end

	local hasadditionalfilter, filtermatch = false, false
	for _, textentry in ipairs(texts) do
		if not textentry.race then
			hasadditionalfilter = true
			text = utf8.lower(textentry.text)

			local shortname, makerracenames = GetMacroData(module, "shortname", "makerracename")
			if string.find(utf8.lower(shortname), text, 1, true) then
				filtermatch = true
			end
			for _, makerracename in ipairs(makerracenames) do
				if string.find(utf8.lower(makerracename), text, 1, true) then
					filtermatch = true
					break
				end
			end
			if filtermatch then
				break
			end
		end
	end

	return ((not hasracefilter) or racematch) and ((not hasadditionalfilter) or filtermatch)
end

function menu.filterUpgradeByText(upgrade, text)
	text = utf8.lower(text)

	local shortname, makerracenames = GetMacroData(upgrade, "shortname", "makerracename")
	if string.find(utf8.lower(shortname), text, 1, true) then
		return true
	end
	for _, makerracename in ipairs(makerracenames) do
		if string.find(utf8.lower(makerracename), text, 1, true) then
			return true
		end
	end

	return false
end

function menu.isEntryExtended(container, index)
	for i, entry in ipairs(menu.extendedentries) do
		if entry.id == container then
			return entry.plan[index]
		end
	end
	return false
end

function menu.extendEntry(container, index, force, exclusive)
	local found = false
	for i, entry in ipairs(menu.extendedentries) do
		if entry.id == container then
			found = true
			if exclusive then
				entry.plan = {}
			end
			if (not force) and entry.plan[index] then
				entry.plan[index] = nil
			else
				entry.plan[index] = true
			end
			break
		end
	end
	if not found then
		table.insert(menu.extendedentries, {id = container, plan = { [index] = true } })
	end
end

function menu.initExtendedEntry(container)
	for i, entry in ipairs(menu.extendedentries) do
		if entry.id == container then
			-- nothing to do
			return
		end
	end
	table.insert(menu.extendedentries, {id = container, plan = { ["planned"] = true, ["removed"] = true } })
end

function menu.isResourceEntryExtended(id, default)
	if (default ~= nil) and (menu.extendedresourceentries[id] == nil) then
		menu.extendedresourceentries[id] = default
	end
	return menu.extendedresourceentries[id]
end

function menu.extendResourceEntry(id)
	menu.extendedresourceentries[id] = not menu.extendedresourceentries[id]
end

function menu.getLeftBarEntry(mode)
	for i, entry in ipairs(config.leftBar) do
		if entry.mode == mode then
			return entry
		end
	end

	return {}
end

function menu.getLeftBarLoadoutEntry(mode)
	for i, entry in ipairs(config.leftBarLoadout) do
		if entry.mode == mode then
			return entry
		end
	end

	return {}
end

function menu.findUpgradeMacro(type, macro)
	for i, upgradeware in ipairs(menu.upgradewares[type] or {}) do
		if upgradeware.macro == macro then
			return i
		end
	end
	DebugError("The equipment macro '" .. macro .. "' is not in the player's blueprint list. This should never happen. [Florian]")
end

function menu.findGroupIndex(path, group)
	for i, groupinfo in ipairs(menu.groups) do
		if (groupinfo.path == path) and (groupinfo.group == group) then
			return i
		end
	end
end

function menu.findConstructionPlanEntry(idx)
	for _, entry in ipairs(menu.constructionplan) do
		if entry.idx == idx then
			return entry
		end
	end
end

function menu.storePlanTableState()
	menu.topRows.plan = GetTopRow(menu.plantable)
	menu.selectedRows.plan = Helper.currentTableRow[menu.plantable]
	menu.topRows.planresources = GetTopRow(menu.planresourcestable)
	menu.selectedRows.planresources = Helper.currentTableRow[menu.planresourcestable]
end

function menu.upgradeSettingsVersion()
	local oldversion = __CORE_DETAILMONITOR_STATIONBUILD.version

	if oldversion < 2 then
		
	end

	__CORE_DETAILMONITOR_STATIONBUILD.version = config.mapfilterversion
end

function menu.applySettings()
	if menu.holomap and (menu.holomap ~= 0) then
		C.SetConstructionMapBuildAngleStep(menu.holomap, __CORE_DETAILMONITOR_STATIONBUILD.discreteanglestep);
		C.SetConstructionMapCollisionDetection(menu.holomap, not __CORE_DETAILMONITOR_STATIONBUILD.moduleoverlap);
		C.SetConstructionMapRenderSectorBackground(menu.holomap, __CORE_DETAILMONITOR_STATIONBUILD.environment);
	end
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- cleanup()
	-- displayPlan_getWareName(ware, name)
	-- isbreak = displayPlan_render_incoming_ware(row, name, reservation)
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuertee end

init()
﻿-- param == { 0, 0, container }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		int64_t trade;
		int64_t defence;
		int64_t build;
		int64_t repair;
		int64_t missile;
	} SupplyBudget;
	typedef struct {
		const char* ware;
		int total;
		int current;
		const char* supplytypes;
	} SupplyResourceInfo;
	typedef struct {
		const char* macro;
		int amount;
	} SupplyOverride;
	typedef struct {
		double time;
		int64_t money;
	} UIAccountStatData;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		double time;
		uint64_t amount;
	} UICargoStatData;
	typedef struct {
		const char* wareid;
		UICargoStatData* data;
		uint32_t numdata;
	} UICargoStat;
	typedef struct {
		const float x;
		const float y;
		const float z;
		const float yaw;
		const float pitch;
		const float roll;
	} UIPosRot;
	typedef struct {
		const char* id;
		const char* group;
		const char* name;
		const char* description;
		double duration;
		double repeatcooldown;
		uint32_t timescompleted;
		int32_t successchance;
		bool resilient;
		bool showalways;
		int64_t price;
		float payoutfactor;
		const char* requiredresearchid;
		const char* pricescale;
		const char* pricescaletext;
		bool anypredecessor;
		uint32_t numpredecessors;
		uint32_t numpredecessorgroups;
		uint32_t numblockingprojects;
		uint32_t numconditions;
		uint32_t numprimaryeffects;
		uint32_t numsideeffects;
		uint32_t numblockedprojects;
		uint32_t numblockedgroups;
		uint32_t numrebates;
		uint32_t numresources;
		uint32_t numremovedprojects;
	} UITerraformingProject2;
	typedef struct {
		double time;
		int64_t price;
		int amount;
		int limit;
	} UITradeOfferStatData;
	typedef struct {
		const char* wareid;
		bool isSellOffer;
		UITradeOfferStatData* data;
		uint32_t numdata;
	} UITradeOfferStat;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* type;
		const char* name;
		float value;
		bool active;
	} UIWorkforceInfluence;
	typedef struct {
		uint32_t numcapacityinfluences;
		uint32_t numgrowthinfluences;
	} WorkforceInfluenceCounts;
	typedef struct {
		uint32_t numcapacityinfluences;
		UIWorkforceInfluence* capacityinfluences;
		uint32_t numgrowthinfluences;
		UIWorkforceInfluence* growthinfluences;
		float basegrowth;
		uint32_t capacity;
		uint32_t current;
		uint32_t sustainable;
		uint32_t target;
		int32_t change;
	} WorkforceInfluenceInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;

	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	void AddTradeWare(UniverseID containerid, const char* wareid);
	bool AreWaresWithinContainerProductionLimits(UniverseID containerid, UIWareAmount* wares, uint32_t numwares);
	void ClearContainerBuyLimitOverride(UniverseID containerid, const char* wareid);
	void ClearContainerSellLimitOverride(UniverseID containerid, const char* wareid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAmmoStorage(AmmoData* result, uint32_t resultlen, UniverseID defensibleid, const char* ammotype);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	size_t GetBuildMapConstructionPlan(UniverseID holomapid, UniverseID defensibleid, bool usestoredplan, UIConstructionPlanEntry* result, uint32_t resultlen);
	uint32_t GetBuildModules(UniverseID* result, uint32_t resultlen, UniverseID containerid);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetCargoStatistics(UICargoStat* result, uint32_t resultlen, size_t numdatapoints);
	float GetContainerBuildPriceFactor(UniverseID containerid);
	uint32_t GetContainerBuildResources(const char** result, uint32_t resultlen, UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	double GetContainerWareConsumptionPerProduct(UniverseID containerid, const char* wareid, const char* productid, bool ignorestate);
	double GetContainerWareProduction(UniverseID containerid, const char* wareid, bool ignorestate);
	void GetContainerWorkforceInfluence(WorkforceInfluenceInfo* result, UniverseID containerid, const char* raceid);
	float GetCurrentBuildProgress(UniverseID containerid);
	double GetCurrentGameTime(void);
	uint32_t GetNPCAccountStatistics(UIAccountStatData* result, size_t resultlen, UniverseID entityid, double starttime, double endtime);
	uint32_t GetNumAllRaces(void);
	uint32_t GetNumAmmoStorage(UniverseID defensibleid, const char* ammotype);
	uint32_t GetNumBlueprints(const char* set, const char* category, const char* macroname);
	size_t GetNumBuildMapConstructionPlan(UniverseID holomapid, bool usestoredplan);
	uint32_t GetNumBuildModules(UniverseID containerid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumCargoStatistics(UniverseID containerorspaceid, double starttime, double endtime, size_t numdatapoints);
	uint32_t GetNumContainerBuildResources(UniverseID containerid);
	WorkforceInfluenceCounts GetNumContainerWorkforceInfluence(UniverseID containerid, const char* raceid, bool force);
	size_t GetNumPlannedStationModules(UniverseID defensibleid, bool includeall);
	uint32_t GetNumRemovedConstructionPlanModules2(UniverseID holomapid, UniverseID defensibleid, uint32_t* newIndex, bool usestoredplan, uint32_t* numChangedIndices, bool checkupgrades);
	uint32_t GetNumRemovedStationModules2(UniverseID defensibleid, uint32_t* newIndex, uint32_t* numChangedIndices, bool checkupgrades);
	uint32_t GetNumResearchModules(UniverseID containerid);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumStationOverviewGraphWares(UniverseID stationid, bool* initialized);
	uint32_t GetNumSupplyOrderResources(UniverseID containerid);
	uint32_t GetNumSupplyOrders(UniverseID containerid, bool defaultorders);
	uint32_t GetNumTerraformingProjects(UniverseID clusterid, bool useevents);
	uint32_t GetNumTradeOfferStatistics(UniverseID containerorspaceid, double starttime, double endtime, size_t numdatapoints);
	size_t GetPlannedStationModules(UIConstructionPlanEntry* result, uint32_t resultlen, UniverseID defensibleid, bool includeall);
	uint32_t GetRemovedConstructionPlanModules2(UniverseID* result, uint32_t resultlen, uint32_t* changedIndices, uint32_t* numChangedIndices);
	uint32_t GetRemovedStationModules2(UniverseID* result, uint32_t resultlen, uint32_t* changedIndices, uint32_t* numChangedIndices);
	uint32_t GetResearchModules(UniverseID* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetStationOverviewGraphWares(const char** result, uint32_t resultlen, UniverseID stationid);
	int64_t GetSupplyBudget(UniverseID containerid);
	uint32_t GetSupplyOrderResources(SupplyResourceInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetSupplyOrders(SupplyOverride* result, uint32_t resultlen, UniverseID containerid, bool defaultorders);
	const char* GetTerraformingActiveProject(UniverseID clusterid);
	uint32_t GetTerraformingProjects2(UITerraformingProject2* result, uint32_t resultlen, UniverseID clusterid, bool useevents);
	uint32_t GetTradeOfferStatistics(UITradeOfferStat* result, uint32_t resultlen, size_t numdatapoints);
	int64_t GetTradeWareBudget(UniverseID containerid);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasEntityMoneyLogEntries(UniverseID entityid);
	bool IsComponentOperational(UniverseID componentid);
	bool IsContainerAmmoMacroCompatible(UniverseID containerid, const char* ammomacroname);
	bool IsHQ(UniverseID componentid);
	bool IsNextStartAnimationSkipped(bool reset);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
	bool IsSupplyManual(UniverseID containerid, const char* type);
	void PauseProductionModule(UniverseID productionmoduleid, bool pause);
	void PauseProcessingModule(UniverseID processingmoduleid, bool pause);
	void RemoveTradeWare(UniverseID containerid, const char* wareid);
	void SetContainerBuildPriceFactor(UniverseID containerid, float value);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetContainerWareIsBuyable(UniverseID containerid, const char* wareid, bool allowed);
	void SetContainerWareIsSellable(UniverseID containerid, const char* wareid, bool allowed);
	void SetContainerWorkforceFillCapacity(UniverseID containerid, bool value);
	bool SetStationOverviewGraphWare(UniverseID stationid, const char* wareid, bool value);
	void SetSupplyManual(UniverseID containerid, const char* type, bool onoff);
	bool ShouldContainerFillWorkforceCapacity(UniverseID containerid);
	void UpdateProductionTradeOffers(UniverseID containerid);
	void UpdateSupplyOverrides(UniverseID containerid, SupplyOverride* overrides, uint32_t numoverrides);
]]

local utf8 = require("utf8")

local menu = {
	name = "StationOverviewMenu",
	graphmode = "tradeofferprices",
	extendedGroups = {},
	showSingleProduction = {},
	showGraph = false,
}

local config = {
	mainFrameLayer = 5,
	expandedMenuFrameLayer = 4,
	contextFrameLayer = 2,
	nodeoffsetx = 30,
	nodewidth = 270,
	dronetypes = { 
		{ type = "transport",	name = ReadText(1001, 7104),	autoname = ReadText(1001, 4207) },
		{ type = "defence",		name = ReadText(1001, 1310),	autoname = ReadText(1001, 4216) },
		{ type = "repair",		name = ReadText(1001, 3000),	autoname = ReadText(1001, 4232) },
		{ type = "build",		name = ReadText(1001, 7833),	autoname = ReadText(1001, 4233) },
	},
	missilestypes = {
		{ type = "missile",		name = ReadText(1001, 1304),	autoname = ReadText(1001, 4234) },
	},
	graph = {
		maxshowndata = 4,
		numdatapoints = 21,
		factors = { 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000 },
		datarecordcolors = {
			[1] = { buy = { r = 253, g =  91, b =  91, a = 100 }, buyhex = "\27#FFFD5B5B#", sell = { r = 252, g = 171, b =  92, a = 100 }, sellhex = "\27#FFFCAB5C#" },
			[2] = { buy = { r =  85, g = 172, b =   0, a = 100 }, buyhex = "\27#FF55AC00#", sell = { r = 180, g = 250, b = 200, a = 100 }, sellhex = "\27#FFB4FAC8#" },
			[3] = { buy = { r =   0, g = 175, b = 180, a = 100 }, buyhex = "\27#FF00AFB4#", sell = { r =  91, g = 133, b = 253, a = 100 }, sellhex = "\27#FF5B85FD#" },
			[4] = { buy = { r = 171, g =  91, b = 253, a = 100 }, buyhex = "\27#FFAB5BFD#", sell = { r = 253, g =  91, b = 213, a = 100 }, sellhex = "\27#FFFD5BD5#" }
		},
		point = {
			type = "square",
			size = 8,
			highlightSize = 8,
		},
		line = {
			type = "normal",
			size = 2,
			highlightSize = 4,
		},
	},
}

-- kuertee start:
local callbacks = {}
-- kuertee end

-- init menu and register with Helper
local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_station_overview.xpl.init - kuertee")
end
-- kuertee end

-- cleanup variables in menu, no need for the menu variable to keep all the data while the menu is not active
function menu.cleanup()
	menu.title = nil
	menu.container = nil
	menu.containerid = nil
	menu.frame = nil
	menu.flowchart = nil
	menu.keyTable = nil
	menu.expandedNode = nil
	menu.expandedMenuFrame = nil
	if menu.wareReservationRegistered then
		UnregisterEvent("newWareReservation", menu.newWareReservationCallback)
		menu.wareReservationRegistered = nil
	end
	if menu.supplyUpdateRegistered then
		UnregisterEvent("supplyUpdate", menu.supplyUpdate)
		menu.supplyUpdateRegistered = nil
	end
	menu.expandedMenuTable = nil
	menu.noupdate = nil

	menu.restoreNode = nil
	menu.restoreNodeWare = nil
	menu.restoreNodeSupply = nil
	menu.restoreNodeSupplyWare = nil
	menu.restoreNodeBuildModule = nil

	menu.constructionplan = {}
	menu.newModulesIndex = nil
	menu.removedModules = {}
	menu.displayedgraphwares = {}
	menu.graphwaresinit = nil
	menu.productionnodes = { }
	menu.researchnodes = {}
	menu.showSingleProduction = {}
	menu.terraformingnodes = {}

	menu.topRows = {}
	menu.firstCols = {}
	menu.selectedRows = {}
	menu.selectedRowData = {}
	menu.selectedCols = {}

	-- kuertee start: callback
	if callbacks ["cleanup"] then
		for _, callback in ipairs (callbacks ["cleanup"]) do
			callback ()
		end
	end
	-- kuertee end: callback
end

-- helpers to maintain row/column states while frame is re-created
function menu.saveFlowchartState(name, flowchart)
	menu.topRows[name], menu.firstCols[name] = GetFlowchartFirstVisibleCell(flowchart.id)
	menu.selectedRows[name], menu.selectedCols[name] = GetFlowchartSelectedCell(flowchart.id)
end

function menu.restoreFlowchartState(name, flowchart)
	flowchart.properties.firstVisibleRow = menu.topRows[name] or 1
	flowchart.properties.firstVisibleCol = menu.firstCols[name] or 1
	menu.topRows[name] = nil
	menu.firstCols[name] = nil
	flowchart.properties.selectedRow = menu.selectedRows[name] or 1
	flowchart.properties.selectedCol = menu.selectedCols[name] or 1
	menu.selectedRows[name] = nil
	menu.selectedRowData[name] = nil
	menu.selectedCols[name] = nil
end

function menu.saveTableState(name, ftable, row, col)
	menu.topRows[name] = GetTopRow(ftable.id)
	menu.selectedRows[name] = row or Helper.currentTableRow[ftable.id]
	menu.selectedRowData[name] = menu.rowDataMap[ftable.id] and menu.rowDataMap[ftable.id][menu.selectedRows[name]]
	menu.selectedCols[name] = col or Helper.currentTableCol[ftable.id]
end

function menu.restoreTableState(name, ftable)
	ftable:setTopRow(menu.topRows[name])
	ftable:setSelectedRow(menu.selectedRows[name])
	ftable:setSelectedCol(menu.selectedCols[name] or 0)

	menu.topRows[name] = nil
	menu.selectedRows[name] = nil
	menu.selectedRowData[name] = nil
	menu.selectedCols[name] = nil
end

-- Menu member functions

function menu.onShowMenu(state)
	menu.containerid = menu.param[3]
	menu.container = ConvertIDTo64Bit(menu.containerid)
	menu.displayedgraphwares = {}

	menu.isdummy = false
	if not menu.container then
		menu.isdummy = true
		menu.containerid = GetPlayerContextByClass("container")
		menu.container = ConvertIDTo64Bit(menu.containerid)
	else
		local boolbuf = ffi.new("bool[1]", 0)
		local n = C.GetNumStationOverviewGraphWares(menu.container, boolbuf)
		menu.graphwaresinit = boolbuf[0]
		if n > 0 then
			local buf = ffi.new("const char*[?]", n)
			n = C.GetStationOverviewGraphWares(buf, n, menu.container)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i])
				menu.displayedgraphwares[ware] = true
			end
		end
	end

	menu.title = ReadText(1001, 7903)

	menu.topRows = {}
	menu.firstCols = {}
	menu.selectedRows = {}
	menu.selectedRowData = {}
	menu.selectedCols = {}

	menu.numshowndata = 0
	menu.showndata = {}

	-- trade rules
	Helper.updateTradeRules()

	-- flowchart init
	menu.setupFlowchartData()

	-- graph init
	if not menu.graphmode then
		menu.graphmode = "tradeofferprices"
	end
	local curtime = C.GetCurrentGameTime()
	menu.timeframe = "hour"
	menu.xStart = math.max(0, curtime - 3600)
	menu.xEnd = curtime
	menu.xGranularity = 300
	if menu.xEnd > menu.xStart then
		while (menu.xEnd - menu.xStart) < menu.xGranularity do
			menu.xGranularity = menu.xGranularity / 2
		end
	end
	menu.xScale = 60
	menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 103) .. "]"
	menu.yTitle = ReadText(1001, 6520) .. " [" .. ReadText(1001, 101) .. "]"

	menu.getData(config.graph.numdatapoints)

	if state then
		menu.onRestoreState(state)
	end

	menu.display()
end

function menu.onShowMenuSound()
	if not C.IsNextStartAnimationSkipped(false) then
		PlaySound("ui_config_station_open")
	else
		PlaySound("ui_menu_changed")
	end
end

function menu.onSaveState()
	local state = {}

	if menu.expandedNode and menu.expandedNode.customdata and menu.expandedNode.customdata.nodedata then
		if menu.expandedNode.customdata.nodedata[1].isstorage then
			state.restoreNodeWare = menu.expandedNode.customdata.nodedata.ware
		elseif menu.expandedNode.customdata.nodedata[1].issupplyresource then
			state.restoreNodeSupplyWare = menu.expandedNode.customdata.nodedata.ware
		elseif menu.expandedNode.customdata.nodedata[1].buildmodule then
			state.restoreNodeBuildModule = menu.expandedNode.customdata.nodedata[1].buildmodule
		elseif menu.expandedNode.customdata.nodedata.drones then
			state.restoreNodeSupply = "drones"
		elseif menu.expandedNode.customdata.nodedata.missiles then
			state.restoreNodeSupply = "missiles"
		end
	end

	state.flowchartTopRow, state.flowchartFirstCol = GetFlowchartFirstVisibleCell(menu.flowchart.id)
	state.flowchartSelectedRow, state.flowchartSelectedCol = GetFlowchartSelectedCell(menu.flowchart.id)

	return state
end

function menu.onRestoreState(state)
	menu.restoreNodeWare = state.restoreNodeWare
	menu.restoreNodeSupplyWare = state.restoreNodeSupplyWare
	menu.restoreNodeBuildModule = ConvertIDTo64Bit(state.restoreNodeBuildModule)
	menu.restoreNodeSupply = state.restoreNodeSupply

	menu.topRows.flowchart, menu.firstCols.flowchart = state.flowchartTopRow, state.flowchartFirstCol
	menu.selectedRows.flowchart, menu.selectedCols.flowchart = state.flowchartSelectedRow, state.flowchartSelectedCol
end

local function addFlowchartWareNode(nodes, warenodes, productiondata)
	if not warenodes[productiondata.ware] then
		local transporttype = GetWareData(productiondata.ware, "transport")
		local planned = false
		local hasstorage = false
		if C.IsComponentClass(menu.container, "container") then
			hasstorage = CheckSuitableTransportType(menu.containerid, productiondata.ware)
		end
		if hasstorage then
			if #menu.constructionplan > 0 then
				local found = false
				for i = 1, #menu.constructionplan do
					local entry = menu.constructionplan[i]
					if IsMacroClass(entry.macro, "storage") then
						local data = GetLibraryEntry("moduletypes_storage", entry.macro)
						if data.storagetags[transporttype] then
							if menu.changedModulesIndices[i] then
								planned = true
							end
							found = true
							break
						end
					end
				end
				if not found then
					hasstorage = false
				end
			end
		else
			if #menu.constructionplan > 0 then
				for i = menu.newModulesIndex, #menu.constructionplan do
					if menu.changedModulesIndices[i] then
						local entry = menu.constructionplan[i]
						if IsMacroClass(entry.macro, "storage") then
							local data = GetLibraryEntry("moduletypes_storage", entry.macro)
							if data.storagetags[transporttype] then
								planned = true
								hasstorage = true
								break
							end
						end
					end
				end
			end
		end

		local warenode = Helper.createLSOStorageNode(menu, menu.container, productiondata.ware, planned, hasstorage)
		table.insert(nodes, warenode)
		warenodes[productiondata.ware] = warenode
	end
	return warenodes[productiondata.ware]
end

local function addFlowchartEdge(node1, node2)
	if not node1 or not node2 then DebugError(TraceBack()) end
	node2.predecessors = node2.predecessors or { }
	node2.predecessors[node1] = (node1.type == "solid" and 3 or (node1.type == "liquid" and 2 or 1))
end

function menu.getFlowchartProductionNodes()
	if menu.isdummy then
		return menu.getFlowchartDummyProductionNodes()
	end

	local nodes = { }
	local warenodes = { }

	local workforcevisible =			C.IsInfoUnlockedForPlayer(menu.container, "efficiency_amount")
	local productioninfo_resources =	C.IsInfoUnlockedForPlayer(menu.container, "production_resources")

	local buildmodules = {}
	Helper.ffiVLA(buildmodules, "UniverseID", C.GetNumBuildModules, C.GetBuildModules, menu.container)
	local buildresources = {}
	local n = C.GetNumContainerBuildResources(menu.container)
	local buf = ffi.new("const char*[?]", n)
	n = C.GetContainerBuildResources(buf, n, menu.container)
	for i = 0, n - 1 do
		buildresources[ffi.string(buf[i])] = true
	end

	-- analyse construction plan (if any)
	menu.constructionplan = {}
	menu.newModulesIndex = 0
	menu.removedModules = {}
	if GetComponentData(menu.containerid, "isplayerowned") then
		local n = C.GetNumBuildMapConstructionPlan(0, true)
		local buf = ffi.new("UIConstructionPlanEntry[?]", n)
		n = tonumber(C.GetBuildMapConstructionPlan(0, menu.container, true, buf, n))
		for i = 0, n - 1 do
			local entry = {}
			entry.idx                   = buf[i].idx
			entry.macro                 = ffi.string(buf[i].macroid)
			entry.component             = buf[i].componentid
			entry.offset                = buf[i].offset
			entry.connection            = ffi.string(buf[i].connectionid)
			entry.predecessoridx        = buf[i].predecessoridx
			entry.predecessorconnection = ffi.string(buf[i].predecessorconnectionid)

			table.insert(menu.constructionplan, entry)
		end
		if #menu.constructionplan > 0 then
			menu.changedModulesIndices = {}
			local newIndex = ffi.new("uint32_t[1]", 0)
			local numChangedIndices = ffi.new("uint32_t[1]", 0)
			local n = C.GetNumRemovedConstructionPlanModules2(0, menu.container, newIndex, true, numChangedIndices, false)
			menu.newModulesIndex = tonumber(newIndex[0]) + 1
			local buf = ffi.new("UniverseID[?]", n)
			local changedIndicesBuf = ffi.new("uint32_t[?]", numChangedIndices[0])
			n = tonumber(C.GetRemovedConstructionPlanModules2(buf, n, changedIndicesBuf, numChangedIndices))
			if n > 0 then
				for i = 0, n - 1 do
					local compID = ConvertStringTo64Bit(tostring(buf[i]))
					menu.removedModules[tostring(compID)] = true
				end
			end
			if numChangedIndices[0] > 0 then
				for i = 0, numChangedIndices[0] - 1 do
					menu.changedModulesIndices[changedIndicesBuf[i]] = true
				end
			end
		else
			local n = C.GetNumPlannedStationModules(menu.container, true)
			local buf = ffi.new("UIConstructionPlanEntry[?]", n)
			n = C.GetPlannedStationModules(buf, n, menu.container, true)
			for i = 0, tonumber(n) - 1 do
				local entry = {}
				entry.idx                   = buf[i].idx
				entry.macro                 = ffi.string(buf[i].macroid)
				entry.component             = buf[i].componentid
				entry.offset                = buf[i].offset
				entry.connection            = ffi.string(buf[i].connectionid)
				entry.predecessoridx        = buf[i].predecessoridx
				entry.predecessorconnection = ffi.string(buf[i].predecessorconnectionid)

				table.insert(menu.constructionplan, entry)
			end

			menu.changedModulesIndices = {}
			local newIndex = ffi.new("uint32_t[1]", 0)
			local numChangedIndices = ffi.new("uint32_t[1]", 0)
			local n = C.GetNumRemovedStationModules2(menu.container, newIndex, numChangedIndices, false)
			menu.newModulesIndex = tonumber(newIndex[0]) + 1
			local buf = ffi.new("UniverseID[?]", n)
			local changedIndicesBuf = ffi.new("uint32_t[?]", numChangedIndices[0])
			n = tonumber(C.GetRemovedStationModules2(buf, n, changedIndicesBuf, numChangedIndices))
			if n > 0 then
				for i = 0, n - 1 do
					local compID = ConvertStringTo64Bit(tostring(buf[i]))
					menu.removedModules[tostring(compID)] = true
				end
			end
			if numChangedIndices[0] > 0 then
				for i = 0, numChangedIndices[0] - 1 do
					menu.changedModulesIndices[changedIndicesBuf[i]] = true
				end
			end
		end
	end

	local productionmoduledata = {}
	-- production modules and processing modules (normal, wrecked and in construction)
	local n = C.GetNumStationModules(menu.container, true, true)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, menu.container, true, true)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		local component, destroyedcomponent
		local isproduction = C.IsRealComponentClass(module, "production")
		local isprocessingmodule = C.IsRealComponentClass(module, "processingmodule")
		if isproduction or isprocessingmodule then
			if not C.IsComponentOperational(module) then
				if C.IsComponentWrecked(module) then
					destroyedcomponent = module
				elseif menu.removedModules[tostring(module)] then
					component = module
				end
			else
				component = module
			end
		end
		if component or destroyedcomponent then
			local macro = GetComponentData(module, "macro")
			--print("existing: " .. macro)
			if productionmoduledata[macro] then
				if component then
					table.insert(productionmoduledata[macro].components, component)
				elseif destroyedcomponent then
					table.insert(productionmoduledata[macro].destroyedcomponents, destroyedcomponent)
				end
			else
				if component then
					productionmoduledata[macro] = { macro = macro, components = { component }, destroyedcomponents = {}, numplanned = 0, isprocessingmodule = isprocessingmodule }
				elseif destroyedcomponent then
					productionmoduledata[macro] = { macro = macro, components = {}, destroyedcomponents = { destroyedcomponent }, numplanned = 0, isprocessingmodule = isprocessingmodule }
				end
			end
		end
	end
	-- go through all new modules
	if #menu.constructionplan > 0 then
		for i = menu.newModulesIndex, #menu.constructionplan do
			if menu.changedModulesIndices[i] then
				local entry = menu.constructionplan[i]
				if (entry.component == 0) or IsComponentConstruction(ConvertStringTo64Bit(tostring(entry.component))) then
					local isproduction = IsMacroClass(entry.macro, "production")
					local isprocessingmodule = IsMacroClass(entry.macro, "processingmodule")
					if isproduction or isprocessingmodule then
						if productionmoduledata[entry.macro] then
							local skip = false
							if entry.component ~= 0 then
								for _, destroyedcomponent in ipairs(productionmoduledata[entry.macro].destroyedcomponents) do
									if destroyedcomponent == entry.component then
										skip = true
										break
									end
								end
							end
							if not skip then
								--print("new: " .. entry.macro)
								productionmoduledata[entry.macro].numplanned = productionmoduledata[entry.macro].numplanned + 1
							end
						else
							--print("new: " .. entry.macro)
							productionmoduledata[entry.macro] = { macro = entry.macro, components = {}, destroyedcomponents = {}, numplanned = 1, isprocessingmodule = isprocessingmodule }
						end
					end
				end
			end
		end
	end

	local cargo = GetComponentData(menu.containerid, "cargo")

	for macro, data in pairs(productionmoduledata) do
		local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
		for _, productdata in ipairs(macrodata.products) do
			productdata.cycletime = productdata.cycle
			productdata.cycle = productdata.amount
			productdata.amount = cargo[productdata.ware] or 0
			local warenode = addFlowchartWareNode(nodes, warenodes, productdata)
			local resources = { }
			local productresources = productdata.resources
			-- link from resource ware nodes to the product ware node (note: ignoring secondary resources)
			for i, resourcedata in ipairs(productresources) do
				resourcedata.name = GetWareData(resourcedata.ware, "name")
				resourcedata.cycletime = resourcedata.cycle
				resourcedata.cycle = resourcedata.amount
				resourcedata.amount = cargo[resourcedata.ware] or 0
				local resourcenode = addFlowchartWareNode(nodes, warenodes, resourcedata)
				addFlowchartEdge(resourcenode, warenode)
				resources[resourcedata.ware] = true
			end
			local modulenode = {
				productionmodules = data,
				properties = { shape = "stadium" },
				resources = resources,
				expandedTableNumColumns = 3,
				expandHandler = data.isprocessingmodule and menu.onExpandProcessing or menu.onExpandProduction,
				-- handle colors in update function
			}
			-- insert before last element, which is the storage module
			table.insert(warenode, #warenode, modulenode)
		end
	end

	local buildmodulenodes = {}
	for _, buildmodule in ipairs(buildmodules) do
		local warenode = {
			text = Helper.unlockInfo(productioninfo_resources, ffi.string(C.GetComponentName(buildmodule))),
			type = "container",
			{
				buildmodule = buildmodule,
				properties = { shape = "stadium" },
				resources = buildresources,
				expandedTableNumColumns = 4,
				expandHandler = menu.onExpandBuildModule,
				color = menu.removedModules[tostring(ConvertStringTo64Bit(tostring(buildmodule)))] and Helper.color.red or nil,
			}
		}

		table.insert(nodes, warenode)
		table.insert(buildmodulenodes, warenode)
	end

	-- destroyed build modules
	local n = C.GetNumStationModules(menu.container, false, true)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, menu.container, false, true)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		if not C.IsComponentOperational(module) then
			if C.IsRealComponentClass(module, "buildmodule") then
				local macro = GetComponentData(module, "macro")
				local data = GetLibraryEntry("moduletypes_build", macro)
				for _, waredata in ipairs(data.buildresources) do
					buildresources[waredata.ware] = true
				end

				local warenode = {
					text = Helper.unlockInfo(productioninfo_resources, data.name),
					type = "container",
					{
						buildmodule = { module, macro },
						properties = { shape = "stadium" },
						resources = buildresources,
						expandHandler = menu.onExpandDestroyedModule,
						color = Helper.color.grey,
						textcolor = Helper.color.red,
						statuscolor = Helper.color.red,
						statusIcon = "lso_warning",
					}
				}

				table.insert(nodes, warenode)
				table.insert(buildmodulenodes, warenode)
			end
		end
	end

	-- go through new buildmodules
	if #menu.constructionplan > 0 then
		for i = menu.newModulesIndex, #menu.constructionplan do
			if menu.changedModulesIndices[i] then
				local entry = menu.constructionplan[i]
				if (entry.component == 0) or IsComponentConstruction(ConvertStringTo64Bit(tostring(entry.component))) then
					if IsMacroClass(entry.macro, "buildmodule") then
						local data = GetLibraryEntry("moduletypes_build", entry.macro)
						for _, waredata in ipairs(data.buildresources) do
							buildresources[waredata.ware] = true
						end

						local warenode = {
							text = Helper.unlockInfo(productioninfo_resources, data.name),
							type = "container",
							{
								buildmodule = { entry.component, entry.macro },
								properties = { shape = "stadium" },
								resources = buildresources,
								expandHandler = menu.onExpandPlannedBuildModule,
								color = Helper.color.grey,
							}
						}

						table.insert(nodes, warenode)
						table.insert(buildmodulenodes, warenode)
					end
				end
			end
		end
	end

	-- buildmodule resource edges
	local cargo = GetComponentData(menu.containerid, "cargo")
	for ware in pairs(buildresources) do
		local resourcenode = addFlowchartWareNode(nodes, warenodes, { ware = ware, name = GetWareData(ware, "name"), amount = cargo[ware] })
		for _, buildmodulenode in ipairs(buildmodulenodes) do
			addFlowchartEdge(resourcenode, buildmodulenode)
		end
	end

	-- workforce
	local workforcenode = {
		workforce = true,
		text = ReadText(1001, 9415),
		type = "container",
		halign = "left",
		{
			properties = {
				shape = "hexagon",
				value = workforcevisible and function () local workforceinfo = C.GetWorkForceInfo(menu.container, ""); local total = C.ShouldContainerFillWorkforceCapacity(menu.container) and math.max(workforceinfo.optimal, workforceinfo.capacity) or workforceinfo.optimal; return (total ~= 0) and math.min(100, math.floor(workforceinfo.current / total * 100)) or 0 end or 0,
				max = 100,
			},
			resources = { },
			expandedTableNumColumns = 4,
			expandHandler = menu.onExpandWorkforce
		}
	}
	table.insert(nodes, workforcenode)
	local workforceraces = {}
	if C.IsComponentClass(menu.container, "container") then
		workforceraces = GetWorkForceRaceResources(menu.containerid)
	end
	if #workforceraces == 0 then
		workforcenode[1].color = Helper.color.grey
		-- TODO: set statusIcon
		-- TODO: Handle case of workforce bonus being non-zero, but no habitation modules present
	else
		-- show workforce bonus in percent
		if workforcevisible then
			if (#GetProductionModules(menu.containerid) > 0) or GetComponentData(menu.containerid, "canequipships") then
				workforcenode[1].statusText = Helper.unlockInfo(workforcevisible, function () local workforceinfo = C.GetWorkForceInfo(menu.container, ""); return ConvertIntegerString(workforceinfo.current, true, 3, true, true) .. "/" .. ConvertIntegerString(C.ShouldContainerFillWorkforceCapacity(menu.container) and math.max(workforceinfo.optimal, workforceinfo.capacity) or workforceinfo.optimal, true, 3, true, true) end)
			end
		end
		-- link from resource ware nodes to the workforce node
		for _, racedata in ipairs(workforceraces) do
			for _, resourcedata in ipairs(racedata.resources) do
				local resourcenode = addFlowchartWareNode(nodes, warenodes, resourcedata)
				addFlowchartEdge(resourcenode, workforcenode)
				workforcenode[1].resources[resourcedata.ware] = true
			end
		end
	end

	-- research
	local researchnode
	if GetComponentData(menu.containerid, "isplayerowned") then
		local researchmodules = {}
		Helper.ffiVLA(researchmodules, "UniverseID", C.GetNumResearchModules, C.GetResearchModules, menu.container)
		for _, researchmodule in ipairs(researchmodules) do
			local researchmodule64 = ConvertStringTo64Bit(tostring(researchmodule))
			local proddata = GetProductionModuleData(researchmodule64)
			if (proddata.state == "producing") or (proddata.state == "waitingforresources") then
				researchnode = {
					research = true,
					text = ReadText(1001, 7400),
					type = "container",
					halign = "left",
					{
						researchmodule = researchmodule64,
						properties = {
							shape = "stadium",
							value = function() return Helper.round(math.max(1, GetProductionModuleData(researchmodule64).cycleprogress or 0)) end,
							max = 100,
						},
						resources = { },
						expandHandler = menu.onExpandResearch
					}
				}
				table.insert(nodes, researchnode)

				local resources = GetWareData(proddata.blueprintware, "resources")
				for _, resourcedata in ipairs(resources) do
					local resourcenode = addFlowchartWareNode(nodes, warenodes, { ware = resourcedata.ware, name = GetWareData(resourcedata.ware, "name"), amount = cargo[resourcedata.ware] or 0 })
					addFlowchartEdge(resourcenode, researchnode)
					researchnode[1].resources[resourcedata.ware] = true
				end
			end
		end
	end

	-- terraforming
	local terraformingnode
	if GetComponentData(menu.containerid, "isplayerowned") and C.IsHQ(menu.container) then
		local cluster = C.GetContextByClass(menu.container, "cluster", false)
		if GetComponentData(ConvertStringTo64Bit(tostring(cluster)), "hasterraforming") then
			local activeprojectid = ffi.string(C.GetTerraformingActiveProject(cluster))
			if activeprojectid ~= "" then
				local activeproject
				local n = C.GetNumTerraformingProjects(cluster, false)
				local buf = ffi.new("UITerraformingProject2[?]", n)
				n = C.GetTerraformingProjects2(buf, n, cluster, false)
				for i = 0, n - 1 do
					local entry = Helper.getProjectEntry(cluster, buf[i], false)
					if entry.id == activeprojectid then
						activeproject = entry
						break
					end
				end
				if activeproject ~= nil then
					terraformingnode = {
						terraforming = true,
						text = ReadText(1001, 3800),
						type = "container",
						halign = "left",
						{
							terraformingproject = { cluster = cluster, project = activeproject },
							properties = {
								shape = "stadium",
								value = function () return menu.nodevalueProject(cluster, activeproject) end,
								max = 100,
							},
							resources = { },
							expandHandler = menu.onExpandTerraforming
						}
					}
					table.insert(nodes, terraformingnode)

					for _, resourcedata in ipairs(activeproject.resources) do
						local resourcenode = addFlowchartWareNode(nodes, warenodes, { ware = resourcedata.ware, name = GetWareData(resourcedata.ware, "name"), amount = cargo[resourcedata.ware] or 0 })
						addFlowchartEdge(resourcenode, terraformingnode)
						terraformingnode[1].resources[resourcedata.ware] = true
					end
				else
					DebugError("Active terraforming project '" .. activeprojectid .. "' not found in list of projects of cluster '" .. ffi.string(C.GetComponentName(cluster)) .. "'.")
				end
			end
		end
	end

	return nodes, warenodes, workforcenode, researchnode, terraformingnode
end

function menu.updateDeliveredWares(cluster, project)
	local curtime = getElapsedTime()
	if (not menu.lastDeliveryUpdateTime) or (curtime > menu.lastDeliveryUpdateTime) then
		menu.lastDeliveryUpdateTime = curtime
		menu.deliveredwares = {}
		local buf_deliveredwares = ffi.new("UIWareInfo[?]", #project.resources)
		local num_deliveredwares = C.GetTerraformingProjectDeliveredResources(buf_deliveredwares, #project.resources, cluster, project.id)
		for i = 0, num_deliveredwares - 1 do
			menu.deliveredwares[ffi.string(buf_deliveredwares[i].ware)] = buf_deliveredwares[i].amount
		end
	end
end

function menu.nodevalueProject(cluster, project)
	local value = 0
	local scale = (#project.resources > 0) and ((project.duration == 0) and 100 or 66) or 0

	if C.HasTerraformingProjectStarted(cluster, project.id) then
		value = scale + C.GetTerraformingProjectCompletionFraction(cluster, project.id) * (100 - scale)
	else
		menu.updateDeliveredWares(cluster, project)
		local sumdeliveries, sumresources = 0, 0
		for _, entry in ipairs(project.resources) do
			local volume = GetWareData(entry.ware, "volume")
			sumresources = sumresources + entry.amount * volume
			sumdeliveries = sumdeliveries + (menu.deliveredwares[entry.ware] or 0) * volume
		end
		value = sumdeliveries / sumresources * scale
	end

	return value
end

function menu.getMissileAmount(defenceinfo_high)
	local total = 0
	local n = C.GetNumAllMissiles(menu.container)
	local buf = ffi.new("AmmoData[?]", n)
	n = C.GetAllMissiles(buf, n, menu.container)
	for j = 0, n - 1 do
		total = total + buf[j].amount
	end

	return defenceinfo_high and total or 0
end

function menu.getSupplyResourceValue(ware)
	local curtime = getElapsedTime()
	if menu.supplyResourceTimeStamp ~= curtime then
		menu.supplyResourceTimeStamp = curtime

		menu.supplyResources = {}
		local n = C.GetNumSupplyOrderResources(menu.container)
		menu.numSupplyResources = n
		local buf = ffi.new("SupplyResourceInfo[?]", n)
		n = C.GetSupplyOrderResources(buf, n, menu.container)
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i].ware)
			local total = buf[i].total
			local current = buf[i].current
			menu.supplyResources[ware] = { value = current, max = total }
		end
	end

	return menu.supplyResources[ware] and menu.supplyResources[ware].value or 0
end

function menu.getSupplyResourceMax(ware, raw)
	local curtime = getElapsedTime()
	if menu.supplyResourceTimeStamp ~= curtime then
		menu.supplyResourceTimeStamp = curtime

		menu.supplyResources = {}
		local n = C.GetNumSupplyOrderResources(menu.container)
		menu.numSupplyResources = n
		local buf = ffi.new("SupplyResourceInfo[?]", n)
		n = C.GetSupplyOrderResources(buf, n, menu.container)
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i].ware)
			local total = buf[i].total
			local current = buf[i].current
			menu.supplyResources[ware] = { value = current, max = total }
		end
	end
	
	if raw then
		return menu.supplyResources[ware] and menu.supplyResources[ware].max or 0
	else
		return menu.supplyResources[ware] and math.max(menu.supplyResources[ware].value, menu.supplyResources[ware].max) or 0
	end
end

function menu.setupFlowchartData()
	-- kuertee start: callback
	if callbacks ["setupFlowchartData_on_start"] then
		for _, callback in ipairs (callbacks ["setupFlowchartData_on_start"]) do
			callback ()
		end
	end
	-- kuertee end: callback

	local nodes, warenodes, workforcenode, researchnode, terraformingnode = menu.getFlowchartProductionNodes()

	-- assign numrows and numcols
	for _, node in ipairs(nodes) do
		local nummodules = #node
		if nummodules > 1 then
			node.numrows = nummodules - 1			-- n-1 production modules
			node.numcols = 2						-- 1 storage module
		end
	end

	-- enable shuffle for testing more random inputs
	--local shuffle = true
	if shuffle then
		for i = 1, #nodes - 1 do
			local rnd = math.random(i, #nodes)
			nodes[i], nodes[rnd] = nodes[rnd], nodes[i]
		end
		local str = ""
		for _, node in ipairs(nodes) do
			str = str .. node.text .. ", "
		end
		print(str)
	end

	-- separate all nodes that are connected to workforce via edges
	local workforcenodes = { }
	if workforcenode then
		-- repeated two-step process to find workforce-related nodes - necessary since we only know a node's predecessors, not its successors
		workforcenode.workforceRelated = true
		local processingqueue = { workforcenode }
		while #processingqueue > 0 do
			-- mark all nodes in the queue and their ancestors as workforce-related
			while #processingqueue > 0 do
				local node = table.remove(processingqueue, 1)
				if node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if not predecessor.workforceRelated then
							predecessor.workforceRelated = true
							table.insert(processingqueue, predecessor)
						end
					end
				end
			end
			-- fill queue with unmarked successors of marked nodes
			for _, node in ipairs(nodes) do
				if not node.workforceRelated and node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if predecessor.workforceRelated then
							node.workforceRelated = true
							table.insert(processingqueue, node)
							break
						end
					end
				end
			end
		end
		-- move workforce-related nodes to other table
		for nodeidx = #nodes, 1, -1 do
			local node = nodes[nodeidx]
			if node.workforceRelated then
				table.remove(nodes, nodeidx)
				table.insert(workforcenodes, 1, node)
			end
		end
	end

	-- separate all nodes that are connected to research via edges
	local researchnodes = { }
	if researchnode then
		-- repeated two-step process to find research-related nodes - necessary since we only know a node's predecessors, not its successors
		researchnode.researchRelated = true
		local processingqueue = { researchnode }
		while #processingqueue > 0 do
			-- mark all nodes in the queue and their ancestors as research-related
			while #processingqueue > 0 do
				local node = table.remove(processingqueue, 1)
				if node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if not predecessor.researchRelated then
							predecessor.researchRelated = true
							table.insert(processingqueue, predecessor)
						end
					end
				end
			end
			-- fill queue with unmarked successors of marked nodes
			for _, node in ipairs(nodes) do
				if not node.researchRelated and node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if predecessor.researchRelated then
							node.researchRelated = true
							table.insert(processingqueue, node)
							break
						end
					end
				end
			end
		end
		-- move research-related nodes to other table
		for nodeidx = #nodes, 1, -1 do
			local node = nodes[nodeidx]
			if node.researchRelated then
				table.remove(nodes, nodeidx)
				table.insert(researchnodes, 1, node)
			end
		end
	end

	-- separate all nodes that are connected to terraforming via edges
	local terraformingnodes = { }
	if terraformingnode then
		-- repeated two-step process to find terraforming-related nodes - necessary since we only know a node's predecessors, not its successors
		terraformingnode.terraformingRelated = true
		local processingqueue = { terraformingnode }
		while #processingqueue > 0 do
			-- mark all nodes in the queue and their ancestors as terraforming-related
			while #processingqueue > 0 do
				local node = table.remove(processingqueue, 1)
				if node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if not predecessor.terraformingRelated then
							predecessor.terraformingRelated = true
							table.insert(processingqueue, predecessor)
						end
					end
				end
			end
			-- fill queue with unmarked successors of marked nodes
			for _, node in ipairs(nodes) do
				if not node.terraformingRelated and node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if predecessor.terraformingRelated then
							node.terraformingRelated = true
							table.insert(processingqueue, node)
							break
						end
					end
				end
			end
		end
		-- move terraforming-related nodes to other table
		for nodeidx = #nodes, 1, -1 do
			local node = nodes[nodeidx]
			if node.terraformingRelated then
				table.remove(nodes, nodeidx)
				table.insert(terraformingnodes, 1, node)
			end
		end
	end

	local flowchartsections = { }
	if #nodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(nodes)
		table.insert(flowchartsections, { nodes = nodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	if #researchnodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(researchnodes)
		table.insert(flowchartsections, { nodes = researchnodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	if #terraformingnodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(terraformingnodes)
		table.insert(flowchartsections, { nodes = terraformingnodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	if #workforcenodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(workforcenodes)
		table.insert(flowchartsections, { nodes = workforcenodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	-- if one of the two production sections has a production module that doesn't require resources (e.g. Energy Cells production),
	-- the production module is located in the very first column and the associated storage module in the second column (in same node with numcols = 2).
	-- Within the same section, all storage modules in the first tier will be right-aligned and end up in the second column,
	-- but for all other sections in the flowchart we have to do this manually, so there are no storage modules in the first column.
	menu.startwithproduction = false
	for _, section in ipairs(flowchartsections) do
		for _, node in ipairs(section.nodes) do
			if node.col == 1 then
				local nummodules = #node
				if nummodules > 1 then
					section.startswithproduction = true
					menu.startwithproduction = true
					break
				end
			end
		end
	end

	-- protectyon section
	local condensateware = "condensate"
	local transporttype = GetWareData(condensateware, "transport")
	local sector = GetComponentData(menu.containerid, "sectorid")
	local sectorcontainsthewave = GetComponentData(sector, "containsthewave")
	local hascondensatestorage = false
	if C.IsComponentClass(menu.container, "container") then
		hascondensatestorage = CheckSuitableTransportType(menu.containerid, condensateware)
	end
	if #menu.constructionplan > 0 then
		local found = false
		for i = 1, #menu.constructionplan do
			local entry = menu.constructionplan[i]
			if IsMacroClass(entry.macro, "storage") then
				local data = GetLibraryEntry("moduletypes_storage", entry.macro)
				if data.storagetags[transporttype] then
					found = true
					break
				end
			end
		end
		if not found then
			hascondensatestorage = false
		end
	end

	if sectorcontainsthewave and hascondensatestorage then
		local condensatenodes = {}
		local production_products =	C.IsInfoUnlockedForPlayer(menu.container, "production_products")

		-- add condensate shield node
		local condensateshieldnode = {
			condensateshield = condensateware,
			text = Helper.unlockInfo(production_products, ReadText(20104, 92501)),
			type = transporttype,
			row = 1, col = 2, numrows = 1, numcols = 1,
			{
				properties = {
					value = 0,
					max = 0,
					shape = "hexagon",
				},
				expandedTableNumColumns = 2,
				expandHandler = menu.onExpandCondensateShield,
			}
		}
		table.insert(condensatenodes, condensateshieldnode)

		-- add condensate storage node
		local node = Helper.createLSOStorageNode(menu, menu.container, condensateware, false, true, true)
		table.insert(condensatenodes, node)
		warenodes[condensateware] = node
		addFlowchartEdge(node, condensateshieldnode)

		table.insert(flowchartsections, { nodes = condensatenodes, junctions = { }, numrows = 1, numcols = 2 })
	end

	-- supply section
	local nodes = {}
	-- Add drone node
	local unitstoragedata = (menu.container and C.IsComponentClass(menu.container, "container")) and GetUnitStorageData(menu.containerid) or nil
	local unitinfo_capacity =	C.IsInfoUnlockedForPlayer(menu.container, "units_capacity")
	local unitinfo_amount =		C.IsInfoUnlockedForPlayer(menu.container, "units_amount")

	local supplynodecount = 0
	local dronesnode, missilesnode
	if unitstoragedata then
		local shownamount = unitinfo_amount and unitstoragedata.stored or 0
		local shownmax = unitinfo_capacity and math.max(shownamount, unitstoragedata.capacity) or shownamount
		dronesnode = {
			drones = true,
			text = Helper.unlockInfo(unitinfo_capacity, ReadText(1001, 8)),
			type = "container",
			row = 1, col = 2, numrows = 1, numcols = 1,
			{
				properties = {
					value = function () local data = GetUnitStorageData(menu.containerid); return unitinfo_amount and data.stored or 0 end,
					max = shownmax,
					shape = "hexagon",
				},
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandSupply,
				collapseHandler = menu.onCollapseSupply,
			}
		}
		dronesnode[1].statusText = function () local data = GetUnitStorageData(menu.containerid); return string.format("%s/%s", Helper.unlockInfo(unitinfo_amount, data.stored), Helper.unlockInfo(unitinfo_capacity, unitstoragedata.capacity)) end
		table.insert(nodes, dronesnode)
		supplynodecount = supplynodecount + 1
	end

	-- Add missile node
	local missilecapacity = GetComponentData(menu.containerid, "missilecapacity") or 0
	if missilecapacity > 0 then
		local defenceinfo_low =		C.IsInfoUnlockedForPlayer(menu.container, "defence_level")
		local defenceinfo_high =	C.IsInfoUnlockedForPlayer(menu.container, "defence_status")
		local total = 0
		local n = C.GetNumAllMissiles(menu.container)
		local buf = ffi.new("AmmoData[?]", n)
		n = C.GetAllMissiles(buf, n, menu.container)
		for j = 0, n - 1 do
			total = total + buf[j].amount
		end

		local shownamount = defenceinfo_high and total or 0
		local shownmax = defenceinfo_low and math.max(shownamount, missilecapacity) or shownamount
		missilesnode = {
			missiles = true,
			text = Helper.unlockInfo(defenceinfo_low, ReadText(1001, 2800)),
			type = "container",
			row = #nodes + 1, col = 2, numrows = 1, numcols = 1,
			{
				properties = {
					value = function () return menu.getMissileAmount(defenceinfo_high) end,
					max = shownmax,
					shape = "hexagon",
				},
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandSupply,
				collapseHandler = menu.onCollapseSupply,
			}
		}
		missilesnode[1].statusText = function () return string.format("%s/%s", Helper.unlockInfo(defenceinfo_high, menu.getMissileAmount(defenceinfo_high)), Helper.unlockInfo(defenceinfo_low, shownmax)) end
		table.insert(nodes, missilesnode)
		supplynodecount = supplynodecount + 1
	end

	-- supply resources
	local supplyresources = {}
	local n = C.GetNumSupplyOrderResources(menu.container)
	menu.numSupplyResources = n
	local buf = ffi.new("SupplyResourceInfo[?]", n)
	n = C.GetSupplyOrderResources(buf, n, menu.container)
	for i = 0, n - 1 do
		local ware = ffi.string(buf[i].ware)
		local total = buf[i].total
		local current = buf[i].current
		table.insert(supplyresources, { ware = ware, name = GetWareData(ware, "name"), max = total, value = current, supplytypes = ffi.string(buf[i].supplytypes) })
	end
	table.sort(supplyresources, Helper.sortName)
	
	local storageinfo_warelist =	C.IsInfoUnlockedForPlayer(menu.container, "storage_warelist")
	for i, entry in ipairs(supplyresources) do
		local hasrestrictions = C.GetContainerTradeRuleID(menu.container, "supply", entry.ware) > 0

		local warenode = {
			ware = entry.ware,
			text = Helper.unlockInfo(storageinfo_warelist, entry.name),
			type = transporttype,
			row = i, col = 1, numrows = 1, numcols = 1,
			{
				properties = {
					value = entry.value,
					max = math.max(entry.value, entry.max),
				},
				issupplyresource = true,
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandSupplyResource,
				statuscolor = hasrestrictions and Helper.color.warningorange or nil,
				statusIcon = hasrestrictions and "lso_error" or nil,
			}
		}
		table.insert(nodes, warenode)

		for supplytype in string.gmatch(entry.supplytypes, "%a+") do
			if dronesnode and (supplytype == "unit") then
				addFlowchartEdge(warenode, dronesnode)
			elseif missilesnode and (supplytype == "missile") then
				addFlowchartEdge(warenode, missilesnode)
			end
		end
	end

	table.insert(flowchartsections, { nodes = nodes, junctions = { }, numrows = math.max(#supplyresources, supplynodecount), numcols = 2 })

	-- add account section
	if C.IsComponentClass(menu.container, "container") and GetComponentData(menu.containerid, "isplayerowned") then
		local nodes = {}
		local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
		local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
		local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
		local budget = productionmoney + supplymoney + tradewaremoney

		local shownamount = money
		local shownmax = math.max(shownamount, budget)
		local accountnode = {
			account = true,
			text = ReadText(1001, 7710),
			type = "container",
			row = #nodes + 1, col = 1, numrows = 1, numcols = 1,
			{
				properties = {
					value = shownamount,
					max = shownmax,
				},
				expandedTableNumColumns = 2,
				expandHandler = menu.onExpandAccount,
				statusText = string.format("%s/%s %s", ConvertMoneyString(money, false, true, 3, true, false), ConvertMoneyString(productionmoney + supplymoney + tradewaremoney, false, true, 3, true, false), ReadText(1001, 101))
			}
		}
		table.insert(nodes, accountnode)
		table.insert(flowchartsections, { nodes = nodes, junctions = { }, numrows = #nodes, numcols = 1 })
	end

	-- Add non-production section
	local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")
	local storageinfo_capacity =	C.IsInfoUnlockedForPlayer(menu.container, "storage_capacity")
	local storageinfo_warelist =	C.IsInfoUnlockedForPlayer(menu.container, "storage_warelist")

	local cargo, tradewares, isplayerowned, resources = GetComponentData(menu.containerid, "cargo", "tradewares", "isplayerowned", "pureresources")
	local cargoandtrade = {}
	for ware, amount in pairs(cargo) do
		if (amount > 0) and (not warenodes[ware]) then
			cargoandtrade[ware] = amount
		end
	end
	for _, ware in ipairs(tradewares) do
		if (not cargoandtrade[ware]) and (not warenodes[ware]) then
			cargoandtrade[ware] = 0 -- assuming 0 due to no entry in cargo
		end
	end
	for _, ware in ipairs(resources) do
		if (not cargoandtrade[ware]) and (not warenodes[ware]) then
			cargoandtrade[ware] = 0 -- assuming 0 due to no entry in cargo
		end
	end

	local remainingcargonodes = { }
	for ware, amount in pairs(cargoandtrade) do
		local transporttype = GetWareData(ware, "transport")
		local hasstorage = true -- ware is in the current cargo list
		if #menu.constructionplan > 0 then
			local found = false
			for i = 1, #menu.constructionplan do
				local entry = menu.constructionplan[i]
				if IsMacroClass(entry.macro, "storage") then
					local data = GetLibraryEntry("moduletypes_storage", entry.macro)
					if data.storagetags[transporttype] then
						found = true
						break
					end
				end
			end
			if not found then
				hasstorage = false
			end
		end

		local node = Helper.createLSOStorageNode(menu, menu.container, ware, false, hasstorage, true)
		table.insert(remainingcargonodes, node)
	end
	-- sort to get a consistent result
	table.sort(remainingcargonodes, function (a, b) return a.text < b.text end)
	if isplayerowned and C.IsComponentClass(menu.container, "container") then
		-- kuertee start: callback
		if callbacks ["setupFlowchartData_pre_trade_wares_button"] then
			for _, callback in ipairs (callbacks ["setupFlowchartData_pre_trade_wares_button"]) do
				callback (remainingcargonodes)
			end
		end
		-- kuertee end: callback

		-- add trade wares option
		local node = {
			cargo = true,
			text = ReadText(1001, 6900),
			row = 1,
			col = 1,
			numrows = 1,
			numcols = 1,
			{
				properties = {
				},
				expandedFrameNumTables = 2,
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandTradeWares,
			}
		}
		table.insert(remainingcargonodes, node)
	end

	-- add flowchart section with all remaining wares
	if #remainingcargonodes > 0 then
		for nodeidx, node in ipairs(remainingcargonodes) do
			node.row = nodeidx
		end
		table.insert(flowchartsections, { nodes = remainingcargonodes, junctions = { }, numrows = #remainingcargonodes, numcols = 1 })
	end

	-- Merge all sections into a single flowchart
	local numrows = 0
	local numcols = 0
	local allnodes = { }
	local alljunctions = { }

	local startrow = 1
	for _, section in ipairs(flowchartsections) do
		local startcol = (menu.startwithproduction and not section.startswithproduction) and 2 or 1
		for _, node in ipairs(section.nodes) do
			node.row = node.row + startrow - 1
			node.col = node.col + startcol - 1
			table.insert(allnodes, node)
		end
		for _, junction in ipairs(section.junctions) do
			junction.row = junction.row + startrow - 1
			junction.col = junction.col + startcol - 1
			table.insert(alljunctions, junction)
		end
		numrows = startrow + section.numrows - 1
		numcols = math.max(numcols, section.numcols + startcol - 1)
		startrow = numrows + 2
	end

	menu.flowchartNumRows = numrows
	menu.flowchartNumCols = numcols
	menu.flowchartNodes = allnodes
	menu.flowchartJunctions = alljunctions
end

function menu.getFlowchartDummyProductionNodes()
	local nodeEnergy = { text = "Energy Cells", type = "container",
		{ properties = { width = 250, value = 600, max = 1000, slider1 = 450, step = 1 } }
	}
	local nodeMethane = { text = "Methane", type = "liquid",
		{ properties = { width = 250, value = 350, max = 1000, slider1 = 450, step = 1 } }
	}
	local nodeHelium = { text = "Helium", type = "liquid",
		{ properties = { width = 220, value = 10, max = 100, step = 1 } }
	}
	local nodeSilicon = { text = "Silicon", type = "solid",
		{ properties = { width = 250, value = 120, max = 200, step = 1 } }
	}
	local nodeHydrogen = { text = "Hydrogen", type = "liquid",
		{ properties = { width = 250, value = 0, max = 100, slider1 = 50, step = 1 } }
	}

	local nodeGraphene = { text = "Graphene", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory" },
		{ properties = { width = 250, value = 40, max = 100, slider1 = 50, slider2 = 15, step = 1, mouseOverText = "Mouse-over test 1: With slider text", slider1MouseOverText = "Buy slider", slider2MouseOverText = "Sell slider" } }
	}
	addFlowchartEdge(nodeEnergy, nodeGraphene)
	addFlowchartEdge(nodeMethane, nodeGraphene)

	local nodeCoolant = { text = "Superfluid Coolant", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusText = "<!>", color = Helper.color.red },
		{ properties = { width = 250, value = 60, max = 100, slider1 = 75, slider2 = 100, step = 1, mouseOverText = "Mouse-over test 2: Without slider text" } }
	}
	addFlowchartEdge(nodeEnergy, nodeCoolant)
	addFlowchartEdge(nodeHelium, nodeCoolant)

	local nodeWafers = { text = "Silicon Wafers", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory" },
		{ properties = { width = 250, value = 15, max = 100, slider1 = 40, slider2 = 50, step = 1, slider1MouseOverText = "Mouse-over test 3: Buy slider", slider2MouseOverText = "Mouse-over test 3: Sell slider" } }
	}
	addFlowchartEdge(nodeEnergy, nodeWafers)
	addFlowchartEdge(nodeSilicon, nodeWafers)
	addFlowchartEdge(nodeHydrogen, nodeWafers)

	local nodeAntimatter = { text = "Antimatter Cells", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory", color = Helper.color.red },
		{ properties = { width = 250, value = 30, max = 100, slider2 = 45, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeAntimatter)
	addFlowchartEdge(nodeHydrogen, nodeAntimatter)

	local nodeTubes = { text = "Quantum Tubes", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory" },
		{ properties = { width = 250, value = 80, max = 100, slider2 = 50, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeTubes)
	addFlowchartEdge(nodeGraphene, nodeTubes)
	addFlowchartEdge(nodeCoolant, nodeTubes)

	local nodeMicrochips = { text = "Microchips", type = "container",
		{ properties = { shape = "stadium", width = 250 } },
		{ properties = { width = 250, value = 25, max = 100, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeMicrochips)
	addFlowchartEdge(nodeWafers, nodeMicrochips)

	local nodeClaytronics = { text = "Claytronics", type = "container",
		{ properties = { shape = "stadium", width = 250 } },
		{ properties = { width = 250, value = 10, max = 100, slider2 = 25, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeClaytronics)
	addFlowchartEdge(nodeTubes, nodeClaytronics)
	addFlowchartEdge(nodeMicrochips, nodeClaytronics)
	addFlowchartEdge(nodeAntimatter, nodeClaytronics)

	-- Workforce
	local nodeMedical = { text = "Medical Supplies", type = "container",
		{ properties = { width = 250, value = 60, max = 100, slider1 = 60, step = 1 } }
	}
	local nodeFood = { text = "Food Rations", type = "container",
		{ properties = { width = 250, value = 60, max = 100, slider1 = 60, step = 1 } }
	}
	local nodeWorkforce = { workforce = true, text = "Workforce", type = "container",
		{ properties = { shape = "hexagon", width = 270, value = 66, max = 100 }, statusText = "66%" }
	}
	addFlowchartEdge(nodeMedical, nodeWorkforce)
	addFlowchartEdge(nodeFood, nodeWorkforce)

	local nodes = { nodeEnergy, nodeMethane, nodeHelium, nodeGraphene, nodeCoolant, nodeTubes, nodeSilicon, nodeHydrogen, nodeWafers, nodeAntimatter, nodeMicrochips, nodeClaytronics, nodeMedical, nodeFood, nodeWorkforce }
	for _, node in ipairs(nodes) do
		for _, modulenode in ipairs(node) do
			modulenode.expandHandler = menu.onExpandDummy
			modulenode.collapseHandler = menu.onCollapseDummy
		end
	end
	local warenodes = { }
	return nodes, warenodes, nodeWorkforce
end

function menu.display()
	--print("Displaying Menu")

	-- remove old data
	Helper.clearDataForRefresh(menu)

	local framewidth = Helper.viewWidth
	local frameheight = Helper.viewHeight
	local xoffset = 0
	local yoffset = 0

	menu.sidebarWidth = Helper.scaleX(Helper.sidebarWidth)
	menu.rightBarX = Helper.viewWidth - menu.sidebarWidth - Helper.frameBorder

	menu.frame = Helper.createFrameHandle(menu, { layer = config.mainFrameLayer, height = frameheight, width = framewidth, x = xoffset, y = yoffset, backgroundID = "solid", backgroundColor = Helper.color.semitransparent })

	local usablewidth = menu.frame.properties.width - 2 * Helper.frameBorder

	local ftable, row
	local rowproperties = { bgColor = Helper.color.transparent }

	ftable = menu.frame:addTable(1, { tabOrder = 1, width = usablewidth, x = Helper.frameBorder })
	ftable:setDefaultCellProperties("text", { halign = "center" })

	row = ftable:addRow(false, rowproperties)
	row[1]:createText(menu.title, Helper.headerRow1Properties)
	row = ftable:addRow(false, rowproperties)
	row[1]:createText(menu.container and GetComponentData(menu.containerid, "name") or "Flowchart Test")
	--row = ftable:addRow(false, rowproperties)
	--row[1]:createText("Antigone Memorial")

	usablewidth = menu.rightBarX - Helper.borderSize - Helper.frameBorder 

	menu.flowchart = menu.frame:addFlowchart(menu.flowchartNumRows, menu.flowchartNumCols, { borderHeight = 3, borderColor = Helper.defaultSimpleBackgroundColor, minRowHeight = 45, minColWidth = 80, x = Helper.frameBorder, y = ftable:getVisibleHeight() + Helper.borderSize, width = usablewidth })
	menu.flowchart:setDefaultNodeProperties({
		expandedFrameLayer = config.expandedMenuFrameLayer,
		expandedTableNumColumns = 2,
		x = config.nodeoffsetx,
		width = config.nodewidth,
		statusBgIconRotating = true,
	})
	for col = 1, menu.flowchartNumCols, 1 do
		if col % 2 == (menu.startwithproduction and 1 or 0) then
			menu.flowchart:setColBackgroundColor(col, Helper.defaultSimpleBackgroundColor)
			menu.flowchart:setColumnCaption(col, ReadText(1001, 1600))
		else
			menu.flowchart:setColumnCaption(col, ReadText(1001, 1400))
		end
	end
	--menu.flowchart:setDefaultTextProperties({ fontsize = 8 })

	local containerSlotColor = Helper.defaultFlowchartConnector3Color
	local liquidSlotColor = Helper.defaultFlowchartConnector2Color
	local solidSlotColor = Helper.defaultFlowchartConnector1Color
	local condensateSlotColor = Helper.defaultFlowchartConnector4Color
	local containerProp = { sourceSlotColor = containerSlotColor, sourceSlotRank = 1, destSlotColor = containerSlotColor, destSlotRank = 1 }
	local liquidProp = { sourceSlotColor = liquidSlotColor, sourceSlotRank = 2, destSlotColor = liquidSlotColor, destSlotRank = 2 }
	local solidProp = { sourceSlotColor = solidSlotColor, sourceSlotRank = 3, destSlotColor = solidSlotColor, destSlotRank = 3 }
	local condensateProp = { sourceSlotColor = condensateSlotColor, sourceSlotRank = 1, destSlotColor = condensateSlotColor, destSlotRank = 1 }

	menu.productionnodes = { }
	menu.processingnodes = { }
	menu.researchnodes = { }
	menu.buildnodes = { }
	menu.storagenodes = { }
	menu.supplyresourcenodes = { }
	menu.terraformingnodes = { }
	menu.accountnodes = { }

	-- Production nodes
	for _, nodedata in ipairs(menu.flowchartNodes) do
		local nummodules = #nodedata
		for moduleidx, moduledata in ipairs(nodedata) do
			local row = nodedata.row + (moduleidx == nummodules and math.floor((math.max(1, nummodules - 1) - 1) / 2) or moduleidx - 1)
			local col = nodedata.col + (moduleidx > 1 and moduleidx == nummodules and 1 or 0)
			local node = menu.flowchart:addNode(row, col, { nodedata = nodedata, moduledata = moduledata }, moduledata.properties):setText(nodedata.text)
			if moduledata.color then
				node.properties.outlineColor = moduledata.color
				node.properties.text.color = moduledata.color
				node.properties.statusColor = moduledata.color
			end
			if moduledata.textcolor then
				node.properties.text.color = moduledata.textcolor
			end
			if moduledata.statuscolor then
				node.properties.statusColor = moduledata.statuscolor
			end
			if moduledata.statusText then
				node:setStatusText(moduledata.statusText)
			elseif moduledata.statusIcon then
				node:setStatusIcon(moduledata.statusIcon)
			end
			if moduledata.expandedFrameNumTables then
				node.properties.expandedFrameNumTables = moduledata.expandedFrameNumTables
			end
			if moduledata.expandedTableNumColumns then
				node.properties.expandedTableNumColumns = moduledata.expandedTableNumColumns
			end
			if moduledata.productionmodules then
				if moduledata.productionmodules.isprocessingmodule then
					table.insert(menu.processingnodes, node)
				else
					table.insert(menu.productionnodes, node)
				end
			end
			if moduledata.researchmodule then
				table.insert(menu.researchnodes, node)
			end
			if moduledata.buildmodule then
				table.insert(menu.buildnodes, node)
				if menu.restoreNodeBuildModule and menu.restoreNodeBuildModule == moduledata.buildmodule then
					menu.restoreNode = node
					menu.restoreNodeBuildModule = nil
				end
			end
			if moduledata.terraformingproject then
				table.insert(menu.terraformingnodes, node)
			end
			if moduledata.isstorage then
				table.insert(menu.storagenodes, node)
				if menu.restoreNodeWare and menu.restoreNodeWare == nodedata.ware then
					menu.restoreNode = node
					menu.restoreNodeWare = nil
				end
			end
			if moduledata.issupplyresource then
				table.insert(menu.supplyresourcenodes, node)
				if menu.restoreNodeSupplyWare and menu.restoreNodeSupplyWare == nodedata.ware then
					menu.restoreNode = node
					menu.restoreNodeSupplyWare = nil
				end
			end
			if nodedata.account then
				table.insert(menu.accountnodes, node)
			end
			if menu.restoreNodeSupply then
				if nodedata.drones and (menu.restoreNodeSupply == "drones") then
					menu.restoreNode = node
					menu.restoreNodeSupply = nil
				elseif nodedata.missiles and (menu.restoreNodeSupply == "missiles") then
					menu.restoreNode = node
					menu.restoreNodeSupply = nil
				end
			end
			node.handlers.onExpanded = menu.onFlowchartNodeExpanded
			node.handlers.onCollapsed = menu.onFlowchartNodeCollapsed
			if moduledata.sliderHandler then
				node.handlers.onSliderChanged = function (_, slideridx, value) return moduledata.sliderHandler(node, nodedata, slideridx, value) end
			end
			moduledata.node = node
		end
		if nummodules > 1 then
			local storagenode = nodedata[nummodules].node
			for moduleidx = 1, nummodules - 1 do
				local productionnode = nodedata[moduleidx].node
				local edgecolor = nodedata[moduleidx].color
				local edge = productionnode:addEdgeTo(storagenode, nodedata.type == "solid" and solidProp or (nodedata.type == "liquid" and liquidProp or containerProp))
				if edgecolor then
					edge.properties.color = edgecolor
				end
			end
		end
	end
	for _, junctiondata in ipairs(menu.flowchartJunctions) do
		junctiondata.junction = menu.flowchart:addJunction(junctiondata.row, junctiondata.col)
	end
	-- Production edges
	for _, nodedata in ipairs(menu.flowchartNodes) do
		if nodedata.predecessors then
			for predecessor, slot in pairs(nodedata.predecessors) do
				local predecessorcell = predecessor.junction or predecessor[#predecessor].node
				if nodedata.junction then
					predecessorcell:addEdgeTo(nodedata.junction, slot == 3 and solidProp or (slot == 2 and liquidProp or containerProp))
				else
					local nummodules = math.max(1, #nodedata - 1)
					for moduleidx = 1, nummodules do
						local destnode = nodedata[moduleidx].node
						local edgevalid = true
						if nodedata[moduleidx].resources then
							-- only link from predecessorcell to destnode if predecessorcell is a required resource
							local realpredecessor = predecessor
							while realpredecessor.junction do
								realpredecessor = next(realpredecessor.predecessors)
							end
							if not nodedata[moduleidx].resources[realpredecessor.ware] then
								edgevalid = false
							end
						end
						if edgevalid then
							local edgecolor = nodedata[moduleidx].color
							local edgeProperties = slot == 3 and solidProp or (slot == 2 and liquidProp or containerProp)
							if nodedata.condensateshield then
								edgeProperties = condensateProp
							end
							local edge = predecessorcell:addEdgeTo(destnode, edgeProperties)
							if edgecolor then
								edge.properties.color = edgecolor
							end
						end
					end
				end
			end
		end
	end
	for _, junctiondata in ipairs(menu.flowchartJunctions) do
		if junctiondata.predecessors then
			for predecessor, slot in pairs(junctiondata.predecessors) do
				local predecessorcell = predecessor.junction or predecessor[#predecessor].node
				predecessorcell:addEdgeTo(junctiondata.junction, slot == 3 and solidProp or (slot == 2 and liquidProp or containerProp))
			end
		end
	end

	-- Economy statistics
	-- title table
	titletable = menu.frame:addTable(5, { tabOrder = 5, width = usablewidth, x = Helper.frameBorder, y = 0, reserveScrollBar = false, skipTabChange = true })
	local title = string.format(ReadText(1001, 6500), GetComponentData(menu.containerid, "name"))
	local titlewidth = C.GetTextWidth(title, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)) + 2 * (Helper.headerRow1Offsetx + Helper.borderSize)
	local checkboxwidth = Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize
	titletable:setColWidth(2, checkboxwidth, false)
	titletable:setColWidth(3, titlewidth, false)
	titletable:setColWidth(4, checkboxwidth, false)

	row = titletable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(5):createText("")
	-- title
	row = titletable:addRow(true, { fixed = true, bgColor = Helper.color.transparent, borderBelow = false })
	row[2]:setBackgroundColSpan(2):createCheckBox(menu.showGraph, { height = checkboxwidth, scaling = false })
	row[2].handlers.onClick = menu.buttonShowGraph
	row[3]:createButton({ bgColor = Helper.color.transparent, height = Helper.headerRow1Height }):setText(title, { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety, halign = "center" })
	row[3].handlers.onClick = menu.buttonShowGraph
	if menu.showGraph then
		row = titletable:addRow(false, { fixed = true, bgColor = Helper.defaultSimpleBackgroundColor })
		row[1]:setColSpan(5):createText(" ", { fontsize = 1, height = 2 })
	end

	-- flowchart size
	if menu.showGraph then
		menu.flowchart.properties.maxVisibleHeight = math.floor((menu.frame:getAvailableHeight() - menu.flowchart.properties.y) / 2) - Helper.borderSize
	else
		menu.flowchart.properties.maxVisibleHeight = math.floor(menu.frame:getAvailableHeight() - menu.flowchart.properties.y) - Helper.borderSize - titletable:getFullHeight() - Helper.frameBorder
	end
	titletable.properties.y = menu.flowchart.properties.y + menu.flowchart.properties.maxVisibleHeight + Helper.borderSize

	if menu.showGraph then
		-- graph table
		local graphWidth = 4 * (usablewidth) / 5
		ftable = menu.frame:addTable(10, { tabOrder = 2, width = graphWidth, x = Helper.frameBorder, y = titletable.properties.y + titletable:getVisibleHeight() + Helper.borderSize, reserveScrollBar = false })
		for i = 2, 9 do
			ftable:setColWidthPercent(i, 7)
		end

		local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")
		local isplayerowned =			GetComponentData(menu.containerid, "isplayerowned")
		if not storageinfo_amounts then
			menu.graphmode = nil
		end
		if (menu.graphmode == "npcaccounts") and (not isplayerowned) then
			menu.graphmode = nil
		end

		-- mode buttons
		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[2]:setColSpan(2):createButton({ active = storageinfo_amounts, bgColor = (menu.graphmode == "tradeofferprices") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6504), { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonGraphMode("tradeofferprices") end
		row[4]:setColSpan(2):createButton({ active = storageinfo_amounts, bgColor = (menu.graphmode == "tradeofferamounts") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6508), { halign = "center" })
		row[4].handlers.onClick = function () return menu.buttonGraphMode("tradeofferamounts") end
		row[6]:setColSpan(2):createButton({ active = storageinfo_amounts, bgColor = (menu.graphmode == "cargolevels") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6505), { halign = "center" })
		row[6].handlers.onClick = function () return menu.buttonGraphMode("cargolevels") end
		row[8]:setColSpan(2):createButton({ active = isplayerowned, bgColor = (menu.graphmode == "npcaccounts") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6506), { halign = "center" })
		row[8].handlers.onClick = function () return menu.buttonGraphMode("npcaccounts") end
		local buttonHeight = row:getHeight()
		-- graph cell
		row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	
		local minY, maxY = 0, 1
		local datarecords = {}
		local hashighlight = false
		for i, entry in pairs(menu.showndata) do
			if menu.selectedrowdata == entry then
				hashighlight = true
				break
			end
		end
		for i, entry in pairs(menu.showndata) do
			if menu.graphmode == "cargolevels" then
				local data = {}
				for i, point in pairs(menu.graphdata[entry].data) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					table.insert(data, Helper.createGraphDataPoint((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil))
				end

				local highlight = menu.selectedrowdata == entry
				local color = { r = config.graph.datarecordcolors[i].buy.r, g = config.graph.datarecordcolors[i].buy.g, b = config.graph.datarecordcolors[i].buy.b, a = config.graph.datarecordcolors[i].buy.a }
				if hashighlight and (not highlight) then
					color.a = 50
				end
				table.insert(datarecords, Helper.createGraphDataRecord(config.graph.point.type, highlight and config.graph.point.highlightSize or config.graph.point.size, color, config.graph.line.type, highlight and config.graph.line.highlightSize or config.graph.line.size, color, data, false, menu.graphdata[entry].text))
			elseif (menu.graphmode == "tradeofferprices") or (menu.graphmode == "tradeofferamounts") then
				local data = {}
				for i, point in pairs(menu.graphdata[entry].selldata) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					table.insert(data, Helper.createGraphDataPoint((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil))
				end

				local highlight = menu.selectedrowdata == entry
				local color = { r = config.graph.datarecordcolors[i].sell.r, g = config.graph.datarecordcolors[i].sell.g, b = config.graph.datarecordcolors[i].sell.b, a = config.graph.datarecordcolors[i].sell.a }
				if hashighlight and (not highlight) then
					color.a = 50
				end
				if #data > 0 then
					table.insert(datarecords, Helper.createGraphDataRecord(config.graph.point.type, highlight and config.graph.point.highlightSize or config.graph.point.size, color, config.graph.line.type, highlight and config.graph.line.highlightSize or config.graph.line.size, color, data, false, ReadText(1001, 2917) .. ReadText(1001, 120) .. " " .. menu.graphdata[entry].text))
				end

				data = {}
				for i, point in pairs(menu.graphdata[entry].buydata) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					table.insert(data, Helper.createGraphDataPoint((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil))
				end

				local highlight = menu.selectedrowdata == entry
				local color = { r = config.graph.datarecordcolors[i].buy.r, g = config.graph.datarecordcolors[i].buy.g, b = config.graph.datarecordcolors[i].buy.b, a = config.graph.datarecordcolors[i].buy.a }
				if hashighlight and (not highlight) then
					color.a = 50
				end
				if #data > 0 then
					table.insert(datarecords, Helper.createGraphDataRecord(config.graph.point.type, highlight and config.graph.point.highlightSize or config.graph.point.size, color, config.graph.line.type, highlight and config.graph.line.highlightSize or config.graph.line.size, color, data, false, ReadText(1001, 2916) .. ReadText(1001, 120) .. " " .. menu.graphdata[entry].text))
				end
			elseif menu.graphmode == "npcaccounts" then
				local data = {}
				for i, point in pairs(menu.graphdata[entry].data) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					table.insert(data, Helper.createGraphDataPoint((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil))
				end

				local highlight = menu.selectedrowdata == entry
				local color = { r = config.graph.datarecordcolors[i].buy.r, g = config.graph.datarecordcolors[i].buy.g, b = config.graph.datarecordcolors[i].buy.b, a = config.graph.datarecordcolors[i].buy.a }
				if hashighlight and (not highlight) then
					color.a = 50
				end
				table.insert(datarecords, Helper.createGraphDataRecord(config.graph.point.type, highlight and config.graph.point.highlightSize or config.graph.point.size, color, config.graph.line.type, highlight and config.graph.line.highlightSize or config.graph.line.size, color, data, false, menu.graphdata[entry].text))
			end
		end

		local mingranularity = maxY / 12
		local maxgranularity = maxY / 8
		local granularity = 0.1
		for _, factor in ipairs(config.graph.factors) do
			local testgranularity = math.ceil(mingranularity / factor) * factor
			if testgranularity >= maxgranularity then
				break;
			end
			granularity = testgranularity
		end
		maxY = (math.ceil(maxY / granularity) + 0.5) * granularity

		local xRange = (menu.xEnd - menu.xStart) / menu.xScale
		local xGranularity = Helper.round(menu.xGranularity / menu.xScale, 3)
		local xOffset = xRange % xGranularity

		local xaxis = Helper.createGraphAxis(Helper.createGraphText(menu.xTitle, Helper.standardFont, 9, menu.white), -xRange, 0, xGranularity, xOffset, true, menu.white, {r = 96, g = 96, b = 96, a = 80})
		local yaxis = Helper.createGraphAxis(Helper.createGraphText(menu.yTitle, Helper.standardFont, 9, menu.white), 0, maxY, granularity, 0, true, menu.white, {r = 96, g = 96, b = 96, a = 80})

		-- graph
		row[1]:setColSpan(10):createGraph("line", true, Helper.color.semitransparent, nil, xaxis, yaxis, datarecords, 0, 0, nil, menu.frame.properties.height - menu.frame:getUsedHeight() - 2 * buttonHeight - 3 * Helper.borderSize)
		-- time interval buttons
		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[3]:setColSpan(2):createButton({ bgColor = (menu.timeframe == "hour") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6501), { halign = "center" })
		row[3].handlers.onClick = function () return menu.buttonTimeFrame("hour") end
		row[5]:setColSpan(2):createButton({ bgColor = (menu.timeframe == "day") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6502), { halign = "center" })
		row[5].handlers.onClick = function () return menu.buttonTimeFrame("day") end
		row[7]:setColSpan(2):createButton({ bgColor = (menu.timeframe == "week") and Helper.defaultArrowRowBackgroundColor or Helper.defaultTitleBackgroundColor }):setText(ReadText(1001, 6503), { halign = "center" })
		row[7].handlers.onClick = function () return menu.buttonTimeFrame("week") end

		-- key table
		menu.keyTable = menu.frame:addTable(5, { tabOrder = 3, width = usablewidth - graphWidth - Helper.borderSize, x = Helper.frameBorder + graphWidth + Helper.borderSize, y = titletable.properties.y + titletable:getVisibleHeight() + Helper.borderSize })
		menu.keyTable:setColWidth(1, Helper.standardTextHeight)
		menu.keyTable:setColWidthPercent(3, 30)
		menu.keyTable:setColWidth(4, 1.5 * Helper.standardTextHeight)
		menu.keyTable:setColWidth(5, Helper.standardTextHeight)
		-- keys
		row = menu.keyTable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 6523), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"
		for i = 1, config.graph.maxshowndata do
			local entry = menu.showndata[i]
			local color1 = config.graph.datarecordcolors[i].sell
			local color2 = config.graph.datarecordcolors[i].buy
			local data = menu.graphdata[entry]
			if entry then
				if (menu.graphmode == "cargolevels") or (menu.graphmode == "npcaccounts") then
					row = menu.keyTable:addRow(entry, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(3):createText(data.text, { minRowHeight = 2 * Helper.standardTextHeight + Helper.borderSize })
					row[4]:createText(config.graph.datarecordcolors[i].buyhex .. "\27[solid]", { y = Helper.borderSize / 2 })
					row[5]:createButton({ height = 2 * Helper.standardTextHeight + Helper.borderSize }):setText("X", { halign = "center" })
					row[5].handlers.onClick = function () return menu.checkboxSelected(entry, row.index, 0) end
				elseif (menu.graphmode == "tradeofferprices") or (menu.graphmode == "tradeofferamounts") then
					row = menu.keyTable:addRow(entry, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(2):createText(data.text, { minRowHeight = 2 * Helper.standardTextHeight + Helper.borderSize })
					row[3]:createText(ReadText(1001, 8309) .. ReadText(1001, 120) .. "\n" .. ReadText(1001, 8308) .. ReadText(1001, 120))
					row[4]:createText(config.graph.datarecordcolors[i].buyhex .. "\27[solid]\n" .. config.graph.datarecordcolors[i].sellhex .. "\27[solid]", { y = Helper.borderSize })
					row[5]:createButton({ height = 2 * Helper.standardTextHeight + Helper.borderSize }):setText("X", { halign = "center" })
					row[5].handlers.onClick = function () return menu.checkboxSelected(entry, row.index, 0) end
				end
			else
				row = menu.keyTable:addRow(false, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(5):createText("---", { minRowHeight = 2 * Helper.standardTextHeight + Helper.borderSize })
			end
		end
		-- data
		local row = menu.keyTable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(ReadText(1001, 6507), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"
		if storageinfo_amounts and ((menu.graphmode ~= "npcaccounts") or isplayerowned) then
			if menu.graphmode then
				if #menu.graphdata > 0 then
					--[[ No ware groups in X4 for now
					if menu.graphmode ~= "npcaccounts" then
						for i, group in ipairs(menu.groupedgraphdata) do
							local isextended = menu.isGroupExpanded(group.id)
							row = menu.keyTable:addRow(true, { bgColor = Helper.color.transparent })
							row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
							row[1].handlers.onClick = function () return menu.buttonExtend(group.id, row.index) end
							row[2]:setColSpan(4):createText(group.name)
							if isextended then
								for j, dataIdx in ipairs(group) do
									local data = menu.graphdata[dataIdx]
									local row = menu.keyTable:addRow(true, { bgColor = Helper.color.transparent })
									row[1]:createCheckBox(data.shown, { height = Helper.standardTextHeight, active = data.shown or (menu.numshowndata < config.graph.maxshowndata), mouseOverText = (data.shown or (menu.numshowndata < config.graph.maxshowndata)) and "" or ReadText(1026, 6500) })
									row[1].handlers.onClick = function () return menu.checkboxSelected(dataIdx, row.index, 1) end
									row[2]:setColSpan(4):createText(data.text)
								end
							end
						end
					else--]]
						for dataIdx, data in ipairs(menu.graphdata) do
							local row = menu.keyTable:addRow(dataIdx, { bgColor = Helper.color.transparent })
							row[1]:createCheckBox(data.shown, { height = Helper.standardTextHeight, active = data.shown or (menu.numshowndata < config.graph.maxshowndata), mouseOverText = (data.shown or (menu.numshowndata < config.graph.maxshowndata)) and "" or ReadText(1026, 6500) })
							row[1].handlers.onClick = function () return menu.checkboxSelected(dataIdx, row.index, 1) end
							row[2]:setColSpan(4):createText(data.text)
						end
					--end
				else
					local row = menu.keyTable:addRow(dataIdx, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(5):createText(ReadText(1001, 6524))
				end
			else
				local row = menu.keyTable:addRow(dataIdx, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(5):createText(ReadText(1001, 6525))
			end
		else
			local row = menu.keyTable:addRow(dataIdx, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText(ReadText(1001, 6526))
		end
		
		menu.restoreTableState("keyTable", menu.keyTable)
	end

	menu.restoreFlowchartState("flowchart", menu.flowchart)

	Helper.createRightSideBar(menu.frame, menu.container, true, "logical", menu.buttonRightBar)

	-- display view/frame
	menu.frame:display()
end

function menu.isOptionSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedOptions) do
		if not menu.contextMenuData.origSelectedOptions[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedOptions) do
		if not menu.contextMenuData.selectedOptions[ware] then
			return true
		end
	end
	return false
end

function menu.onFlowchartNodeExpanded(node, frame, ftable, ftable2)
	node.flowchart:collapseAllNodes()
	local data = node.customdata
	local expandHandler = data.moduledata.expandHandler
	if expandHandler then
		menu.expandedNode = node
		menu.expandedMenuFrame = frame
		menu.expandedMenuTable = ftable
		expandHandler(frame, ftable, ftable2, data.nodedata, data.moduledata.productionmodules or data.moduledata.buildmodule or data.moduledata.researchmodule or data.moduledata.terraformingproject)
	end
end

function menu.onExpandTradeWares(frame, ftable, ftable2, nodedata)
	ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidthPercent(3, 50)
	ftable2:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable2:setColWidthPercent(3, 50)

	-- kuertee start: callback
	if callbacks ["onExpandTradeWares_on_start"] then
		for _, callback in ipairs (callbacks ["onExpandTradeWares_on_start"]) do
			callback ()
		end
	end
	-- kuertee end: callback

	local excludedwares = {}, {}
	menu.selectedWares, menu.origSelectedWares = {}, {}
	local allresources, allproducts, cargo, rawtradewares = GetComponentData(menu.containerid, "allresources", "products", "cargo", "tradewares")
	for _, ware in ipairs(allresources) do
		excludedwares[ware] = true
	end
	for _, ware in ipairs(allproducts) do
		excludedwares[ware] = true
	end
	for ware in pairs(cargo) do
		excludedwares[ware] = true
	end
	for _, ware in ipairs(rawtradewares) do
		menu.origSelectedWares[ware] = true
		menu.selectedWares[ware] = true
	end

	local allwares = {}
	local n = C.GetNumWares("economy", false, "", "")
	local buf = ffi.new("const char*[?]", n)
	n = C.GetWares(buf, n, "economy", false, "", "")
	for i = 0, n - 1 do
		local ware = ffi.string(buf[i])
		if not excludedwares[ware] then

			-- kuertee start: callback
			if (not callbacks ["onExpandTradeWares_insert_ware_to_allwares"]) or (not #callbacks ["onExpandTradeWares_insert_ware_to_allwares"]) then
				table.insert(allwares, { ware = ware, name = GetWareData(ware, "name") })
			elseif callbacks ["onExpandTradeWares_insert_ware_to_allwares"] then
				for _, callback in ipairs (callbacks ["onExpandTradeWares_insert_ware_to_allwares"]) do
					callback (allwares, ware)
				end
			end
			-- kuertee end: callback

		end
	end
	table.sort(allwares, Helper.sortName)

	for _, entry in ipairs(allwares) do
		local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:createCheckBox(menu.selectedWares[entry.ware], { width = Helper.standardButtonHeight, height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function (_, checked) if checked then menu.selectedWares[entry.ware] = true else menu.selectedWares[entry.ware] = nil end end
		row[2]:setColSpan(2):createText(entry.name)
	end
	local row = ftable2:addRow(true, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createButton({ active = function () return not menu.compareTradeWareSelection() end }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.setTradeWares
	row[3]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[3].handlers.onClick = function () return menu.expandedNode:collapse() end

	local buttontableheight = ftable2:getFullHeight()
	local maxVisibleHeight = ftable:getFullHeight()
	if maxVisibleHeight + buttontableheight + Helper.borderSize > frame.properties.height then
		maxVisibleHeight = frame.properties.height - buttontableheight - Helper.borderSize
		ftable.properties.maxVisibleHeight = maxVisibleHeight
	end
	ftable2.properties.y = maxVisibleHeight + Helper.borderSize
end

function menu.onExpandSupplyResource(_, ftable, _, nodedata)
	local storageinfo_capacity =	C.IsInfoUnlockedForPlayer(menu.container, "storage_capacity")
	local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	local row
	-- storage
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 2415) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(ReadText(1001, 11018), { halign = "right" })
	if C.IsComponentClass(menu.container, "container") then
		-- amount
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 6521) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(
			function()
				local amount = menu.getSupplyResourceValue(nodedata.ware)
				local limit = menu.getSupplyResourceMax(nodedata.ware, true)
				return string.format("%s / %s", Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(amount, true, 3, true, true)), Helper.unlockInfo(storageinfo_capacity, ConvertIntegerString(limit, true, 3, true, true)))
			end,
			{ halign = "right" }
		)
		if GetComponentData(menu.containerid, "isplayerowned") then
			-- buy offer
			-- title
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 8309), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			-- automatic pricing
			local row = ftable:addRow("autobuypricecheckbox", { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
			local avgprice, maxprice = GetWareData(nodedata.ware, "avgprice", "maxprice")
			row[2]:setColSpan(2):createText(RoundTotalTradePrice((avgprice + maxprice) / 2) .. " " .. ReadText(1001, 101), { halign = "right" })

			-- trade rule
			local hasownlist = C.HasContainerOwnTradeRule(menu.container, "supply", nodedata.ware)
			local traderuleid = C.GetContainerTradeRuleID(menu.container, "supply", nodedata.ware)
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
			-- global
			local row = ftable:addRow("supplytraderule_global", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 11025) .. ReadText(1001, 120), textproperties)
			row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
			row[3].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.container, "supply", nodedata.ware, checked) end
			-- current
			local row = ftable:addRow("supplytraderule_current", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.container, "supply", nodedata.ware, id) end
			row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
			row[3].handlers.onClick = menu.buttonEditTradeRule
		end
	end

	if menu.selectedRowData["nodeTable"] then
		menu.selectedCols["nodeTable"] = nil
	end
	menu.restoreTableState("nodeTable", ftable)
end

function menu.compareTradeWareSelection()
	local tradewares = Helper.tableCopy(menu.origSelectedWares)
	for ware in pairs(menu.selectedWares) do
		if not tradewares[ware] then
			return false
		else
			tradewares[ware] = nil
		end
	end
	return next(tradewares) == nil
end

function menu.setTradeWares()	
	local tradewares = Helper.tableCopy(menu.origSelectedWares)
	for ware in pairs(menu.selectedWares) do
		if not tradewares[ware] then
			-- add
			C.AddTradeWare(menu.container, ware)
		else
			-- nothing to do
			tradewares[ware] = nil
		end
	end
	for ware in pairs(tradewares) do
		-- remove
		C.ClearContainerBuyLimitOverride(menu.container, ware)
		C.SetContainerWareIsBuyable(menu.container, ware, false)
		ClearContainerWarePriceOverride(menu.containerid, ware, true)

		C.ClearContainerSellLimitOverride(menu.container, ware)
		C.SetContainerWareIsSellable(menu.container, ware, false)
		ClearContainerWarePriceOverride(menu.containerid, ware, false)

		ClearContainerStockLimitOverride(menu.containerid, ware)
		C.RemoveTradeWare(menu.container, ware)
	end

	menu.setupFlowchartData()
	menu.refresh = true
	menu.expandedNode:collapse()
end

function menu.onExpandProduction(_, ftable, _, nodedata, productionmodules)
	local productioninfo_products, productioninfo_rate, productioninfo_resources
	local isplayerowned = GetComponentData(menu.containerid, "isplayerowned")
	if isplayerowned then
		productioninfo_products, productioninfo_rate, productioninfo_resources = true, true, true
	end

	local nostorage, noresources, hacked, nonfunctional, destroyed, plannedremoval, planned, producing, paused, realpaused, queued = 0, 0, 0, 0, #productionmodules.destroyedcomponents, 0, productionmodules.numplanned, 0, 0, 0, 0
	local sunlight, workforce, hullefficiency
	for _, module in ipairs(productionmodules.components) do
		if not IsComponentConstruction(module) then
			productioninfo_products		= productioninfo_products	or C.IsInfoUnlockedForPlayer(module, "production_products")
			productioninfo_rate			= productioninfo_rate		or C.IsInfoUnlockedForPlayer(module, "production_rate")
			productioninfo_resources	= productioninfo_resources	or C.IsInfoUnlockedForPlayer(module, "production_resources")

			local proddata = GetProductionModuleData(module)
			if proddata.state ~= "empty" then
				hullefficiency = hullefficiency or proddata.efficiency.efficiency
				sunlight = sunlight or proddata.efficiency.sunlight
				workforce = workforce or proddata.efficiency.work
			end
			local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")

			local isqueued = true
			if proddata.state ~= "empty" then
				for _, product in ipairs(proddata.products) do
					if product.ware == nodedata.ware then
						isqueued = false
						break
					end
				end
			end

			if menu.removedModules[tostring(module)] then
				plannedremoval = plannedremoval + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ishacked then
				hacked = hacked + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ispausedmanually then
				paused = paused + 1
				realpaused = realpaused + 1
			elseif not isfunctional then
				nonfunctional = nonfunctional + 1
			elseif (proddata.state == "choosingitem") or (proddata.state == "waitingforstorage") then
				nostorage = nostorage + 1
			elseif proddata.state == "waitingforresources" then
				noresources = noresources + 1
			elseif isqueued then
				queued = queued + 1
			else
				producing = producing + 1
			end
		else
			plannedremoval = plannedremoval + 1
		end
	end

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidthPercent(3, 10)
	local row
	if productioninfo_rate then
		-- status
		local shown = false
		if destroyed > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8428) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(destroyed, { halign = "right", color = Helper.color.red })
		end
		if nonfunctional > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8429) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(nonfunctional, { halign = "right", color = Helper.color.red })
		end
		if hacked > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8430) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(hacked, { halign = "right", color = Helper.color.red })
		end
		if paused > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8448) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.warningorange })
			row[3]:createText(paused, { halign = "right", color = Helper.color.warningorange })
		end
		if queued > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8469) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.warningorange })
			row[3]:createText(queued, { halign = "right", color = Helper.color.warningorange })
		end
		if noresources > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8431) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(noresources, { halign = "right", color = Helper.color.red })
		end
		if nostorage > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8432) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.warningorange })
			row[3]:createText(nostorage, { halign = "right", color = Helper.color.warningorange })
		end
		if planned > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8433) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(planned, { halign = "right" })
		end
		if plannedremoval > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8434) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(plannedremoval, { halign = "right" })
		end
		if shown then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("")
		end
	end

	-- Pause
	if isplayerowned and (#productionmodules.components > 0) then
		row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		local allpaused = #productionmodules.components == realpaused
		row[1]:setColSpan(3):createButton({  }):setText(allpaused and ReadText(1001, 8450) or ReadText(1001, 8449), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonPauseProductionModules(productionmodules.components, not allpaused) end
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")
	end

	-- efficiency
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 1602) .. ReadText(1001, 120), { wordwrap = true })
	row[2]:setColSpan(2):createText(function() return menu.getProductionEfficiency(productionmodules.components) end, { halign = "right" })
	-- workforce
	if workforce then
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText("   " .. ReadText(1001, 9415) .. ReadText(1001, 120), { wordwrap = true })
		row[2]:setColSpan(2):createText(function() return menu.getProductionWorkforceEfficiency(productionmodules.components) end, { halign = "right" })
	end
	-- hull damage
	if hullefficiency then
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText("   " .. ReadText(1001, 8468) .. ReadText(1001, 120), { wordwrap = true })
		row[2]:setColSpan(2):createText(function() return menu.getProductionHullEfficiency(productionmodules.components) end, { halign = "right" })
	end
	-- sunlight
	if sunlight then
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText("   " .. ReadText(1001, 2412) .. ReadText(1001, 120), { wordwrap = true })
		row[2]:setColSpan(2):createText(sunlight.sunlight * 100 .. " %", { halign = "right" })
	end
	-- bonus products
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(1001, 8461) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120), { wordwrap = true })
	row[2]:setColSpan(2):createText(function() return menu.getProductionEfficiencyProducts(nodedata.ware, productionmodules.macro, producing) end, { halign = "right" })
	-- remaining cycle time
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 8435) .. ReadText(1001, 120), { wordwrap = true })
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(function() return menu.getProductionCycleTime(productionmodules.components) end, { halign = "right" })
	-- resource remaining time
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 8409) .. ReadText(1001, 120), { wordwrap = true })
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(function() return menu.getProductionRemainingTime(nodedata.ware, productionmodules.components, productionmodules.macro) end, { halign = "right" })
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText("")

	local macrodata = GetLibraryEntry(GetMacroData(productionmodules.macro, "infolibrary"), productionmodules.macro)
	local queueduration = 0
	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == nodedata.ware then
			proddata = entry
		end
		queueduration = queueduration + entry.cycle
	end

	if proddata then
		local product = proddata.ware
		local baseamount = (queueduration > 0) and Helper.round(proddata.amount * 3600 / queueduration) or 0
		local currentamount = C.GetContainerWareProduction(menu.container, product, false)
		-- factor
		local factor = menu.showSingleProduction[productionmodules.macro] and 1 or producing
		row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 8462) .. ReadText(1001, 120))
		row[3]:createCheckBox(menu.showSingleProduction[productionmodules.macro], { width = Helper.standardButtonHeight, height = Helper.standardButtonHeight, active = (producing ~= 1) or (baseamount ~= currentamount) })
		row[3].handlers.onClick = function (_, checked) return menu.checkboxProductionSingle(productionmodules.macro, checked) end
		-- product
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 1624) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText("   " .. Helper.unlockInfo(productioninfo_products, GetWareData(product, "name")))
		local amount = menu.showSingleProduction[productionmodules.macro] and baseamount or currentamount
		row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(amount, true, 0, true, false)), { halign = "right" })
		-- resources
		if #proddata.resources > 0 then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			for _, resourcedata in ipairs(proddata.resources) do
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				local amount = menu.showSingleProduction[productionmodules.macro] and ((queueduration > 0) and Helper.round(factor * resourcedata.amount * 3600 / queueduration) or 0) or C.GetContainerWareConsumptionPerProduct(menu.container, resourcedata.ware, product, false)
				row[1]:createText("   " .. Helper.unlockInfo(productioninfo_resources, GetWareData(resourcedata.ware, "name")))
				row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(amount, true, 0, true, false)), { halign = "right" })
			end
		else
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("   ---")
		end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.onExpandProcessing(_, ftable, _, nodedata, processingmodules)
	local productioninfo_products, productioninfo_rate, productioninfo_resources
	local isplayerowned = GetComponentData(menu.containerid, "isplayerowned")
	if isplayerowned then
		productioninfo_products, productioninfo_rate, productioninfo_resources = true, true, true
	end

	local macrodata = GetLibraryEntry(GetMacroData(processingmodules.macro, "infolibrary"), processingmodules.macro)
	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == nodedata.ware then
			proddata = entry
		end
	end

	local wares = ffi.new("UIWareAmount[?]", 1)
	wares[0].wareid = Helper.ffiNewString(nodedata.ware)
	wares[0].amount = proddata and proddata.amount or 1
	local isstoragefull = not C.AreWaresWithinContainerProductionLimits(menu.container, wares, 1)

	local rawproducts, rawresources = {}, {}
	local nostorage, noresources, hacked, nonfunctional, destroyed, plannedremoval, planned, producing, realpaused = 0, 0, 0, 0, #processingmodules.destroyedcomponents, 0, processingmodules.numplanned, 0, 0
	for _, module in ipairs(processingmodules.components) do
		local data = GetProcessingModuleData(module)
		if not IsComponentConstruction(module) then
			productioninfo_products		= productioninfo_products	or C.IsInfoUnlockedForPlayer(module, "production_products")
			productioninfo_rate			= productioninfo_rate		or C.IsInfoUnlockedForPlayer(module, "production_rate")
			productioninfo_resources	= productioninfo_resources	or C.IsInfoUnlockedForPlayer(module, "production_resources")

			local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")

			if menu.removedModules[tostring(module)] then
				plannedremoval = plannedremoval + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ishacked then
				hacked = hacked + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ispausedmanually then
				realpaused = realpaused + 1
			elseif not isfunctional then
				nonfunctional = nonfunctional + 1
			elseif data.state == "waitingforstorage" then
				nostorage = nostorage + 1
			elseif data.state == "waitingforresources" then
				noresources = noresources + 1
			else
				producing = producing + 1

				for _, entry in ipairs(data.products) do
					rawproducts[entry.ware] = (rawproducts[entry.ware] or 0) + entry.amountperhour
				end
				for _, entry in ipairs(data.resources) do
					rawresources[entry.ware] = (rawresources[entry.ware] or 0) + entry.amountperhour
				end
			end
		else
			plannedremoval = plannedremoval + 1
		end
	end
	local products, resources = {}, {}
	for ware, amount in pairs(rawproducts) do
		table.insert(products, { ware = ware, amount = amount, name = GetWareData(ware, "name") })
	end
	table.sort(products, Helper.sortName)
	for ware, amount in pairs(rawresources) do
		table.insert(resources, { ware = ware, amount = amount, name = GetWareData(ware, "name") })
	end
	table.sort(resources, Helper.sortName)

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidthPercent(3, 10)
	local row
	if productioninfo_rate then
		-- status
		local shown = false
		if destroyed > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8428) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(destroyed, { halign = "right", color = Helper.color.red })
		end
		if nonfunctional > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8429) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(nonfunctional, { halign = "right", color = Helper.color.red })
		end
		if hacked > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8430) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(hacked, { halign = "right", color = Helper.color.red })
		end
		if noresources > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8431) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.red })
			row[3]:createText(noresources, { halign = "right", color = Helper.color.red })
		end
		if nostorage > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8432) .. ReadText(1001, 120), { wordwrap = true, color = Helper.color.warningorange })
			row[3]:createText(nostorage, { halign = "right", color = Helper.color.warningorange })
		end
		if planned > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8433) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(planned, { halign = "right" })
		end
		if plannedremoval > 0 then
			shown = true
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8434) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(plannedremoval, { halign = "right" })
		end
		if shown then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("")
		end
	end

	-- Pause
	if isplayerowned and (#processingmodules.components > 0) then
		row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		local allpaused = #processingmodules.components == realpaused
		row[1]:setColSpan(3):createButton({  }):setText(allpaused and ReadText(1001, 8450) or ReadText(1001, 8449), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonPauseProcessingModules(processingmodules.components, not allpaused) end
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")
	end

	-- remaining cycle time
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(ReadText(1001, 8435) .. ReadText(1001, 120), { wordwrap = true })
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(3):createText(function() return menu.getProcessingCycleTime(processingmodules.components) end, { halign = "right" })

	if next(products) then
		-- product
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 1624) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
		for _, entry in ipairs(products) do
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:createText("   " .. Helper.unlockInfo(productioninfo_products, GetWareData(entry.ware, "name")))
			row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(entry.amount, true, 0, true, false)), { halign = "right" })
		end
		-- resources
		if #resources > 0 then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			for _, entry in ipairs(resources) do
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:createText("   " .. Helper.unlockInfo(productioninfo_resources, GetWareData(entry.ware, "name")))
				row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(entry.amount, true, 0, true, false)), { halign = "right" })
			end
		else
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("   ---")
		end
	elseif proddata then
		-- product
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 1624) .. ReadText(1001, 120))
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText("   " .. Helper.unlockInfo(productioninfo_products, GetWareData(proddata.ware, "name")))
		row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(proddata.amount, true, 0, true, false)), { halign = "right" })
		-- resources
		if #proddata.resources > 0 then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. ReadText(1001, 120))
			for _, resourcedata in ipairs(proddata.resources) do
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:createText("   " .. Helper.unlockInfo(productioninfo_resources, GetWareData(resourcedata.ware, "name")))
				row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(resourcedata.amount, true, 0, true, false)), { halign = "right" })
			end
		else
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. ReadText(1001, 120))
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("   ---")
		end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.getProductionEfficiency(modules)
	local efficiency, numproducing = 0, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_rate") then
					efficiency = efficiency + proddata.products.efficiency
				end
			end
		end
	end
	if numproducing > 0 then
		if efficiency > 0 then
			return Helper.round(efficiency / numproducing, 2) * 100 .. " %"
		else
			return ReadText(1001, 3210)
		end
	end
	return "- %"
end

function menu.getProductionEfficiencyProducts(ware, macro, producing)
	if producing > 0 then
		local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
		local proddata
		local queueduration = 0
		for _, entry in ipairs(macrodata.products) do
			if entry.ware == ware then
				proddata = entry
			end
			queueduration = queueduration + entry.cycle
		end

		if proddata then
			local product = proddata.ware
			local currentproduction = C.GetContainerWareProduction(menu.container, product, false)
			local baseproduction = (queueduration > 0) and (Helper.round(proddata.amount * 3600 / queueduration) * producing) or 0
			local diff = currentproduction - baseproduction
			return string.format("%s%d", (diff > 0) and "\27G+" or ((diff < 0) and "\27R" or ""), diff)
		else
			return "-"
		end
	else
		return "-"
	end
end

function menu.getProductionWorkforceEfficiency(modules)
	local efficiency, numproducing, unlocked = 0, 0, false
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_rate") then
					unlocked = true
					efficiency = efficiency + proddata.efficiency.work.workforce * proddata.efficiency.work.product
				end
			end
		end
	end
	if numproducing > 0 then
		if not unlocked then
			return ReadText(1001, 3210)
		elseif efficiency > 0 then
			return Helper.round(1 + (efficiency / numproducing), 2) * 100 .. " %"
		end
	end
	return "- %"
end

function menu.getProductionHullEfficiency(modules)
	local efficiency, numproducing, unlocked = 0, 0, false
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_rate") then
					unlocked = true
					efficiency = efficiency + proddata.efficiency.efficiency.product
				end
			end
		end
	end
	if numproducing > 0 then
		if not unlocked then
			return ReadText(1001, 3210)
		elseif efficiency > 0 then
			return math.floor((efficiency / numproducing) * 100) .. " %"
		end
	end
	return "- %"
end

function menu.getProductionCycleTime(modules)
	local cycle, numproducing = nil, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_time") then
					if cycle then
						cycle = math.min(cycle, proddata.remainingcycletime)
					else
						cycle = proddata.remainingcycletime
					end
				end
			end
		end
	end
	if numproducing > 0 then
		if cycle then
			return ConvertTimeString(cycle)
		else
			return ReadText(1001, 3210)
		end
	end
	return "-"
end

function menu.getProductionRemainingTime(ware, modules, macro)
	local storageinfo_amounts = C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")
	local remainingtime, numproducing = nil, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProductionModuleData(module)
			if proddata.state ~= "empty" then
				local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
				local isqueued = true
				for _, product in ipairs(proddata.products) do
					if product.ware == ware then
						isqueued = false
						break
					end
				end
				if (not ishacked) and isfunctional and (proddata.state == "producing") and (not isqueued) then
					numproducing = numproducing + 1
					if storageinfo_amounts then
						if remainingtime then
							remainingtime = math.max(remainingtime, proddata.remainingtime)
						else
							remainingtime = proddata.remainingtime
						end
					end
				end
			end
		end
	end
	if numproducing > 0 then
		if remainingtime then
			if remainingtime == 0 then
				return utf8.char(8734)
			else
				local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
				local proddata
				for _, entry in ipairs(macrodata.products) do
					if entry.ware == ware then
						proddata = entry
						break
					end
				end
				if remainingtime < 2 * proddata.cycle then
					-- if we only have enough resources for one more production cycle, we don't need to consider the number of production modules
					return ConvertTimeString(remainingtime)
				else
					return ConvertTimeString(remainingtime / numproducing)
				end
			end
		else
			return ReadText(1001, 3210)
		end
	end
	return "-"
end

function menu.getProcessingCycleTime(modules)
	local cycle, numprocessing = nil, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProcessingModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "processing") then
				numprocessing = numprocessing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_time") then
					if cycle then
						cycle = math.min(cycle, proddata.remainingcycletime)
					else
						cycle = proddata.remainingcycletime
					end
				end
			end
		end
	end
	if numprocessing > 0 then
		if cycle then
			return ConvertTimeString(cycle)
		else
			return ReadText(1001, 3210)
		end
	end
	return "-"
end

function menu.onExpandResearch(_, ftable, _, nodedata, researchmodule)
	local proddata = GetProductionModuleData(researchmodule)
	local researchtime, resources, precursors = 0, {}, {}
	if proddata.state ~= "empty" then
		researchtime, resources, precursors = GetWareData(proddata.blueprintware, "researchtime", "resources", "researchprecursors")
	end
	-- remaining time
	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(function () return menu.researchStateText(researchmodule) end)
	local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(function () return menu.researchTimeText(researchmodule, researchtime) end, { halign = "right" })
	if proddata.state == "waitingforresources" then
		-- mission precursors
		local hasmissionprecursors = false
		for i, precursor in ipairs(precursors) do
			if GetWareData(precursor, "ismissiononly") and (not C.HasResearched(precursor)) then
				hasmissionprecursors = true
				break
			end
		end
		if (#precursors > 0) and hasmissionprecursors then
			local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 7412) .. ReadText(1001, 120))
			for i, precursor in ipairs(precursors) do
				local name, ismissiononly = GetWareData(precursor, "name", "ismissiononly")
				if ismissiononly and (not C.HasResearched(precursor)) then
					local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
					row[1]:setColSpan(2):createText("  " .. name)
				end
			end
		end
		-- resources
		if #resources > 0 then
			local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 7411) .. ReadText(1001, 120))
			for _, resourcedata in ipairs(resources) do
				local locamount = C.GetAmountOfWareAvailable(resourcedata.ware, researchmodule)
				local color
				if locamount and (locamount < resourcedata.amount) then
					color = Helper.color.warningorange
				end
				local row = ftable:addRow(nil, { fixed = true, bgColor = Helper.color.transparent })
				local name = GetWareData(resourcedata.ware, "name")
				local resourcename = "  " .. name
				row[1]:createText(resourcename, { color = color })
				row[2]:createText((locamount and (locamount .. " / ") or "") .. resourcedata.amount, { halign = "right", color = color })
			end
		end
	end
end

function menu.researchStateText(researchmodule)
	local proddata = GetProductionModuleData(researchmodule)
	if proddata.state == "empty" then
		return ReadText(1001, 7408)
	elseif proddata.state == "waitingforresources" then
		return ReadText(1001, 4231) .. ReadText(1001, 120)
	end
	return ReadText(1001, 7409) .. ReadText(1001, 120)
end

function menu.researchTimeText(researchmodule, researchtime)
	local proddata = GetProductionModuleData(researchmodule)
	return (proddata.state == "waitingforresources") and ConvertTimeString(researchtime) or ConvertTimeString(researchmodule and (proddata.remainingcycletime or 0) or 0)
end

function menu.onExpandTerraforming(_, ftable, _, nodedata, project)
	ftable:setColWidthPercent(1, 66)
	ftable.properties.highlightMode = "grey"

	local shiptrader = GetComponentData(menu.containerid, "shiptrader")
	menu.updateDroneInfo(project.cluster, project.project)
	if (not project.project.isongoing) and ((shiptrader == nil) or ((menu.droneinfo.numbuildsinprogress + menu.droneinfo.numcurrentdeliveries) == 0)) then
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(function () return menu.terraformingErrorText(project) end, { wordwrap = true, color = Helper.color.red })

		ftable:addEmptyRow(Helper.standardTextHeight / 2)
	end

	-- queue
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 3804) .. ReadText(1001, 120))
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(function () menu.updateDroneInfo(project.cluster, project.project); return ConvertIntegerString(tonumber(menu.droneinfo.numbuildsinqueue), true, 0, true) end, { halign = "right" })
	-- progress
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 3803) .. ReadText(1001, 120))
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(function () menu.updateDroneInfo(project.cluster, project.project); return ConvertIntegerString(tonumber(menu.droneinfo.numbuildsinprogress), true, 0, true) end, { halign = "right" })
	-- in-flight
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 3805) .. ReadText(1001, 120))
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(function () menu.updateDroneInfo(project.cluster, project.project); return ConvertIntegerString(tonumber(menu.droneinfo.numcurrentdeliveries), true, 0, true) end, { halign = "right" })

	-- resources
	if #project.project.resources > 0 then
		ftable:addEmptyRow(Helper.standardTextHeight / 2)
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 3802) .. ReadText(1001, 120))
		for _, entry in ipairs(project.project.resources) do
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createText("· " .. GetWareData(entry.ware, "name"))
			menu.updateDeliveredWares(project.cluster, project.project)
			row[2]:createText(function () menu.updateDeliveredWares(project.cluster, project.project); return ConvertIntegerString(menu.deliveredwares[entry.ware] or 0, true, 1, true) .. " / " .. ConvertIntegerString(entry.amount, true, 1, true) end, { halign = "right", mouseOverText = ConvertIntegerString(menu.deliveredwares[entry.ware] or 0, true, 0, true) .. " / " .. ConvertIntegerString(entry.amount, true, 0, true) })
		end
	end

	-- duration
	if project.project.duration > 0 then
		if not hasspacing then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
			hasspacing = true
		end
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 3813) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 3800) })
		if project.project.isongoing then
			row[2]:createText(function () return ConvertTimeString(C.GetTerraformingProjectCompletionTime(project.cluster, project.project.id) - C.GetCurrentGameTime(), "%h:%M:%S") end, { halign = "right", mouseOverText = ReadText(1026, 3800) })
		else
			row[2]:createText(ConvertTimeString(project.project.duration, "%h:%M:%S"), { halign = "right", mouseOverText = ReadText(1026, 3800) })
		end
	end
end

function menu.terraformingErrorText(project)
	local name, shiptrader = GetComponentData(menu.containerid, "name", "shiptrader")
	if shiptrader then
		menu.updateDroneInfo(project.cluster, project.project)
		return ((menu.droneinfo.numbuildsinprogress + menu.droneinfo.numcurrentdeliveries) == 0) and ReadText(1001, 3845) or ""
	else
		return string.format(ReadText(1001, 11264), name)
	end
end

function menu.updateDroneInfo(cluster, project)
	local curtime = getElapsedTime()
	if (not menu.lastDroneInfoUpdateTime) or (curtime > menu.lastDroneInfoUpdateTime) then
		menu.lastDroneInfoUpdateTime = curtime
		menu.droneinfo = C.GetTerraformingProjectDroneStatus(cluster, project.id)
	end
end

function menu.onExpandDestroyedModule(_, ftable, _, nodedata, module)
	if GetComponentData(menu.containerid, "isplayerowned") then
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 8427), { color = Helper.color.red })
	end
end

function menu.onExpandBuildModule(_, ftable, _, nodedata, buildmodule)
	local productioninfo_products =	C.IsInfoUnlockedForPlayer(buildmodule, "production_products")
	local productioninfo_time =		C.IsInfoUnlockedForPlayer(buildmodule, "production_time")

	local constructions = {}
	local n = C.GetNumBuildTasks(menu.container, buildmodule, true, true)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetBuildTasks(buf, n, menu.container, buildmodule, true, true)
	for i = 0, n - 1 do
		table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
	end

	ftable:setColWidthPercent(1, 50)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidth(4, Helper.scaleY(Helper.standardButtonHeight), false)

	local ishacked = GetComponentData(ConvertStringTo64Bit(tostring(buildmodule)), "ishacked")
	if ishacked then
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(ReadText(1001, 8426), { color = Helper.color.red, wordwrap = true })
	end

	if #constructions > 0 then
		for _, construction in ipairs(constructions) do
			local name = ReadText(20109, 5101)
			if construction.component ~= 0 then
				name = GetComponentName(ConvertStringTo64Bit(tostring(construction.component)), Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), config.nodewidth, nil, true)
			elseif construction.macro ~= "" then
				name = GetMacroData(construction.macro, "name")
			end
			local color = (productioninfo_products and (construction.factionid == "player")) and Helper.color.green or Helper.color.white

			if construction.inprogress then
				local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(4):createText(Helper.unlockInfo(productioninfo_products, name .. " (" .. ffi.string(C.GetObjectIDCode(construction.component)) .. ")"), { color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
				local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:createText(Helper.unlockInfo(productioninfo_time, function () return menu.getShipBuildProgress(construction.component, "") end), { color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" }) 
				row[2]:setColSpan(3):createText(Helper.unlockInfo(productioninfo_time, function () return (construction.ismissingresources and "\27Y\27[warning] " or "") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(construction.buildercomponent), "%h:%M:%S") end), { halign = "right", color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
			end
		end
	else
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(Helper.unlockInfo(productioninfo_products, ReadText(1001, 8419)))
	end

	ftable:addEmptyRow()

	if GetComponentData(menu.containerid, "isplayerowned") then
		-- trade rule
		local hasownlist = C.HasContainerOwnTradeRule(menu.container, "build", "")
		local traderuleid = C.GetContainerTradeRuleID(menu.container, "build", "")
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
		-- global
		local row = ftable:addRow("buildtraderule_global", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
		row[4]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
		row[4].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.container, "build", "", checked) end
		-- current
		local row = ftable:addRow("buildtraderule_current", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.container, "build", "", id) end
		row[4]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
		row[4].handlers.onClick = menu.buttonEditTradeRule

		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText("")

		-- price factor
		row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(ReadText(1001, 8425) .. ReadText(1001, 120), { wordwrap = true })
		row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createSliderCell({
			height = Helper.standardTextHeight,
			min = 50,
			max = 150,
			start = math.floor(C.GetContainerBuildPriceFactor(menu.container) * 100 + 0.5),
			hideMaxValue = true,
			suffix = "%",
		})
		row[1].handlers.onSliderCellChanged = function(_, value) return menu.slidercellBuildPriceFactor(menu.container, value) end
	end
end

function menu.onExpandPlannedBuildModule(_, ftable, _, nodedata, buildmodule)
	if GetComponentData(menu.containerid, "isplayerowned") then
		local data = GetLibraryEntry("moduletypes_build", buildmodule[2])

		local row
		-- build
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 8417) .. ReadText(1001, 120))
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(function () return menu.getBuildProgress(menu.containerid, buildmodule[1]) end, { halign = "right" })
		if IsComponentConstruction(ConvertStringTo64Bit(tostring(buildmodule[1]))) then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			local buildingprocessor = GetComponentData(menu.container, "buildingprocessor")
			local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
			row[1]:setColSpan(2):createText(function () return menu.getBuildTime(buildmodule[1]) end, { halign = "right", mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
		end
	end
end

function menu.onExpandWorkforce(_, ftable, _, nodedata)
	ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidthPercent(3, 30)
	ftable:setColWidth(4, Helper.scaleY(Helper.standardTextHeight), false)
	ftable.properties.highlightMode = "grey"

	local workforceinfo_all =	C.IsInfoUnlockedForPlayer(menu.container, "operator_name")

	local resourceinfos = {}
	if C.IsComponentClass(menu.container, "container") then
		resourceinfos = GetWorkForceRaceResources(menu.containerid)
	end

	local races = {}
	local n = C.GetNumAllRaces()
	local buf = ffi.new("RaceInfo[?]", n)
	n = C.GetAllRaces(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.id = ffi.string(buf[i].id)
		entry.name = ffi.string(buf[i].name)

		table.insert(races, entry)
	end
	table.sort(races, Helper.sortName)

	local row
	-- global
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 8412) .. ReadText(1001, 120), { wordwrap = true })
	row[3]:setColSpan(2):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, "").current, true, 0, true, false)) end, { halign = "right" })
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 9611) .. ReadText(1001, 120), { wordwrap = true })
	row[3]:setColSpan(2):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, "").capacity, true, 0, true, false)) end, { halign = "right" })
	-- optimal
	if (#GetProductionModules(menu.containerid) > 0) or GetComponentData(menu.containerid, "canequipships") then
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(ReadText(1001, 8413) .. ReadText(1001, 120), { wordwrap = true })
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(4):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, "").optimal, true, 0, true, false)) end, { halign = "right" })
	end
	local shouldfill = C.ShouldContainerFillWorkforceCapacity(menu.container)
	if C.GetWorkForceInfo(menu.container, "").capacity > 0 then
		if GetComponentData(menu.containerid, "isplayerowned") then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
			-- target
			row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:createCheckBox(shouldfill, { height = Helper.standardButtonHeight })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxSetWorkforceFill(menu.container) end
			row[2]:setColSpan(3):createText(ReadText(1001, 8453), { mouseOverText = ReadText(1026, 8406) })
			if shouldfill then
				-- employment target
				row = ftable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createText(ReadText(1001, 8455) .. ReadText(1001, 120), { wordwrap = true })
				row[3]:setColSpan(2):createText(function() local workforceinfo = C.GetWorkForceInfo(menu.container, ""); return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(workforceinfo.capacity, true, 0, true, false)) end, { halign = "right" })
			end
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end
		-- efficiency
		row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 8464) .. ReadText(1001, 120), { wordwrap = true })
		row[3]:setColSpan(2):createText(function() return Helper.unlockInfo(workforceinfo_all, math.floor((GetComponentData(menu.containerid, "workforcebonus") or 0) * 100) .. " %") end, { halign = "right" })
		if GetComponentData(menu.containerid, "isplayerowned") then
			-- next update
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 8463), { wordwrap = true })
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(ReadText(1001, 8414) .. ReadText(1001, 120), { wordwrap = true })
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertTimeString(C.GetWorkForceInfo(menu.container, "").timeuntilnextupdate - C.GetCurrentGameTime())) end, { halign = "right" })
		end
	end
	for _, race in ipairs(races) do
		local workforceinfo = C.GetWorkForceInfo(menu.container, race.id)
		if workforceinfo.capacity > 0 then
			local workforceinfluencecounts = C.GetNumContainerWorkforceInfluence(menu.container, race.id, menu.forceNextWorkforceInfluenceUpdate or false)
			menu.forceNextWorkforceInfluenceUpdate = nil
			local buf = ffi.new("WorkforceInfluenceInfo")
			buf.capacityinfluences = Helper.ffiNewHelper("UIWorkforceInfluence[?]", workforceinfluencecounts.numcapacityinfluences)
			buf.numcapacityinfluences = workforceinfluencecounts.numcapacityinfluences
			buf.growthinfluences = Helper.ffiNewHelper("UIWorkforceInfluence[?]", workforceinfluencecounts.numgrowthinfluences)
			buf.numgrowthinfluences = workforceinfluencecounts.numgrowthinfluences
			C.GetContainerWorkforceInfluence(buf, menu.container, race.id)

			local workforceinfluences = {}
			workforceinfluences.capacityinfluences = {}
			for i = 0, buf.numcapacityinfluences - 1 do
				table.insert(workforceinfluences.capacityinfluences, {
					type = ffi.string(buf.capacityinfluences[i].type),
					name = ffi.string(buf.capacityinfluences[i].name),
					value = buf.capacityinfluences[i].value,
					active = buf.capacityinfluences[i].active,
				})
			end
			workforceinfluences.growthinfluences = {}
			for i = 0, buf.numgrowthinfluences - 1 do
				table.insert(workforceinfluences.growthinfluences, {
					type = ffi.string(buf.growthinfluences[i].type),
					name = ffi.string(buf.growthinfluences[i].name),
					value = buf.growthinfluences[i].value,
					active = buf.growthinfluences[i].active,
				})
			end
			workforceinfluences.basegrowth = buf.basegrowth
			workforceinfluences.capacity = buf.capacity
			workforceinfluences.current = buf.current
			workforceinfluences.sustainable = buf.sustainable
			workforceinfluences.target = buf.target
			workforceinfluences.change = buf.change

			-- title
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(4):createText(Helper.unlockInfo(workforceinfo_all, race.name), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			-- current
			row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8412) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, race.id).current, true, 0, true, false)) end, { halign = "right", x = 0 })
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 9611) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, race.id).capacity, true, 0, true, false)) end, { halign = "right", x = 0 })
			-- sustainable
			row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			local mouseovertext = ""
			if workforceinfo_all then
				mouseovertext = ReadText(1026, 8405)
				local first = true
				for i, entry in ipairs(workforceinfluences.capacityinfluences) do
					if entry.active then
						if first then
							mouseovertext = ""
						else
							mouseovertext = mouseovertext .. "\n"
						end
						first = false
						mouseovertext = mouseovertext .. "· " .. entry.name .. ReadText(1001, 120) .. "  " .. Helper.convertColorToText((entry.value > 0) and Helper.color.green or ((entry.value < 0) and Helper.color.red or Helper.color.white)) .. string.format("%+.0f%%", entry.value * 100) .. "\27X"
					end
				end
			end
			local icon = "widget_circle_01"
			local color = Helper.color.grey
			if workforceinfluences.sustainable > workforceinfluences.capacity then
				icon = "widget_arrow_up_01"
				color = Helper.color.green
			elseif workforceinfluences.sustainable < workforceinfluences.capacity then
				icon = "widget_arrow_down_01"
				color = Helper.color.red
			end
			row[1]:setBackgroundColSpan(4):setColSpan(2):createText(ReadText(1001, 8454) .. ReadText(1001, 120), { mouseOverText = mouseovertext })
			row[3]:createText(Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(workforceinfluences.sustainable, true, 0, true, false)), { halign = "right", mouseOverText = mouseovertext, x = 0 })
			row[4]:createIcon(icon, { color = color, width = Helper.standardTextHeight, height = Helper.standardTextHeight, mouseOverText = mouseovertext })
			-- target
			row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(2):createText(ReadText(1001, 8455) .. ReadText(1001, 120))
			row[3]:createText(Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(shouldfill and workforceinfluences.capacity or workforceinfluences.target, true, 0, true, false)), { halign = "right", x = 0 })
			-- change
			row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			local mouseovertext = ""
			if workforceinfo_all then
				mouseovertext = ReadText(20230, 1001) .. ReadText(1001, 120) .. "  " .. Helper.convertColorToText(Helper.color.green) .. string.format("%+.0f", workforceinfluences.basegrowth) .. "\27X"
				for i, entry in ipairs(workforceinfluences.growthinfluences) do
					if entry.active then
						mouseovertext = mouseovertext .. "\n· " .. entry.name .. ReadText(1001, 120) .. "  " .. Helper.convertColorToText((entry.value > 0) and Helper.color.green or ((entry.value < 0) and Helper.color.red or Helper.color.white)) .. string.format("%+.0f%%", entry.value * 100) .. "\27X"
					end
				end
			end
			local icon = "widget_circle_01"
			local color = nil
			if workforceinfluences.change > 0 then
				icon = "widget_arrow_up_01"
				color = Helper.color.green
			elseif workforceinfluences.change < 0 then
				icon = "widget_arrow_down_01"
				color = Helper.color.red
			end
			row[1]:setBackgroundColSpan(4):setColSpan(2):createText(ReadText(1001, 8456) .. ReadText(1001, 120), { mouseOverText = mouseovertext })
			row[3]:createText(Helper.unlockInfo(workforceinfo_all, string.format("%+s", ConvertIntegerString(workforceinfluences.change, true, 0, true, false))), { halign = "right", color = color, mouseOverText = mouseovertext, x = 0 })
			row[4]:createIcon(icon, { color = color, width = Helper.standardTextHeight, height = Helper.standardTextHeight, mouseOverText = mouseovertext })

			-- resources
			if workforceinfo_all then
				local resourcedata
				for _, resourceinfo in ipairs(resourceinfos) do
					if resourceinfo.race == race.id then
						resourcedata = resourceinfo
					end
				end
			
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(4):createText(ReadText(1001, 8451) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
				for i, resource in ipairs(resourcedata.resources) do
					row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
					local amount = Helper.round(resource.cycle * 3600 / resource.cycleduration * workforceinfo.current / resourcedata.productamount)
					row[1]:setColSpan(2):createText("   " .. resource.name)
					row[3]:createText(ConvertIntegerString(amount, true, 0, true, false), { halign = "right", x = 0 })
				end
			end
		end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.onExpandCondensateShield(_, ftable, _, nodedata)
	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(20104, 92502), { wordwrap = true })

	ftable:addEmptyRow()

	local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:createText(ReadText(30251, 1) .. ReadText(1001, 120))
	row[2]:createText("1" .. ReadText(1001, 42) .. " " .. GetWareData(nodedata.condensateshield, "name"), { halign = "right" })

	menu.restoreTableState("nodeTable", ftable)
end

function menu.onExpandSupply(_, ftable, _, nodedata)
	if nodedata.drones then
		AddUITriggeredEvent(menu.name, "expand_supply", "drones")
	end

	if not menu.supplyUpdateRegistered then
		RegisterEvent("supplyUpdate", menu.supplyUpdate)
		menu.supplyUpdateRegistered = true
	end

	local info_high =		nodedata.drones and C.IsInfoUnlockedForPlayer(menu.container, "units_amount") or C.IsInfoUnlockedForPlayer(menu.container, "defence_status")
	local info_low =		nodedata.drones and C.IsInfoUnlockedForPlayer(menu.container, "units_details") or C.IsInfoUnlockedForPlayer(menu.container, "defence_level")

	ftable:setColWidthPercent(2, 20)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	local row

	local supply_auto = {}
	menu.supplyoverride = {}
	menu.supplydefaults = {}
	local canequipships, isplayerowned = GetComponentData(menu.containerid, "canequipships", "isplayerowned")
	if isplayerowned then
		supply_auto["transport"]	= not C.IsSupplyManual(menu.container, "units_trade")
		supply_auto["defence"]		= not C.IsSupplyManual(menu.container, "units_defence")
		supply_auto["build"]		= not C.IsSupplyManual(menu.container, "units_build")
		supply_auto["repair"]		= not C.IsSupplyManual(menu.container, "units_repair")
		supply_auto["missile"]		= not C.IsSupplyManual(menu.container, "missiles")

		local n = C.GetNumSupplyOrders(menu.container, false)
		local buf = ffi.new("SupplyOverride[?]", n)
		n = C.GetSupplyOrders(buf, n, menu.container, false)
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			menu.supplyoverride[macro] = buf[i].amount
		end

		local n = C.GetNumSupplyOrders(menu.container, true)
		local buf = ffi.new("SupplyOverride[?]", n)
		n = C.GetSupplyOrders(buf, n, menu.container, true)
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			menu.supplydefaults[macro] = buf[i].amount
		end
	end

	menu.types = nodedata.drones and config.dronetypes or config.missilestypes
	local currentOrders = 0
	menu.supplies = {}
	for _, supplytypeentry in ipairs(menu.types) do
		menu.supplies[supplytypeentry.type] = {}
		if supplytypeentry.type == "missile" then
			local knownmacros = {}
			local n = C.GetNumBlueprints("", "missiletypes", "")
			local buf = ffi.new("UIBlueprint[?]", n)
			n = C.GetBlueprints(buf, n, "", "missiletypes", "")
			for i = 0, n - 1 do
				macro = ffi.string(buf[i].macro)

				if C.IsContainerAmmoMacroCompatible(menu.container, macro) then
					currentOrders = currentOrders + (menu.supplyoverride[macro] or menu.supplydefaults[macro] or 0)
					table.insert(menu.supplies[supplytypeentry.type], { name = GetMacroData(macro, "name"), macro = macro, stored = 0, compatible = true })
					knownmacros[macro] = #menu.supplies[supplytypeentry.type]
				end
			end

			local n = C.GetNumAllMissiles(menu.container)
			local buf = ffi.new("AmmoData[?]", n)
			n = C.GetAllMissiles(buf, n, menu.container)
			for j = 0, n - 1 do
				local macro = ffi.string(buf[j].macro)
				local amount = buf[j].amount

				if knownmacros[macro] then
					if not supply_auto[supplytypeentry.type] then
						currentOrders = currentOrders + amount
					end
					menu.supplies[supplytypeentry.type][knownmacros[macro]].stored = amount
				else
					if supply_auto[supplytypeentry.type] then
						currentOrders = currentOrders + (menu.supplyoverride[macro] or menu.supplydefaults[macro] or 0)
					else
						currentOrders = currentOrders + amount + (menu.supplyoverride[macro] or menu.supplydefaults[macro] or 0)
					end
					table.insert(menu.supplies[supplytypeentry.type], { name = GetMacroData(macro, "name"), macro = macro, stored = amount, compatible = false })
				end
			end
			menu.supplies[supplytypeentry.type].capacity = GetComponentData(menu.containerid, "missilecapacity")

			table.sort(menu.supplies[supplytypeentry.type], Helper.sortName)
		else
			local units = GetUnitStorageData(menu.containerid, supplytypeentry.type)
			for _, entry in ipairs(units) do
				if supply_auto[supplytypeentry.type] then
					currentOrders = currentOrders + (menu.supplyoverride[entry.macro] or menu.supplydefaults[entry.macro] or 0)
				else
					currentOrders = currentOrders + entry.amount + (menu.supplyoverride[entry.macro] or menu.supplydefaults[entry.macro] or 0)
				end
				table.insert(menu.supplies[supplytypeentry.type], { name = entry.name, macro = entry.macro, stored = entry.amount })
			end
			menu.supplies[supplytypeentry.type].capacity = units.capacity

			table.sort(menu.supplies[supplytypeentry.type], Helper.sortName)
		end
	end

	for _, supplytypeentry in ipairs(menu.types) do
		if (supplytypeentry.type ~= "build") or canequipships then
			if menu.supplies[supplytypeentry.type].capacity > 0 then
				-- title
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(Helper.unlockInfo(info_low, supplytypeentry.name), Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
				-- auto setting
				local auto
				if isplayerowned then
					auto = supply_auto[supplytypeentry.type]
					row = ftable:addRow(true, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(2):createText(supplytypeentry.autoname)
					row[3]:createCheckBox(auto, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return menu.checkboxSupplyAuto(menu.container, supplytypeentry.type, checked) end
				end
				-- available macros
				if #menu.supplies[supplytypeentry.type] > 0 then
					for i, entry in ipairs(menu.supplies[supplytypeentry.type]) do
						
						local limit = 0
						if auto then
							if menu.supplyoverride[entry.macro] then
								limit = menu.supplyoverride[entry.macro]
							else
								limit = menu.supplydefaults[entry.macro] or 0
							end
						end
						-- name
						row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						row[1]:createText(Helper.unlockInfo(info_low, entry.name))
						row[2]:setColSpan(2):createText(isplayerowned and function () return menu.supplies[supplytypeentry.type][i].stored .. menu.getManualOrder(entry.macro, auto) .. (auto and (" / " .. (menu.supplyoverride[entry.macro] or menu.supplydefaults[entry.macro] or 0)) or "") end or "", { halign = "right", color = (entry.compatible == false) and Helper.color.grey or Helper.color.white })
						-- amount
						local start = info_high and (auto and limit or (entry.stored + (menu.supplyoverride[entry.macro] or 0))) or 0
						local max = math.max(0, menu.supplies[supplytypeentry.type].capacity - currentOrders + start)
						local maxSelect = math.min(max, (entry.compatible == false) and entry.stored or max)
						start = math.min(maxSelect, math.max(0, start))
						row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						local slidercell = row[1]:setColSpan(3):createSliderCell({
							height = Helper.standardTextHeight,
							valueColor = Helper.defaultSliderCellValueColor,
							min = 0,
							maxSelect = maxSelect,
							max = max,
							start = start,
							hideMaxValue = true,
							readOnly = not isplayerowned,
						}):setText(ReadText(1001, 8415) .. ReadText(1001, 120), { color = (entry.compatible == false) and Helper.color.grey or Helper.color.white })
						row[1].handlers.onSliderCellChanged = function (_, value) menu.supplyoverride[entry.macro] = value - (auto and 0 or menu.supplies[supplytypeentry.type][i].stored) end
						row[1].handlers.onSliderCellConfirm = function (id, value) return menu.slidercellSupplyAmount(menu.container, entry.macro, auto, supplytypeentry.type, i, value) end
						row[1].handlers.onSliderCellActivated = function () return menu.slidercellSupplyAmountActivated(entry.macro) end
						row[1].handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end

						if entry.macro == menu.restoreSliderCellInput then
							menu.restoreSliderCellInput = slidercell
						end
					end
				else
					row = ftable:addRow(false, { bgColor = Helper.color.transparent })
					row[1]:setColSpan(3):createText(ReadText(1001, 4235))
				end
			end
		end
	end
	
	if isplayerowned then
		-- trade rule
		local hasownlist = C.HasContainerOwnTradeRule(menu.container, "supply", "")
		local traderuleid = C.GetContainerTradeRuleID(menu.container, "supply", "")
		row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText("")

		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createText(ReadText(1001, 11030), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"
		-- global
		local row = ftable:addRow("supplytraderule_global", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
		row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
		row[3].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.container, "supply", "", checked) end
		-- current
		local row = ftable:addRow("supplytraderule_current", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.container, "supply", "", id) end
		row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
		row[3].handlers.onClick = menu.buttonEditTradeRule
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.getManualOrder(macro, auto)
	local manualorder = ""
	if (not auto) and menu.supplyoverride[macro] then
		if menu.supplyoverride[macro] > 0 then
			manualorder = " \27G(+" .. menu.supplyoverride[macro] .. ")\27X"
		elseif menu.supplyoverride[macro] < 0 then
			manualorder = " \27R(" .. menu.supplyoverride[macro] .. ")\27X"
		end
	end

	return manualorder
end

function menu.slidercellSupplyAmountActivated(macro)
	if menu.refreshnode then
		-- We started slidercell input, but a menu update is pending. Let it update and re-activate input
		menu.restoreSliderCellInput = macro
	else
		menu.noupdate = true
	end
end

function menu.onExpandAccount(_, ftable, _, nodedata)
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local trademoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = productionmoney + supplymoney + trademoney
	local playermoney = math.max(0, GetPlayerMoney())

	local row
	-- missing funds
	if money < budget then
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(2):createText(menu.getAccountWarningText, { color = menu.getAccountWarningColor, wordwrap = true })

		ftable:addEmptyRow(Helper.standardTextHeight / 2)
	end
	-- wanted money
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 1919) .. ReadText(1001, 120))
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ConvertMoneyString(budget, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- production and building
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	local numproductionmodules = #GetProductionModules(menu.containerid)
	local numbuildmodules = C.GetNumBuildModules(menu.container)
	local text = ReadText(1001, 8420)
	if numbuildmodules > 0 then
		if numproductionmodules > 0 then
			text = ReadText(1001, 8422)
		else
			text = ReadText(1001, 8421)
		end
	end
	row[1]:setColSpan(2):createText(text .. ReadText(1001, 120))
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ConvertMoneyString(productionmoney, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- supplies
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 8423) .. ReadText(1001, 120))
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ConvertMoneyString(supplymoney, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- trade wares
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ReadText(1001, 8447) .. ReadText(1001, 120))
	row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createText(ConvertMoneyString(trademoney, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- current money
	row = ftable:addRow(true, { bgColor = Helper.color.transparent })
	row[1]:setColSpan(2):createSliderCell({
		height = Helper.standardTextHeight,
		min = 0,
		max = playermoney + money,
		start = money,
		hideMaxValue = true,
		suffix = ReadText(1001, 101),
	}):setText(ReadText(1001, 7710))
	row[1].handlers.onSliderCellChanged = menu.slidercellAccount
	-- confirm
	row = ftable:addRow(true, { bgColor = Helper.color.transparent })
	row[1]:createButton({ active = function () return (menu.newAccountValue ~= nil) and GetComponentData(menu.containerid, "isplayerowned") end }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonAccountConfirm
	row[2]:createButton({ active = function () local money, estimate, isplayerowned = GetComponentData(menu.containerid, "money", "productionmoney", "isplayerowned"); estimate = estimate + tonumber(C.GetSupplyBudget(menu.container)) / 100; estimate = estimate + tonumber(C.GetTradeWareBudget(menu.container)) / 100; return isplayerowned and ((money + GetPlayerMoney()) > estimate) end }):setText(ReadText(1001, 7965), { halign = "center" })
	row[2].handlers.onClick = menu.buttonAccountToEstimate

	menu.restoreTableState("nodeTable", ftable)
end

function menu.getAccountWarningText()
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local trademoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = productionmoney + supplymoney + trademoney

	if money < budget then
		if money == 0 then
			return ReadText(1001, 8465)
		else
			return ReadText(1001, 8466)
		end
	end
	return ""
end

function menu.getAccountWarningColor()
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local trademoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = productionmoney + supplymoney + trademoney

	if money < budget then
		if money == 0 then
			return Helper.color.red
		else
			return Helper.color.warningorange
		end
	end
	return Helper.color.white
end

function menu.onExpandDummy(_, ftable, _, nodedata)
	local node = menu.expandedNode
	local maxcaptionlen = 100
	local maxstatuslen = 100

	-- caption and status
	menu.expandedDummyNodeText = node.properties.text.text
	local row = ftable:addRow(true)
	row[1]:createText("Caption length")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = maxcaptionlen, hideMaxValue = true, start = 10 })
	row[2].handlers.onSliderCellChanged = function(_, value)
		local str = ""
		for i = 1, value do
			str = str .. "-";
		end
		node:updateText(str)
	end

	local row = ftable:addRow(true)
	row[1]:createText("Status length")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = maxstatuslen, hideMaxValue = true, start = 10 })
	row[2].handlers.onSliderCellChanged = function(_, value)
		if value == maxstatuslen then
			node:updateStatus(nil, "lso_pie_09", "lso_progress")
		else
			local str = ""
			for i = 1, value do
				str = str .. "|";
			end
			node:updateStatus(str)
		end
	end

	if node.properties.max > 0 then
		-- separator
		local row = ftable:addRow(false)
		row[1]:setColSpan(2):createText("", { height = 1 })

		-- bar and sliders
		local row = ftable:addRow(true)
		row[1]:createText("Value")
		row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = node.properties.value })
		row[2].handlers.onSliderCellChanged = function(_, value) node:updateValue(math.min(value, node.properties.max)) end

		local row = ftable:addRow(true)
		row[1]:createText("Max")
		row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = node.properties.max, exceedMaxValue = true })
		row[2].handlers.onSliderCellChanged = function(_, value)
			if node.properties.value > value then node:updateValue(value) end
			if node.properties.slider1 > value then node:updateSlider1(value) end
			if node.properties.slider2 > value then node:updateSlider2(value) end
			node:updateMaxValue(value)
		end

		if node.properties.step > 0 then
			-- separator
			local row = ftable:addRow(false)
			row[1]:setColSpan(2):createText("", { height = 1 })

			local row = ftable:addRow(true)
			local sliderenabled = node.properties.slider1 >= 0
			local slidervalue = sliderenabled and node.properties.slider1 or 0
			row[1]:createText("Buy enabled")
			local checkbox = row[2]:createCheckBox(sliderenabled, { width = Helper.standardTextHeight })
			checkbox.handlers.onClick = function(_, checked) sliderenabled = checked; node:updateSlider1(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end
			local row = ftable:addRow(true)
			row[1]:createText("Buy slider")
			row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = slidervalue })
			row[2].handlers.onSliderCellChanged = function(_, value) slidervalue = value; node:updateSlider1(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end

			local row = ftable:addRow(true)
			local sliderenabled = node.properties.slider2 >= 0
			local slidervalue = sliderenabled and node.properties.slider2 or 0
			row[1]:createText("Sell enabled")
			local checkbox = row[2]:createCheckBox(sliderenabled, { width = Helper.standardTextHeight })
			checkbox.handlers.onClick = function(_, checked) sliderenabled = checked; node:updateSlider2(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end
			local row = ftable:addRow(true)
			row[1]:createText("Sell slider")
			row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = slidervalue })
			row[2].handlers.onSliderCellChanged = function(_, value) slidervalue = value; node:updateSlider2(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end
		end
	end

	-- separator
	local row = ftable:addRow(false)
	row[1]:setColSpan(2):createText("", { height = 1 })

	-- colors
	menu.expandedDummyNodeColor = node.properties.statusColor or node.properties.outlineColor
	local colorupdatefunc = function(value, colorprop)
		-- important: don't change elements of an existing color table, it may be referenced in several other places already, so always make a new copy first
		local color = { r = menu.expandedDummyNodeColor.r, g = menu.expandedDummyNodeColor.g, b = menu.expandedDummyNodeColor.b, a = menu.expandedDummyNodeColor.a }
		color[colorprop] = value
		menu.expandedDummyNodeColor = color
		node:updateOutlineColor(color)
		for _, edge in ipairs(node.incomingEdges) do
			menu.updateEdgeColorRecursively(edge, color)
		end
	end

	local color = menu.expandedDummyNodeColor
	local row = ftable:addRow(true)
	row[1]:createText("Red")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = 255, hideMaxValue = true, start = color.r })
	row[2].handlers.onSliderCellChanged = function(_, value) colorupdatefunc(value, "r") end
	local row = ftable:addRow(true)
	row[1]:createText("Green")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = 255, hideMaxValue = true, start = color.g })
	row[2].handlers.onSliderCellChanged = function(_, value) colorupdatefunc(value, "g") end
	local row = ftable:addRow(true)
	row[1]:createText("Blue")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = 255, hideMaxValue = true, start = color.b })
	row[2].handlers.onSliderCellChanged = function(_, value) colorupdatefunc(value, "b") end
end

function menu.onCollapseDummy(nodedata)
	menu.expandedNode:updateText(menu.expandedDummyNodeText)
	menu.expandedDummyNodeText = nil
end

function menu.onFlowchartNodeCollapsed(node, frame)
	if menu.expandedNode == node and menu.expandedMenuFrame == frame then
		local data = node.customdata
		local collapseHandler = data.moduledata.collapseHandler
		if collapseHandler then
			collapseHandler(data.nodedata)
		end
		Helper.clearFrame(menu, config.expandedMenuFrameLayer)
		menu.expandedMenuTable = nil
		menu.expandedMenuFrame = nil
		menu.expandedNode = nil
	end
end

function menu.onCollapseSupply(nodedata)
	if nodedata.drones then
		AddUITriggeredEvent(menu.name, "collapse_supply", "drones")
	end

	UnregisterEvent("supplyUpdate", menu.supplyUpdate)
	menu.supplyUpdateRegistered = nil

	menu.types = {}
end

function menu.buttonAccountConfirm()
	if menu.newAccountValue then
		local stationmoney, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
		local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
		local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
		local estimate = productionmoney + supplymoney + tradewaremoney
		local amount = menu.newAccountValue - stationmoney

		SetMaxBudget(menu.containerid, (menu.newAccountValue * 3) / 2)
		SetMinBudget(menu.containerid, menu.newAccountValue)
		
		if amount > 0 then
			TransferPlayerMoneyTo(amount, menu.containerid)
		else
			TransferMoneyToPlayer(-amount, menu.containerid)
		end

		local shownmax = math.max(menu.newAccountValue, estimate)
		if amount > 0 then
			menu.expandedNode:updateMaxValue(shownmax)
		end
		menu.expandedNode:updateValue(menu.newAccountValue)
		if amount < 0 then
			menu.expandedNode:updateMaxValue(shownmax)
		end
		menu.newAccountValue = nil
		menu.refreshnode = getElapsedTime() + 0.1
	end
end

function menu.buttonAccountToEstimate()
	local stationmoney, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local estimate = productionmoney + supplymoney + tradewaremoney
	local amount = estimate - stationmoney

	SetMaxBudget(menu.containerid, (estimate * 3) / 2)
	SetMinBudget(menu.containerid, estimate)

	if amount > 0 then
		TransferPlayerMoneyTo(amount, menu.containerid)
	else
		TransferMoneyToPlayer(-amount, menu.containerid)
	end

	menu.expandedNode:updateValue(estimate)
	menu.expandedNode:updateMaxValue(estimate)
	menu.newAccountValue = nil
	menu.refreshnode = getElapsedTime() + 0.1
end

function menu.buttonExtend(groupID, row)
	if menu.extendedGroups[groupID] then
		menu.extendedGroups[groupID] = nil
	else
		menu.extendedGroups[groupID] = true
	end

	menu.saveFlowchartState("flowchart", menu.flowchart)
	menu.saveTableState("keyTable", menu.keyTable)
	if menu.expandedNode then
		menu.expandedNode:collapse()
	end
	menu.display()
end

function menu.buttonTimeFrame(type)
	menu.timeframe = type
	if type == "hour" then
		menu.xStart = math.max(0, menu.xEnd - 3600)
		menu.xGranularity = 300
		menu.xScale = 60
		menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 103) .. "]"
	elseif type == "day" then
		menu.xStart = math.max(0, menu.xEnd - (24 * 3600))
		menu.xGranularity = 7200
		menu.xScale = 3600
		menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 102) .. "]"
	elseif type == "week" then
		menu.xStart = math.max(0, menu.xEnd - (7 * 24 * 3600))
		menu.xGranularity = 12 * 3600
		menu.xScale = 24 * 3600
		menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 104) .. "]"
	end
	if menu.xEnd > menu.xStart then
		while ((menu.xEnd - menu.xStart) < menu.xGranularity) and (menu.xGranularity >= (0.001 * menu.xScale)) do
			menu.xGranularity = menu.xGranularity / 2
		end
	end
	
	menu.getData(config.graph.numdatapoints)
	menu.saveFlowchartState("flowchart", menu.flowchart)
	menu.saveTableState("keyTable", menu.keyTable)
	if menu.expandedNode then
		menu.expandedNode:collapse()
	end
	menu.display()
end

function menu.buttonGraphMode(mode)
	menu.graphmode = mode

	if mode == "tradeofferprices" then
		menu.yTitle = ReadText(1001, 6520) .. " [" .. ReadText(1001, 101) .. "]"
	elseif (mode == "tradeofferamounts") or (mode == "cargolevels") then
		menu.yTitle = ReadText(1001, 6521)
	elseif mode == "npcaccounts" then
		menu.yTitle = ReadText(1001, 6522) .. " [" .. ReadText(1001, 101) .. "]"
	end
	menu.getData(config.graph.numdatapoints)
	menu.saveFlowchartState("flowchart", menu.flowchart)
	if menu.expandedNode then
		menu.expandedNode:collapse()
	end
	menu.display()
end

function menu.buttonRightBar(newmenu, params)
	Helper.closeMenuAndOpenNewMenu(menu, newmenu, params, true)
	menu.cleanup()
end

function menu.buttonShowGraph()
	menu.showGraph = not menu.showGraph
	menu.refresh = true
end

function menu.buttonPauseProductionModules(productionmodules, pause)
	for _, module in ipairs(productionmodules) do
		C.PauseProductionModule(module, pause)
	end

	menu.refreshnode = getElapsedTime() + 0.1
end

function menu.buttonPauseProcessingModules(processingmodules, pause)
	for _, module in ipairs(processingmodules) do
		C.PauseProcessingModule(module, pause)
	end

	menu.refreshnode = getElapsedTime() + 0.1
end


function menu.buttonEditTradeRule()
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function menu.checkboxSelected(idx, row, col)
	if menu.graphdata[idx].shown or (menu.numshowndata < config.graph.maxshowndata) then
		menu.graphdata[idx].shown = not menu.graphdata[idx].shown
		menu.displayedgraphwares[menu.graphdata[idx].ware] = menu.graphdata[idx].shown or nil
		C.SetStationOverviewGraphWare(menu.container, menu.graphdata[idx].ware, menu.graphdata[idx].shown)
		if menu.graphdata[idx].shown then
			for i = 1, config.graph.maxshowndata do
				if not menu.showndata[i] then
					menu.showndata[i] = idx
					menu.numshowndata = menu.numshowndata + 1
					break
				end
			end
		else
			for i, entry in pairs(menu.showndata) do
				if entry == idx then
					menu.showndata[i] = nil
					menu.numshowndata = menu.numshowndata - 1
					break
				end
			end
		end
		
		menu.saveFlowchartState("flowchart", menu.flowchart)
		menu.saveTableState("keyTable", menu.keyTable, row, col)
		if menu.expandedNode then
			menu.expandedNode:collapse()
		end
		menu.display()
	end
end

function menu.checkboxSupplyAuto(container64, type, checked)
	if type == "transport" then
		C.SetSupplyManual(container64, "units_trade", not checked)
	elseif type == "defence" then
		C.SetSupplyManual(container64, "units_defence", not checked)
	elseif type == "build" then
		C.SetSupplyManual(container64, "units_build", not checked)
	elseif type == "repair" then
		C.SetSupplyManual(container64, "units_repair", not checked)
	elseif type == "missile" then
		C.SetSupplyManual(container64, "missiles", not checked)
	end

	for _, entry in ipairs(menu.supplies[type]) do
		if not checked then
			if menu.supplyoverride[entry.macro] then
				menu.supplyoverride[entry.macro] = menu.supplyoverride[entry.macro] - entry.stored
			end
		else
			if menu.supplyoverride[entry.macro] then
				menu.supplyoverride[entry.macro] = menu.supplyoverride[entry.macro] + entry.stored
			elseif entry.stored ~= 0 then
				menu.supplyoverride[entry.macro] = entry.stored
			end
		end
	end

	menu.updateOverride(container64)
	C.UpdateProductionTradeOffers(container64)

	if menu.numSupplyResources ~= C.GetNumSupplyOrderResources(menu.container) then
		menu.setupFlowchartData()
		menu.restoreNodeSupply = (type == "missile") and "missiles" or "drones"
		menu.refresh = true
	else
		menu.refreshnode = getElapsedTime() + 0.1
	end
end

function menu.checkboxProductionSingle(macro, checked)
	menu.showSingleProduction[macro] = checked or nil

	menu.updateExpandedNode()
end

function menu.checkboxMultiSelect(option, checked)
	menu.contextMenuData.selectedOptions[option] = checked or nil
end

function menu.checkboxToggleMultiSelect(checked)
	for _, entry in ipairs(menu.contextMenuData.options) do
		menu.contextMenuData.selectedOptions[entry.id] = checked or nil
	end
end
	 
function menu.checkboxSetTradeRuleOverride(container, type, ware, checked)
	if checked then 
		C.SetContainerTradeRule(container, -1, type, ware, false)
	else
		local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
		C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware, true)
	end

	if (type == "buy") or (type == "sell") then
		menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(menu.container, ware) and "lso_error" or nil, nil, Helper.color.warningorange)
	end
	menu.updateExpandedNode()
end

function menu.checkboxSetWorkforceFill(container)
	C.SetContainerWorkforceFillCapacity(container, not C.ShouldContainerFillWorkforceCapacity(container))
	menu.forceNextWorkforceInfluenceUpdate = true
	menu.refreshnode = getElapsedTime()
end

function  menu.dropdownTradeRule(container, type, ware, id)
	C.SetContainerTradeRule(container, tonumber(id), type, ware, true)
	
	if (type == "buy") or (type == "sell") then
		menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(menu.container, ware) and "lso_error" or nil, nil, Helper.color.warningorange)
	end
end

function menu.slidercellAccount(_, value)
	if value then
		menu.newAccountValue = value
	end
end

function menu.slidercellSupplyAmount(container64, macro, auto, type, idx, value)
	if value then
		menu.supplyoverride[macro] = value - (auto and 0 or menu.supplies[type][idx].stored)

		menu.updateOverride(container64)
		C.UpdateProductionTradeOffers(container64)

		if menu.numSupplyResources ~= C.GetNumSupplyOrderResources(menu.container) then
			menu.setupFlowchartData()
			menu.restoreNodeSupply = (type == "missile") and "missiles" or "drones"
			menu.refresh = true
		else
			menu.refreshnode = getElapsedTime() + 0.1
		end
	end
end

function menu.slidercellBuildPriceFactor(container64, value)
	if value then
		C.SetContainerBuildPriceFactor(container64, value / 100)
	end
end

function menu.updateOverride(container64)
	local numoverrides = 0
	for _, _ in pairs(menu.supplyoverride) do
		numoverrides = numoverrides + 1
	end
	local overrides = ffi.new("SupplyOverride[?]", numoverrides)

	local idx = 0
	for macro, amount in pairs(menu.supplyoverride) do
		overrides[idx].macro = Helper.ffiNewString(macro)
		overrides[idx].amount = amount
		idx = idx + 1
	end

	C.UpdateSupplyOverrides(container64, overrides, numoverrides)

	Helper.ffiClearNewHelper()
end

function menu.updateExpandedNode(row, col)
	if menu.expandedNode then
		menu.saveTableState("nodeTable", menu.expandedMenuTable, row, col)

		local node = menu.expandedNode
		node:collapse()
		node:expand()
	end
end

function menu.getPrimaryJunctionEdgeColor(edges)
	-- Determine incoming edge color based on color of all outgoing edges
	local colorprecedence = {
		Helper.standardColor,
		Helper.color.warningorange,
		Helper.color.red,
	}
	-- We choose the first color in colorprecedence table that appears on any outgoing edge (ignoring alpha)
	local colorindex = #colorprecedence + 1	-- special index denoting fallback color
	local color = Helper.color.grey			-- remember last edge color as fallback color
	for _, edge in ipairs(edges) do
		color = edge.properties.color
		if type(color) == "function" then
			color = color(edge)
		end
		-- Try to set colorindex to a lower index
		for i = 1, colorindex - 1 do
			if color.r == colorprecedence[i].r and color.g == colorprecedence[i].g and color.b == colorprecedence[i].b then
				colorindex = i
				break
			end
		end
		if colorindex == 1 then break end
	end
	return (colorindex <= #colorprecedence) and colorprecedence[colorindex] or color
end

function menu.updateEdgeColorRecursively(edge, color)
	edge:updateColor(color)
	-- If edge source cell is a junction, update the junction's incoming edges as well, based on its outgoing edges
	local cell = edge.sourcecell
	if cell.type == "flowchartjunction" then
		local incomingcolor = menu.getPrimaryJunctionEdgeColor(cell.outgoingEdges)
		for _, incomingedge in ipairs(cell.incomingEdges) do
			menu.updateEdgeColorRecursively(incomingedge, incomingcolor)
		end
	end
end

function menu.getData(numdatapoints)
	menu.numshowndata = 0
	menu.showndata = {}

	local ffiHelper = {}

	menu.graphdata = {}
	if menu.graphmode == "cargolevels" then
		local numstats = 0
		if C.IsComponentClass(menu.container, "container") then
			numstats = C.GetNumCargoStatistics(menu.container, menu.xStart, menu.xEnd, numdatapoints)
		end
		if numstats > 0 then
			local result = ffi.new("UICargoStat[?]", numstats)
			for i = 0, numstats - 1 do
				table.insert(ffiHelper, 1, ffi.new("UICargoStatData[?]", numdatapoints))
				result[i].data = ffiHelper[1]
			end
			numstats = C.GetCargoStatistics(result, numstats, numdatapoints)
			for i = 0, numstats - 1 do
				local ware = ffi.string(result[i].wareid)
				local text = GetWareData(ware, "name")
				menu.graphdata[i + 1] = { shown = false, text = text, ware = ware, data = {} }
				for j = 0, result[i].numdata - 1 do
					menu.graphdata[i + 1].data[j + 1] = { t = tonumber(result[i].data[j].time), y = tonumber(result[i].data[j].amount) }
				end
			end
		end
	elseif (menu.graphmode == "tradeofferprices") or (menu.graphmode == "tradeofferamounts") then
		local numstats = 0
		if C.IsComponentClass(menu.container, "container") then
			numstats = C.GetNumTradeOfferStatistics(menu.container, menu.xStart, menu.xEnd, numdatapoints)
		end
		if numstats > 0 then
			local result = ffi.new("UITradeOfferStat[?]", numstats)
			for i = 0, numstats - 1 do
				table.insert(ffiHelper, 1, ffi.new("UITradeOfferStatData[?]", numdatapoints))
				result[i].data = ffiHelper[1]
			end
			numstats = C.GetTradeOfferStatistics(result, numstats, numdatapoints)
			for i = 0, numstats - 1 do
				local ware = ffi.string(result[i].wareid)
				local text = GetWareData(ware, "name")
				local dataIdx = menu.getDataIdxByWare(ware)
				if not dataIdx then
					table.insert(menu.graphdata, { shown = false, text = text, ware = ware, selldata = {}, buydata = {} })
					dataIdx = #menu.graphdata
				end
				for j = 0, result[i].numdata - 1 do
					local y = 0
					if menu.graphmode == "tradeofferprices" then
						y = tonumber(result[i].data[j].price) / 100
					elseif menu.graphmode == "tradeofferamounts" then
						y = tonumber(result[i].data[j].amount)
					end
					if result[i].isSellOffer then
						menu.graphdata[dataIdx].selldata[j + 1] = { t = tonumber(result[i].data[j].time), y = y }
					else
						menu.graphdata[dataIdx].buydata[j + 1] = { t = tonumber(result[i].data[j].time), y = y }
					end
				end
			end
		end
	elseif menu.graphmode == "npcaccounts" then
		local npcs = Helper.getSuitableControlEntities(menu.containerid, false)
		for i = #npcs, 1, -1 do
			if not C.HasEntityMoneyLogEntries(ConvertIDTo64Bit(npcs[i])) then
				table.remove(npcs, i)
			end
		end
		for i, npc in ipairs(npcs) do
			local result = ffi.new("UIAccountStatData[?]", numdatapoints)
			local numdata = C.GetNPCAccountStatistics(result, numdatapoints, ConvertIDTo64Bit(npc), menu.xStart, menu.xEnd)
			local name, postname, post = GetComponentData(npc, "name", "postname", "poststring")
			local text = postname .. " " .. name
			menu.graphdata[i] = { shown = false, text = text, npc = npc, post = poststring, data = {} }
			-- select the 4 first data sets as default
			if #menu.graphdata <= 4 then
				menu.showndata[i] = npc
			end
			for j = 0, numdata - 1 do
				menu.graphdata[i].data[j + 1] = { t = tonumber(result[j].time), y = tonumber(result[j].money) / 100 }
			end
		end
	end

	table.sort(menu.graphdata, function (a, b) return a.text < b.text end)


	if menu.graphmode ~= "npcaccounts" then
		for ware in pairs(menu.displayedgraphwares) do
			local dataIdx = menu.getDataIdxByWare(ware)
			if not dataIdx then
				menu.displayedgraphwares[ware] = nil
				C.SetStationOverviewGraphWare(menu.container, ware, false)
			end
		end

		for i, entry in ipairs(menu.graphdata) do
			if not menu.graphwaresinit and not menu.isdummy then
				if #menu.showndata < 4 then
					-- default select the 4 first data sets
					table.insert(menu.showndata, entry.ware)
					menu.displayedgraphwares[entry.ware] = true
					C.SetStationOverviewGraphWare(menu.container, entry.ware, true)
				end
			elseif menu.displayedgraphwares[entry.ware] then
				if #menu.showndata < 4 then
					table.insert(menu.showndata, entry.ware)
				else
					menu.displayedgraphwares[entry.ware] = nil
					C.SetStationOverviewGraphWare(menu.container, entry.ware, false)
				end
			end
		end
		menu.graphwaresinit = true
	end

	for i = 1, config.graph.maxshowndata do
		local newdataidx
		if menu.showndata[i] then
			if menu.graphmode ~= "npcaccounts" then
				newdataidx = menu.getDataIdxByWare(menu.showndata[i])
			else
				newdataidx = menu.getDataIdxByNPC(menu.showndata[i])
			end
		end
		if newdataidx then
			menu.showndata[i] = newdataidx
			menu.graphdata[newdataidx].shown = true
			menu.numshowndata = menu.numshowndata + 1
		else
			menu.showndata[i] = nil
		end
	end

	local numgroupeddata = 0
	menu.groupedgraphdata = { }
	if menu.graphmode ~= "npcaccounts" then
		for i, data in ipairs(menu.graphdata) do
			local groupID, groupName = GetWareData(data.ware, "groupID", "groupName")
			local groupIdx = menu.getGroupIdxByID(groupID)
			if groupIdx then
				table.insert(menu.groupedgraphdata[groupIdx], i)
			else
				table.insert(menu.groupedgraphdata, { id = groupID, name = groupName, [1] = i })
			end
		end
	end

	table.sort(menu.groupedgraphdata, Helper.sortName)
end

function menu.getDataIdxByWare(ware)
	for i, data in ipairs(menu.graphdata) do
		if data.ware == ware then
			return i
		end
	end

	return nil
end

function menu.getDataIdxByNPC(npc)
	for i, data in ipairs(menu.graphdata) do
		if IsSameComponent(data.npc, npc) then
			return i
		end
	end

	return nil
end

function menu.getGroupIdxByID(id)
	for i, group in ipairs(menu.groupedgraphdata) do
		if group.id == id then
			return i
		end
	end

	return nil
end

function menu.isGroupExpanded(groupID)
	return menu.extendedGroups[groupID]
end

function menu.newWareReservationCallback(_, data)
	local containerid, ware, reserverid = string.match(data, "(.+);(.+);(.+)")
	if menu.container == ConvertStringTo64Bit(containerid) then
		menu.updateExpandedNode()
	end
end

function menu.getBuildProgress(station, component)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ConvertIDTo64Bit(station)))
	elseif component == 0 then
		buildprogress = "-"
	end

	if (buildprogress == 100) or (buildprogress == -1) then
		return ReadText(1001, 8418)
	else
		return buildprogress .. " %"
	end
end

function menu.getBuildTime(component)
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		local buildingprocessor = GetComponentData(menu.containerid, "buildingprocessor")
		local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
		return (ismissingresources and "\27Y\27[warning] (" or "(") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(ConvertIDTo64Bit(buildingprocessor)), "%h:%M:%S") .. ")"
	else
		return ""
	end
end

function menu.getShipBuildProgress(ship, name)
	local buildprogress = math.floor(C.GetCurrentBuildProgress(ship))
	if buildprogress == -1 then
		if not menu.refreshnode then
			menu.refreshnode = getElapsedTime()
		end
	end

	if (buildprogress == 100) or (buildprogress == -1) then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

function menu.supplyUpdate(_, container)
	if menu.container == ConvertStringTo64Bit(tostring(container)) then
		if not menu.refreshnode then
			if not menu.noupdate then
				menu.refreshnode = getElapsedTime() + 0.1
			else
				for _, supplytypeentry in ipairs(menu.types) do
					if supplytypeentry.type == "missile" then
						local n = C.GetNumAllMissiles(menu.container)
						local buf = ffi.new("AmmoData[?]", n)
						n = C.GetAllMissiles(buf, n, menu.container)
						for j = 0, n - 1 do
							local macro = ffi.string(buf[j].macro)
							local amount = buf[j].amount

							local idx = menu.getSupplyIdx(menu.supplies[supplytypeentry.type], macro)
							if idx then
								menu.supplies[supplytypeentry.type][idx].stored = amount
							end
						end
					else
						local units = GetUnitStorageData(menu.containerid, supplytypeentry.type)
						for _, entry in ipairs(units) do
							local idx = menu.getSupplyIdx(menu.supplies[supplytypeentry.type], entry.macro)
							if idx then
								menu.supplies[supplytypeentry.type][idx].stored = entry.amount
							end
						end
					end
				end
			end
		end
	end
end

function menu.getSupplyIdx(array, macro)
	for i, entry in ipairs(array) do
		if entry.macro == macro then
			return i
		end
	end
	return nil
end

function menu.updateProductionNode(node, productionmodules)
	local text = node.customdata.nodedata.text
	local ware = node.customdata.nodedata.ware
	local textcolor = Helper.color.white
	local statusicon
	local statusiconmouseovertext = ""
	local statusbgicon
	local statuscolor = Helper.defaultFlowchartOutlineColor
	local outlinecolor = Helper.defaultFlowchartOutlineColor

	local progress = 0

	local macrodata = GetLibraryEntry(GetMacroData(productionmodules.macro, "infolibrary"), productionmodules.macro)
	local makerrace = GetMacroData(productionmodules.macro, "makerrace")
	for i, racestring in ipairs(makerrace) do
		text = text .. " (" .. racestring .. ")"
	end

	local total = #productionmodules.destroyedcomponents + productionmodules.numplanned
	if #productionmodules.destroyedcomponents > 0 then
		statusicon = "lso_warning"
		statuscolor = Helper.color.red
		statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8428)
		textcolor = Helper.color.red
		outlinecolor = Helper.color.grey
	elseif (#productionmodules.components == 0) and (productionmodules.numplanned > 0) then
		statusicon = "lso_build"
		statuscolor = Helper.color.white
		statusiconmouseovertext = ReadText(1001, 8433)
		textcolor = Helper.color.grey
		outlinecolor = Helper.color.grey
	end
	local producing, queued = 0, 0
	local isknown = false
	for _, module in ipairs(productionmodules.components) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local proddata = GetProductionModuleData(module)
			if proddata.state ~= "empty" then
				local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")
				local isqueued = true
				for _, product in ipairs(proddata.products) do
					if product.ware == ware then
						isqueued = false
						break
					end
				end
				if ishacked then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Helper.color.red
						statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8430)
						textcolor = Helper.color.red
						outlinecolor = Helper.color.red
					end
				elseif ispausedmanually then
					if not statusicon then
						statusicon = "lso_pause"
						statuscolor = Helper.color.warningorange
						statusiconmouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1001, 8448)
						textcolor = Helper.color.warningorange
						outlinecolor = Helper.color.warningorange
					end
				elseif not isfunctional then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Helper.color.red
						statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8429)
						textcolor = Helper.color.red
						outlinecolor = Helper.color.red
					end
				elseif (proddata.state == "choosingitem") or (proddata.state == "waitingforstorage") then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Helper.color.red
						statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8432)
					end

					for _, entry in ipairs(proddata.products) do
						menu.storagemissing[entry.ware] = true
					end
				elseif proddata.state == "waitingforresources" then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Helper.color.red
						statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8431)
						textcolor = Helper.color.red
					end
				elseif isqueued then
					queued = queued + 1
				else
					producing = producing + 1
					progress = math.max(progress, math.floor((proddata.cycleprogress * 12 / 100) + 0.5))
				end
				if (not isknown) and C.IsInfoUnlockedForPlayer(module, "production_rate") then
					isknown = true
				end
			end
		end
		if not menu.removedModules[tostring(module)] then
			total = total + 1
		end
	end
	if queued == total then
		if not statusicon then
			statusicon = "lso_pause"
			statuscolor = Helper.color.warningorange
			statusiconmouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1001, 8469)
			textcolor = Helper.color.warningorange
		end
	end
	if producing == total then
		text = "(" .. total .. ") " .. text
	else
		text = "(" .. producing .. "/" .. total .. ") " .. text
	end
	
	if not statusicon then
		if producing > 0 then
			statusicon = string.format("lso_pie_%02d", progress)
			statusiconmouseovertext = ReadText(1001, 1607)
			statusbgicon = "lso_progress"
		end
	end

	if not isknown then
		statusicon = nil
		statusbgicon = nil
	end

	node:updateText(text, textcolor)
	node:updateStatus(nil, statusicon, statusbgicon, statuscolor, statusiconmouseovertext)
	node:updateOutlineColor(outlinecolor)

	local cargo = GetComponentData(menu.containerid, "cargo")

	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == ware then
			proddata = entry
			break
		end
	end

	if #proddata.resources > 0 then
		for _, resourcedata in ipairs(proddata.resources) do
			if resourcedata.amount > (cargo[resourcedata.ware] or 0) then
				menu.resourcesmissing[resourcedata.ware] = true
			end
		end

		for _, edge in ipairs(node.incomingEdges) do
			local storagenode = menu.findStorageNode(edge)
			local edgecolor = Helper.color.white
			if menu.resourcesmissing[storagenode.customdata.nodedata.ware] then
				edgecolor = Helper.color.red
			end
			menu.updateEdgeColorRecursively(edge, edgecolor)
		end
	end
end

function menu.updateProcessingNode(node, processingmodules)
	local text = node.customdata.nodedata.text
	local ware = node.customdata.nodedata.ware
	local textcolor = Helper.color.white
	local statusicon
	local statusiconmouseovertext = ""
	local statusbgicon
	local statuscolor = Helper.defaultFlowchartOutlineColor
	local outlinecolor = Helper.defaultFlowchartOutlineColor

	local progress = 0

	local macrodata = GetLibraryEntry(GetMacroData(processingmodules.macro, "infolibrary"), processingmodules.macro)
	local makerrace = GetMacroData(processingmodules.macro, "makerrace")
	for i, racestring in ipairs(makerrace) do
		text = text .. " (" .. racestring .. ")"
	end
	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == ware then
			proddata = entry
			break
		end
	end

	local total = #processingmodules.destroyedcomponents + processingmodules.numplanned
	if #processingmodules.destroyedcomponents > 0 then
		statusicon = "lso_warning"
		statuscolor = Helper.color.red
		statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8428)
		textcolor = Helper.color.red
		outlinecolor = Helper.color.grey
	elseif (#processingmodules.components == 0) and (processingmodules.numplanned > 0) then
		statusicon = "lso_build"
		statuscolor = Helper.color.white
		statusiconmouseovertext = ReadText(1001, 8433)
		textcolor = Helper.color.grey
		outlinecolor = Helper.color.grey
	end

	local wares = ffi.new("UIWareAmount[?]", 1)
	wares[0].wareid = Helper.ffiNewString(ware)
	wares[0].amount = proddata and proddata.amount or 1
	local isstoragefull = not C.AreWaresWithinContainerProductionLimits(menu.container, wares, 1)

	local producing = 0
	local isknown = false
	for _, module in ipairs(processingmodules.components) do
		-- components that are already being recycled are in state construction
		if not IsComponentConstruction(module) then
			local data = GetProcessingModuleData(module)
			local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")
			if ishacked then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Helper.color.red
					statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8430)
					textcolor = Helper.color.red
					outlinecolor = Helper.color.red
				end
			elseif ispausedmanually then
				if not statusicon then
					statusicon = "lso_pause"
					statuscolor = Helper.color.warningorange
					statusiconmouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1001, 8448)
					textcolor = Helper.color.warningorange
					outlinecolor = Helper.color.warningorange
				end
			elseif not isfunctional then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Helper.color.red
					statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8429)
					textcolor = Helper.color.red
					outlinecolor = Helper.color.red
				end
			elseif data.state == "waitingforstorage" then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Helper.color.red
					statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8432)
				end

				menu.storagemissing[ware] = true
			elseif data.state == "waitingforresources" then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Helper.color.red
					statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8431)
					textcolor = Helper.color.red
				end
			else
				producing = producing + 1
				progress = math.max(progress, math.floor((data.cycleprogress * 12 / 100) + 0.5))
			end
			if (not isknown) and C.IsInfoUnlockedForPlayer(module, "production_rate") then
				isknown = true
			end
		end
		if not menu.removedModules[tostring(module)] then
			total = total + 1
		end
	end
	if producing == total then
		text = "(" .. total .. ") " .. text
	else
		text = "(" .. producing .. "/" .. total .. ") " .. text
	end
	
	if not statusicon then
		if producing > 0 then
			statusicon = string.format("lso_pie_%02d", progress)
			statusiconmouseovertext = ReadText(1001, 7605)
			statusbgicon = "lso_progress"
		else
			statusicon = "mapob_recyclable"
		end
	end

	if not isknown then
		statusicon = nil
		statusbgicon = nil
	end

	node:updateText(text, textcolor)
	node:updateStatus(nil, statusicon, statusbgicon, statuscolor, statusiconmouseovertext)
	node:updateOutlineColor(outlinecolor)

	local cargo = GetComponentData(menu.containerid, "cargo")
	if #proddata.resources > 0 then
		for _, resourcedata in ipairs(proddata.resources) do
			local isprocessed = GetWareData(resourcedata.ware, "isprocessed")
			if (not isprocessed) and (resourcedata.amount > (cargo[resourcedata.ware] or 0)) then
				menu.resourcesmissing[resourcedata.ware] = true
			end
		end

		for _, edge in ipairs(node.incomingEdges) do
			local storagenode = menu.findStorageNode(edge)
			local edgecolor = Helper.color.white
			if menu.resourcesmissing[storagenode.customdata.nodedata.ware] then
				edgecolor = Helper.color.red
			end
			menu.updateEdgeColorRecursively(edge, edgecolor)
		end
	end
end

function menu.updateResearchNode(node, researchmodule)
	local text = node.customdata.nodedata.text
	local textcolor = Helper.color.white
	local statusicon
	local statusiconmouseovertext = ""
	local statusbgicon
	local statuscolor = Helper.defaultFlowchartOutlineColor
	local outlinecolor = Helper.defaultFlowchartOutlineColor

	local proddata = GetProductionModuleData(researchmodule)
	if (proddata.state == "producing") or (proddata.state == "waitingforresources") then
		local progress = math.floor((proddata.cycleprogress * 12 / 100) + 0.5)
	
		if proddata.state == "waitingforresources" then
			statusicon = "lso_warning"
			statuscolor = Helper.color.warningorange
			statusiconmouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8412)
		else
			statusicon = string.format("lso_pie_%02d", progress)
			statusbgicon = "lso_progress"
			statusiconmouseovertext = ReadText(1026, 8411)
		end

		node:updateText(text, textcolor)
		node:updateStatus(nil, statusicon, statusbgicon, statuscolor, statusiconmouseovertext)
		node:updateOutlineColor(outlinecolor)

		if proddata.state == "waitingforresources" then
			local cargo = GetComponentData(menu.containerid, "cargo")
			local resources = GetWareData(proddata.blueprintware, "resources")
			for _, resourcedata in ipairs(resources) do
				if resourcedata.amount > (cargo[resourcedata.ware] or 0) then
					menu.resourcesmissing[resourcedata.ware] = true
				end
			end

			for _, edge in ipairs(node.incomingEdges) do
				local storagenode = menu.findStorageNode(edge)
				local edgecolor = Helper.color.white
				if menu.resourcesmissing[storagenode.customdata.nodedata.ware] then
					edgecolor = Helper.color.red
				end
				menu.updateEdgeColorRecursively(edge, edgecolor)
			end
		end
	end
end

function menu.updateBuildNode(node, buildmodule)
	local ishacked = GetComponentData(ConvertStringTo64Bit(tostring(buildmodule)), "ishacked")
	if ishacked then
		node:updateStatus(nil, "lso_warning", nil, Helper.color.red, Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8426))
	else
		node:updateStatus(nil, nil, nil, nil, "")
	end
end

function menu.updateTerraformingNode(node, project)
	project.project.isongoing = C.IsTerraformingProjectOngoing(project.cluster, project.project.id)
	menu.updateDroneInfo(project.cluster, project.project)
	if project.project.isongoing or ((menu.droneinfo.numbuildsinprogress + menu.droneinfo.numcurrentdeliveries) > 0) then
		node:updateStatus(nil, "lso_pie_00", "lso_progress", Helper.defaultFlowchartOutlineColor, ReadText(1001, 3800))
	else
		node:updateStatus(nil, "lso_warning", nil, Helper.color.red, Helper.convertColorToText(Helper.color.red) .. menu.terraformingErrorText(project))
	end
end

function menu.updateSupplyResourceNode(node, ware)
	local value = menu.getSupplyResourceValue(ware)
	local max = menu.getSupplyResourceMax(ware)
	if max < node.properties.value then
		node:updateValue(value)
	end
	node:updateMaxValue(max)
	node:updateValue(value)

	local hasrestrictions = C.GetContainerTradeRuleID(menu.container, "supply", ware) > 0
	local statusicon = hasrestrictions and "lso_error" or nil
	local statuscolor = hasrestrictions and Helper.color.warningorange or nil
	local statusiconmouseovertext = hasrestrictions and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8404)) or ""
	node:updateStatus(nil, statusicon, nil, statuscolor, statusiconmouseovertext)
end

function menu.updateAccountNode(node)
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = productionmoney + supplymoney + tradewaremoney

	local shownamount = money
	local shownmax = math.max(shownamount, budget)

	if shownamount ~= node.properties.value then
		menu.refreshnode = getElapsedTime()
	end
	if shownmax < node.properties.value then
		node:updateValue(shownamount)
	end
	node:updateMaxValue(shownmax)
	node:updateValue(shownamount)
	
	local statustext = string.format("%s/%s %s", ConvertMoneyString(money, false, true, 3, true, false), ConvertMoneyString(productionmoney + supplymoney + tradewaremoney, false, true, 3, true, false), ReadText(1001, 101))
	local statuscolor = (money < budget) and ((money == 0) and Helper.color.red or Helper.color.warningorange) or Helper.defaultFlowchartOutlineColor
	node:updateStatus(statustext)
	node:updateOutlineColor(statuscolor)
end

function menu.findStorageNode(edge)
	if edge.sourcecell.customdata then
		return edge.sourcecell
	else
		for _, edge in ipairs(edge.sourcecell.incomingEdges) do
			local node = menu.findStorageNode(edge)
			if node then
				return node
			end
		end
	end
end

menu.updateInterval = 0.1

-- hook to update the menu while it is being displayed
function menu.onUpdate()
	if menu.restoreSliderCellInput then
		if type(menu.restoreSliderCellInput) == "table" then
			ActivateSliderCellInput(menu.restoreSliderCellInput.id)
			menu.restoreSliderCellInput = nil
		end
	end

	menu.frame:update()
	if menu.expandedMenuFrame then
		menu.expandedMenuFrame:update()
	end
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	menu.resourcesmissing = {}
	menu.storagemissing = {}
	for _, node in pairs(menu.productionnodes) do
		menu.updateProductionNode(node, node.customdata.moduledata.productionmodules)
	end
	for _, node in pairs(menu.processingnodes) do
		menu.updateProcessingNode(node, node.customdata.moduledata.productionmodules)
	end
	for _, node in pairs(menu.researchnodes) do
		menu.updateResearchNode(node, node.customdata.moduledata.researchmodule)
	end
	for _, node in pairs(menu.buildnodes) do
		if type(node.customdata.moduledata.buildmodule) ~= "table" then
			menu.updateBuildNode(node, node.customdata.moduledata.buildmodule)
		end
	end
	for _, node in pairs(menu.terraformingnodes) do
		menu.updateTerraformingNode(node, node.customdata.moduledata.terraformingproject)
	end
	for _, node in pairs(menu.storagenodes) do
		Helper.updateLSOStorageNode(menu, node, menu.container, node.customdata.nodedata.ware)
	end
	for _, node in pairs(menu.supplyresourcenodes) do
		menu.updateSupplyResourceNode(node, node.customdata.nodedata.ware)
	end
	for _, node in pairs(menu.accountnodes) do
		menu.updateAccountNode(node)
	end

	if menu.refresh then
		menu.refresh = nil

		menu.saveFlowchartState("flowchart", menu.flowchart)
		if menu.keyTable then
			menu.saveTableState("keyTable", menu.keyTable)
		end
		if menu.expandedNode then
			if menu.restoreNodeWare or menu.restoreNodeSupply or menu.restoreNodeSupplyWare or menu.restoreNodeBuildModule then
				menu.saveTableState("nodeTable", menu.expandedMenuTable)
			end
			menu.expandedNode:collapse()
		end
		menu.display()
		return
	end

	if menu.restoreNode and menu.restoreNode.id then
		menu.restoreNode:expand()
		menu.restoreNode = nil
	end

	local curtime = getElapsedTime()
	if menu.refreshnode and (menu.refreshnode < curtime) then
		menu.refreshnode = nil
		menu.updateExpandedNode()
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	if menu.keyTable and (uitable == menu.keyTable.id) then
		if menu.selectedrowdata ~= rowdata then
			menu.selectedrowdata = rowdata
			menu.refresh = true
		end
	end
end

-- hook if the highlighted row is selected
function menu.onSelectElement(table, modified)
end

function menu.closeContextMenu()
	menu.contextTable = nil
	menu.contextFrame = nil
	Helper.clearFrame(menu, config.contextFrameLayer)
	menu.contextMenuData = {}
	menu.contextMenu = nil
end

-- hook if the menu is being closed
function menu.onCloseElement(dueToClose, layer)
	if menu.contextMenu then
		if layer == config.contextFrameLayer then
			menu.closeContextMenu()
		end
		return
	end
	if menu.expandedNode and (dueToClose == "back") then
		menu.expandedNode:collapse()
		return
	end
	if layer == config.expandedMenuFrameLayer then
		menu.expandedNode:collapse()
		return
	end

	if dueToClose == "back" then
		if Helper.checkDiscardStationEditorChanges(menu) then
			return
		end
	end

	if menu.param[3] then
		Helper.closeMenu(menu, dueToClose)
	else
		-- flowchart test through MD conversation
		Helper.closeMenuAndReturn(menu)
	end
	menu.cleanup()
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- cleanup ()
	-- setupFlowchartData_on_start ()
	-- setupFlowchartData_pre_trade_wares_button(remainingcargonodes)
	-- onExpandTradeWares_on_start()
	-- onExpandTradeWares_insert_ware_to_allwares(allwares, ware)
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuertee end

init()
-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
]]

local menu = {
	name = "TopLevelMenu",
	mouseOutBox = {},
}

local config = {
	width = Helper.sidebarWidth,
	height = Helper.sidebarWidth,
	offsetY = 0,
	layer = 2,
	mouseOutRange = 100,
}

-- kuertee start:
menu.callbacks = {}
local pullDownArrowsHeight = Helper.sidebarWidth
local isDisplayed = false
-- end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	menu.init = true
	registerForEvent("gameplanchange", getElement("Scene.UIContract"), menu.onGamePlanChange)
	RegisterEvent("playerUndocked", menu.playerUndocked)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_toplevel.xpl.init - kuertee")
end
-- kuertee end

function menu.onGamePlanChange(_, mode)
	if menu.init then
		if (mode == "cockpit") or (mode == "external") then
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
				OpenMenu("TopLevelMenu", { 0, 0 }, nil)
			end
			menu.init = nil
		elseif (mode == "firstperson") or (mode == "externalfirstperson") then
			menu.init = nil
		end
	else
		if (mode == "firstperson") or (mode == "externalfirstperson") then
			if menu.shown then
				menu.close()
			end
		end
	end
end

function menu.playerUndocked()
	local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
		OpenMenu("TopLevelMenu", { 0, 0 }, nil)
	end
end

function menu.cleanup()
	menu.infoFrame = nil

	menu.showTabs = nil
	menu.over = nil
	menu.mouseOutBox = {}

	if menu.hasRegistered then
		unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
		menu.hasRegistered = nil
	end

	-- kuertee start:
	isDisplayed = false
	-- kuertee end
end

function menu.buttonShowTopLevel()
	menu.showTabs = true
	menu.refresh = getElapsedTime()
end

-- Menu member functions

function menu.onShowMenu()
	C.SetTrackedMenuFullscreen(menu.name, false)
	menu.width = Helper.scaleX(config.width)
	menu.height = Helper.scaleX(config.height)

	-- display info
	menu.createInfoFrame()
end

function menu.createInfoFrame()
	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	local frameProperties = {
		standardButtons = {},
		width = menu.width + 2 * Helper.borderSize,
		x = (Helper.viewWidth - menu.width) / 2,
		y = Helper.scaleY(config.offsetY),
		layer = config.layer,
		startAnimation = false,
		playerControls = true,

		-- kuertee start:
		-- 	useMiniWidgetSystem = (not menu.showTabs) and (not menu.over),
		useMiniWidgetSystem = (not menu.showTabs) and (not menu.over) and (not isDisplayed),
		-- kuertee end

		enableDefaultInteractions = false,
	}
	-- kuertee end

	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)

	local tableProperties = {
		width = menu.width,
		x = Helper.borderSize,
		y = Helper.borderSize,
	}
	
	if menu.showTabs then
		if not menu.hasRegistered then
			menu.hasRegistered = true
			Helper.setTabScrollCallback(menu, menu.onTabScroll)
			registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
		end

		menu.infoFrame.properties.width = Helper.viewWidth
		menu.infoFrame.properties.x = 0
		menu.topLevelHeight, menu.topLevelWidth = Helper.createTopLevelTab(menu, "", menu.infoFrame, "", nil, nil, true)
		menu.infoFrame.properties.height = menu.topLevelHeight + Helper.borderSize

		menu.mouseOutBox = {
			x1 = - menu.topLevelWidth / 2                    - config.mouseOutRange,
			x2 =   menu.topLevelWidth / 2                    + config.mouseOutRange,
			y1 = Helper.viewHeight / 2,
			y2 = Helper.viewHeight / 2 - menu.topLevelHeight - config.mouseOutRange
		}
	else
		if menu.hasRegistered then
			Helper.removeAllTabScrollCallbacks(menu)
			unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
			menu.hasRegistered = nil
		end
		local ftable = menu.createTable(menu.infoFrame, tableProperties)

		-- kuertee start:
		-- menu.infoFrame.properties.height = ftable.properties.y + ftable:getVisibleHeight() + Helper.borderSize
		pullDownArrowsHeight = ftable:getVisibleHeight()
		menu.infoFrame.properties.height = ftable.properties.y + pullDownArrowsHeight + Helper.borderSize
		if menu.callbacks ["createInfoFrame_on_before_frame_display"] then
			for _, callback in ipairs (menu.callbacks ["createInfoFrame_on_before_frame_display"]) do
				callback (menu.infoFrame)
			end
			menu.updateFrameHeight ()
			menu.refresh = getElapsedTime()
		end
		-- kuertee end

	end

	menu.infoFrame:display()
end

function menu.createTable(frame, tableProperties)
	local ftable = frame:addTable(1, { tabOrder = menu.over and 1 or 0, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })

	if menu.over then
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ width = config.width, height = config.height, bgColor = Helper.color.transparent, highlightColor = Helper.color.transparent }):setText("\27[tlt_arrow]", { color = { r = 128, g = 196, b = 255, a = 100 }, halign = "center", fontsize = 18, x = 0, y = 5 })
		row[1].handlers.onClick = menu.buttonShowTopLevel
	else
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText("\27[tlt_arrow]", { width = config.width, height = config.height, color = { r = 64, g = 98, b = 128, a = 100 }, halign = "center", fontsize = 18, x = 0, y = 0 })
	end

	return ftable
end

function menu.onTabScroll(direction)
	Helper.scrollTopLevel(menu, "playerinfo", 1)
end

function menu.onInputModeChanged(_, mode)
	menu.createInfoFrame()
end

function menu.viewCreated(layer, ...)
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	if menu.showTabs and next(menu.mouseOutBox) then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeTabs()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeTabs()
			end
		end
	end

	local curtime = getElapsedTime()
	if menu.lock and (menu.lock + 0.11 < curtime) then
		menu.lock = nil
	end

	if menu.over and (not menu.lock) then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local mouseOutBox = {
				x1 = - menu.width / 2,
				x2 =   menu.width / 2,
				y1 = Helper.viewHeight / 2,
				y2 = Helper.viewHeight / 2 - menu.infoFrame.properties.height,
			}

			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < mouseOutBox.x1) or (curpos[1] > mouseOutBox.x2)) then
				menu.over = false
				menu.lock = getElapsedTime()
				menu.createInfoFrame()
				return
			elseif curpos[2] and ((curpos[2] > mouseOutBox.y1) or (curpos[2] < mouseOutBox.y2)) then
				menu.over = false
				menu.lock = getElapsedTime()
				menu.createInfoFrame()
				return
			end
		end
	end

	if menu.refresh and menu.refresh <= curtime then
		menu.createInfoFrame()


		-- kuertee start: callback
		-- menu.refresh = nil
		local count_contentBeforeCallback = #menu.infoFrame.content
		if menu.callbacks ["createInfoFrame_onUpdate_before_frame_update"] then
			for _, callback in ipairs (menu.callbacks ["createInfoFrame_onUpdate_before_frame_update"]) do
				callback (menu.infoFrame)
			end
		end

		if #menu.infoFrame.content > count_contentBeforeCallback then
			menu.refresh = getElapsedTime()
		else
			menu.refresh = nil
		end
		-- kuertee end: callback

		return
	end

	menu.infoFrame:update()
end

function menu.onTableMouseOut(uitable, row)
	if (not menu.showTabs) and (not menu.lock) then
		menu.over = false
		menu.lock = getElapsedTime()
		menu.createInfoFrame()
	end
end

function menu.onTableMouseOver(uitable, row)
	if (not menu.showTabs) and (not menu.lock) then
		menu.over = true
		menu.lock = getElapsedTime()
		menu.createInfoFrame()
	end
end

function menu.onRowChanged(row, rowdata, uitable)
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.close()
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

function menu.closeTabs()
	menu.showTabs = nil
	menu.over = nil
	menu.lock = getElapsedTime()
	menu.refresh = getElapsedTime()
end

function menu.onCloseElement(dueToClose, layer)
	if menu.showTabs then
		menu.closeTabs()
	elseif layer == nil then
		Helper.closeMenu(menu, dueToClose)
		menu.cleanup()
	else
		Helper.closeMenuAndOpenNewMenu(menu, "OptionsMenu", nil)
		menu.cleanup()
	end
end

-- menu helpers

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- createInfoFrame_on_before_frame_display (frame)
	-- createInfoFrame_onUpdate_before_frame_update (frame)
	-- {ftables = {created ftable 1, created ftable 2, ...}} = kHUD_add_HUD_tables (frame)
	-- kHUD_update_HUD_tables (frame, {created ftable 1, created ftable 2, ...})
	--
	if menu.callbacks [callbackName] == nil then
		menu.callbacks [callbackName] = {}
	end
	table.insert (menu.callbacks [callbackName], callbackFunction)
end

function menu.requestUpdate (adj)
	if adj == nil then
		adj = 0
	end
	if menu.refresh == nil then
		menu.refresh = getElapsedTime () + adj
	end
end

function menu.updateFrameHeight ()
	local yBottomMax = 0
	local yBottomFTable = 0
	local frame = menu.infoFrame
	local ftable
	for i = 1, #frame.content do
		if frame.content [i].type == "table" then
			ftable = frame.content [i]
			yBottomFTable = ftable.properties.y + ftable:getVisibleHeight ()
			if yBottomFTable > yBottomMax then
				yBottomMax = yBottomFTable
			end
		end
	end
	local frameHeight = yBottomMax - frame.properties.y
	isDisplayed = false
	if menu.infoFrame.properties.height ~= frameHeight then
		menu.infoFrame.properties.height = frameHeight
		menu.height = Helper.scaleX (frameHeight)
		isDisplayed = true
	end
end
-- kuertee end

init()
﻿-- param == { 0, 0, container }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	bool IsComponentOperational(UniverseID componentid);
	bool IsMouseEmulationActive(void);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
]]

local menu = {
	name = "TransactionLogMenu",
	lastRefreshTime = 0,
}

local config = {
	infoLayer = 4,
	contextLayer = 2,
	mouseOutRange = 100,
}

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_transactionlog.xpl.init - kuertee")
end
-- kuertee end

function menu.cleanup()
	menu.infoFrame = nil
	menu.sidebar = nil

	-- start: kuertee call-back
	if callbacks ["cleanup"] then
		for _, callback in ipairs (callbacks ["cleanup"]) do
			callback ()
		end
	end
	-- end: kuertee call-back
end

-- widget scripts

function menu.buttonRightBar(newmenu, params)
	Helper.closeMenuAndOpenNewMenu(menu, newmenu, params, true)
	menu.cleanup()
end

function menu.buttonContainerInfo(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", controllable } })
	menu.cleanup()
end

function menu.buttonTransactionLog(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, controllable });
	menu.cleanup()
end

-- Menu member functions

function menu.onShowMenu()
	-- Init
	menu.containerid = menu.param[3]
	menu.container = ConvertIDTo64Bit(menu.containerid)

	menu.isstation = C.IsRealComponentClass(menu.container, "station")

	menu.selectedRows = {}

	-- display main frame
	menu.createFrame()
end

function menu.createFrame(toprow, selectedrow)
	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	local frameProperties = {
		layer = config.infoLayer,
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { back = true, close = true, help = true  }
	}
	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)

	menu.sidebarWidth = Helper.scaleX(Helper.sidebarWidth)

	if menu.isstation then
		local rightbartable = Helper.createRightSideBar(menu.infoFrame, menu.container, true, "transactions", menu.buttonRightBar)
		rightbartable:addConnection(1, 4, true)
	end

	local tableProperties = {
		width = Helper.playerInfoConfig.width * 5 / 4,
		height = Helper.viewHeight - 2 * Helper.frameBorder,
		x = Helper.frameBorder,
		y = Helper.frameBorder,
		x2 = menu.isstation and (menu.sidebarWidth + Helper.borderSize + Helper.frameBorder) or Helper.frameBorder,
	}
	local selection = {}
	if menu.infoTable then
		selection = { toprow = toprow or GetTopRow(menu.infoTable), selectedrow = selectedrow or Helper.currentTableRow[menu.infoTable] }
	end
	Helper.createTransactionLog(menu.infoFrame, menu.container, tableProperties, menu.createFrame, selection)

	-- start: kuertee call-back
	if callbacks ["createFrame_on_create_transaction_log"] then
			for _, callback in ipairs (callbacks ["createFrame_on_create_transaction_log"]) do
				callback ()
			end
		end
	-- end: kuertee call-back

	menu.infoFrame:display()
	menu.lastRefreshTime = getElapsedTime()
end

function menu.createContextFrame(data, x, y, width, nomouseout)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local contextmenuwidth = width or menu.contextMenuWidth

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
		standardButtons = { close = true },
		width = contextmenuwidth,
		x = x,
		y = 0,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 4, highlightMode = "off" })
	local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[data]
	if entryIdx == nil then
		return
	end
	local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
	local active = (entry.partner ~= 0) and C.IsComponentOperational(entry.partner)

	local row = ftable:addRow(false, { fixed = true })
	local text = TruncateText(entry.partnername, Helper.standardFontBold, Helper.scaleFont(Helper.standardFontBold, Helper.headerRow1FontSize), contextmenuwidth - 2 * Helper.scaleX(Helper.standardButtonWidth))
	row[1]:createText(text, Helper.headerRowCenteredProperties)
	row[1].properties.mouseOverText = entry.partnername

	row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:createButton({ active = active, bgColor = active and Helper.color.transparent or Helper.color.darkgrey }):setText(ReadText(1001, 2427), { color = active and Helper.color.white or Helper.color.lightgrey })
	row[1].handlers.onClick = function () return menu.buttonContainerInfo(entry.partner) end

	if active and GetComponentData(ConvertStringTo64Bit(tostring(entry.partner)), "isplayerowned") then
		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createButton({ active = active, bgColor = active and Helper.color.transparent or Helper.color.darkgrey }):setText(ReadText(1001, 7702), { color = active and Helper.color.white or Helper.color.lightgrey })
		row[1].handlers.onClick = function () return menu.buttonTransactionLog(entry.partner) end
	end

	if menu.contextFrame.properties.x + contextmenuwidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - contextmenuwidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()

	if not nomouseout then
		menu.mouseOutBox = {
			x1 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2                    - config.mouseOutRange,
			x2 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2 + contextmenuwidth + config.mouseOutRange,
			y1 = - menu.contextFrame.properties.y + Helper.viewHeight / 2                    + config.mouseOutRange,
			y2 = - menu.contextFrame.properties.y + Helper.viewHeight / 2 - height           - config.mouseOutRange
		}
	end
end

function menu.viewCreated(layer, ...)
	if menu.isstation then
		menu.sidebar, menu.infoTable = ...
	else
		menu.infoTable = ...
	end
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	Helper.onTransactionLogUpdate()
	menu.infoFrame:update()

	if not Helper.transactionLogData.noupdate then
		local curtime = getElapsedTime()
		if curtime > menu.lastRefreshTime + 10 then
			menu.createFrame()
		end
	end

	if menu.mouseOutBox then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeContextMenu()
			end
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	if uitable == menu.infoTable then
		Helper.onTransactionLogRowChanged(rowdata)
	end
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.onEditBoxActivated(widget)
	Helper.onTransactionLogEditBoxActivated(widget)
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if uitable == menu.infoTable then
		local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]

		local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[rowdata]
		if entryIdx == nil then
			return
		end
		local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
		if entry.partnername ~= "" then
			local x, y = GetLocalMousePosition()
			if x == nil then
				-- gamepad case
				x = posx
				y = -posy
			end
			menu.contextMenuMode = "transactionlog"
			menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y, Helper.scaleX(260))
		end
	end
end

function menu.closeContextMenu()
	Helper.clearFrame(menu, config.contextLayer)
	menu.contextMenuMode = nil
	menu.mouseOutBox = nil
end

function menu.onCloseElement(dueToClose)
	if dueToClose == "back" then
		if menu.contextMenuMode then
			menu.closeContextMenu()
			return
		end

		if Helper.checkDiscardStationEditorChanges(menu) then
			return
		end
	end

	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- createFrame_on_create_transaction_log ()
	-- cleanup()
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuertee end

init()
﻿-- param == { 0, 0, transporter, transporterconnection }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef struct {
		const char* factionID;
		const char* factionName;
		const char* factionIcon;
	} FactionDetails;
	typedef struct {
		UniverseID component;
		const char* connection;
	} UIComponentSlot;
	typedef uint64_t UniverseID;
	const char* GetActiveObjectiveType(void);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	UniverseID GetContextForTransporterCheck(UniverseID positionalid);
	UniverseID GetSlotComponent(UIComponentSlot slot);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumValidTransporterTargets2(UniverseID componentid, UIComponentSlot currentlocation);
	const char* GetObjectIDCode(UniverseID objectid);
	FactionDetails GetOwnerDetails(UniverseID componentid);
	UniverseID GetRoomForTransporter(UIComponentSlot transporter);
	UniverseID GetTransporterLocationComponent(UIComponentSlot transporter);
	const char* GetTransporterLocationName(UIComponentSlot transporter);
	uint32_t GetValidTransporterTargets2(UIComponentSlot* result, uint32_t resultlen, UniverseID componentid, UIComponentSlot currentlocation);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsShipAtExternalDock(UniverseID shipid);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	void TransportPlayerToTarget(UIComponentSlot target);
]]

local menu = {
	name = "TransporterMenu",
	white = { r = 255, g = 255, b = 255, a = 100 },
	red = { r = 255, g = 0, b = 0, a = 100 },
	green = { r = 0, g = 255, b = 0, a = 100 },
	transparent = { r = 0, g = 0, b = 0, a = 0 },
	extendedcategories = {
		["ships"] = true,
		["npcs"] = true,
	},
}

local config = {
	sortOrder = {
		["dyninterior"] = 1,
		["cockpit"] = 2,
		["shipinterior"] = 3,
		["walkablemodule"] = 4,
		["ship"] = 5,
		["parent"] = 6,
		["zone"] = 7,
	},
	roomClassSortOrder = {
		["room"] = 1,
		["dockingbay"] = 2,
	},
}

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_transporter.xpl.init - kuertee")
end
-- kuertee end

function menu.cleanup()
	menu.transportercomponent = nil
	menu.transporterconnection = nil
	menu.targets = {}
	menu.currentselection = nil
	menu.npcs = {}
	menu.extendInfo = nil
	
	menu.refresh = nil
	
	menu.pretoprow = nil
	menu.preselectrow = nil

	menu.infotable = nil
	menu.selecttable = nil
end

-- Menu member functions

function menu.buttonGoTo()
	if not menu.currentselection.hassubentries then
		if (menu.transportercomponent ~= menu.currentselection.target.component) or (menu.transporterconnection ~= menu.currentselection.target.connection) then
			if C.IsComponentClass(menu.currentselection.target.component, "zone") then
				-- space suit case
				Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "transporter", { menu.currentselection.target.component, menu.currentselection.target.connection } })
			else
				C.TransportPlayerToTarget(menu.currentselection.target)
				Helper.closeMenuAndReturn(menu)
			end
			menu.cleanup()
		end
	end
end

function menu.buttonExtendCategory(category)
	if menu.extendedcategories[category] then
		menu.extendedcategories[category] = nil
	else
		menu.extendedcategories[category] = true
	end
	menu.pretoprow = GetTopRow(menu.selecttable)
	menu.preselectrow = Helper.currentTableRow[menu.selecttable]
	menu.display()
end

function menu.buttonExpand(category)
	menu.extendInfo = not menu.extendInfo
	menu.pretoprow = GetTopRow(menu.selecttable)
	menu.preselectrow = Helper.currentTableRow[menu.selecttable]
	menu.display()
end

function menu.onShowMenu()
	C.SetTrackedMenuFullscreen(menu.name, false)
	menu.transportercomponent = ConvertIDTo64Bit(menu.param[3])
	menu.transporterconnection = ffi.string(menu.param[4])

	menu.extendInfo = false

	menu.topcontext = menu.transportercomponent
	while true do
		if C.IsComponentClass(menu.topcontext, "ship_m") or C.IsComponentClass(menu.topcontext, "ship_s") then
			break
		end
		local context = C.GetContextByClass(menu.topcontext, "container", false)
		if context ~= 0 then
			menu.topcontext = context
		else
			break
		end
	end

	menu.targets = {}
	local targets = {}
	if menu.transportercomponent ~= 0 then
		local curLocationSlot = ffi.new("UIComponentSlot")
		curLocationSlot.component = menu.transportercomponent
		curLocationSlot.connection = menu.transporterconnection

		local n = C.GetNumValidTransporterTargets2(menu.transportercomponent, curLocationSlot)
		local buf = ffi.new("UIComponentSlot[?]", n)
		n = C.GetValidTransporterTargets2(buf, n, menu.transportercomponent, curLocationSlot)
		local found = false
		for i = 0, n - 1 do
			local component = buf[i].component
			local connection = ffi.string(buf[i].connection)
			table.insert(targets, { component = component, connection = connection })
			if (component == menu.transportercomponent) and (connection == menu.transporterconnection) then
				found = true
			end
		end
		if not found then
			table.insert(targets, { component = menu.transportercomponent, connection = menu.transporterconnection })
		end
	end

	for _, target in ipairs(targets) do
		local iscurrent
		if menu.transportercomponent == target.component and menu.transporterconnection == target.connection then
			iscurrent = true
		end
		local parent = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(target.component)), "parent"))
		if C.IsComponentClass(parent, "walkablemodule") then
			local containercontext = C.GetContextByClass(parent, "container", false)
			if containercontext == menu.topcontext then
				local i = menu.findArrayEntry(menu.targets, parent)
				if i == nil then
					table.insert(menu.targets, { type = "walkablemodule", component = parent, directtarget = target, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
					menu.extendedcategories[tostring(parent)] = true
				else
					if iscurrent then
						menu.targets[i].iscurrent = iscurrent
					end
					table.insert(menu.targets[i].subtargets, target)
				end
			else
				local i = menu.findArrayEntry(menu.targets, containercontext)
				if i == nil then
					table.insert(menu.targets, { type = "walkablemodule", component = containercontext, subtargets = {}, subcomponents = { { component = parent, directtarget = target, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent } } })
					menu.extendedcategories[tostring(containercontext)] = true
				else
					local subcomponents = menu.targets[i].subcomponents
					local j = menu.findArrayEntry(subcomponents, parent)
					if j == nil then
						table.insert(subcomponents, { type = "walkablemodule", component = parent, directtarget = target, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
						menu.extendedcategories[tostring(parent)] = true
					else
						if iscurrent then
							subcomponents[j].iscurrent = iscurrent
						end
						table.insert(subcomponents[j].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(parent, "ship") then
			local iscockpit, isexit = false, false
			local room = C.GetRoomForTransporter(target)
			if room ~= 0 then
				if C.IsComponentClass(room, "cockpit") then
					iscockpit = true
				elseif C.GetContextByClass(room, "container", false) ~= parent then
					isexit = true
				end
			end
			if isexit then
				-- If ship is mission target, the exit should not be highlighted as mission target
				local shipismissiontarget = GetComponentData(ConvertStringTo64Bit(tostring(parent)), "ismissiontarget")
				table.insert(menu.targets, { type = "parent", component = C.GetContextByClass(parent, "container", false), directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent, nomissiontarget = shipismissiontarget })
			else
				local i = menu.findArrayEntry(menu.targets, parent)
				if i == nil then
					if iscockpit then
						local type = "ship"
						local subtarget = target
						if parent == menu.topcontext then
							type = "cockpit"
							subtarget = nil
						end
						table.insert(menu.targets, { type = type, component = parent, directtarget = target, subtargets = { subtarget }, subcomponents = {}, iscurrent = iscurrent })
					else
						table.insert(menu.targets, { type = "ship", component = parent, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
					end
					menu.extendedcategories[tostring(parent)] = true
				else
					if iscurrent then
						menu.targets[i].iscurrent = iscurrent
					end
					if iscockpit then
						if parent == menu.topcontext then
							menu.targets[i].type = "cockpit"
						else
							table.insert(menu.targets[i].subtargets, target)
						end
						menu.targets[i].directtarget = target
					else
						table.insert(menu.targets[i].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(parent, "navcontext") then
			local containercontext = C.GetContextByClass(parent, "container", true)
			if containercontext == menu.topcontext then
				table.insert(menu.targets, { type = "dyninterior", component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
			else
				local i = menu.findArrayEntry(menu.targets, containercontext)
				if i == nil then
					table.insert(menu.targets, { type = "ship", component = containercontext, subtargets = {}, subcomponents = { { component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent } } })
					menu.extendedcategories[tostring(containercontext)] = true
				else
					local subcomponents = menu.targets[i].subcomponents
					local j = menu.findArrayEntry(subcomponents, parent)
					if j == nil then
						table.insert(subcomponents, { type = "ship", component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
						menu.extendedcategories[tostring(parent)] = true
					else
						if iscurrent then
							subcomponents[j].iscurrent = iscurrent
						end
						table.insert(subcomponents[j].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(parent, "ventureplatform") then
			table.insert(menu.targets, { type = "dyninterior", component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
		elseif C.IsComponentClass(target.component, "ship") then
			local iscockpit, isexit = false, false
			local room = C.GetRoomForTransporter(target)
			if room ~= 0 then
				if C.IsComponentClass(room, "cockpit") then
					iscockpit = true
				elseif C.GetContextByClass(room, "container", false) ~= parent then
					isexit = true
				end
			end
			if isexit then
				-- If ship is mission target, the exit should not be highlighted as mission target
				local shipismissiontarget = GetComponentData(ConvertStringTo64Bit(tostring(target.component)), "ismissiontarget")
				table.insert(menu.targets, { type = "parent", component = C.GetContextByClass(parent, "container", false), directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent, nomissiontarget = shipismissiontarget })
			else
				local i = menu.findArrayEntry(menu.targets, target.component)
				if i == nil then
					if iscockpit then
						local subtarget = target
						if target.component == menu.topcontext then
							subtarget = nil
						end
						table.insert(menu.targets, { type = "cockpit", component = target.component, directtarget = target, subtargets = { subtarget }, subcomponents = {}, iscurrent = iscurrent })
					else
						table.insert(menu.targets, { type = "shipinterior", component = target.component, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
					end
					menu.extendedcategories[tostring(target.component)] = true
				else
					if iscurrent then
						menu.targets[i].iscurrent = iscurrent
					end
					if iscockpit then
						menu.targets[i].type = "cockpit"
						menu.targets[i].directtarget = target
						if target.component ~= menu.topcontext then
							table.insert(menu.targets[i].subtargets, target)
						end
					else
						table.insert(menu.targets[i].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(target.component, "zone") then
			table.insert(menu.targets, { type = "zone", component = menu.topcontext, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
		end
	end
	table.sort(menu.targets, menu.sortTargets)

	for _, target in ipairs(menu.targets) do
		table.sort(target.subtargets, menu.sortSubTargets)
	end
	menu.currentselection = {}
	menu.currentselection.target = ffi.new("UIComponentSlot")
	menu.currentselection.target.component = menu.transportercomponent
	menu.currentselection.target.connection = menu.transporterconnection

	menu.display()
end

function menu.onShowMenuSound()
	-- no sound
end

function menu.sortTargets(a, b)
	if config.sortOrder[a.type] == config.sortOrder[b.type] then
		if a.directtarget and b.directtarget then
			return ffi.string(C.GetTransporterLocationName(a.directtarget)) < ffi.string(C.GetTransporterLocationName(b.directtarget))
		end
		return a.directtarget and not b.directtarget
	end
	return config.sortOrder[a.type] < config.sortOrder[b.type]
end

function menu.sortSubTargets(a, b)
	local aroom = ffi.string(C.GetComponentClass(C.GetRoomForTransporter(a)))
	local broom = ffi.string(C.GetComponentClass(C.GetRoomForTransporter(b)))
	if aroom == broom then
		return menu.getSubTargetName(a) < menu.getSubTargetName(b)
	end
	return (config.roomClassSortOrder[aroom] or 0) < (config.roomClassSortOrder[broom] or 0)
end

function menu.getSubTargetName(subtarget)
	local display = true
	local name = ffi.string(C.GetTransporterLocationName(subtarget))
	local objectid, icon, isship
	local room = C.GetRoomForTransporter(subtarget)
	if room ~= 0 then
		local dockedships = {}
		if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, "player")
			if #dockedships > 0 then
				name = ffi.string(C.GetComponentName(dockedships[1]))
				objectid = ffi.string(C.GetObjectIDCode(dockedships[1]))
				icon = GetComponentData(ConvertStringTo64Bit(tostring(dockedships[1])), "icon")
				isship = true
			else
				name = ffi.string(C.GetComponentName(room))
				display = GetComponentData(ConvertStringTo64Bit(tostring(room)), "ismissiontarget")
			end
		end
	end

	return name, objectid, display, icon, isship
end

function menu.hasShipOrRoomMissionTarget(subtarget)
	local room = C.GetRoomForTransporter(subtarget)
	if room ~= 0 then
		if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
			local dockedships = {}
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, "player")
			if #dockedships > 0 then
				return GetComponentData(ConvertStringTo64Bit(tostring(dockedships[1])), "ismissiontarget")
			end
		end
		return GetComponentData(ConvertStringTo64Bit(tostring(room)), "ismissiontarget")
	end
end

function menu.findArrayEntry(array, component)
	for i, entry in ipairs(array) do
		if entry.component == component then
			return i
		end
	end
end

function menu.addEntry(ftable, target, indent, parentcomponent)
	local componentIndent = ""
	local subtargetIndent = "   "
	for i = 1, indent do
		componentIndent = componentIndent .. "   "
		subtargetIndent = subtargetIndent .. "   "
	end

	local displaysubtargets = false
	for _, subtarget in ipairs(target.subtargets) do
		local display = true
		local room = C.GetRoomForTransporter(subtarget)
		if room ~= 0 then
			local dockedships = {}
			if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
				Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, "player")
				if #dockedships == 0 then
					display = false
				end
			end
		end
		if display then
			displaysubtargets = true
			break
		end
	end

	local row = ftable:addRow({ target = target.directtarget, issubtarget = false, hassubentries = (#target.subcomponents > 0) or displaysubtargets }, { bgColor = Helper.color.transparent })
	local name = ffi.string(C.GetComponentName(target.component))

	local font = Helper.standardFont
	local color = menu.white
	if GetComponentData(ConvertStringTo64Bit(tostring(target.component)), "isplayerowned") then
		color = menu.green
	end
	local objectid
	if C.IsComponentClass(target.component, "ship") then
		objectid = ffi.string(C.GetObjectIDCode(target.component))
	end
	if target.component == menu.topcontext then
		name = ffi.string(C.GetTransporterLocationName(target.directtarget))
		if menu.checkPlayerProperty(target.directtarget) then
			color = menu.green
		end
	end
	local current = ""
	if target.iscurrent then
		current = " [" .. ReadText(1001, 6301) .. "]"
		if not menu.preselectrow then
			menu.preselectrow = row.index
		end
	end
	if target.directtarget then
		local ismissiontarget = false
		if ffi.string(C.GetActiveObjectiveType()) == "usespacesuit" then
			ismissiontarget = target.type == "zone"
		else
			local locationcomponent = C.GetTransporterLocationComponent(target.directtarget) -- Note: context can be NULL if the component is a zone, which is the case for the space suit target
			ismissiontarget = (locationcomponent ~= 0) and (not displaysubtargets) and (not target.nomissiontarget) and GetComponentData(ConvertStringTo64Bit(tostring(locationcomponent)), "ismissiontarget")
		end
		if ismissiontarget then
			font = Helper.standardFontBold
			color = Helper.color.mission
		end
		if (menu.currentselection.target == target.directtarget) then
			menu.buttontext = ReadText(1001, 6303)
			if (target.type == "ship") or (target.type == "cockpit") then
				if C.IsComponentClass(target.component, "ship_m") or C.IsComponentClass(target.component, "ship_s") then
					menu.infotext = string.format(ReadText(1001, 6308), ffi.string(C.GetComponentName(target.component)))
				elseif C.IsComponentClass(target.component, "navcontext") then
					menu.infotext = string.format(ReadText(1001, 6306), name)
				else
					menu.infotext = string.format(ReadText(1001, 6307), ffi.string(C.GetComponentName(target.component)))
				end
			elseif target.type == "parent" then
				menu.infotext = ReadText(1001, 6309)
			elseif target.type == "zone" then
				menu.infotext = ReadText(1001, 6311)
				menu.buttontext = ReadText(1001, 6312)
			elseif target.type == "dyninterior" then
				menu.infotext = string.format(ReadText(1001, 6306), name)
			elseif target.type == "walkablemodule" then
				menu.infotext = string.format(ReadText(1001, 6305), ffi.string(C.GetComponentName(parentcomponent)))
			end
		end
	end
	--[[ collapsing support disabled for now for better controller support
	if (#target.subcomponents > 0) or displaysubtargets then
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(menu.extendedcategories[tostring(target.component)] and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonExtendCategory(tostring(target.component)) end
	end --]]

	-- kuertee start: callback
	if callbacks ["addEntry_on_set_room_name"] then
		local result
		for _, callback in ipairs (callbacks ["addEntry_on_set_room_name"]) do
			result = callback (name, target)
			if result then
				-- DebugError ("kuertee_menu_transporter.addEntry_on_set_room_name name pre " .. tostring (name))
				name = result.name
				-- DebugError ("kuertee_menu_transporter.addEntry_on_set_room_name name post " .. tostring (name))
			end
		end
	end
	-- kuertee end: callback

	if objectid then
		row[2]:createText(componentIndent .. name .. current, { color = color, font = font })
		row[3]:createText(objectid, { color = color, font = font, halign = "right" })
	else
		row[2]:setColSpan(2):createText(componentIndent .. name .. current, { color = color, font = font })
	end

	if menu.extendedcategories[tostring(target.component)] then
		local hasmissionshipsubtarget = false
		for _, subtarget in ipairs(target.subtargets) do
			if menu.hasShipOrRoomMissionTarget(subtarget) then
				hasmissionshipsubtarget = true
				break
			end
		end

		for _, subtarget in ipairs(target.subtargets) do
			local name, objectid, display, icon, isship = menu.getSubTargetName(subtarget)

			local font = Helper.standardFont
			local color = menu.white
			if menu.checkPlayerProperty(subtarget) then
				color = menu.green
			end
			if hasmissionshipsubtarget then
				if menu.hasShipOrRoomMissionTarget(subtarget) then
					font = Helper.standardFontBold
					color = Helper.color.mission
				end
			else
				if isship then
					local context = C.GetContextForTransporterCheck(subtarget.component) -- Note by Matthias: context can be NULL if the component is a zone, which is the case for the space suit target
					if (context ~= 0) and GetComponentData(ConvertStringTo64Bit(tostring(context)), "ismissiontarget") then
						font = Helper.standardFontBold
						color = Helper.color.mission
					end
				else
					local locationcomponent = C.GetTransporterLocationComponent(subtarget) -- Note: context can be NULL if the component is a zone, which is the case for the space suit target
					if (locationcomponent ~= 0) and GetComponentData(ConvertStringTo64Bit(tostring(locationcomponent)), "ismissiontarget") then
						font = Helper.standardFontBold
						color = Helper.color.mission
					end
				end
			end

			if display then
				local row = ftable:addRow({ target = subtarget, issubtarget = true }, { bgColor = Helper.color.transparent })
				local current = ""
				if menu.transportercomponent == subtarget.component and menu.transporterconnection == subtarget.connection then
					current = " [" .. ReadText(1001, 6301) .. "]"
					if not menu.preselectrow then
						menu.preselectrow = row.index
					end
				end
				if (menu.currentselection.target == subtarget) and (menu.currentselection.issubtarget == true) then
					menu.infotext = string.format(ReadText(1001, 6310), name)
				end

				if objectid then
					row[2]:createText(subtargetIndent .. string.format("\027[%s] %s", icon, name) .. current, { color = color, font = font })
					row[3]:createText(objectid, { color = color, font = font, halign = "right" })
				else
					row[2]:setColSpan(2):createText(subtargetIndent .. name .. current, { color = color, font = font })
				end
			end
		end

		for _, subcomponent in ipairs(target.subcomponents) do
			menu.addEntry(ftable, subcomponent, indent + 1, target.component)
		end
	end
end

function menu.display()
	-- remove old data
	Helper.clearDataForRefresh(menu)

	local width = Helper.scaleX(720)
	local height = Helper.scaleY(400)

	local frame = Helper.createFrameHandle(menu, {
		width = (menu.extendInfo and 1 or 0.5) * width + 2 * Helper.borderSize,
		height = height + 2 * Helper.borderSize,
		x = (Helper.viewWidth - 0.5 * width) / 2,
		y = (Helper.viewHeight - height) / 2,
		backgroundID = "solid",
		backgroundColor = Helper.color.semitransparent,
	})

	menu.infotext = ""

	local ftable = frame:addTable(3, { tabOrder = 1, width = 0.5 * width, x = Helper.borderSize, y = Helper.borderSize })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidthPercent(3, 20)

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 6302), Helper.headerRow1Properties)

	local row = ftable:addRow(false, {  })
	row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.topcontext)), Helper.subHeaderTextProperties)

	for _, target in ipairs(menu.targets) do
		menu.addEntry(ftable, target, 0, menu.topcontext)
	end

	ftable:setTopRow(menu.pretoprow)
	ftable:setSelectedRow(menu.preselectrow)
	menu.pretoprow = nil
	menu.preselectrow = nil

	local buttontable = frame:addTable(3, { tabOrder = 3, width = 0.5 * width, x = Helper.borderSize, skipTabChange = true })
	buttontable:setColWidth(1, 0.25 * width, false)
	local iconsize = Helper.scaleY(2 * Helper.standardTextHeight)
	buttontable:setColWidth(3, iconsize, false)

	local buttonrow = buttontable:addRow(true, { fixed = true })
	buttonrow[1]:setColSpan(2):createText(menu.infotext, { minRowHeight = 2 * Helper.standardTextHeight, wordwrap = true })
	local textheight = buttonrow[1]:getMinTextHeight(true)
	buttonrow[3]:createButton({ height = textheight, scaling = false }):setIcon(menu.extendInfo and "widget_arrow_left_01" or "widget_arrow_right_01", { width = iconsize, height = iconsize, y = (textheight - iconsize) / 2 })
	buttonrow[3].handlers.onClick = menu.buttonExpand

	local buttonrow = buttontable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	local active = (not menu.currentselection.hassubentries) and ((menu.transportercomponent ~= menu.currentselection.target.component) or (menu.transporterconnection ~= menu.currentselection.target.connection))

	-- kuertee start: callback
	if callbacks ["display_on_set_room_active"] then
		local activeCount = 0
		local callbacksCount = 0
		local result
		for _, callback in ipairs (callbacks ["display_on_set_room_active"]) do
			callbacksCount = callbacksCount + 1
			result = callback (active)
			if result and result.active then
				activeCount = activeCount + 1
			end
		end
		active = activeCount == callbacksCount
	end
	-- kuertee end: callback

	buttonrow[2]:setColSpan(2):createButton({ active = active, height = Helper.standardTextHeight }):setText(menu.buttontext, { halign = "center" })
	buttonrow[2].handlers.onClick = menu.buttonGoTo

	-- kuertee start: callback
	if callbacks ["display_on_set_buttontable"] then
		for _, callback in ipairs (callbacks ["display_on_set_buttontable"]) do
			callback (buttontable)
		end
	end
	-- kuertee end: callback

	buttontable.properties.y = height + Helper.borderSize - buttontable:getFullHeight()
	ftable.properties.maxVisibleHeight = buttontable.properties.y

	if menu.extendInfo then
		local infotable = frame:addTable(4, { tabOrder = 2, width = width - ftable.properties.width - Helper.borderSize, x = ftable.properties.x + ftable.properties.width + Helper.borderSize, y = Helper.borderSize, highlightMode = "off", skipTabChange = true })
		infotable:setColWidth(1, Helper.standardTextHeight)
		infotable:setColWidthPercent(3, 25)
		infotable:setColWidthPercent(4, 30)

		local row = infotable:addRow(false, { fixed = true })
		row[1]:setColSpan(4):createText(ReadText(1001, 2427), Helper.headerRow1Properties)

		menu.room = C.GetRoomForTransporter(menu.currentselection.target)
		if menu.room ~= 0 then
			--- SHIPS ---
			local internalstoragecontext
			if not menu.currentselection.issubtarget then
				internalstoragecontext = C.GetContextByClass(menu.room, "container", false)
			end
			local dockedships = {}
			if menu.currentselection.issubtarget then
				if ffi.string(C.GetComponentClass(menu.room)) == "dockingbay" then
					Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.room, "player")
					if #dockedships > 0 then
						internalstoragecontext = dockedships[1]
					end
				end
			end

			dockedships = {}
			if internalstoragecontext then
				Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, internalstoragecontext, "player")
				for i = #dockedships, 1, -1 do
					if C.IsShipAtExternalDock(dockedships[i]) then
						table.remove(dockedships, i)
					end
				end
			end
			
			if #dockedships > 0 then
				local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createButton():setText(menu.extendedcategories["ships"] and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendCategory("ships") end
				row[2]:setColSpan(3):createText(ReadText(1001, 6304), Helper.subHeaderTextProperties)
				if menu.extendedcategories["ships"] then
					table.sort(dockedships, Helper.sortUniverseIDName)
					for _, ship in ipairs(dockedships) do
						local ship64 = ConvertStringTo64Bit(tostring(ship))
						local font = Helper.standardFont
						local color = menu.white
						local shiptext = ffi.string(C.GetComponentName(ship))
						local objectid = ffi.string(C.GetObjectIDCode(ship))
						local ismissiontarget, isplayerowned = GetComponentData(ship64, "ismissiontarget", "isplayerowned")

						if ismissiontarget then
							font = Helper.standardFontBold
							color = Helper.color.mission
						elseif isplayerowned then
							color = menu.green
						end
						local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
						row[2]:setColSpan(2):createText(shiptext, { color = color, font = font })
						row[4]:createText(objectid, { color = color, font = font, halign = "right" })
					end
				end
			end

			--- NPCS ---
			dockedships = {}
			if ffi.string(C.GetComponentClass(menu.room)) == "dockingbay" then
				Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.room, nil)
			end
			menu.npcs = menu.getNPCs(menu.room, dockedships, menu.currentselection.issubtarget)
			if #menu.npcs > 0 then
				local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
				row[1]:createButton():setText(menu.extendedcategories["npcs"] and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendCategory("npcs") end
				row[2]:setColSpan(3):createText(ReadText(1001, 6300), Helper.subHeaderTextProperties)
				if menu.extendedcategories["npcs"] then
					for _, npc in ipairs(menu.npcs) do
						local name, typestring, typeicon, typename, isenemy, isplayerowned, ismissiontarget, postname, rolename = GetComponentData(npc, "name", "typestring", "typeicon", "typename", "isenemy", "isplayerowned", "ismissiontarget", "postname", "rolename")
						local font = Helper.standardFont
						local color = menu.white
						if ismissiontarget then
							font = Helper.standardFontBold
							color = Helper.color.mission
						elseif isenemy then
							color = menu.red
						elseif isplayerowned then
							color = menu.green
						end
						local title = postname
						if title == "" then
							title = rolename
							if title == "" then
								title = typename
							end
						end
						local row = infotable:addRow(true, { bgColor = Helper.color.transparent })
						row[2]:createText(title, { color = color, font = font })
						row[3]:setColSpan(2):createText(name, { color = color, font = font })
					end
				end
			end
		end

		infotable.properties.maxVisibleHeight = buttontable.properties.y
	end

	frame:display()
end

function menu.viewCreated(layer, ...)
	menu.selecttable, menu.infotable, menu.buttontable = ...

	-- clear descriptors again
	Helper.releaseDescriptors()
end

menu.updateInterval = 0.1

function menu.onUpdate()
	if menu.refresh and (menu.refresh < getElapsedTime()) then
		menu.display()
		menu.refresh = nil
	end
end

function menu.onRowChanged(row, rowdata)
	rowdata = Helper.getCurrentRowData(menu, menu.defaulttable)
	if type(rowdata) == "table" then
		if (menu.currentselection.target ~= rowdata.target) or (menu.currentselection.issubtarget ~= rowdata.issubtarget) then
			menu.currentselection = rowdata
			menu.pretoprow = GetTopRow(menu.selecttable)
			menu.preselectrow = Helper.currentTableRow[menu.defaulttable]
			menu.refresh = getElapsedTime() + 0.11
		end
	end
end

function menu.onSelectElement(uitable)
	if uitable == menu.defaulttable then
		menu.buttonGoTo()
	end
end

function menu.onCloseElement(dueToClose)
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.getNPCs(room, ships, issubtarget)
	local rawnpcs = GetPrioritizedPlatformNPCs(ConvertStringTo64Bit(tostring(room)))
	local npcs = {}
	
	if not issubtarget then
		if C.GetContextByClass(room, "ship", false) ~= 0 then
			npcs = GetNPCs(ConvertStringTo64Bit(tostring(room)))
		else
			npcs = rawnpcs
		end
	end
	if issubtarget then
		for _, ship in ipairs(ships) do
			local npcs2 = GetNPCs(ConvertStringTo64Bit(tostring(ship)))
			for _, npc in ipairs(npcs2) do
				table.insert(npcs, npc)
			end
		end
		for _, npc in ipairs(rawnpcs) do
			if C.GetContextByClass(ConvertIDTo64Bit(npc), "room", false) == room then
				table.insert(npcs, npc)
			end
		end
	end
	for i = #npcs, 1, -1 do
		-- filter out non-mission crowd actors
		if GetComponentData(npcs[i], "typestring") == "crowd" and GetComponentData(npcs[i], "ismissionactor") == false then
			table.remove(npcs, i)
		end
	end

	return npcs
end

function menu.checkPlayerProperty(transporter)
	if ffi.string(C.GetOwnerDetails(transporter.component).factionID) == "player" then
		return true
	end
	local room = C.GetRoomForTransporter(transporter)
	if room ~= 0 then
		local dockedships = {}
		if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, nil)
			for _, ship in ipairs(dockedships) do
				if ffi.string(C.GetOwnerDetails(ship).factionID) == "player" then
					return true
				end
			end
		end

		local npcs = menu.getNPCs(room, dockedships)
		for _, npc in ipairs(npcs) do
			if GetComponentData(npc, "isplayerowned") then
				return true
			end
		end
	end

	return false
end

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- {name = name} = addEntry_on_set_room_name (name, target)
	-- {active = true / false} = display_on_set_room_active (active)
	-- display_on_set_buttontable (buttontable)
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end
-- kuertee end

init()
﻿
-- param == { 0, 0, mode, modeparam }
-- modes: - "hackpanel",		param: { panelcomponent, panelconnection, paneltype }
--		  - "abortupgrade",		param: { container, task, price }
--		  - "transporter",		param: { transportercomponent, transporterconnection }
--		  - "markashostile",	param: { component }
--		  - "discardstationeditor"
--		  - "custom",			param: { title, question, { leftoptionid, leftoptionname[, uicallbackparam, ...] }, { rightoptionid, rightoptionname[, uicallbackparam, ...] }[, uicallbackmode][, preselectoption ("left"|"right")] }
--			uicallbackmodes:	- "invertinput",				param: { rangeid, configname, value }
--								- "autoroll",					param: { value }
--								- "mouse_steering_adaptive",	param: { value }
--								- "stick_steering_adaptive",	param: { value }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef uint64_t UniverseID;
	typedef struct {
		UniverseID component;
		const char* connection;
	} UIComponentSlot;
	bool CancelConstruction(UniverseID containerid, BuildTaskID id);
	const char* GetControlPanelName(UIComponentSlot controlpanel);
	void SetAutoRoll(bool value);
	void SetInversionSetting(uint32_t uirangeid, const char* parametername, bool value);
	void SetJoystickSteeringAdapative(bool value);
	void SetMouseSteeringAdapative(bool value);
	void SetMouseSteeringInvertedOption(const char* paramname, bool value);
	void StartControlPanelHack(UIComponentSlot target, const char* paneltypeid);
	const char* UndockPlayerShip(bool checkonly);
]]

local menu = {
	name = "UserQuestionMenu",
	saveOption = false,
}

local config = {
	width = 400,
	layer = 2,
	saveOptionVersion = 1,
}

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	__CORE_DETAILMONITOR_USERQUESTION = __CORE_DETAILMONITOR_USERQUESTION or {
		version = config.saveOptionVersion,
	}
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_userquestion.xpl.init - kuertee")
end
-- kuertee end

function menu.cleanup()
	menu.infoFrame = nil

	menu.mode = nil
	menu.modeparam = {}
	menu.hacktarget = nil
	menu.transportertarget = nil
	menu.upgradecontainer = nil
	menu.upgradetask = nil
	menu.upgradeprice = nil
	menu.saveOption = false

	-- kuertee start:
	if callbacks ["cleanup_end"] then
		for _, callback in ipairs (callbacks ["cleanup_end"]) do
			callback ()
		end
	end
	-- kuertee end
end

-- Menu member functions

function menu.confirm()
	if menu.mode == "hackpanel" then
		C.StartControlPanelHack(menu.hacktarget, menu.modeparam[3])
	elseif menu.mode == "abortupgrade" then
		if C.CancelConstruction(menu.upgradecontainer, menu.upgradetask) then
			if ffi.string(C.UndockPlayerShip(false)) ~= "granted" then
				DebugError("failed undocking.")
			end
		else
			menu.onCloseElement("back", true)
		end
	elseif menu.mode == "transporter" then
		C.TransportPlayerToTarget(menu.transportertarget)
	elseif menu.mode == "markashostile" then
		C.SetRelationBoostToFaction(menu.hostilecomponent, "player", "markedashostile", -1, 1, 600)
	elseif menu.mode == "discardstationeditor" then
		Helper.clearStationEditorState()
	end
	if menu.saveOption then
		__CORE_DETAILMONITOR_USERQUESTION[menu.mode] = true
	end
	menu.onCloseElement("close")
end

function menu.customOption(optionid, optionparameters)
	if menu.modeparam[5] then
		if menu.modeparam[5] == "invertinput" then
			if (optionparameters[3] ~= nil) and (optionparameters[4] ~= nil) and (optionparameters[5] ~= nil) then
				if optionparameters[3] == 0 then
					C.SetMouseSteeringInvertedOption(optionparameters[4], optionparameters[5])
				else
					C.SetInversionSetting(optionparameters[3], optionparameters[4], optionparameters[5])
				end
			end
		elseif menu.modeparam[5] == "autoroll" then
			if (optionparameters[3] ~= nil) then
				C.SetAutoRoll(optionparameters[3])
			end
		elseif menu.modeparam[5] == "mouse_steering_adaptive" then
			if (optionparameters[3] ~= nil) then
				C.SetMouseSteeringAdapative(optionparameters[3])
			end
		elseif menu.modeparam[5] == "stick_steering_adaptive" then
			if (optionparameters[3] ~= nil) then
				C.SetJoystickSteeringAdapative(optionparameters[3])
			end
		end
	end
	AddUITriggeredEvent(menu.name, "selected", optionid)
	menu.onCloseElement("close")
end

function menu.onShowMenu()
	menu.mode = menu.param[3]
	menu.modeparam = menu.param[4]
	if menu.mode == "hackpanel" then
		menu.hacktarget = ffi.new("UIComponentSlot")
		menu.hacktarget.component = ConvertIDTo64Bit(menu.modeparam[1])
		menu.hacktarget.connection = menu.modeparam[2]
	elseif menu.mode == "abortupgrade" then
		menu.upgradecontainer = ConvertIDTo64Bit(menu.modeparam[1])
		menu.upgradetask = ConvertIDTo64Bit(menu.modeparam[2])
		menu.upgradeprice = menu.modeparam[3]
	elseif menu.mode == "transporter" then
		menu.transportertarget = ffi.new("UIComponentSlot")
		menu.transportertarget.component = ConvertIDTo64Bit(menu.modeparam[1])
		menu.transportertarget.connection = menu.modeparam[2]
	elseif menu.mode == "markashostile" then
		menu.hostilecomponent = ConvertIDTo64Bit(menu.modeparam[1])
	elseif menu.mode == "discardstationeditor" then
		Helper.unregisterStationEditorChanges()
	end

	if __CORE_DETAILMONITOR_USERQUESTION[menu.mode] then
		-- continue immediately
		menu.confirm()
	else
		-- display info
		menu.createInfoFrame()
	end
end

function menu.createInfoFrame()
	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	-- kuertee start: callback
	local frameProperties, isUseFrameHeight
	if callbacks ["createInfoFrame_custom_frame_properties"] then
		for _, callback in ipairs (callbacks ["createInfoFrame_custom_frame_properties"]) do
			frameProperties, isUseFrameHeight = callback (config)
			if frameProperties then break end
		end
		-- Lib.Print_Table (frameProperties)
	end
	if not frameProperties then
	-- kuertee end: callback
		frameProperties = {
			standardButtons = {},
			width = Helper.scaleX(config.width) + 6 * Helper.borderSize,
			x = (Helper.viewWidth - Helper.scaleX(config.width)) / 2,
			y = Helper.viewHeight / 2,
			layer = config.layer,
			backgroundID = "solid",
			backgroundColor = Helper.color.semitransparent,
			startAnimation = false,
			playerControls = menu.mode == "markashostile",
		}
	-- kuertee start: callback
	end
	-- kuertee end: callback

	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)

	local tableProperties = {
		width = Helper.scaleX(config.width),
		x = 3 * Helper.borderSize,
		y = 3 * Helper.borderSize,
	}

	local ftable = menu.createTable(menu.infoFrame, tableProperties)

	-- kuertee start:
	if not isUseFrameHeight then
		menu.infoFrame.properties.height = ftable.properties.y + ftable:getVisibleHeight() + 3 * Helper.borderSize
	else
	-- kuertee end

		menu.infoFrame.properties.height = frameProperties.height

	-- kuertee start:
	end
	-- kuertee end

	menu.infoFrame.properties.y = (Helper.viewHeight - menu.infoFrame.properties.height) / 2

	menu.infoFrame:display()
end

function menu.createTable(frame, tableProperties)
	if string.find ("" .. tostring (menu.mode), "custom") then
		return menu.createTable_kuertee (frame, tableProperties)
	end

	local numCols = (menu.mode == "custom") and 5 or 6
	local ftable = frame:addTable(numCols, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, defaultInteractiveObject = true })
	if menu.mode == "custom" then
		local leftwith = math.ceil(C.GetTextWidth(menu.modeparam[3][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		local rightwidth = math.ceil(C.GetTextWidth(menu.modeparam[4][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		local minbuttonwidth = 0.2 * tableProperties.width - Helper.borderSize
		local maxbuttonwidth = (tableProperties.width - 4 * Helper.borderSize - 3) / 2

		local buttonwidth = math.max(minbuttonwidth, math.min(maxbuttonwidth, math.max(leftwith, rightwidth) + 2 * Helper.standardTextOffsetx))
		ftable:setColWidth(2, buttonwidth, false)
		ftable:setColWidth(4, buttonwidth, false)
	else
		ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
		ftable:setColWidthPercent(5, 25, false)
		ftable:setColWidthPercent(6, 25, false)
	end

	if menu.mode == "hackpanel" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9701), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9702) .. ReadText(1001, 120))
		
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ffi.string(C.GetControlPanelName(menu.hacktarget)))
	elseif menu.mode == "abortupgrade" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9703), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9704), { wordwrap = true })
	elseif menu.mode == "transporter" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9707), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9708), { wordwrap = true })
	elseif menu.mode == "markashostile" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11114), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9710), { wordwrap = true })
	elseif menu.mode == "discardstationeditor" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9721), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9722), { wordwrap = true })
	elseif menu.mode == "custom" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(menu.modeparam[1] or "", Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(menu.modeparam[2] or "", { wordwrap = true })
	end

	local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	row[1]:setColSpan(numCols):createText("")

	if menu.mode == "custom" then
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[2]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[3][2] or "", { halign = "center" })
		row[2].handlers.onClick = function () return menu.customOption(menu.modeparam[3][1], menu.modeparam[3]) end
		row[4]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[4][2] or "", { halign = "center" })
		row[4].handlers.onClick = function () return menu.customOption(menu.modeparam[4][1], menu.modeparam[4]) end

		if menu.modeparam[6] == "right" then
			ftable:setSelectedCol(4)
		elseif menu.modeparam[6] == "left" then
			ftable:setSelectedCol(2)
		end
	else
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createCheckBox(function () return menu.saveOption end, { height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function () menu.saveOption = not menu.saveOption end
		row[2]:setColSpan(3):createButton({ bgColor = Helper.color.transparent }):setText(ReadText(1001, 9709))
		row[2].handlers.onClick = function () menu.saveOption = not menu.saveOption end
		row[5]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
		row[5].handlers.onClick = menu.confirm
		row[6]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		row[6].handlers.onClick = function () return menu.onCloseElement("back", true) end
		ftable:setSelectedCol(5)
	end

	return ftable
end

function menu.viewCreated(layer, ...)
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	-- kuertee start: refresh feature
	-- menu.infoFrame:update()
	local currentTime = getElapsedTime()
	if menu.isRefresh == true or menu.isRefresh == 1 or (menu.refresh and currentTime > menu.refresh) then
		menu.isRefresh = false
		menu.refresh = nil
		menu.createInfoFrame ()
	else
		menu.infoFrame:update()
	end
	-- kuertee end: refresh feature
end

function menu.onRowChanged(row, rowdata, uitable)
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.onCloseElement(dueToClose, allowAutoMenu)
	if menu.mode == "discardstationeditor" then
		if dueToClose == "close" then
			Helper.clearStationEditorState()
		elseif dueToClose == "back" then
			-- restore state
			Helper.registerStationEditorChanges()
		end
	end
	Helper.closeMenu(menu, dueToClose, allowAutoMenu or (menu.mode ~= "abortupgrade"))
	menu.cleanup()
end

-- menu helpers

-- kuertee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- 
	-- cleanup_end ()
	-- frameProperties = createInfoFrame_custom_frame_properties ()
	-- ftable = createTable_new_custom_table (frame, tableProperties) -- if multiple ftables are created, return the ftable with the the most bottom y because createInfoFrame () uses that to determine the visible height of the frame
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end

function menu.createTable_kuertee(frame, tableProperties)
	-- DebugError ("kuertee_menu_userquestion createTable menu.mode " .. tostring (menu.mode))
	-- DebugError ("kuertee_menu_userquestion createTable #callbacks ['createTable_new_custom_table'] " .. tostring (#callbacks ["createTable_new_custom_table"]))
	local ftable
	if menu.mode == "custom" then
		-- kuertee start: re-written custom user question
		local numCols = (menu.mode == "custom") and 5 or 6
		ftable = frame:addTable(numCols, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, defaultInteractiveObject = true })
		local leftwidth = 0
		if menu.modeparam[3] ~= nil then
			leftwidth = math.ceil(C.GetTextWidth(menu.modeparam[3][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		end
		local rightwidth = 0
		if menu.modeparam[4] ~= nil  then
			rightwidth = math.ceil(C.GetTextWidth(menu.modeparam[4][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		end
		local minbuttonwidth = 0.2 * tableProperties.width - Helper.borderSize
		local maxbuttonwidth = (tableProperties.width - 4 * Helper.borderSize - 3) / 2
		local buttonwidth = math.max(minbuttonwidth, math.min(maxbuttonwidth, math.max(leftwidth, rightwidth) + 2 * Helper.standardTextOffsetx))
		ftable:setColWidth(2, buttonwidth, false)
		ftable:setColWidth(4, buttonwidth, false)
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(menu.modeparam[1] or "", Helper.headerRowCenteredProperties)
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(menu.modeparam[2] or "", { wordwrap = true })
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText("")
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		if menu.modeparam[3] then
			row[2]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[3][2] or "", { halign = "center" })
			row[2].handlers.onClick = function () return menu.customOption(menu.modeparam[3][1], menu.modeparam[3]) end
		end
		if menu.modeparam[4] then
			row[4]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[4][2] or "", { halign = "center" })
			row[4].handlers.onClick = function () return menu.customOption(menu.modeparam[4][1], menu.modeparam[4]) end
		end
		if menu.modeparam[4] and menu.modeparam[6] == "right" then
			ftable:setSelectedCol(4)
		elseif menu.modeparam[3] and menu.modeparam[6] == "left" then
			ftable:setSelectedCol(2)
		elseif menu.modeparam [3] then
			ftable:setSelectedCol(2)
		end
		-- kuertee end: re-written custom user question
	elseif string.find ("" .. tostring (menu.mode), "custom_") then
		-- <open_menu menu="UserQuestionMenu" param="[0, 0, 'custom', [$title, $text, null, ['kATD_on_death_notice_read', {111204, 903}], null, 'right']]" />
		-- local ftable = frame:addTable (numCols, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, defaultInteractiveObject = true })
		if callbacks ["createTable_new_custom_table"] then
			for _, callback in ipairs (callbacks ["createTable_new_custom_table"]) do
				ftable = callback (frame, tableProperties, config)
				if ftable then break end
			end
		end
	end
	return ftable
end
-- kuertee end

init()
﻿-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef int32_t BlacklistID;
	typedef int32_t FightRuleID;
	typedef uint64_t MissionID;
	typedef uint64_t NPCSeed;
	typedef uint64_t TradeID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;
	
	typedef struct {
		uint32_t nummacros;
		uint32_t numfactions;
	} BlacklistCounts;
	typedef struct {
		uint32_t id;
		const char* type;
		const char* name;
		bool usemacrowhitelist;
		uint32_t nummacros;
		const char** macros;
		bool usefactionwhitelist;
		uint32_t numfactions;
		const char** factions;
		const char* relation;
		bool hazardous;
	} BlacklistInfo2;
	typedef struct {
		uint32_t red;
		uint32_t green;
		uint32_t blue;
		uint32_t alpha;
	} Color;
	typedef struct {
		const char* newroleid;
		NPCSeed seed;
		uint32_t amount;
		int64_t price;
	} CrewTransferContainer2;
	typedef struct {
		CrewTransferContainer2* removed;
		uint32_t numremoved;
		CrewTransferContainer2* added;
		uint32_t numadded;
		CrewTransferContainer2* transferred;
		uint32_t numtransferred;
	} CrewTransferInfo2;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
		const char* propdatatype;
		float basevalue;
		bool poseffect;
	} EquipmentModPropertyInfo;
	typedef struct {
		uint32_t numfactions;
	} FightRuleCounts;
	typedef struct {
		double time;
		int64_t money;
		int64_t entryid;
	} MoneyLogEntry;
	typedef struct {
		const char* name;
		const char* transport;
		uint32_t spaceused;
		uint32_t capacity;
	} StorageInfo;
	typedef struct {
		uint32_t numfactions;
	} TradeRuleCounts;
	typedef struct {
		uint32_t id;
		const char* name;
		uint32_t numfactions;
		const char** factions;
		bool iswhitelist;
	} TradeRuleInfo;
	typedef struct {
		double time;
		int64_t money;
		int64_t entryid;
		const char* eventtype;
		const char* eventtypename;
		UniverseID partnerid;
		const char* partnername;
		const char* partneridcode;
		int64_t tradeentryid;
		const char* tradeeventtype;
		const char* tradeeventtypename;
		UniverseID buyerid;
		UniverseID sellerid;
		const char* ware;
		uint32_t amount;
		int64_t price;
		bool complete;
	} TransactionLogEntry;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float ForwardThrustFactor;
		float StrafeThrustFactor;
		float RotationThrustFactor;
		float BoostThrustFactor;
		float BoostDurationFactor;
		float BoostAttackTimeFactor;
		float BoostReleaseTimeFactor;
		float BoostChargeTimeFactor;
		float BoostRechargeTimeFactor;
		float TravelThrustFactor;
		float TravelStartThrustFactor;
		float TravelAttackTimeFactor;
		float TravelReleaseTimeFactor;
		float TravelChargeTimeFactor;
	} UIEngineMod;
	typedef struct {
		const char* factionid;
		const char* civiliansetting;
		const char* militarysetting;
	} UIFightRuleSetting;
	typedef struct {
		const float x;
		const float y;
		const float z;
		const float yaw;
		const float pitch;
		const float roll;
	} UIPosRot;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float CapacityFactor;
		float RechargeDelayFactor;
		float RechargeRateFactor;
	} UIShieldMod;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float MassFactor;
		float DragFactor;
		float MaxHullFactor;
		float RadarRangeFactor;
		uint32_t AddedUnitCapacity;
		uint32_t AddedMissileCapacity;
		uint32_t AddedCountermeasureCapacity;
		uint32_t AddedDeployableCapacity;
		float RadarCloakFactor;
		float RegionDamageProtection;
		float HideCargoChance;
	} UIShipMod2;
	typedef struct {
		const char* stat;
		uint32_t min;
		uint32_t max;
		uint64_t minvalue;
		uint64_t maxvalue;
		bool issatisfied;
	} UITerraformingProjectCondition;
	typedef struct {
		const char* text;
		const char* stat;
		int32_t change;
		uint64_t value;
		uint64_t minvalue;
		uint64_t maxvalue;
		bool onfail;
		bool issideeffect;
		uint32_t chance;
		uint32_t setbackpercent;
		bool isbeneficial;
	} UITerraformingProjectEffect;
	typedef struct {
		const char* id;
		const char* name;
	} UITerraformingProjectGroup;
	typedef struct {
		const char* id;
		bool anyproject;
	} UITerraformingProjectPredecessorGroup;
	typedef struct {
		const char* ware;
		const char* waregroupname;
		uint32_t value;
	} UITerraformingProjectRebate;
	typedef struct {
		const char* name;
		const char* rawname;
		const char* icon;
		const char* rewardicon;
		int64_t remainingtime;
		uint32_t numships;
	} UIVentureInfo;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float DamageFactor;
		float CoolingFactor;
		float ReloadFactor;
		float SpeedFactor;
		float LifeTimeFactor;
		float MiningFactor;
		float StickTimeFactor;
		float ChargeTimeFactor;
		float BeamLengthFactor;
		uint32_t AddedAmount;
		float RotationSpeedFactor;
		float SurfaceElementFactor;
	} UIWeaponMod;
	typedef struct {
		const char* path;
		const char* group;
	} UpgradeGroup;
	typedef struct {
		UniverseID reserverid;
		const char* ware;
		uint32_t amount;
		bool isbuyreservation;
		double eta;
		TradeID tradedealid;
		MissionID missionid;
		bool isvirtual;
		bool issupply;
	} WareReservationInfo2;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;

	typedef struct {
		FightRuleID id;
		const char* name;
		uint32_t numfactions;
		UIFightRuleSetting* factions;
	} FightRuleInfo;
	void AddTradeWare(UniverseID containerid, const char* wareid);
	bool AreVenturesCompatible(void);
	bool AreVenturesEnabled(void);
	bool CancelPlayerInvolvedTradeDeal(UniverseID containerid, TradeID tradeid, bool checkonly);
	bool CanResearch(void);
	void ClearContainerBuyLimitOverride(UniverseID containerid, const char* wareid);
	void ClearContainerSellLimitOverride(UniverseID containerid, const char* wareid);
	void ClearTrackedMenus(void);
	void DisableAutoMouseEmulation(void);
	void EnableAutoMouseEmulation(void);
	uint32_t GetAllBlacklists(BlacklistID* result, uint32_t resultlen);
	uint32_t GetAllEquipmentModProperties(EquipmentModPropertyInfo* result, uint32_t resultlen, const char* equipmentmodclass);
	uint32_t GetAllFightRules(FightRuleID* result, uint32_t resultlen);
	uint32_t GetAllTradeRules(TradeRuleID* result, uint32_t resultlen);
	BlacklistCounts GetBlacklistInfoCounts(BlacklistID id);
	bool GetBlacklistInfo2(BlacklistInfo2* info, BlacklistID id);
	uint32_t GetCargoTransportTypes(StorageInfo* result, uint32_t resultlen, UniverseID containerid, bool merge, bool aftertradeorders);
	const char* GetComponentName(UniverseID componentid);
	int32_t GetContainerBuyLimit(UniverseID containerid, const char* wareid);
	int32_t GetContainerSellLimit(UniverseID containerid, const char* wareid);
	uint32_t GetContainerStockLimitOverrides(UIWareInfo* result, uint32_t resultlen, UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	double GetContainerWareConsumption(UniverseID containerid, const char* wareid, bool ignorestate);
	bool GetContainerWareIsBuyable(UniverseID containerid, const char* wareid);
	bool GetContainerWareIsSellable(UniverseID containerid, const char* wareid);
	int32_t GetContainerWareMaxProductionStorageForTime(UniverseID containerid, const char* wareid, double duration, bool ignoreoverrides);
	double GetContainerWareProduction(UniverseID containerid, const char* wareid, bool ignorestate);
	uint32_t GetContainerWareReservations2(WareReservationInfo2* result, uint32_t resultlen, UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	int64_t GetCreditsDueFromPlayerBuilds(void);
	int64_t GetCreditsDueFromPlayerTrades(void);
	double GetCurrentGameTime(void);
	int64_t GetCurrentUTCDataTime(void);
	UIVentureInfo GetCurrentVentureInfo(UniverseID ventureplatformid);
	uint32_t GetCurrentVentureShips(UniverseID* result, uint32_t resultlen, UniverseID ventureplatformid);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	bool GetFightRuleInfo(FightRuleInfo* info, FightRuleID id);
	FightRuleCounts GetFightRuleInfoCounts(FightRuleID id);
	bool GetInstalledEngineMod(UniverseID objectid, UIEngineMod* enginemod);
	bool GetInstalledGroupedWeaponMod(UniverseID defensibleid, UniverseID contextid, const char* group, UIWeaponMod* weaponmod);
	bool GetInstalledShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group, UIShieldMod* shieldmod);
	bool GetInstalledShipMod2(UniverseID shipid, UIShipMod2* shipmod);
	bool GetInstalledWeaponMod(UniverseID weaponid, UIWeaponMod* weaponmod);
	const char* GetMappedInputName(const char* functionkey);
	uint32_t GetMoneyLog(MoneyLogEntry* result, size_t resultlen, UniverseID componentid, double starttime, double endtime);
	uint32_t GetNumAllBlacklists(void);
	uint32_t GetNumAllEquipmentModProperties(const char* equipmentmodclass);
	uint32_t GetNumAllFightRules(void);
	uint32_t GetNumAllTradeRules(void);
	uint32_t GetNumCargoTransportTypes(UniverseID containerid, bool merge);
	uint32_t GetNumContainerStockLimitOverrides(UniverseID containerid);
	uint32_t GetNumContainerWareReservations2(UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumTerraformingProjects(UniverseID clusterid, bool useevents);
	uint32_t GetNumTransactionLog(UniverseID componentid, double starttime, double endtime);
	uint32_t GetNumVenturePlatformDocks(UniverseID ventureplatformid);
	uint32_t GetNumVenturePlatforms(UniverseID defensibleid);
	const char* GetObjectIDCode(UniverseID objectid);
	UIPosRot GetObjectPositionInSector(UniverseID objectid);
	const char* GetPlayerCoverFaction(void);
	const char* GetPlayerCurrentControlGroup(void);
	UniverseID GetPlayerID(void);
	const char* GetPlayerName(void);
	UniverseID GetPlayerOccupiedShipID(void);
	uint32_t GetTerraformingProjectBlockingProjects(const char** result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectConditions(UITerraformingProjectCondition* result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectEffects(UITerraformingProjectEffect* result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectPredecessorGroups(UITerraformingProjectPredecessorGroup* result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectPredecessors(const char** result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectRebatedResources(UIWareInfo* result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectRebates(UITerraformingProjectRebate* result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	uint32_t GetTerraformingProjectRemovedProjects(const char** result, uint32_t resultlen, UniverseID clusterid, const char* projectid);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	float GetTextWidth(const char*const text, const char*const fontname, const float fontsize);
	uint32_t GetTransactionLog(TransactionLogEntry* result, uint32_t resultlen, UniverseID componentid, double starttime, double endtime);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	bool GetTradeRuleInfo(TradeRuleInfo* info, TradeRuleID id);
	TradeRuleCounts GetTradeRuleInfoCounts(TradeRuleID id);
	float GetUIScale(const bool scalewithresolution);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	uint32_t GetVenturePlatformDocks(UniverseID* result, uint32_t resultlen, UniverseID ventureplatformid);
	uint32_t GetVenturePlatforms(UniverseID* result, uint32_t resultlen, UniverseID defensibleid);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasContainerBuyLimitOverride(UniverseID containerid, const char* wareid);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasContainerSellLimitOverride(UniverseID containerid, const char* wareid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsComponentOperational(UniverseID componentid);
	bool IsConversationActive(void);
	bool IsConversationCancelling(void);
	bool IsDemoVersion(void);
	bool IsInfoUnlockedForPlayer(UniverseID componentid, const char* infostring);
	bool IsGameOver(void);
	bool IsNextStartAnimationSkipped(bool reset);
	bool IsOnlineEnabled(void);
	bool IsPlayerBlacklistDefault(BlacklistID id, const char* listtype, const char* defaultgroup);
	bool IsPlayerFightRuleDefault(FightRuleID id, const char* listtype);
	bool IsSetaActive();
	bool IsStartmenu();
	bool IsTerraformingProjectOngoing(UniverseID clusterid, const char* projectid);
	bool IsValidTrade(TradeID tradeid);
	bool IsVRMode(void);
	bool IsWeaponModeCompatible(UniverseID weaponid, const char* macroname, const char* weaponmodeid);
	void ReleaseConstructionMapState(void);
	void ReleaseDetachedSubordinateGroup(UniverseID controllableid, int group);
	void RemoveTrackedMenu(const char* menu);
	void SetBoxText(const int boxtextid, const char* text);
	void SetBoxTextBoxColor(const int boxtextid, Color color);
	void SetBoxTextColor(const int boxtextid, Color color);
	void SetButtonActive(const int buttonid, bool active);
	void SetButtonHighlightColor(const int buttonid, Color color);
	void SetButtonIconColor(const int buttonid, Color color);
	void SetButtonIcon2Color(const int buttonid, Color color);
	void SetButtonIconID(const int buttonid, const char* iconid);
	void SetButtonIcon2ID(const int buttonid, const char* iconid);
	void SetButtonTextColor(const int buttonid, Color color);
	void SetButtonText2(const int buttonid, const char* text);
	void SetButtonText2Color(const int buttonid, Color color);
	void SetCheckBoxChecked2(const int checkboxid, bool checked, bool update);
	void SetCheckBoxColor(const int checkboxid, Color color);
	void SetContainerBuyLimitOverride(UniverseID containerid, const char* wareid, int32_t amount);
	void SetContainerSellLimitOverride(UniverseID containerid, const char* wareid, int32_t amount);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetContainerWareIsBuyable(UniverseID containerid, const char* wareid, bool allowed);
	void SetContainerWareIsSellable(UniverseID containerid, const char* wareid, bool allowed);
	void SetDropDownCurOption(const int dropdownid, const char* id);
	void SetEditBoxActive(const int editboxid, bool active);
	void SetEditBoxText(const int editboxid, const char* text);
	void SetEditBoxTextHidden(const int editboxid, bool hidden);
	void SetFlowChartEdgeColor(const int flowchartedgeid, Color color);
	void SetFlowChartNodeCaptionText(const int flowchartnodeid, const char* text);
	void SetFlowChartNodeCaptionTextColor(const int flowchartnodeid, Color color);
	void SetFlowChartNodeCurValue(const int flowchartnodeid, double value);
	void SetFlowchartNodeExpanded(const int flowchartnodeid, const int frameid, bool expandedabove);
	void SetFlowChartNodeMaxValue(const int flowchartnodeid, double value);
	void SetFlowChartNodeOutlineColor(const int flowchartnodeid, Color color);
	void SetFlowChartNodeSlider1Value(const int flowchartnodeid, double value);
	void SetFlowChartNodeSlider2Value(const int flowchartnodeid, double value);
	void SetFlowChartNodeSliderStep(const int flowchartnodeid, double step);
	void SetFlowChartNodeStatusBgIcon(const int flowchartnodeid, const char* iconid);
	void SetFlowChartNodeStatusIcon(const int flowchartnodeid, const char* iconid);
	void SetFlowChartNodeStatusIconMouseOverText(const int flowchartnodeid, const char* mouseovertext);
	void SetFlowChartNodeStatusText(const int flowchartnodeid, const char* text);
	void SetFlowChartNodeStatusColor(const int flowchartnodeid, Color color);
	void SetIcon(const int widgeticonid, const char* iconid);
	void SetIconColor(const int widgeticonid, Color color);
	void SetIconText(const int widgeticonid, const char* text);
	void SetIconText2(const int widgeticonid, const char* text);
	void SetMouseOverText(int widgetid, const char* text);
	void SetShieldHullBarHullPercent(const int shieldhullbarid, float hullpercent);
	void SetShieldHullBarShieldPercent(const int shieldhullbarid, float shieldpercent);
	void SetSliderCellMaxSelectValue(const int slidercellid, double value);
	void SetSliderCellMaxValue(const int slidercellid, double value);
	void SetSubordinateGroupAssignment(UniverseID controllableid, int group, const char* assignment);
	void SetSubordinateGroupProtectedLocation(UniverseID controllableid, int group, UniverseID sectorid, UIPosRot offset);
	void SetStatusBarCurrentValue(const int statusbarid, float value);
	void SetStatusBarMaxValue(const int statusbarid, float value);
	void SetStatusBarStartValue(const int statusbarid, float value);
	void SetTableNextConnectedTable(const int tableid, const int nexttableid);
	void SetTablePreviousConnectedTable(const int tableid, const int prevtableid);
	void SetTableNextHorizontalConnectedTable(const int tableid, const int nexttableid);
	void SetTablePreviousHorizontalConnectedTable(const int tableid, const int prevtableid);
	void SetWidgetViewScheduled(bool scheduled);
	void SkipNextStartAnimation(void);
	void TrackMenu(const char* menu, bool fullscreen);
	bool WasSessionOnline(void);
]]

local utf8 = require("utf8")

---------------------------------------------------------------------------------
-- Global helper table
---------------------------------------------------------------------------------

Helper = {
	standardHalignment = "left",
	standardColor = { r = 255, g = 255, b = 255, a = 100 },
	standardFontBold = "Zekton bold",
	standardFontMono = "Zekton fixed",
	standardFontBoldMono = "Zekton bold fixed",
	standardFontOutlined = "Zekton outlined",
	standardFontBoldOutlined = "Zekton bold outlined",
	standardButtonWidth = 16,
	standardButtonHeight = 20,
	standardFlowchartNodeHeight = 30,
	standardFlowchartConnectorSize = 10,
	standardHotkeyIconSizex = 19,
	standardHotkeyIconSizey = 19,
	-- normal text properties
	standardFont = "Zekton",
	standardFontSize = 9,
	standardTextOffsetx = 5,
	standardTextOffsety = 0,
	standardTextHeight = 16,
	standardTextWidth = 0,
	-- title text properties
	titleFont = "Zekton bold",
	titleFontSize = 12,
	titleOffsetX = 3,
	titleOffsetY = 2,
	titleHeight = 20,
	-- header properties
	headerRow1Font = "Zekton bold",
	headerRow1FontSize = 10,
	headerRow1Offsetx = 3,
	headerRow1Offsety = 2,
	headerRow1Height = 20,
	headerRow1Width = 0,
	-- subheader properties
	subHeaderHeight = 18,
	-- large icon text properties
	largeIconFontSize = 16,
	largeIconTextHeight = 32,
	-- default colors
	defaultHeaderBackgroundColor = { r = 0, g = 0, b = 0, a = 60 },
	defaultSimpleBackgroundColor = { r = 66, g = 92, b = 111, a = 60 },
	defaultTitleBackgroundColor = { r = 49, g = 69, b = 83, a = 60 },
	defaultArrowRowBackgroundColor = { r = 83, g = 116, b = 139, a = 60 },
	defaultUnselectableBackgroundColor = { r = 35, g = 53, b = 71, a = 60 },
	defaultUnselectableFontColor = { r = 163, g = 193, b = 227, a = 100 },
	defaultButtonBackgroundColor = { r = 49, g = 69, b = 83, a = 60 },
	defaultUnselectableButtonBackgroundColor = { r = 31, g = 31, b = 31, a = 100 },
	defaultButtonHighlightColor = { r = 71, g = 136, b = 184, a = 100 },
	defaultUnselectableButtonHighlightColor = { r = 80, g = 80, b = 80, a = 100 },
	defaultCheckBoxBackgroundColor = { r = 66, g = 92, b = 111, a = 100 },
	defaultEditBoxBackgroundColor = { r = 49, g = 69, b = 83, a = 60 },
	defaultSliderCellBackgroundColor = { r = 22, g = 34, b = 41, a = 60 },
	defaultSliderCellInactiveBackgroundColor = { r = 40, g = 40, b = 40, a = 60 },
	defaultSliderCellValueColor = { r = 99, g = 138, b = 166, a = 100 },
	defaultSliderCellPositiveValueColor = { r = 29, g = 216, b = 35, a = 30 },
	defaultSliderCellNegativeValueColor = { r = 216, g = 68, b = 29, a = 30 },
	defaultStatusBarValueColor = { r = 71, g = 136, b = 184, a = 100 },
	defaultStatusBarPosChangeColor = { r = 20, g = 222, b = 20, a = 30 },
	defaultStatusBarNegChangeColor = { r = 236, g = 53, b = 0, a = 30 },
	defaultStatusBarMarkerColor = { r = 151, g = 192, b = 223, a = 100 },
	defaultBoxTextBoxColor = { r = 49, g = 69, b = 83, a = 60 },
	defaultFlowchartOutlineColor = { r = 90, g = 146, b = 186, a = 100 },			-- light cyan
	defaultFlowchartBackgroundColor = { r = 25, g = 25, b = 25, a = 100 },			-- dark grey
	defaultFlowchartValueColor = { r = 0, g = 116, b = 153, a = 100 },				-- cyan
	defaultFlowchartSlider1Color = { r = 225, g = 149, b = 0, a = 100 },			-- orange
	defaultFlowchartDiff1Color = { r = 89, g = 52, b = 0, a = 100 },				-- brown
	defaultFlowchartSlider2Color = { r = 66, g = 171, b = 61, a = 100 },			-- green
	defaultFlowchartDiff2Color = { r = 4, g = 89, b = 0, a = 100 },					-- dark green
	defaultFlowchartConnector1Color = { r = 255, g = 220, b = 0, a = 100 },			-- yellow
	defaultFlowchartConnector2Color = { r = 0, g = 154, b = 204, a = 100 },			-- light cyan
	defaultFlowchartConnector3Color = { r = 224, g = 79, b = 0, a = 100 },			-- dark orange
	defaultFlowchartConnector4Color = { r = 255, g = 153, b = 255, a = 100 },		-- pink
	defaultTitleTrapezoidBackgroundColor = { r = 66, g = 92, b = 111, a = 100 },
	statusRed = {r = 255, g = 0, b = 0, a = 100},
	statusOrange = {r = 255, g = 64, b = 0, a = 100},
	statusYellow = {r = 255, g = 255, b = 0, a = 100},
	statusGreen = {r = 0, g = 255, b = 0, a = 100},
	-- rows, cols and rowdata
	currentTableRow = {},
	currentTableCol = {},
	-- misc
	configButtonBorderSize = 2,
	scrollbarWidth = 19,
	yScalingFactor = 0.4,
	borderSize = 3,
	buttonMinHeight = 23,
	slidercellMinHeight = 16,
	editboxMinHeight = 23,
	standardButtons_CloseBack = { close = true, back = true, minimize = false },
	standardButtons_Close = { close = true, back = false, minimize = false },
	standardIndentStep = 15,
	sidebarWidth = 40,
	frameBorder = 25,
	standardButtons_Size = 18,
	maxTableCols = 13,
	maxTextIcons = 15,
}

Helper.titleTextProperties = {
	font = Helper.titleFont,
	fontsize = Helper.titleFontSize,
	x = Helper.titleOffsetX,
	y = Helper.titleOffsetY,
	height = Helper.titleHeight,
	halign = "center",
	cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
	titleColor = Helper.defaultSimpleBackgroundColor,
}
Helper.headerRow1Properties = {
	font = Helper.headerRow1Font,
	fontsize = Helper.headerRow1FontSize,
	x = Helper.headerRow1Offsetx,
	y = Helper.headerRow1Offsety,
	height = Helper.headerRow1Height - Helper.headerRow1Offsety,
	cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
	titleColor = Helper.defaultSimpleBackgroundColor,
}
Helper.headerRowCenteredProperties = {
	font = Helper.headerRow1Font,
	fontsize = Helper.headerRow1FontSize,
	x = Helper.headerRow1Offsetx,
	y = Helper.headerRow1Offsety,
	height = Helper.headerRow1Height - Helper.headerRow1Offsety,
	halign = "center",
	cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
	titleColor = Helper.defaultSimpleBackgroundColor,
}
Helper.subHeaderTextProperties = {
	font = Helper.titleFont,
	fontsize = Helper.standardFontSize,
	height = Helper.subHeaderHeight,
	cellBGColor = { r = 0, g = 0, b = 0, a = 0 },
	titleColor = Helper.defaultSimpleBackgroundColor,
}

Helper.color = {
	black = { r = 0, g = 0, b = 0, a = 100 },
	slidervalue = { r = 71, g = 136, b = 184, a = 100 },
	green = { r = 0, g = 255, b = 0, a = 100 },
	playergreen = { r = 170, g = 255, b = 139, a = 100 },
	grey = { r = 128, g = 128, b = 128, a = 100 },
	lightgreen = { r = 100, g = 225, b = 0, a = 100 },
	lightgrey = { r = 192, g = 192, b = 192, a = 100 },
	orange = { r = 255, g = 192, b = 0, a = 100 },
	darkorange = { r = 128, g = 95, b = 0, a = 100 },
	red = { r = 255, g = 0, b = 0, a = 100 },
	semitransparent = { r = 0, g = 0, b = 0, a = 95 },
	transparent60 = { r = 0, g = 0, b = 0, a = 60 },
	transparent = { r = 0, g = 0, b = 0, a = 0 },
	white = { r = 255, g = 255, b = 255, a = 100 },
	yellow = { r = 144, g = 144, b = 0, a = 100 },
	brightyellow = { r = 255, g = 255, b = 0, a = 100 },
	warning = { r = 192, g = 192, b = 0, a = 100 },
	done = { r = 38, g = 61, b = 78, a = 100 },
	available = { r = 7, g = 29, b = 46, a = 100 },
	darkgrey = { r = 32, g = 32, b = 32, a = 100 },
	mission = { r = 255, g = 190, b = 0, a = 100 },
	warningorange = { r = 255, g = 138, b = 0, a = 100 },
	blue = { r = 90, g = 146, b = 186, a = 100 },
	changedvalue = { r = 255, g = 236, b = 81, a = 100 },
	cyan = { r = 46, g = 209, b = 255, a = 100 },
	checkboxgroup = { r = 0, g = 102, b = 238, a = 60 },
	unselectable = { r = 32, g = 32, b = 32, a = 100 },
	cover = { r = 231, g = 244, b = 70, a = 100 },
	textred = { r = 255, g = 80, b = 80, a = 100 },
	grey64 = { r = 64, g = 64, b = 64, a = 100 },
	illegal = { r = 255, g = 64, b = 0, a = 100 },
	illegaldark = { r = 128, g = 32, b = 0, a = 100 },
}

Helper.intersectorDefenceFactor = 3000

Helper.excludeFromMouseEmulation = {
	["OptionsMenu"] = function () return C.IsStartmenu() end,
	["TopLevelMenu"] = true,
}

Helper.classOrder = {
	["station"]		= 1,
	["ship_xl"]		= 2,
	["ship_l"]		= 3,
	["ship_m"]		= 4,
	["ship_s"]		= 5,
	["ship_xs"]		= 6,
}
Helper.purposeOrder = {
	["fight"]		= 1,
	["auxiliary"]	= 2,
	["build"]		= 3,
	["mine"]		= 4,
	["dismantling"] = 5,
	["salvage"]		= 6,
	["trade"]		= 7,
}
Helper.raceSorting = {
	["argon"] = 1,
	["teladi"] = 2,
	["paranid"] = 3,
	["split"] = 4,
	["terran"] = 5,
}
Helper.genderSorting = {
	["female"] = 1,
	["male"] = 2,
}

Helper.slotSizeOrder = {
	["extralarge"]	= 1,
	["large"]		= 2,
	["medium"]		= 3,
	["small"]		= 4,
}

Helper.slotTypeOrder = {
	["shields"]		= 1,
	["engines"]		= 2,
	["turrets"]		= 3
}

Helper.autoFrameHeight = 0

local objDescriptors = { }
local viewDescriptors = { }

-- forward declarations of local functions
local onUpdate								-- callback, delegates to onUpdateHandler
local onUpdateHandler = nil					-- a function will be called once per frame when assigned to this variable
local onChatUpdateHandler = nil				-- a function will be called once per frame when assigned to this variable

local getSectionBaseParam

local closeMenu

local registerObjDescriptor
local registerViewDescriptor
local releaseObjectDescriptors
local releaseViewDescriptors

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	SetScript("onUpdate", onUpdate)
	
	RegisterEvent("playerUndock", function () Helper.isPlayerUndocking = true end)
	RegisterEvent("playerUndocked", function () Helper.isPlayerUndocking = nil end)
	RegisterEvent("textdbreload", function () Helper.texts = {} end)

	C.ClearTrackedMenus()

	if Menus then
		-- Register menus that have been initialized before Helper
		-- (menus that are initialized after Helper have to call Helper.registerMenu() themselves)
		for _, menu in ipairs(Menus) do
			Helper.registerMenu(menu)
		end
	end

	Helper.viewWidth, Helper.viewHeight = GetWidgetSystemSize()
	Helper.uiScale = C.GetUIScale(C.IsVRMode())

	Helper.createTopLevelConfig()
	Helper.createPlayerInfoConfig()

	-- kuertee start:
	Helper.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function Helper.init_kuertee ()
	DebugError("menu_helper.xpl.init - kuertee")
end
-- kuertee end

function Helper.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESET TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- name = createLSOStorageNode_get_ware_name(ware)
	-- onExpandLSOStorageNode_list_incoming_trade(row, name, reservation)
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end

function Helper.debugText (data1, data2, indent, isForced)
	local isDebug = false
	if isDebug == true or isForced == true then
		if indent == nil then
			indent = ""
		end
		if type (data1) == "table" then
			for i, value in pairs (data1) do
				DebugError ("kuertee " .. indent .. tostring (i) .. ReadText (1001, 120) .. " " .. tostring (value))
				if type (value) == "table" then
					Helper.debugText(value, nil, indent .. "    ", isForced)
				end
			end
		else
			DebugError ("kuertee " .. indent .. tostring (data1) .. " (" .. type(data1) .. ")")
		end
		if data2 then
			Helper.debugText(data2, nil, indent .. "    ", isForced)
		end
	end
end

function Helper.debugText_forced (data1, data2, indent)
	return Helper.debugText(data1, data2, indent, true)
end
-- kuertee end

---------------------------------------------------------------------------------
-- Wrapper
---------------------------------------------------------------------------------

Helper.texts  = {}
local origreadtext = ReadText
ReadText = function(page, line) 
	local refstr = page .. "-" .. line
	local text = Helper.texts[refstr]
	if not text then
		text = origreadtext(page, line)
		Helper.texts[refstr] = text
	end
	return text
end

---------------------------------------------------------------------------------
-- Scaling
---------------------------------------------------------------------------------

function Helper.round(x, digits)
	local mult = 1
	if digits and digits > 0 then
		mult = 10^digits
	end
	if x == nil then
		DebugError("Invalid number provided to Helper.round().")
		DebugError(TraceBack())
	else
		return math.floor(x * mult + 0.5) / mult
	end
end

function Helper.scaleX(x, enabled)
	if enabled ~= false then
		return Helper.round(x * Helper.uiScale)
	end
	return Helper.round(x)
end

function Helper.scaleY(y, enabled)
	if enabled ~= false then
		return Helper.round(y * Helper.uiScale)
	end
	return Helper.round(y)
end

function Helper.scaleFont(fontname, fontsize, enabled)
	-- the enable argument was added for consistency with the other scale-functions
	-- TODO: review whether that is reasonable - i.e. should there ever be a scaleFont() call with enabled being set to false?
	if enabled ~= false then
		-- note: this is inconsistent with the usual fontsize scale behavior (which is to use the floating point fontsize rather than applying a rounding logic in the caller)
		--       it was left unchanged however, since it might result in issues throughout menus and hence should be reviewed by someone at some point --- it's suggested to simply
		--       return fontsize * Helper.uiScale
		--       This will make a difference of 1pt for fontsizes at most (i.e. a fontsize of 15.4 becomes 16 by the current logic; when passing in 15.4 as the fontsize this would become
		--       15 however)
		-- TODO: review eventually
		return math.ceil(fontsize * Helper.uiScale)
	end
	return fontsize
end

function Helper.getRelativeRenderTargetSize(menu, layer, rendertarget)
	local renderX0, renderX1, renderY0, renderY1

	local rendertargetWidth, rendertargetHeight = GetSize(rendertarget)
	local rendertargetOffsetX, rendertargetOffsetY = GetOffset(rendertarget)
	rendertargetOffsetX = rendertargetOffsetX + menu.frameData[layer].x
	rendertargetOffsetY = rendertargetOffsetY + menu.frameData[layer].y

	renderX0 = 2 * (rendertargetOffsetX / Helper.viewWidth) - 1
	renderX1 = 2 * (rendertargetWidth + rendertargetOffsetX) / Helper.viewWidth - 1
	renderY0 = 1 - 2 * (rendertargetHeight + rendertargetOffsetY) / Helper.viewHeight
	renderY1 = 1 - 2 * (rendertargetOffsetY / Helper.viewHeight)

	return renderX0, renderX1, renderY0, renderY1
end

---------------------------------------------------------------------------------
-- Supported savegame filenames
---------------------------------------------------------------------------------

Helper.validSaveFilenames = {}
Helper.validSaveFilenames["online_save"] = true
Helper.validSaveFilenames["quicksave"] = true
for i = 1, 3 do
	Helper.validSaveFilenames[string.format("autosave_%02d", i)] = true
end
for i = 1, 10 do
	Helper.validSaveFilenames[string.format("save_%03d", i)] = true
end

---------------------------------------------------------------------------------
-- empty cell descriptors
---------------------------------------------------------------------------------

Helper.emptyCellDescriptor = CreateFontString("", Helper.standardHalignment, Helper.standardColor.r, Helper.standardColor.g, Helper.standardColor.b, Helper.standardColor.a, Helper.standardFont, Helper.standardFontSize, false, Helper.standardTextOffsetx, Helper.standardTextOffsety)

function Helper.getEmptyCellDescriptor()
	return Helper.emptyCellDescriptor
end

---------------------------------------------------------------------------------
-- current table selection
---------------------------------------------------------------------------------

Helper.currentTableRow = {}
Helper.currentTableCol = {}

---------------------------------------------------------------------------------
-- Menu registration and function hook management
---------------------------------------------------------------------------------

function onUpdate()
	-- delegate function call so we don't have to set and remove the callback all the time
	if onUpdateHandler then
		onUpdateHandler()
	end
	if onChatUpdateHandler then
		onChatUpdateHandler()
	end
end

local function createCustomHooks(menu)
	menu.rowChanged = function(uitable, row, modified, input, source)
							Helper.currentTableRow[uitable] = row
							-- row data is data provided in addSelectRow(), or nil otherwise
							local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
							local layer = Helper.findFrameLayer(menu, uitable)
							if menu.onRowChangedSound then
								menu.onRowChangedSound(row, rowdata, uitable, layer, modified, input, source)
							elseif (menu.frames[layer] == GetActiveFrame()) and (uitable == GetInteractiveObject(menu.frames[layer])) then
								PlaySound("ui_positive_hover_normal")
							end
							menu.sound_rowChanged[uitable] = getElapsedTime()
							if menu.onRowChanged then
								menu.onRowChanged(row, rowdata, uitable, modified, input, source)
							end
						end
	menu.colChanged = function(uitable, col)
							local layer = Helper.findFrameLayer(menu, uitable)
							if menu.onColChangedSound then
								menu.onColChangedSound(Helper.currentTableRow[uitable], col, uitable)
							elseif (menu.frames[layer] == GetActiveFrame()) and (uitable == GetInteractiveObject(menu.frames[layer])) then
								if (not menu.sound_rowChanged[uitable]) or (menu.sound_rowChanged[uitable] < getElapsedTime()) then
									PlaySound("ui_positive_hover_normal")
								end
							end
							Helper.currentTableCol[uitable] = col
							if menu.onColChanged then
								menu.onColChanged(Helper.currentTableRow[uitable], col, uitable)
							end
						end
	menu.selectElement = function(uitable, modified, row, isdblclick, input)
							if menu.onSelectElementSound then
								menu.onSelectElementSound()
							else
								--PlaySound("ui_table_row_select")
							end
							if menu.onSelectElement then
								menu.onSelectElement(uitable, modified, row, isdblclick, input)
							end
						end
	menu.interactiveElementChanged = function(_, element)
							if menu.onInteractiveElementChanged then
								menu.onInteractiveElementChanged(element)
							end
						end
	menu.renderTargetSelect = function(rendertarget, modified)
							if menu.onRenderTargetSelect then
								menu.onRenderTargetSelect(modified)
							end
						end
	menu.renderTargetDoubleClick = function(rendertarget, modified)
							if menu.onRenderTargetDoubleClick then
								menu.onRenderTargetDoubleClick(modified)
							end
						end
	menu.renderTargetMouseDown = function(rendertarget, modified)
							if menu.onRenderTargetMouseDown then
								menu.onRenderTargetMouseDown(modified)
							end
						end
	menu.renderTargetMouseUp = function(rendertarget, modified)
							if menu.onRenderTargetMouseUp then
								menu.onRenderTargetMouseUp(modified)
							end
						end
	menu.renderTargetMiddleMouseDown = function(rendertarget, modified)
							if menu.onRenderTargetMiddleMouseDown then
								menu.onRenderTargetMiddleMouseDown(modified)
							end
						end
	menu.renderTargetMiddleMouseUp = function(rendertarget, modified)
							if menu.onRenderTargetMiddleMouseUp then
								menu.onRenderTargetMiddleMouseUp(modified)
							end
						end
	menu.renderTargetRightMouseClick = function(rendertarget, modified)
							if menu.onRenderTargetRightMouseClick then
								menu.onRenderTargetRightMouseClick(modified)
							end
						end
	menu.renderTargetRightMouseDown = function(rendertarget, modified)
							if menu.onRenderTargetRightMouseDown then
								menu.onRenderTargetRightMouseDown(modified)
							end
						end
	menu.renderTargetRightMouseUp = function(rendertarget, modified)
							if menu.onRenderTargetRightMouseUp then
								menu.onRenderTargetRightMouseUp(modified)
							end
						end
	menu.renderTargetCombinedScrollDown = function(rendertarget, step)
							if menu.onRenderTargetCombinedScrollDown then
								menu.onRenderTargetCombinedScrollDown(step)
							end
						end
	menu.renderTargetCombinedScrollUp = function(rendertarget, step)
							if menu.onRenderTargetCombinedScrollUp then
								menu.onRenderTargetCombinedScrollUp(step)
							end
						end
	menu.renderTargetScrollDown = function(rendertarget)
							if menu.onRenderTargetScrollDown then
								menu.onRenderTargetScrollDown()
							end
						end
	menu.renderTargetScrollUp = function(rendertarget)
							if menu.onRenderTargetScrollUp then
								menu.onRenderTargetScrollUp()
							end
						end
	menu.closeElement = function(widget, dueToClose)
							if menu.onCloseElementSound then
								menu.onCloseElementSound()
							else
								PlaySound("ui_menu_close")
							end
							local layer = Helper.findFrameLayer(menu, widget)
							if layer then
								if dueToClose == "auto" then
									if menu.cleanup then
										menu.cleanup()
									end
									Helper.clearMenu(menu)
								else
									menu.onCloseElement(dueToClose, layer)
								end
							end
						end
	menu.editBoxActivated = function(widget)
							if menu.onEditBoxActivated then
								menu.onEditBoxActivated(widget)
							end
						end
	menu.editBoxCursorChanged = function(widget)
							if menu.onEditBoxCursorChanged then
								menu.onEditBoxCursorChanged(widget)
							end
						end
	menu.editboxRightMouseClick = function(widget)
							if menu.onEditboxRightMouseClick then
								menu.onEditboxRightMouseClick(widget)
							end
						end
	menu.tableScrollBarOver = function()
							if menu.onTableScrollBarOver then
								menu.onTableScrollBarOver()
							else
								PlaySound("ui_sbar_table_over")
							end
						end
	menu.tableScrollBarDown = function()
							if menu.onTableScrollBarDown then
								menu.onTableScrollBarDown()
							else
								PlaySound("ui_sbar_table_down")
							end
						end
	menu.tableScrollBarUp = function()
							if menu.onTableScrollBarUp then
								menu.onTableScrollBarUp()
							end
						end
	menu.sliderScrollBarOver = function()
							if menu.onSliderScrollBarOver then
								menu.onSliderScrollBarOver()
							else
								PlaySound("ui_sbar_slider_over")
							end
						end
	menu.sliderScrollBarDown = function()
							if menu.onSliderScrollBarDown then
								menu.onSliderScrollBarDown()
							else
								PlaySound("ui_sbar_slider_down")
							end
						end
	menu.tableRightMouseClick = function(uitable, row, posx, posy)
							if menu.onTableRightMouseClick then
								menu.onTableRightMouseClick(uitable, row, posx, posy)
							end
						end
	menu.tableMouseOver = function(uitable, row)
							if menu.onTableMouseOver then
								menu.onTableMouseOver(uitable, row)
							end
						end
	menu.tableMouseOut = function(uitable, row)
							if menu.onTableMouseOut then
								menu.onTableMouseOut(uitable, row)
							end
						end
	menu.buttonRightMouseClick = function(button, row, col, posx, posy)
							if menu.onButtonRightMouseClick then
								menu.onButtonRightMouseClick(button, row, col, posx, posy)
							end
						end
	menu.buttonOver = function(input, button)
							local uitable, row, col
							for i = 1, #menu.buttonScriptMap do
								local scriptdata = menu.buttonScriptMap[i]
								if scriptdata.button == button then
									uitable = scriptdata.tableobj
									row = scriptdata.row
									col = scriptdata.col
									break
								end
							end
							if menu.onButtonOverSound then
								menu.onButtonOverSound(uitable, row, col, button, input)
							else
								if not menu.sound_selectedelement or button ~= menu.sound_selectedelement then
									if input == "mouse" then
										if (not menu.sound_buttonOverLock) then
											PlaySound("ui_positive_hover_normal")
											menu.sound_buttonOverLock = true
										end
									end
								end
								menu.sound_selectedelement = button
							end
							if menu.onButtonOver then
								menu.onButtonOver(uitable, row, col, button, input)
							end
						end
	menu.buttonOut = function(input, button)
							menu.sound_buttonOverLock = nil
						end
	menu.buttonDown = function()
							if menu.onButtonDown then
								menu.onButtonDown()
							else
								PlaySound("ui_positive_click")
							end
						end
	menu.buttonUp = function()
							if menu.onButtonUp then
								menu.onButtonUp()
							end
						end
	-- triggers when your mouse moves away from a standard button
	menu.standardButtonOut = function()
						end
	-- triggers when your mouse moves to a position over a standard button
	menu.standardButtonOver = function()
							PlaySound("ui_btn_standard_over")
						end
	menu.checkboxOver = function()
							--PlaySound("ui_positive_hover_normal")
						end
	menu.editboxUpdateText = function(editbox, text, textchanged, wasconfirmed)
							if menu.onEditboxUpdateText then
								menu.onEditboxUpdateText(editbox, text, textchanged, wasconfirmed)
							end
						end
	menu.editboxTextChanged = function(editbox, text)
							if menu.onEditboxTextChanged then
								menu.onEditboxTextChanged(editbox, text)
							end
						end
	menu.dropdownActivated = function(dropdown)
							PlaySound("ui_positive_click")
							if menu.onDropDownActivated then
								menu.onDropDownActivated(dropdown)
							end
						end
	menu.dropdownConfirmed = function(dropdown, value)
							PlaySound("ui_positive_click")
							if menu.onDropDownConfirmed then
								menu.onDropDownConfirmed(dropdown, value)
							end
						end
	menu.dropdownRemoved = function(dropdown, value)
							if menu.onDropDownRemoved then
								menu.onDropDownRemoved(dropdown, value)
							end
						end
	menu.slidercellChanged = function(slidercell, newvalue)
						end
	menu.slidercellActivated = function(slidercell)
							if menu.onSliderCellActivated then
								menu.onSliderCellActivated(slidercell)
							end
						end
	menu.slidercellDeactivated = function(slidercell, newvalue, valuechanged)
						end
	menu.slidercellRightMouseClick = function(slidercell, row, col, posx, posy)
							if menu.onSliderCellRightMouseClick then
								menu.onSliderCellRightMouseClick(slidercell, row, col, posx, posy)
							end
						end
	menu.slidercellConfirm = function(slidercell, newvalue, valuechanged)
							if menu.onSliderCellConfirm then
								menu.onSliderCellConfirm(newvalue, valuechanged)
							end
						end
	menu.slidercellDown = function()
							if menu.onSliderCellDown then
								menu.onSliderCellDown()
							else
								PlaySound("ui_sbar_slider_down")
							end
						end
	menu.slidercellRightOver = function()
							if menu.onSliderCellRightOver then
								menu.onSliderCellRightOver()
							else
								PlaySound("ui_sbar_btn_right_over")
							end
						end
	menu.slidercellRightDown = function()
							if menu.onSliderCellRightDown then
								menu.onSliderCellRightDown()
							else
								PlaySound("ui_sbar_btn_right_down")
							end
						end
	menu.slidercellLeftOver = function()
							if menu.onSliderCellLeftOver then
								menu.onSliderCellLeftOver()
							else
								PlaySound("ui_sbar_btn_left_over")
							end
						end
	menu.slidercellLeftDown = function()
							if menu.onSliderCellLeftDown then
								menu.onSliderCellLeftDown()
							else
								PlaySound("ui_sbar_btn_left_down")
							end
						end
	menu.onConversationCancelled = function()
										if menu.onCloseElement then
											menu.onCloseElement("close", nil, true)
										end
										Helper.clearMenu(menu)
								end
	menu.onDialogOptionSelected = function()
								end
end

function Helper.registerMenu(menu)
	menu.rowDataMap = {}
	menu.frameData = {}
	menu.sound_rowChanged = {}

	createCustomHooks(menu)

	-- Create and register a closure that will be called when the menu should be started
	menu.showMenuCallback = function(...)
		if C.IsGameOver() and (menu.name ~= "OptionsMenu") then
			return
		end
		if not menu.shown then
			-- Set up menu parameters
			local name, param, param2 = GetMenuParameters2()
			if name ~= menu.name then
				-- menu parameters do not match the menu name, do not show the menu (this can happen if menus are opened in the same frame, e.g. click transporter room button and press esc)
				return
			end
			menu.param = param
			menu.param2 = param2
			if menu.name == "DockedMenu" then
				-- if there is a minimized menu, restore it instead
				if Helper.minimizedMenu then
					Helper.restoreMenu(Helper.minimizedMenu)
					return
				end
				-- if the top level tab is open, open the docked menu anyway
				if (not Helper.topLevelMenu) and View.hasMenu({ Helper = true }) then
					return
				end
				if Helper.topLevelMenu then
					local topLevelMenu = Helper.topLevelMenu
					Helper.closeMenu(topLevelMenu, "close")
					topLevelMenu.cleanup()
				end
				Helper.topLevelMenu = nil
				Helper.dockedMenu = menu
			elseif menu.name == "TopLevelMenu" then
				-- if the docked menu is open, open the top level tab anyway
				if (not Helper.dockedMenu) and View.hasMenu({ Helper = true }) then
					return
				end
				if Helper.dockedMenu then
					local dockedMenu = Helper.dockedMenu
					Helper.closeMenu(dockedMenu, "close")
					dockedMenu.cleanup()
				end
				Helper.dockedMenu = nil
				Helper.topLevelMenu = menu
			else
				if Helper.dockedMenu then
					local dockedMenu = Helper.dockedMenu
					Helper.closeMenu(dockedMenu, "close")
					dockedMenu.cleanup()
				end
				if Helper.topLevelMenu then
					local topLevelMenu = Helper.topLevelMenu
					Helper.closeMenu(topLevelMenu, "close")
					topLevelMenu.cleanup()
				end
			end

			menu.shown = true
			menu.minimized = false
			if menu.name == "OptionsMenu" then
				-- the options menu is never a conversation menu, but is allowed during inescapable conversations
				-- force flag to false so the unrelated conversations do not get returned when closing the menu
				menu.conversationMenu = false
			else
				menu.conversationMenu = C.IsConversationActive() and (not C.IsConversationCancelling())
			end
			View.clearMenus({ Helper = true })

			if menu.onUpdate then
				local nextUpdateTime = 0
				onUpdateHandler = function()
									if GetCurRealTime() >= nextUpdateTime then
										menu.onUpdate()
										nextUpdateTime = GetCurRealTime() + (menu.updateInterval or 0)
									end
								end
			end

			RegisterEvent("conversationCancelled", menu.onConversationCancelled)
			RegisterEvent("dialogOptionSelected", menu.onDialogOptionSelected)
			local state = nil
			if menu.param2 and menu.param2[1] == "restore" then
				state = menu.param2[2]
				menu.param2 = menu.param2[3]
			end
			C.TrackMenu(menu.name, true)
			AddUITriggeredEvent(menu.name, "", menu.param)
			if menu.onShowMenuSound then
				menu.onShowMenuSound()
			else
				if not C.IsNextStartAnimationSkipped(false) then
					PlaySound("ui_map_open")
				else
					PlaySound("ui_menu_changed")
				end
			end
			local excludeEmulation = Helper.excludeFromMouseEmulation[menu.name]
			if type(excludeEmulation) == "function" then
				excludeEmulation = excludeEmulation()
			end
			if not excludeEmulation then
				C.EnableAutoMouseEmulation()
			end
			-- The actual callback
			menu.onShowMenu(state, ...)
		elseif menu.minimized then
			if onRestoreMenuSound then
				onRestoreMenuSound()
			else
				PlaySound("ui_map_open")
			end
			local excludeEmulation = Helper.excludeFromMouseEmulation[menu.name]
			if type(excludeEmulation) == "function" then
				excludeEmulation = excludeEmulation()
			end
			if not excludeEmulation then
				C.EnableAutoMouseEmulation()
			end
			Helper.restoreMenu(menu)
		else
			if menu.name == "InteractMenu" then
				Helper.closeMenu(menu, "close")
			end
			C.SetWidgetViewScheduled(false)
		end
	end
	RegisterEvent("show"..menu.name, menu.showMenuCallback)
	if menu.name == "InteractMenu" then
		Helper.interactMenuCallbacks = {
			show = menu.showInteractMenu,
			update = menu.onUpdate,
			close = menu.onCloseElement,
		}
	elseif menu.name == "ChatWindow" then
		Helper.chatWindowCallbacks = {
			callback = menu.callback,
		}
	end
end

function Helper.setChatUpdateHandler(menu)
	if menu.onUpdate then
		local nextUpdateTime = 0
		onChatUpdateHandler = function()
							if GetCurRealTime() >= nextUpdateTime then
								menu.onUpdate()
								nextUpdateTime = GetCurRealTime() + (menu.updateInterval or 0)
							end
						end
	end
end

function Helper.clearChatUpdateHandler()
	onChatUpdateHandler = nil
end

function Helper.closeMinimizedMenus()
	if Helper.minimizedMenu then
		for layer, frame in pairs(Helper.minimizedMenu.frames) do
			Helper.minimizedMenu.onCloseElement("auto", layer)
		end
		Helper.minimizedMenu = nil
	end
end

function Helper.minimizeMenu(menu, text)
	if (not menu.conversationMenu) and (not menu.minimized) then
		menu.minimized = true
		Helper.minimizedMenu = menu
		-- disable mouse emulation mode
		C.DisableAutoMouseEmulation()
		-- if a menu was minimized once forget the history of the menu so the previous will not pop-up after hours of on-off use of this menu
		menu.param2 = nil
		-- clean up scripts
		Helper.removeAllWidgetScripts(menu)
		Helper.removeAllKeyBindings(menu)
		Helper.removeAllTabScrollCallbacks(menu)
		Helper.removeAllMenuScripts(menu)
		-- unregister callbacks
		UnregisterEvent("conversationCancelled", menu.onConversationCancelled)
		UnregisterEvent("dialogOptionSelected", menu.onDialogOptionSelected)
		for layer, frame in pairs(menu.frames) do
			if IsValidWidgetElement(frame) then
				View.minimizeMenu("Helper" .. layer, text)
			end
		end
		onUpdateHandler = function ()
				onUpdateHandler = nil
				for layer, frame in pairs(menu.frames) do
					if IsValidWidgetElement(frame) then
						-- rehook the onHide event to allow closing and restoring the menu
						Helper.setMenuScript(menu, layer, frame, "onHide", menu.closeElement)
					end
				end
			end

		C.RemoveTrackedMenu(menu.name)

		if menu.onMinimizeMenu then
			menu.onMinimizeMenu()
		end
	end
end

function Helper.restoreMenu(menu)
	if (not menu.conversationMenu) and (menu.minimized) then
		Helper.removeAllMenuScripts(menu)
		menu.minimized = nil
		Helper.minimizedMenu = nil
		RegisterEvent("conversationCancelled", menu.onConversationCancelled)
		RegisterEvent("dialogOptionSelected", menu.onDialogOptionSelected)
		for layer, frame in pairs(menu.frames) do
			if IsValidWidgetElement(frame) then
				View.restoreMenu("Helper" .. layer)
			end
		end
		if menu.onUpdate then
			local nextUpdateTime = 0
			onUpdateHandler = function()
								if GetCurRealTime() >= nextUpdateTime then
									menu.onUpdate()
									nextUpdateTime = GetCurRealTime() + (menu.updateInterval or 0)
								end
							end
		end

		C.TrackMenu(menu.name, true)

		if menu.onRestoreMenu then
			menu.onRestoreMenu()
		end
	end
end

function Helper.clearFrame(menu, layer)
	Helper.removeAllWidgetScripts(menu, layer)
	Helper.removeAllMenuScripts(menu, layer)
	View.unregisterMenu("Helper" .. layer)
	menu.frames[layer] = nil
end

function Helper.clearMenu(menu, UpdateHandler)
	-- stop mouse emulation
	C.DisableAutoMouseEmulation()
	-- cleanup
	if menu.name == "DockedMenu" then
		Helper.dockedMenu = nil
	elseif menu.name == "TopLevelMenu" then
		Helper.topLevelMenu = nil
	end
	-- clean up scripts
	Helper.removeAllWidgetScripts(menu)
	Helper.removeAllKeyBindings(menu)
	Helper.removeAllTabScrollCallbacks(menu)
	Helper.removeAllMenuScripts(menu)
	-- unregister callbacks
	if not menu.minimized then
		UnregisterEvent("conversationCancelled", menu.onConversationCancelled)
		UnregisterEvent("dialogOptionSelected", menu.onDialogOptionSelected)
	end
	-- necessary API calls for cleanup
	for layer, frame in pairs(menu.frames) do
		if IsValidWidgetElement(frame) then
			View.unregisterMenu("Helper" .. layer)
		end
	end
	HideAllShapes()
	-- clean up table data
	menu.currentTableRow = {}
	menu.currentTableCol = {}
	menu.rowDataMap = {}
	-- clean up parameters
	menu.param = nil
	menu.param2 = nil
	menu.frames = {}
	menu.tableConnections = {}
	menu.shown = nil
	menu.defaulttable = nil
	onUpdateHandler = UpdateHandler
end

function Helper.findFrameLayer(menu, widget)
	for layer, frame in pairs(menu.frames) do
		if widget == frame then
			return layer
		end
		local children = table.pack(GetChildren(frame))
		for _, child in ipairs(children) do
			if child == widget then
				return layer
			end
		end
	end
end

function Helper.setMenuScript(menu, layer, obj, handleType, script)
	SetScript(obj, handleType, script)
	menu.scripts = menu.scripts or { }
	table.insert(menu.scripts, { layer = layer, obj = obj, handleType = handleType, script = script })
end

function Helper.removeMenuScript(obj, handleType, script)
	RemoveScript(obj, handleType, script)
end

function Helper.removeAllMenuScripts(menu, layer)
	menu.scripts = menu.scripts or {}
	menu.frames = menu.frames or {}
	if next(menu.frames) then
		for i = #menu.scripts, 1, -1 do
			local scriptdata = menu.scripts[i]
			if (not layer) or (layer == scriptdata.layer) then
				if menu.frames[scriptdata.layer] and IsValidWidgetElement(menu.frames[scriptdata.layer]) then
					Helper.removeMenuScript(scriptdata.obj, scriptdata.handleType, scriptdata.script)
				end
				table.remove(menu.scripts, i)
			end
		end
	end
end

function Helper.openInteractMenu(menu, param)
	Helper.closeInteractMenu()
	PlaySound("ui_positive_click")

	Helper.interactMenuCallbacks.returnToMenu = menu.onInteractMenuCallback
	Helper.interactMenuCallbacks.onTableMouseOut = menu.onTableMouseOut
	Helper.interactMenuCallbacks.onTableMouseOver = menu.onTableMouseOver

	Helper.interactMenuActive = true
	Helper.updateHandlerBackup = onUpdateHandler
	local nextUpdateTime = 0
	onUpdateHandler = function()
			if GetCurRealTime() >= nextUpdateTime then
				Helper.interactMenuCallbacks.update()
				menu.onUpdate()
				nextUpdateTime = GetCurRealTime() + (menu.updateInterval or 0)
			end
		end

	Helper.interactMenuCallbacks.show(param)
end

function Helper.returnFromInteractMenu(uitable, ...)
	if Helper.interactMenuCallbacks.onTableMouseOut then
		Helper.interactMenuCallbacks.onTableMouseOut(uitable)
	end
	if Helper.interactMenuCallbacks.returnToMenu then
		Helper.interactMenuCallbacks.returnToMenu(...)
	end
	Helper.resetInteractMenuCallbacks()
end

function Helper.closeInteractMenu()
	if Helper.interactMenuActive then
		Helper.resetUpdateHandler()
		Helper.interactMenuCallbacks.close()
		Helper.resetInteractMenuCallbacks()
		return true
	end
	return false
end

function Helper.resetUpdateHandler()
	onUpdateHandler = Helper.updateHandlerBackup
	Helper.interactMenuActive = false
end

function Helper.resetInteractMenuCallbacks()
	Helper.interactMenuCallbacks.returnToMenu = nil
	Helper.interactMenuCallbacks.onTableMouseOut = nil
	Helper.interactMenuCallbacks.onTableMouseOver = nil
end

function Helper.sendChatWindowCallback(param)
	Helper.chatWindowCallbacks.callback(param)
end

-- This or another Helper.closeMenu*() function must be called from menu.onCloseElement()
function Helper.closeMenu(menu, dueToClose, allowAutoMenu, sound)
	local updateHandler
	if allowAutoMenu == nil then
		allowAutoMenu = true
	end
	if (dueToClose == "back") then
		if menu.conversationMenu then
			updateHandler = ReturnFromMenu
			allowAutoMenu = false
		else
			if menu.param2 and (#menu.param2 > 0) then
				C.SkipNextStartAnimation()
				OpenMenu(menu.param2[1], menu.param2[2], menu.param2[3])
				allowAutoMenu = false
			elseif sound ~= false then
				PlaySound("ui_map_close")
			end
		end
	elseif (dueToClose == "close") then
		if Helper.checkDiscardStationEditorChanges(menu) then
			return
		end

		if sound ~= false then
			PlaySound("ui_map_close")
		end
		if menu.conversationMenu then
			updateHandler = CancelConversation
		end
	end
	closeMenu(menu, updateHandler, allowAutoMenu)
end

function Helper.closeMenuAndOpenNewMenu(menu, newname, param, noreturn)
	C.SkipNextStartAnimation()
	if noreturn then
		OpenMenu(newname, Helper.convertComponentIDs(param), menu.param2)
	else
		OpenMenu(newname, Helper.convertComponentIDs(param), { menu.name, menu.param, { "restore", Helper.convertComponentIDs(menu.onSaveState and menu.onSaveState() or false), menu.param2 } })
	end
	closeMenu(menu, nil, false)
end

function Helper.closeMenuAndReturn(menu, returnparam)
	closeMenu(menu, function() ReturnFromMenu(Helper.convertComponentIDs(returnparam)) end, false)
end

function Helper.closeMenuForSection(menu, nextsection, choiceparam)
	closeMenu(menu, function() ProceedFromMenu(nextsection, Helper.convertComponentIDs(choiceparam)) end, false)
end

function Helper.closeMenuForSubSection(menu, nextsection, choiceparam)
	-- Keep a copy of baseparam as upvalue because menu.param may change
	local baseparam = getSectionBaseParam(menu)
	closeMenu(menu, function() ProceedFromMenu(nextsection, Helper.convertComponentIDs(choiceparam), Helper.convertComponentIDs(baseparam)) end, false)
end

function Helper.closeMenuAndCancel(menu)
	closeMenu(menu, CancelConversation, true)
end

function Helper.closeMenuForSubConversation(menu, nextconversation, nextactor, convparam)
	-- Keep a copy of baseparam as upvalue because menu.param may change
	local baseparam = getSectionBaseParam(menu)
	closeMenu(menu, function() StartSubConversationFromMenu(nextconversation, nextactor, Helper.convertComponentIDs(convparam), Helper.convertComponentIDs(baseparam)) end, false)
end

function Helper.closeMenuForNewConversation(menu, conversation, actor, convparam, disablereturn)
	local updateHandler
	if menu.conversationMenu then
		-- TEMP Florian: Remove once menus do not open other menus via the conversation manager
		local baseparam = getSectionBaseParam(menu)
		updateHandler = function() ProceedFromMenu(conversation, Helper.convertComponentIDs(convparam), Helper.convertComponentIDs(baseparam)) end
	else
		if not disablereturn then
			Helper.addConversationReturnHandler(menu)
		end
		updateHandler = function() StartConversationFromMenu(conversation, actor, Helper.convertComponentIDs(convparam)) end
	end
	closeMenu(menu, updateHandler, false)
end

function Helper.onConversationReturned(eventname, sectionname)
	Helper.savedState = Helper.savedState or {}
	local state = Helper.savedState[1]
	if state then
		if sectionname ~= "g_cancel" then
			OpenMenu(state[1], state[2], state[3])
		end
		table.remove(Helper.savedState, 1)
	end
	UnregisterEvent("conversationCancelled", Helper.onConversationReturned)
	UnregisterEvent("conversationFinished", Helper.onConversationReturned)
	Helper.hasConversationReturnHandler = nil
end

function Helper.addConversationReturnHandler(menu)
	Helper.savedState = Helper.savedState or {}
	table.insert(Helper.savedState, 1, { menu.name, menu.param, { "restore", Helper.convertComponentIDs(menu.onSaveState and menu.onSaveState() or false), menu.param2 } })
	Helper.hasConversationReturnHandler = true
	RegisterEvent("conversationCancelled", Helper.onConversationReturned)
	RegisterEvent("conversationFinished", Helper.onConversationReturned)
end

-- Internal helper function for Helper.closeMenuForSubSection() and Helper.closeMenuForSubConversation()
function getSectionBaseParam(menu)
	-- Store menu display state (top row and select row) in baseparam
	if menu.defaulttable then
		if menu.param == nil then
			return {
				GetTopRow(menu.defaulttable),
				Helper.currentTableRow[menu.defaulttable]
			}
		end
		if type(menu.param) == "table" and type(menu.param[1]) == "number" and type(menu.param[2]) == "number" then
			menu.param[1] = GetTopRow(menu.defaulttable)
			menu.param[2] = Helper.currentTableRow[menu.defaulttable]
		end
	end
	return menu.param
end

function Helper.convertComponentIDs(input)
	local universeIDType = ffi.typeof("UniverseID")

	if ffi.istype(universeIDType, input) then
		input = ConvertStringToLuaID(tostring(input))
	elseif type(input) == "table" then
		for key, value in pairs(input) do
			input[key] = Helper.convertComponentIDs(value)
		end
	end

	return input
end

-- Internal helper function for Helper.closeMenu*()
function closeMenu(menu, resultfunc, allowAutoMenu)
	if not menu.minimized then
		C.RemoveTrackedMenu(menu.name)
	end
	AddUITriggeredEvent(menu.name, "menu_close")
	if menu.name == "DockedMenu" then
		Helper.dockedMenu = nil
		if allowAutoMenu then
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
				OpenMenu("TopLevelMenu", { 0, 0 }, nil)
			end
		end
	elseif menu.name == "TopLevelMenu" then
		Helper.topLevelMenu = nil
	elseif allowAutoMenu and (not Helper.isPlayerUndocking) then
		local iscontrollingdockedship = false
		local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
		if (occupiedship ~= 0) then
			iscontrollingdockedship = GetComponentData(occupiedship, "isdocked")
		end
		local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
		if iscontrollingdockedship or ((controlpost ~= "") and (controlpost ~= "pilotcontrol")) then
			C.SkipNextStartAnimation()
			OpenMenu("DockedMenu", { 0, 0 }, nil)
		elseif (occupiedship ~= 0) then
			OpenMenu("TopLevelMenu", { 0, 0 }, nil)
		end
	end
	-- Wake up conversation and send menu result (even if nil or false) but only on next frame!
	-- This gives the current menu a chance to clean things up, in case the conversation decides to open another menu right away
	local UpdateHandler
	if resultfunc then
		UpdateHandler = function()
							onUpdateHandler = nil	-- don't call me again
							UnsuspendConversation()
							-- NOTE: This must happen AFTER UnsuspendConversation()
							resultfunc()
						end
	else
		UpdateHandler = nil
	end
	Helper.clearMenu(menu, UpdateHandler)
end

---------------------------------------------------------------------------------
-- Descriptor reference management
---------------------------------------------------------------------------------

function registerObjDescriptor(descriptor)
	if not descriptor then DebugError(TraceBack()) end
	-- Avoid duplicates
	objDescriptors[descriptor] = true
	return descriptor
end

function registerViewDescriptor(descriptor)
	if not descriptor then DebugError(TraceBack()) end
	-- Avoid duplicates
	viewDescriptors[descriptor] = true
	return descriptor
end

function releaseObjectDescriptors()
	for descriptor, _ in pairs(objDescriptors) do
		if not ReleaseDescriptor(descriptor) then
			DebugError("Presentation error. Failed to free a UI object descriptor. Skipping that one.")
		end
	end
	objDescriptors = { }
end

function releaseViewDescriptors()
	for descriptor, _ in pairs(viewDescriptors) do
		if not ReleaseViewDescriptor(descriptor) then
			DebugError("Presentation error. Failed to free a UI view descriptor. Skipping that one.")
		end
	end
	viewDescriptors = { }
end

function Helper.releaseDescriptors()
	releaseViewDescriptors()
	releaseObjectDescriptors()
end

---------------------------------------------------------------------------------
-- Object descriptor creation wrappers
---------------------------------------------------------------------------------

function Helper.createFontString(text, noscaling, halignment, textred, textgreen, textblue, textalpha, fontname, fontsize, wordwrap, offsetx, offsety, height, width, mouseovertext)
	if halignment == nil then
		halignment = Helper.standardHalignment
	end
	if textred == nil then
		textred = Helper.standardColor.r
	end
	if textgreen == nil then
		textgreen = Helper.standardColor.g
	end
	if textblue == nil then
		textblue = Helper.standardColor.b
	end
	if textalpha == nil then
		textalpha = Helper.standardColor.a
	end
	if fontname == nil then
		fontname = Helper.standardFont
	end
	if fontsize == nil then
		fontsize = Helper.standardFontSize
	end
	if offsetx == nil then
		offsetx = Helper.standardTextOffsetx
	end
	if offsety == nil then
		offsety = Helper.standardTextOffsety
	end
	if height == nil then
		height = Helper.standardTextHeight
	end
	if width == nil then
		width = Helper.standardTextWidth
	end
	if mouseovertext == nil then
		mouseovertext = ""
	end
	if not noscaling then
		fontsize	= Helper.scaleFont(fontname, fontsize)
		offsetx		= Helper.scaleX(offsetx)
		offsety		= Helper.scaleY(offsety)
		height		= Helper.scaleY(height)
		width		= Helper.scaleX(width)
	end
	if height and height ~= 0 then
		height = height - offsety
	end
	if width and width ~= 0 then
		width = width - offsetx
	end
	local desc = CreateFontString(text, halignment, textred, textgreen, textblue, textalpha, fontname, fontsize, wordwrap, offsetx, offsety, height, width, mouseovertext)
	return registerObjDescriptor(desc)
end

function Helper.createGraph(type, noscaling, bgcolor, title, xaxis, yaxis, datarecords, offsetx, offsety, width, height, mouseovertext)
	local graphDescriptor = {}
	graphDescriptor.type = type
	graphDescriptor.bgcolor = bgcolor
	graphDescriptor.title = title
	graphDescriptor.xAxis = xaxis
	graphDescriptor.yAxis = yaxis
	graphDescriptor.offset = { x = offsetx or 0, y = offsety or 0 }
	graphDescriptor.size = { width = width or 0, height = height or 0 }
	graphDescriptor.mouseovertext = mouseovertext

	graphDescriptor.datarecords = {}
	graphDescriptor.icons = {}
	for datarecordidx, datarecord in ipairs(datarecords) do
		for dataidx, datapoint in ipairs(datarecord.data) do
			if datapoint.icon then
				table.insert(graphDescriptor.icons, { datarecord = datarecordidx, data = dataidx, icon = datapoint.icon, mouseovertext = datapoint.mouseovertext })
				datarecord.data.icon = nil
				datarecord.data.mouseovertext = nil
			end
		end
		table.insert(graphDescriptor.datarecords, datarecord)
	end

	if not noscaling then
		graphDescriptor.offset.x		= Helper.scaleX(graphDescriptor.offset.x)
		graphDescriptor.offset.y		= Helper.scaleY(graphDescriptor.offset.y)
		graphDescriptor.size.width		= Helper.scaleX(graphDescriptor.size.width)
		graphDescriptor.size.height		= Helper.scaleY(graphDescriptor.size.height)

		if graphDescriptor.title then
			graphDescriptor.title.size = Helper.scaleFont(graphDescriptor.title.font, graphDescriptor.title.size)
		end
		if graphDescriptor.xAxis.label then
			graphDescriptor.xAxis.label.size = Helper.scaleFont(graphDescriptor.xAxis.label.font, graphDescriptor.xAxis.label.size)
		end
		if graphDescriptor.yAxis.label then
			graphDescriptor.yAxis.label.size = Helper.scaleFont(graphDescriptor.yAxis.label.font, graphDescriptor.yAxis.label.size)
		end
		for _, datarecord in ipairs(graphDescriptor.datarecords) do
			if datarecord.marker then
				datarecord.marker.size = Helper.scaleX(datarecord.marker.size)
			end
			if datarecord.line then
				datarecord.line.width = math.floor(Helper.scaleY(datarecord.line.width) / 2) * 2
			end
		end
	end

	local desc = CreateGraph(graphDescriptor)
	return registerObjDescriptor(desc)
end

function Helper.createGraphText(text, fontname, fontsize, color)
	return { text = text or "", font = fontname or Helper.standardFont, size = fontsize or Helper.standardFontSize, color = color or Helper.standardColor }
end

function Helper.createGraphAxis(label, startvalue, endvalue, granularity, offset, grid, color, gridcolor)
	return { label = label, startvalue = startvalue, endvalue = endvalue, granularity = granularity, offset = offset, grid = grid, color = color or Helper.standardColor, gridcolor = gridcolor or Helper.standardColor}
end

function Helper.createGraphDataRecord(markertype, markersize, markercolor, linetype, linewidth, linecolor, data, highlighted, mouseovertext)
	local marker
	if markertype then
		marker = { type = markertype, size = markersize or 1, color = markercolor or 1 }
	end

	local line
	if linetype then
		line = { type = linetype, width = linewidth or 1, color = linecolor or 1 }
	end

	return { marker = marker, line = line, data = data, highlighted = highlighted, mouseovertext = mouseovertext }
end

function Helper.createGraphDataPoint(x, y, icon, mouseovertext, inactive)
	return { x = x, y = y, icon = icon, mouseovertext = mouseovertext, inactive = inactive }
end

function Helper.createIcon(texturename, noscaling, red, green, blue, alpha, offsetx, offsety, height, width, mouseovertext, text, text2)
	if not noscaling then
		if text then
			text.fontsize = text.fontsize and Helper.scaleFont(text.fontname, text.fontsize) or text.fontsize
		end
		if text2 then
			text2.fontsize = text2.fontsize and Helper.scaleFont(text2.fontname, text2.fontsize) or text2.fontsize
		end

		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width
	end

	if width and width ~= 0 then
		if text then
			text.text = TruncateText(text.text, text.fontname, text.fontsize, width - (text.x and (2 * text.x) or 0))
		end
		if text2 then
			text2.text = TruncateText(text2.text, text2.fontname, text2.fontsize, width - (text2.x and (2 * text2.x) or 0))
		end
	end

	local desc = CreateIcon(texturename, red, green, blue, alpha, offsetx, offsety, height, width, mouseovertext, text, text2)

	return registerObjDescriptor(desc)
end

--    [icon] = {                   -- icon and text are mutually exclusive
--        [iconID]     = string,   -- the iconID
--        [swapIconID] = string,   -- the iconID used when the button has been clicked on (optional - defaults to nil)
--        [color] = {              -- icon color (optional - defaults to no icon color)
--            [r] = number,        -- red color value 0-255
--            [g] = number,        -- green color value 0-255
--            [b] = number         -- blue color value 0-255
--            [a] = number         -- alpha value 0-100
--        },
--		  [x]		= number,	   -- x offset
--		  [y]		= number,	   -- y offset
--		  [width]	= number,	   -- width
--		  [height]	= number	   -- height
--    }
--    [icon2] = {                   -- icon and text are mutually exclusive
--        [iconID]     = string,   -- the iconID
--        [swapIconID] = string,   -- the iconID used when the button has been clicked on (optional - defaults to nil)
--        [color] = {              -- icon color (optional - defaults to no icon color)
--            [r] = number,        -- red color value 0-255
--            [g] = number,        -- green color value 0-255
--            [b] = number         -- blue color value 0-255
--            [a] = number         -- alpha value 0-100
--        },
--		  [x]		= number,	   -- x offset
--		  [y]		= number,	   -- y offset
--		  [width]	= number,	   -- width
--		  [height]	= number	   -- height
--    }
--    [text] = {                   -- text and icon are mutually exclusive
--        [text]      = string,    -- the text to be displayed
--        [alignment] = string,    -- the horizontal text alignment (optional - defaults to center)
--        [fontsize]  = number,    -- the font size
--        [fontname]    = string,  -- the font name
--        [color]        = {       -- text color
--            [r] = number,        -- red color value 0-255
--            [g] = number,        -- green color value 0-255
--            [b] = number,        -- blue color value 0-255
--            [a] = number         -- alpha value 0-100
--        },
--		  [x]		= number,	   -- x offset
--		  [y]		= number	   -- y offset
--    } 
function Helper.createButton(text, icon, noscaling, active, offsetx, offsety, width, height, color, hotkey, icon2, mouseovertext)
	local buttonDescriptor = {}
	buttonDescriptor.text = text
	buttonDescriptor.icon = icon
	buttonDescriptor.icon2 = icon2
	buttonDescriptor.mouseovertext = mouseovertext

	buttonDescriptor.color = color or Helper.defaultButtonBackgroundColor
	buttonDescriptor.hotkey = hotkey
	if hotkey then
		if not buttonDescriptor.hotkey.x then
			buttonDescriptor.hotkey.x = math.max(0, noscaling and width or Helper.scaleX(width))
		end
		if not buttonDescriptor.hotkey.y then
			buttonDescriptor.hotkey.y = 0
		end
	end

	if not noscaling then
		if text then
			buttonDescriptor.text.fontsize = buttonDescriptor.text.fontsize and Helper.scaleFont(buttonDescriptor.text.fontname, buttonDescriptor.text.fontsize) or buttonDescriptor.text.fontsize
		end

		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width

		if icon2 then
			buttonDescriptor.icon2.width = buttonDescriptor.icon2.width and Helper.scaleX(buttonDescriptor.icon2.width) or buttonDescriptor.icon2.width
			buttonDescriptor.icon2.height = buttonDescriptor.icon2.height and Helper.scaleX(buttonDescriptor.icon2.height) or buttonDescriptor.icon2.height
			buttonDescriptor.icon2.x = buttonDescriptor.icon2.x and Helper.scaleX(buttonDescriptor.icon2.x - Helper.configButtonBorderSize) + Helper.configButtonBorderSize or buttonDescriptor.icon2.x
			buttonDescriptor.icon2.y = buttonDescriptor.icon2.y and Helper.scaleX(buttonDescriptor.icon2.y - Helper.configButtonBorderSize) + Helper.configButtonBorderSize or buttonDescriptor.icon2.y
		end
	end

	if hotkey and (height < Helper.buttonMinHeight) then
		height = Helper.buttonMinHeight
	end

	if text and width and width ~= 0 then
		buttonDescriptor.text.text = TruncateText(buttonDescriptor.text.text, buttonDescriptor.text.fontname, buttonDescriptor.text.fontsize, width - (buttonDescriptor.text.x and (2 * buttonDescriptor.text.x) or 0))
	end
	
	buttonDescriptor.active = active
	buttonDescriptor.offset = {x = offsetx, y = offsety}
	buttonDescriptor.size = {width = width , height = height}

	local desc = CreateButton(buttonDescriptor)
	return registerObjDescriptor(desc)
end

function Helper.createCheckBox(checked, noscaling, color, active, offsetx, offsety, width, height, mouseovertext)
	local checkboxDescriptor = {}
	checkboxDescriptor.mouseovertext = mouseovertext

	checkboxDescriptor.color = color or Helper.defaultCheckBoxBackgroundColor

	if not noscaling then
		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width
	end
	
	checkboxDescriptor.checked = checked
	checkboxDescriptor.active = active
	checkboxDescriptor.offset = {x = offsetx, y = offsety}
	checkboxDescriptor.size = {width = width , height = height}

	local desc = CreateCheckBox(checkboxDescriptor)
	return registerObjDescriptor(desc)
end

--    [offset] = {                    -- the checkbox offset (optional - defaults to 0/0)
--        [x] = number,               -- dropdown x-offset in px - relative to the parent's upper left corner (optional - defaults to 0)
--        [y] = number                -- dropdown y-offset in px - relative to the parent's upper left corner  (optional - defaults to 0)
--    },
--    [size] = {                      -- the checkbox's dimensions (optional - defaults to parent width/height)
--        [width] =  number,          -- dropdown width (optional - defaults to parent width)
--        [height] = number,          -- dropdown height (optional - defaults to parent height)
--    },
--    [mouseovertext] = string,       -- mouse over text (optional - defaults to "")
--    [color] = {                     -- the dropdown color
--        [r] = number,               -- red color value 0-255
--        [g] = number,               -- green color value 0-255
--        [b] = number,               -- blue color value 0-255
--        [a] = number                -- alpha color value 0-100
--    },
--    [active] = boolean,             -- indicates whether the checkbox is active (optional - defaults to true),
--    [hotkey] = {                    -- information about the assigned hotkey (optional - defaults to nil)
--        [action]      = string,     -- the associated hotkey action (must correspond to a valid INPUT_STATE - for instance "INPUT_STATE_FOO")
--        [displayIcon] = boolean,    -- indicates whether the button displays the associated icon as a hotkey (defaults to false)
--        [x]           = number,     -- x offset for the hotkey icon (only used, if displayIcon is set to true)
--        [y]           = number,     -- y offset for the hotkey icon (only used, if displayIcon is set to true)
--    },
--    [icon] = {                      -- icon and text are mutually exclusive
--        [color] = {                 -- icon color
--            [r] = number,           -- red color value 0-255
--            [g] = number,           -- green color value 0-255
--            [b] = number,           -- blue color value 0-255
--            [a] = number            -- alpha color value 0-100
--        },
--        [width]  = number,          -- width for the icon element (scaled to button size if nil)
--        [height] = number,          -- height for the icon element (scaled to button size if nil)
--        [x]      = number,          -- x offset for the icon element
--        [y]      = number,          -- y offset for the icon element
--    },
--    [text] = {                      -- text and icon are mutually exclusive
--        [alignment] = string,       -- the horizontal text alignment (optional - defaults to center)
--        [fontsize]  = number,       -- the font size
--        [fontname]  = string,       -- the font name
--        [color] = {                 -- text color
--            [r] = number,           -- red color value 0-255
--            [g] = number,           -- green color value 0-255
--            [b] = number,           -- blue color value 0-255
--            [a] = number            -- alpha color value 0-100
--        },
--        [x] = number,               -- x offset for the text element
--        [y] = number,               -- y offset for the text element
--    },
--    [textoverride] = string,        -- override text
--    [text2] = {                     -- text and icon are mutually exclusive
--        [alignment] = string,       -- the horizontal text alignment (optional - defaults to center)
--        [fontsize]  = number,       -- the font size
--        [fontname]	= string,     -- the font name
--        [color]		= {           -- text color
--            [r] = number,           -- red color value 0-255
--            [g] = number,           -- green color value 0-255
--            [b] = number,           -- blue color value 0-255
--            [a] = number            -- alpha color value 0-100
--        },
--        [x] = number,               -- x offset for the text element
--        [y] = number,               -- y offset for the text element
--    },
--    [text2override] = string,        -- override text2
--    [options] = {                   -- the dropdown's options
--        [1] = {
--            [id]   = string,        -- option id
--            [icon] = string,        -- icon id
--            [text] = string         -- option text
--        },
--        ...
--    },
--    [startoption] = number          -- the preselected option id (optional)
function Helper.createDropDown(options, startoption, text, icon, noscaling, active, offsetx, offsety, width, height, color, hotkey, mouseovertext, optionwidth, allowmouseoverinteraction, optionheight)
	local dropdownDescriptor = {}
	dropdownDescriptor.options = options
	dropdownDescriptor.startoption = startoption or ""
	dropdownDescriptor.textoverride = ""
	dropdownDescriptor.text2override = ""
	if text then
		text.text = text.text or ""
		dropdownDescriptor.textoverride = text.override
	end
	dropdownDescriptor.text = text
	dropdownDescriptor.text2 = text
	if icon then
		icon.iconID = "solid"
	end
	dropdownDescriptor.icon = icon
	dropdownDescriptor.mouseovertext = mouseovertext

	dropdownDescriptor.color = color or Helper.defaultButtonBackgroundColor
	dropdownDescriptor.optioncolor = Helper.color.black
	dropdownDescriptor.hotkey = hotkey
	if hotkey then
		if not dropdownDescriptor.hotkey.x then
			dropdownDescriptor.hotkey.x = math.max(0, (noscaling and width or Helper.scaleX(width)) - Helper.standardHotkeyIconSizex - 4)
		end
		if not dropdownDescriptor.hotkey.y then
			dropdownDescriptor.hotkey.y = math.max(0, (noscaling and height or Helper.scaleY(height)) - Helper.standardHotkeyIconSizey - 4)
		end
	end

	if not noscaling then
		if text then
			dropdownDescriptor.text.fontsize = dropdownDescriptor.text.fontsize and Helper.scaleFont(dropdownDescriptor.text.fontname, dropdownDescriptor.text.fontsize) or dropdownDescriptor.text.fontsize
		end

		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width
	end

	if text and width and width ~= 0 then
		--dropdownDescriptor.text.text = TruncateText(dropdownDescriptor.text.text, dropdownDescriptor.text.fontname, dropdownDescriptor.text.fontsize, width - (dropdownDescriptor.text.x and (2 * dropdownDescriptor.text.x) or 0)) TODO
	end
	
	dropdownDescriptor.active = active
	if allowmouseoverinteraction == nil then
		allowmouseoverinteraction = false
	end
	dropdownDescriptor.allowmouseoverinteraction = allowmouseoverinteraction

	dropdownDescriptor.offset = {x = offsetx, y = offsety}
	dropdownDescriptor.size = {width = width , height = height}
	dropdownDescriptor.optionwidth = optionwidth or 0
	dropdownDescriptor.optionheight = optionheight or 0

	local desc = CreateDropDown(dropdownDescriptor)
	return registerObjDescriptor(desc)
end

--    [text] = {                   -- text and icon are mutually exclusive
--        [text]      = string,    -- the text to be displayed
--        [alignment] = string,    -- the horizontal text alignment (optional - defaults to center)
--        [fontsize]  = number,    -- the font size
--        [fontname]    = string,  -- the font name
--        [color]        = {       -- text color
--            [r] = number,        -- red color value 0-255
--            [g] = number,        -- green color value 0-255
--            [b] = number         -- blue color value 0-255
--            [a] = number         -- alpha value 0-100
--        }
--    } 
function Helper.createEditBox(text, noscaling, offsetx, offsety, width, height, color, hotkey, closemenuonback, mouseovertext, defaulttext, texthidden)
	local editboxDescriptor = {}
	editboxDescriptor.text = text
	editboxDescriptor.defaulttext = defaulttext
	editboxDescriptor.mouseovertext = mouseovertext
	editboxDescriptor.color = color or Helper.defaultEditBoxBackgroundColor
	editboxDescriptor.hotkey = hotkey
	if hotkey then
		if not editboxDescriptor.hotkey.x then
			editboxDescriptor.hotkey.x = math.max(0, noscaling and width or Helper.scaleX(width))
		end
	end

	if not noscaling then
		if text then
			editboxDescriptor.text.fontsize = editboxDescriptor.text.fontsize and Helper.scaleFont(editboxDescriptor.text.fontname, editboxDescriptor.text.fontsize) or editboxDescriptor.text.fontsize
		end

		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width
	end
	
	editboxDescriptor.offset = {x = offsetx, y = offsety}
	editboxDescriptor.size = {width = width , height = height}
	editboxDescriptor.closemenu = closemenuonback
	editboxDescriptor.texthidden = texthidden

	local desc = CreateEditBox(editboxDescriptor)
	return registerObjDescriptor(desc)
end

function Helper.createTextInfo(text, alignment, fontname, fontsize, red, green, blue, alpha, offsetx, offsety)
	return {text = text, alignment = alignment, fontname = fontname, fontsize = fontsize, color = {r = red, g = green, b = blue, a = alpha}, x = offsetx, y = offsety}
end

function Helper.createButtonIcon(icon, swapicon, red, green, blue, alpha, width, height, offsetx, offsety)
	if width and height then
		width = width - 2 * Helper.configButtonBorderSize
		height = height - 2 * Helper.configButtonBorderSize
		if offsetx then
			offsetx = offsetx + Helper.configButtonBorderSize
		end
		if offsety then
			offsety = offsety + Helper.configButtonBorderSize
		end
	end
	return {iconID = icon, swapIconID = swapicon, color = {r = red, g = green, b = blue, a = alpha}, width = width, height = height, x = offsetx, y = offsety}
end

function Helper.createButtonHotkey(state, displayicon, offsetx, offsety)
	return {action = state, displayIcon = displayicon, x = offsetx, y = offsety}
end

-- TODO: Add full arguments again when nil is supported for all optional arguments
function Helper.createTable(...) --(header, content, numcolumns, borderenabled, taborder, skiptabchange, defaultinteractiveobject, offsetx, offsety, height)
	local desc = CreateTable(...)
	return registerObjDescriptor(desc)
end

function Helper.createCustomWidthTable(...) --(header, content, columnwidths, columnwidthpercent, borderenabled, taborder, skiptabchange, defaultinteractiveobject, fixedrows, offsetx, offsety, height)
	local desc = CreateTable(...)
	return registerObjDescriptor(desc)
end

-- shieldHullBarDescription = {
--		[offset] = {				-- the offset (optional - defaults to 0/0)
--			[x] = number,			-- x-offset in px - relative to the parent's upper left corner (optional - defaults to 0)
--			[y] = number			-- y-offset in px - relative to the parent's upper left corner  (optional - defaults to 0)
--		},
--		[size] = {					-- dimensions (optional - defaults to parent width/height)
--			[width] = number,		-- width (optional - defaults to parent width)
--			[height] = number,		-- height (optional - defaults to parent height)
--		},
--		[shield] = number,			-- shield percentage
--		[hull] = number				-- hull percentage
-- }
function Helper.createShieldHullBar(shield, hull, noscaling, offsetx, offsety, width, height, mouseovertext)
	local shieldHullBarDescriptor = { shield = shield, hull = hull, mouseovertext = mouseovertext }
	if not noscaling then
		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width
	end
	shieldHullBarDescriptor.offset = { x = offsetx, y = offsety }
	shieldHullBarDescriptor.size = { width = width , height = height }

	local desc = CreateShieldHullBar(shieldHullBarDescriptor)
	return registerObjDescriptor(desc)
end

-- slidercellDescription = {
--		[offset] = {				-- the slider offset (optional - defaults to 0/0)
--			[x] = number,			-- slider x-offset in px - relative to the parent's upper left corner (optional - defaults to 0)
--			[y] = number			-- slider y-offset in px - relative to the parent's upper left corner  (optional - defaults to 0)
--		},
--		[size] = {					-- the slider's dimensions (optional - defaults to parent width/height)
--			[width] = number,		-- slider width (optional - defaults to parent width)
--			[height] = number,		-- slider height (optional - defaults to parent height)
--		},
--		[bgcolor] = {				-- the background color
--			[r] = number,			-- red color value 0-255
--			[g] = number,			-- green color value 0-255
--			[b] = number,			-- blue color value 0-255
--			[a] = number			-- alpha color value 0-100
--		},
--		[valuecolor] = {			-- the value color
--			[r] = number,			-- red color value 0-255
--			[g] = number,			-- green color value 0-255
--			[b] = number,			-- blue color value 0-255
--			[a] = number			-- alpha color value 0-100
--		},
--		[negativevaluecolor] = {	-- the value color for negative values (optional - defaults to valuecolor)
--			[r] = number,			-- red color value 0-255
--			[g] = number,			-- green color value 0-255
--			[b] = number,			-- blue color value 0-255
--			[a] = number			-- alpha color value 0-100
--		},
--		[text] = {					-- the slider text 
--			[text]      = string,	-- the text to be displayed
--			[fontsize]  = number,	-- the font size
--			[fontname]	= string,	-- the font name
--			[color]		= {			-- text color
--				[r] = number,		-- red color value 0-255
--				[g] = number,		-- green color value 0-255
--				[b] = number,		-- blue color value 0-255
--				[a] = number		-- alpha color value 0-100
--			}
--		},
--		[scale] = {					-- scale setup
--			[min]	= number,		-- minimum value
--			[minselect] = number,	-- min selectable value (optional, defaults to min)
--			[max]	= number,		-- maximum value
--			[maxselect] = number,	-- max selectable value (optional, defaults to max - do not use with exceedmax)
--			[start]	= number,		-- start value
--			[step]	= number,		-- step size
--			[suffix] = string,		-- suffix to be displayed
--			[exceedmax] = bool		-- allow player to exceed the max value (requires min >= 0)
--			[hidemaxvalue] = bool	-- Hide the max value in the number display
--			[righttoleft] = bool	-- Right-to-left (mirrored) scale
--			[fromcenter] = bool		-- Slider bar extends from zero in the center
--			[readonly] = bool		-- Slider is read-only (non-interactive), only used as output
--		}
-- }
function Helper.createSliderCell(text, noscaling, offsetx, offsety, width, height, bgcolor, valuecolor, scale, mouseovertext)
	local slidercellDescriptor = {}
	slidercellDescriptor.text = text
	slidercellDescriptor.mouseovertext = mouseovertext
	slidercellDescriptor.bgcolor = bgcolor or Helper.defaultSliderCellBackgroundColor
	slidercellDescriptor.inactivebgcolor = Helper.defaultSliderCellInactiveBackgroundColor
	if not valuecolor and scale.fromcenter then
		slidercellDescriptor.valuecolor = Helper.defaultSliderCellPositiveValueColor
		slidercellDescriptor.negativevaluecolor = Helper.defaultSliderCellNegativeValueColor
	else
		slidercellDescriptor.valuecolor = valuecolor or Helper.defaultSliderCellValueColor
	end

	if not noscaling then
		if text then
			slidercellDescriptor.text.fontsize = slidercellDescriptor.text.fontsize and Helper.scaleFont(slidercellDescriptor.text.fontname, slidercellDescriptor.text.fontsize) or slidercellDescriptor.text.fontsize
		end

		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
		height		= height	and Helper.scaleY(height)		or height
		width		= width		and Helper.scaleX(width)		or width
	end
	
	if height < Helper.slidercellMinHeight then
		height = Helper.slidercellMinHeight
	end

	slidercellDescriptor.offset = {x = offsetx, y = offsety}
	slidercellDescriptor.size = {width = width , height = height}

	slidercellDescriptor.scale = scale

	local desc = CreateSliderCell(slidercellDescriptor)
	return registerObjDescriptor(desc)
end

function Helper.createRenderTarget(width, height, offsetx, offsety, noscaling, alpha, mouseovertext)
	if not noscaling then
		width		= width		and Helper.scaleX(width)		or width
		height		= height	and Helper.scaleY(height)		or height
		offsetx		= offsetx	and Helper.scaleX(offsetx)		or offsetx
		offsety		= offsety	and Helper.scaleY(offsety)		or offsety
	end
	
	Helper.autoFrameHeight = math.max(Helper.autoFrameHeight, offsety + height)
	local desc = CreateRenderTarget(width, height, offsetx, offsety, alpha, mouseovertext)
	return registerObjDescriptor(desc)
end

---------------------------------------------------------------------------------
-- View descriptor creation wrappers
---------------------------------------------------------------------------------

function Helper.setScripts(menu, layer, frame, children)
	if frame then
		Helper.setMenuScript(menu, layer, frame, "onHide", menu.closeElement)
		Helper.setMenuScript(menu, layer, frame, "onInteractiveElementChanged", menu.interactiveElementChanged)
		Helper.setMenuScript(menu, layer, frame, "onStandardButtonMouseOut", menu.standardButtonOut)
		Helper.setMenuScript(menu, layer, frame, "onStandardButtonMouseOver", menu.standardButtonOver)
	end

	for _, child in ipairs(children) do
		if IsType(child, "table") then
			Helper.setMenuScript(menu, layer, child, "onClick", menu.selectElement)
			Helper.setMenuScript(menu, layer, child, "onRightClick", menu.tableRightMouseClick)
			Helper.setMenuScript(menu, layer, child, "onRowChanged", menu.rowChanged)
			Helper.setMenuScript(menu, layer, child, "onColumnChanged", menu.colChanged)
			Helper.setMenuScript(menu, layer, child, "onScrollBarOver", menu.tableScrollBarOver)
			Helper.setMenuScript(menu, layer, child, "onScrollBarDown", menu.tableScrollBarDown)
			Helper.setMenuScript(menu, layer, child, "onScrollBarUp", menu.tableScrollBarUp)
			Helper.setMenuScript(menu, layer, child, "onTableMouseOver", menu.tableMouseOver)
			Helper.setMenuScript(menu, layer, child, "onTableMouseOut", menu.tableMouseOut)
		elseif IsType(child, "rendertarget") then
			Helper.setMenuScript(menu, layer, child, "onClick", menu.renderTargetSelect)
			Helper.setMenuScript(menu, layer, child, "onDoubleClick", menu.renderTargetDoubleClick)
			Helper.setMenuScript(menu, layer, child, "onMouseDown", menu.renderTargetMouseDown)
			Helper.setMenuScript(menu, layer, child, "onMouseUp", menu.renderTargetMouseUp)
			Helper.setMenuScript(menu, layer, child, "onMiddleMouseDown", menu.renderTargetMiddleMouseDown)
			Helper.setMenuScript(menu, layer, child, "onMiddleMouseUp", menu.renderTargetMiddleMouseUp)
			Helper.setMenuScript(menu, layer, child, "onRightClick", menu.renderTargetRightMouseClick)
			Helper.setMenuScript(menu, layer, child, "onRightMouseDown", menu.renderTargetRightMouseDown)
			Helper.setMenuScript(menu, layer, child, "onRightMouseUp", menu.renderTargetRightMouseUp)
			Helper.setMenuScript(menu, layer, child, "onCombinedScrollDown", menu.renderTargetCombinedScrollDown)
			Helper.setMenuScript(menu, layer, child, "onCombinedScrollUp", menu.renderTargetCombinedScrollUp)
			-- TODO #Florian - kept for mod compatibility, remove in next project
			Helper.setMenuScript(menu, layer, child, "onScrollDown", menu.renderTargetScrollDown)
			Helper.setMenuScript(menu, layer, child, "onScrollUp", menu.renderTargetScrollUp)
		end
	end
end

function Helper.addTableDescRowDataMap(menu, desc, rowdatamap)
	menu.rowDataMapPerTableDesc = menu.rowDataMapPerTableDesc or {}
	menu.rowDataMapPerTableDesc[desc] = rowdatamap
end

function Helper.addTableIndexRowDataMap(menu, tableidx, rowdatamap)
	menu.rowDataMapPerTableIndex = menu.rowDataMapPerTableIndex or {}
	menu.rowDataMapPerTableIndex[tableidx] = rowdatamap
end

function Helper.handleTableDesc(menu, descriptors)
	local found = false
	for i, desc in ipairs(descriptors) do
		if menu.defaulttable and (desc == menu.defaulttable) then
			found = true
			menu.defaulttable = i
		end
		if menu.rowDataMapPerTableDesc[desc] then
			Helper.addTableIndexRowDataMap(menu, i, menu.rowDataMapPerTableDesc[desc])
			menu.rowDataMapPerTableDesc[desc] = nil
		end
	end

	if not found then
		menu.defaulttable = nil
	end
end

function Helper.handleCreatedTables(menu, tables)
	if menu.defaulttable then
		menu.defaulttable = tables[menu.defaulttable]
	end
	for tableidx, rowdatamap in pairs(menu.rowDataMapPerTableIndex) do
		menu.rowDataMap[tables[tableidx]] = rowdatamap
	end
	menu.rowDataMapPerTableIndex = {}
end

function Helper.viewCreated(menu, layer, frames)
	menu.frames = menu.frames or {}
	if frames[1] then
		menu.frames[layer] = frames[1]
		local children = table.pack(GetChildren(menu.frames[layer]))

		Helper.setScripts(menu, layer, menu.frames[layer], children)
		Helper.handleCreatedTables(menu, children)
		if menu.viewCreated then
			menu.viewCreated(layer, table.unpack(children))
		end
	else
		DebugError(TraceBack())
		ScheduleReloadUI()
		error("Failed to create view for menu " .. menu.name .. ". Reloading UI ...")
	end
end

function Helper.clearDataForRefresh(menu, layer)
	Helper.removeAllWidgetScripts(menu, layer)
	if layer then
		if menu.frames[layer] then
			local children = table.pack(GetChildren(menu.frames[layer]))
			for _, childrenID in ipairs(children) do
				Helper.currentTableRow[childrenID] = nil
				menu.rowDataMap[childrenID] = nil
			end
		end
	else
		Helper.currentTableRow = {}
		menu.rowDataMap = {}
	end
end

function Helper.getCurrentRowData(menu, uitable)
	local row = Helper.currentTableRow[uitable]
	return menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
end

function Helper.displayFrame(menu, tabledescs, exclusiveinteractions, backgroundID, overlayID, standardButtons, closeOnUnhandledClick, layer, backgroundColor, overlayColor, showBrackets, autoFrameHeight, playerControls, enableDefaultInteractions, width, height, xoffset, yoffset)
	layer = layer or 4
	exclusiveinteractions = exclusiveinteractions or false
	backgroundID = backgroundID or ""
	backgroundColor = backgroundColor or Helper.color.white
	overlayID = overlayID or ""
	overlayColor = overlayColor or Helper.color.white
	standardButtons = standardButtons or { back = true, close = true }
	showBrackets = showBrackets or false
	closeOnUnhandledClick = closeOnUnhandledClick or false
	enableDefaultInteractions = (enableDefaultInteractions == nil and true) or enableDefaultInteractions

	menu.frameData[layer] = {
		width = width or Helper.viewWidth,
		height = height or Helper.viewHeight,
		x = xoffset or 0,
		y = yoffset or 0,
	}
	if autoFrameHeight then
		menu.frameData[layer].height = Helper.autoFrameHeight
	end
	Helper.autoFrameHeight = 0

	local framedesc = CreateFrame(tabledescs, layer, backgroundID, backgroundColor, overlayID, overlayColor, menu.frameData[layer].width, menu.frameData[layer].height, menu.frameData[layer].x, menu.frameData[layer].y, standardButtons, { x = 0, y = 0 }, showBrackets, enableDefaultInteractions, nil, closeOnUnhandledClick)

	Helper.handleTableDesc(menu, tabledescs)

	Helper.closeMinimizedMenus()
	View.registerMenu("Helper" .. layer, "Helper", function (frames) return Helper.viewCreated(menu, layer, frames) end, function () return menu.onCloseElement("close", nil, true) end, {[layer] = framedesc}, exclusiveinteractions, closeOnUnhandledClick, nil, playerControls, false, true)
end

---------------------------------------------------------------------------------
-- Draw geometry
---------------------------------------------------------------------------------

function Helper.drawLine(startpos, endpos, thickness, z, color, noscaling)
	if not thickness then
		thickness = 2
	end
	if not z then
		z = 0
	end
	if not color then
		color = Helper.standardColor
	end

	if not noscaling then
		startpos.x = Helper.scaleX(startpos.x)
		startpos.y = Helper.scaleY(startpos.y)
		endpos.x = Helper.scaleX(endpos.x)
		endpos.y = Helper.scaleY(endpos.y)
		thickness = Helper.scaleY(thickness)
	end

	local width = math.sqrt((endpos.x - startpos.x)^2 + (endpos.y - startpos.y)^2)
	-- we have to flip start and endpos here, as we later flip the y-Axis in the coordinate transformation
	local angle = math.asin(2 * (startpos.y - endpos.y) / 2 / width)
	local height = thickness
	local offsetx = (startpos.x + endpos.x) / 2 - Helper.viewWidth / 2 - width / 2
	local offsety = Helper.viewHeight / 2 - (startpos.y + endpos.y) / 2 + height / 2

	return DrawRect(width, height, offsetx, offsety, angle, z, color)
end

function Helper.drawRectangle(width, height, offsetx, offsety, angle, z, color, noscaling)
	if not width then
		width = 1
	end
	if not height then
		height = 1
	end
	if not offsetx then
		offsetx = 0
	end
	if not offsety then
		offsety = 0
	end
	if not angle then
		angle = 0
	end
	if not z then
		z = 0
	end
	if not color then
		color = Helper.standardColor
	end

	if not noscaling then
		width = Helper.scaleX(width)
		height = Helper.scaleY(height)
		offsetx = Helper.scaleX(offsetx)
		offsety = Helper.scaleY(offsety)
	end

	offsetx = offsetx - Helper.viewWidth / 2
	offsety = Helper.viewHeight / 2 - offsety

	return DrawRect(width, height, offsetx, offsety, math.rad(angle), z, color)
end

function Helper.drawCircle(radius, centerx, centery, z, color, noscaling)
	if not radius then
		radius = 1
	end
	if not centerx then
		centerx = 0
	end
	if not centery then
		centery = 0
	end
	if not z then
		z = 0
	end
	if not color then
		color = Helper.standardColor
	end

	if not noscaling then
		radius = Helper.scaleY(radius)
		centerx = Helper.scaleX(centerx)
		centery = Helper.scaleY(centery)
	end

	centerx = centerx - Helper.viewWidth / 2
	centery = Helper.viewHeight / 2 - centery

	return DrawCircle(radius, radius, centerx, centery, z, color)
end

function Helper.drawEllipse(radiusx, radiusy, centerx, centery, z, color, noscaling)
	if not radiusx then
		radiusx = 1
	end
	if not radiusy then
		radiusy = 1
	end
	if not centerx then
		centerx = 0
	end
	if not centery then
		centery = 0
	end
	if not z then
		z = 0
	end
	if not color then
		color = Helper.standardColor
	end

	if not noscaling then
		radiusx = Helper.scaleX(radiusx)
		radiusy = Helper.scaleY(radiusy)
		centerx = Helper.scaleX(centerx)
		centery = Helper.scaleY(centery)
	end

	centerx = centerx - Helper.viewWidth / 2
	centery = Helper.viewHeight / 2 - centery

	return DrawCircle(radiusx, radiusy, centerx, centery, z, color)
end

function Helper.drawTriangle(width, height, offsetx, offsety, angle, z, color, noscaling)
	if not width then
		width = 1
	end
	if not height then
		height = 1
	end
	if not offsetx then
		offsetx = 0
	end
	if not offsety then
		offsety = 0
	end
	if not angle then
		angle = 0
	end
	if not z then
		z = 0
	end
	if not color then
		color = Helper.standardColor
	end

	if not noscaling then
		width = Helper.scaleX(width)
		height = Helper.scaleY(height)
		offsetx = Helper.scaleX(offsetx)
		offsety = Helper.scaleY(offsety)
	end

	offsetx = offsetx - Helper.viewWidth / 2
	offsety = Helper.viewHeight / 2 - offsety

	return DrawTriangle(width, height, offsetx, offsety, math.rad(angle), z, color)
end

---------------------------------------------------------------------------------
-- Table updates
---------------------------------------------------------------------------------

function Helper.updateCellText(tableobj, row, col, newtext, newcolor)
	local cell = GetCellText(tableobj, row, col)
	if not cell then
		print("updateCellText Error: ", tableobj, row, col, newtext, newcolor)
	else
		SetText(cell, newtext)
		if newcolor then
			SetTextColor(cell, newcolor.r, newcolor.g, newcolor.b, newcolor.a)
		end
	end
end

function Helper.updateButtonText(tableobj, row, col, newtext)
	local cell = GetCellContent(tableobj, row, col)
	SetButtonText(cell, newtext)
end

function Helper.updateButtonColor(tableobj, row, col, newcolor)
	local cell = GetCellContent(tableobj, row, col)
	SetButtonColor(cell, newcolor.r, newcolor.g, newcolor.b, newcolor.a)
end

function Helper.updateEditBoxText(tableobj, row, col, newtext)
	local cell = GetCellContent(tableobj, row, col)
	C.SetEditBoxText(cell, newtext)
end

function Helper.updateDropDownCurrentOption(tableobj, row, col, id)
	local cell = GetCellContent(tableobj, row, col)
	C.SetDropDownCurOption(cell, id)
end

function Helper.setButtonScript(menu, id, tableobj, row, col, script, onRightClickScript)
	menu.buttonScriptMap = menu.buttonScriptMap or { }
	local layer = Helper.findFrameLayer(menu, tableobj)

	local overSoundMouse = function (...) return menu.buttonOver("mouse", ...) end
	local overSoundKeyboard = function (...) return menu.buttonOver("keyboard", ...) end
	local outSoundMouse = function (...) return menu.buttonOut("mouse", ...) end
	local downSound = menu.buttonDown
	local upSound = menu.buttonUp
	if onRightClickScript == nil then
		onRightClickScript = menu.buttonRightMouseClick
	end

	local scriptWrapper = function (...)
		if id then
			AddUITriggeredEvent(menu.name, id)
		end
		if script then
			return script(...)
		end
	end

	local cell = GetCellContent(tableobj, row, col)

	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onClick", script = scriptWrapper })
	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onRightClick", script = onRightClickScript })
	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onButtonMouseOver", script = overSoundMouse })
	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onButtonMouseOut", script = outSoundMouse })
	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onButtonSelect", script = overSoundKeyboard })
	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onButtonDown", script = downSound })
	table.insert(menu.buttonScriptMap, { layer = layer, tableobj = tableobj, button = cell, row = row, col = col, type = "onButtonUp", script = upSound })

	SetScript(cell, "onClick", scriptWrapper)
	SetScript(cell, "onRightClick", onRightClickScript)
	SetScript(cell, "onButtonMouseOver", overSoundMouse)
	SetScript(cell, "onButtonMouseOut", outSoundMouse)
	SetScript(cell, "onButtonSelect", overSoundKeyboard)
	SetScript(cell, "onButtonDown", downSound)
	SetScript(cell, "onButtonUp", upSound)
end

function Helper.setCheckBoxScript(menu, id, tableobj, row, col, script)
	menu.checkboxScriptMap = menu.checkboxScriptMap or {}
	local layer = Helper.findFrameLayer(menu, tableobj)

	local scriptWrapper = function (...)
		if id then
			AddUITriggeredEvent(menu.name, id)
		end
		PlaySound("ui_positive_click")
		return script(...)
	end

	table.insert(menu.checkboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onClick", script = scriptWrapper })
	table.insert(menu.checkboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onCheckBoxMouseOver", script = menu.checkboxOver })
	table.insert(menu.checkboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onCheckBoxSelect", script = menu.checkboxOver })

	local cell = GetCellContent(tableobj, row, col)
	SetScript(cell, "onClick", scriptWrapper)
	SetScript(cell, "onCheckBoxMouseOver", menu.checkboxOver)
	SetScript(cell, "onCheckBoxSelect", menu.checkboxOver)
end

function Helper.setDropDownScript(menu, id, tableobj, row, col, activateScript, confirmScript, removedScript)
	menu.dropdownScriptMap = menu.dropdownScriptMap or {}
	local layer = Helper.findFrameLayer(menu, tableobj)

	if not activateScript then
		activateScript = menu.dropdownActivated
	end
	if not confirmScript then
		confirmScript = menu.dropdownConfirmed
	end
	if not removedScript then
		removedScript = menu.dropdownRemoved
	end

	local scriptWrapper = function (widgetid, value, ...)
		if id then
			AddUITriggeredEvent(menu.name, id, value)
		end
		if confirmScript then
			return confirmScript(widgetid, value, ...)
		end
	end

	table.insert(menu.dropdownScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onDropDownActivated", script = activateScript })
	table.insert(menu.dropdownScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onDropDownConfirmed", script = scriptWrapper })
	table.insert(menu.dropdownScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onDropDownRemoved", script = removedScript })

	local cell = GetCellContent(tableobj, row, col)
	SetScript(cell, "onDropDownActivated", activateScript)
	SetScript(cell, "onDropDownConfirmed", scriptWrapper)
	SetScript(cell, "onDropDownRemoved", removedScript)
end

function Helper.setEditBoxScript(menu, id, tableobj, row, col, script, textchangedscript, activatedscript, cursorchangedscript)
	menu.editboxScriptMap = menu.editboxScriptMap or { }
	local layer = Helper.findFrameLayer(menu, tableobj)

	if not script then
		script = menu.editboxUpdateText
	end
	if not textchangedscript then
		textchangedscript = menu.editboxTextChanged
	end
	if not activatedscript then
		activatedscript = menu.editBoxActivated
	end
	if not cursorchangedscript then
		cursorchangedscript = menu.editBoxCursorChanged
	end
	local onRightClickScript = menu.buttonRightMouseClick

	local scriptWrapper = function (...)
		if id then
			AddUITriggeredEvent(menu.name, id)
		end
		return script(...)
	end

	table.insert(menu.editboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onEditBoxDeactivated", script = scriptWrapper })
	table.insert(menu.editboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onTextChanged", script = textchangedscript })
	table.insert(menu.editboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onCursorChanged", script = cursorchangedscript })
	table.insert(menu.editboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onEditBoxActivated", script = activatedscript })
	table.insert(menu.editboxScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onRightClick", script = onRightClickScript })
		
	local cell = GetCellContent(tableobj, row, col)
	SetScript(cell, "onEditBoxDeactivated", scriptWrapper)
	SetScript(cell, "onTextChanged", textchangedscript)
	SetScript(cell, "onCursorChanged", cursorchangedscript)
	SetScript(cell, "onEditBoxActivated", activatedscript)
	SetScript(cell, "onRightClick", onRightClickScript)
end

function Helper.confirmEditBoxInput(tableobj, row, col)
	local cell = GetCellContent(tableobj, row, col)
	ConfirmEditBoxInput(cell)
end

function Helper.cancelEditBoxInput(tableobj, row, col)
	local cell = GetCellContent(tableobj, row, col)
	CancelEditBoxInput(cell)
end

function Helper.activateEditBox(tableobj, row, col, cursorpos, shiftstartpos)
	local cell = GetCellContent(tableobj, row, col)
	ActivateEditBox(cell, cursorpos, shiftstartpos)
end

function Helper.setGraphScript(menu, id, tableobj, row, col, script)
	menu.graphScriptMap = menu.graphScriptMap or {}
	local layer = Helper.findFrameLayer(menu, tableobj)

	local scriptWrapper = function (...)
		if id then
			AddUITriggeredEvent(menu.name, id)
		end
		PlaySound("ui_positive_click")
		if script then
			return script(...)
		end
	end

	table.insert(menu.graphScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onClick", script = scriptWrapper })

	local cell = GetCellContent(tableobj, row, col)
	SetScript(cell, "onClick", scriptWrapper)
end

function Helper.closeDropDownOptions(tableobj, row, col)
	local cell = GetCellContent(tableobj, row, col)
	CloseDropDownOptions(cell)
end

function Helper.setSliderCellScript(menu, id, tableobj, row, col, changedScript, activateScript, deactivateScript, onRightClickScript, confirmScript)
	menu.slidercellScriptMap = menu.slidercellScriptMap or {}
	local layer = Helper.findFrameLayer(menu, tableobj)
	
	if not changedScript then
		changedScript = menu.slidercellChanged
	end
	if not activateScript then
		activateScript = menu.slidercellActivated
	end
	if not deactivateScript then
		deactivateScript = menu.slidercellDeactivated
	end
	if not onRightClickScript then
		onRightClickScript = menu.slidercellRightMouseClick
	end
	if not confirmScript then
		confirmScript = menu.slidercellConfirm
	end
	
	table.insert(menu.slidercellScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onSliderCellChanged", script = changedScript })
	table.insert(menu.slidercellScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onSliderCellActivated", script = activateScript })
	table.insert(menu.slidercellScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onSliderCellDeactivated", script = deactivateScript })
	table.insert(menu.slidercellScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onRightClick", script = onRightClickScript })
	table.insert(menu.slidercellScriptMap, { layer = layer, tableobj = tableobj, row = row, col = col, type = "onSliderCellConfirm", script = confirmScript })

	local cell = GetCellContent(tableobj, row, col)
	SetScript(cell, "onSliderCellChanged", changedScript)
	SetScript(cell, "onSliderCellActivated", activateScript)
	SetScript(cell, "onSliderCellDeactivated", deactivateScript)
	SetScript(cell, "onRightClick", onRightClickScript)
	SetScript(cell, "onSliderCellConfirm", confirmScript)

	SetScript(cell, "onSliderCellDown", menu.slidercellDown)
	SetScript(cell, "onSliderCellRightOver", menu.slidercellRightOver)
	SetScript(cell, "onSliderCellRightDown", menu.slidercellRightDown)
	SetScript(cell, "onSliderCellLeftOver", menu.slidercellLeftOver)
	SetScript(cell, "onSliderCellLeftDown", menu.slidercellLeftDown)
end

function Helper.setSliderCellValue(tableobj, row, col, value)
	local cell = GetCellContent(tableobj, row, col)
	if cell then
		SetSliderCellValue(cell, value)
	end
end

function Helper.activateSliderCellInput(tableobj, row, col)
	local cell = GetCellContent(tableobj, row, col)
	ActivateSliderCellInput(cell)
end

function Helper.removeTableScript(tableobj, row, col, type, script)
	local cell = GetCellContent(tableobj, row, col)
	if cell then
		RemoveScript(cell, type, script)
	end
end

function Helper.removeFlowchartScript(flowchartid, row, col, type, script)
	local cell = GetFlowchartNodeID(flowchartid, row, col)
	if cell then
		RemoveScript(cell, type, script)
	end
end

function Helper.removeScripts(scriptMap, menu, widget, row, col)
	for i = #scriptMap, 1, -1 do
		local scriptdata = scriptMap[i]
		if (scriptdata.tableobj or scriptdata.flowchartid) == widget and scriptdata.row == row and scriptdata.col == col then
			if scriptdata.tableobj then
				Helper.removeTableScript(scriptdata.tableobj, scriptdata.row, scriptdata.col, scriptdata.type, scriptdata.script)
			else
				Helper.removeFlowchartScript(scriptdata.flowchartid, scriptdata.row, scriptdata.col, scriptdata.type, scriptdata.script)
			end
			table.remove(scriptMap, i)
		end
	end
end

function Helper.removeButtonScripts(menu, tableobj, row, col)
	Helper.removeScripts(menu.buttonScriptMap or {}, menu, tableobj, row, col)
end

function Helper.removeCheckBoxScripts(menu, tableobj, row, col)
	Helper.removeScripts(menu.checkboxScriptMap or {}, menu, tableobj, row, col)
end

function Helper.removeDropDownScripts(menu, tableobj, row, col)
	Helper.removeScripts(menu.dropdownScriptMap or {}, menu, tableobj, row, col)
end

function Helper.removeEditBoxScripts(menu, tableobj, row, col)
	Helper.removeScripts(menu.editboxScriptMap or {}, menu, tableobj, row, col)
end

function Helper.removeGraphScripts(menu, tableobj, row, col)
	Helper.removeScripts(menu.graphScriptMap or {}, menu, tableobj, row, col)
end

function Helper.removeSliderCellScripts(menu, tableobj, row, col)
	Helper.removeScripts(menu.slidercellScriptMap or {}, menu, tableobj, row, col)
end

function Helper.removeFlowchartNodeScripts(menu, flowchartid, row, col)
	Helper.removeScripts(menu.flowchartNodeScriptMap or {}, menu, flowchartid, row, col)
end

function Helper.removeAllScripts(scriptMap, menu, layer)
	menu.frames = menu.frames or {}
	if next(menu.frames) then
		for i = #scriptMap, 1, -1 do
			local scriptdata = scriptMap[i]
			if (not layer) or (scriptdata.layer == layer) then
				if menu.frames[scriptdata.layer] and IsValidWidgetElement(menu.frames[scriptdata.layer]) then
					if scriptdata.tableobj then
						Helper.removeTableScript(scriptdata.tableobj, scriptdata.row, scriptdata.col, scriptdata.type, scriptdata.script)
					else
						Helper.removeFlowchartScript(scriptdata.flowchartid, scriptdata.row, scriptdata.col, scriptdata.type, scriptdata.script)
					end
					table.remove(scriptMap, i)
				end
			end
		end
	end
end

function Helper.removeAllButtonScripts(menu, layer)
	Helper.removeAllScripts(menu.buttonScriptMap or {}, menu, layer)
end

function Helper.removeAllCheckBoxScripts(menu, layer)
	Helper.removeAllScripts(menu.checkboxScriptMap or {}, menu, layer)
end

function Helper.removeAllDropDownScripts(menu, layer)
	Helper.removeAllScripts(menu.dropdownScriptMap or {}, menu, layer)
end

function Helper.removeAllEditBoxScripts(menu, layer)
	Helper.removeAllScripts(menu.editboxScriptMap or {}, menu, layer)
end

function Helper.removeAllGraphScripts(menu, layer)
	Helper.removeAllScripts(menu.graphScriptMap or {}, menu, layer)
end

function Helper.removeAllSliderCellScripts(menu, layer)
	Helper.removeAllScripts(menu.slidercellScriptMap or {}, menu, layer)
end

function Helper.removeAllFlowchartNodeScripts(menu, layer)
	Helper.removeAllScripts(menu.flowchartNodeScriptMap or {}, menu, layer)
end

function Helper.removeAllWidgetScripts(menu, layer)
	Helper.removeAllButtonScripts(menu, layer)
	Helper.removeAllCheckBoxScripts(menu, layer)
	Helper.removeAllDropDownScripts(menu, layer)
	Helper.removeAllEditBoxScripts(menu, layer)
	Helper.removeAllGraphScripts(menu, layer)
	Helper.removeAllSliderCellScripts(menu, layer)
	Helper.removeAllFlowchartNodeScripts(menu, layer)
end

function Helper.removeButton(menu, tableobj, row, col)
	menu.buttonScriptMap = menu.buttonScriptMap or {}
	local foundentries = {}
	for i, scriptdata in ipairs(menu.buttonScriptMap) do
		if scriptdata.tableobj == tableobj and scriptdata.row == row and scriptdata.col == col then
			Helper.removeTableScript(scriptdata.tableobj, scriptdata.row, scriptdata.col, scriptdata.type, scriptdata.script)
			table.insert(foundentries, i)
		end
	end
	for i = #foundentries, 1, -1 do
		table.remove(menu.buttonScriptMap, foundentries[i])
	end
	local success = SetCellContent(tableobj, Helper.getEmptyCellDescriptor(), row, col)
end

function Helper.setKeyBinding(menu, script)
	menu.keyBindingMap = menu.keyBindingMap or { }
	table.insert(menu.keyBindingMap, { script = script })
	
	SetScript("onHotkey", script)
end

function Helper.removeKeyBinding(script)
	RemoveScript("onHotkey", script)
end

function Helper.removeAllKeyBindings(menu)
	menu.keyBindingMap = menu.keyBindingMap or {}
	for _, scriptdata in ipairs(menu.keyBindingMap) do
		Helper.removeKeyBinding(scriptdata.script)
	end
	menu.keyBindingMap = {}
end

function Helper.setTabScrollCallback(menu, script)
	menu.tabScrollMap = menu.tabScrollMap or { }
	table.insert(menu.tabScrollMap, { script = script })
	
	SetScript("onTabScroll", script)
end

function Helper.removeTabScrollCallback(script)
	RemoveScript("onTabScroll", script)
end

function Helper.removeAllTabScrollCallbacks(menu)
	menu.tabScrollMap = menu.tabScrollMap or {}
	for _, scriptdata in ipairs(menu.tabScrollMap) do
		Helper.removeTabScrollCallback(scriptdata.script)
	end
	menu.tabScrollMap = {}
end

---------------------------------------------------------------------------------
-- Table setup
---------------------------------------------------------------------------------

function Helper.createTableSetup(menu, header)
	-- create and return helper object for table setup
	-- both arguments optional but menu will be needed if row data is used in addSelectRow()
	local setup = {
		header = header or "",
		rows = { },
		noscalingRows = { },
		numFillRows = 0,
		rowDataMap = {}
	}

	-- add setup member functions

	-- all arguments optional, returns row number
	function setup:addRow(selectable, cells, rowdata, colspans, noscaling, bgColor)
		local row = { color = bgColor, selectable = selectable, cols = {} }
		if colspans then
			for i, cell in ipairs(cells) do
				table.insert(row.cols, { colspan = colspans[i], content = cell })
				for j = 1, colspans[i] - 1 do
					table.insert(row.cols, { colspan = 0, content = nil })
				end
			end
		else
			for i, cell in ipairs(cells) do
				table.insert(row.cols, { colspan = 1, content = cell })
			end
		end
		table.insert(self.rows, row)
		local curRow = #self.rows
		if noscaling then
			self.noscalingRows[curRow] = noscaling
		end
		if rowdata and menu then
			self.rowDataMap[curRow] = rowdata
		end
		return curRow
	end

	-- shortcut for selectable rows without arrow
	function setup:addSimpleRow(cells, rowdata, colspans, noscaling, bgColor)
		return self:addRow(true, cells, rowdata, colspans, noscaling, bgColor or Helper.defaultSimpleBackgroundColor)
	end

	-- shortcut for header row (with default header background color)
	function setup:addHeaderRow(cells, rowdata, colspans, noscaling, bgColor)
		return self:addRow(false, cells, rowdata, colspans, noscaling, bgColor or Helper.defaultHeaderBackgroundColor)
	end

	-- shortcut for title row ( with default title background color)
	function setup:addTitleRow(cells, rowdata, colspans, noscaling, bgColor)
		return self:addRow(false, cells, rowdata, colspans, noscaling, bgColor or Helper.defaultTitleBackgroundColor)
	end

	-- shortcut for selectable row with arrow
	function setup:addSelectRow(cells, rowdata, colspans, noscaling, bgColor)
		return self:addRow(true, cells, rowdata, colspans, noscaling, bgColor or Helper.defaultArrowRowBackgroundColor, true)
	end
	
	-- fill the menu with empty rows up to maxrows
	function setup:addFillRows(maxrows, noscaling, colspans, color)
		local currows = #self.rows
		if noscaling then
			maxrows = Helper.scaleY(maxrows)
		end
		local emptystrings = {""}
		if colspans and #colspans > 1 then
			for i = 2, #colspans do
				table.insert(emptystrings, "")
			end
		end
		if not color then
			color = Helper.defaultUnselectableBackgroundColor
		end
		self.numFillRows = math.max(0, maxrows - currows)
		for i = 1, self.numFillRows do
			self:addHeaderRow(emptystrings, nil, colspans, noscaling, color)
		end
	end

	-- create table content from rows array, can also handle incomplete row definitions
	-- (recommended to use setup:create[...]Table() instead)
	function setup:createTableContent(numcolumns)
		for rownumber, row in ipairs(self.rows) do
			for col = 1, numcolumns do
				local cell
				if row.cols[col] then
					cell = row.cols[col].content
					if type(cell) == "string" or type(cell) == "number" then
						self.rows[rownumber].cols[col].content = Helper.createFontString(tostring(cell), self.noscalingRows[rownumber])
					end
				else
					cell = Helper.createFontString("", self.noscalingRows[rownumber])
					self.rows[rownumber].cols[col] = { colspan = 1, content = cell }
				end
			end
		end
		return self.rows
	end

	function setup:createTable(numcolumns, noscaling, borderenabled, taborder, fixedrows, offsetx, offsety, height, ignorefixedrowchanges, toprow, selectedrow, selectedcol, wraparound, highlightmode, skiptabchange, defaultinteractiveobject)
		if borderenabled == nil then
			borderenabled = true
		end
		if taborder == nil then
			taborder = 0
		end
		if fixedrows == nil then
			fixedrows = 0
		end
		if offsetx == nil then
			offsetx = 0
		end
		if offsety == nil then
			offsety = 0
		end
		if height == nil then
			height = 0
		end

		if not noscaling then
			offsetx		= Helper.scaleX(offsetx)
			offsety		= Helper.scaleY(offsety)
			height		= Helper.scaleY(height)
		end
		if toprow == nil and selectedrow == nil and taborder == 1 then
			if menu.param then
				toprow = menu.param[1]
				selectedrow = menu.param[2]
			else
				toprow = 0
				selectedrow = 0
			end
		else
			if toprow == nil then
				toprow = 0
			end
			if selectedrow == nil then
				selectedrow = 0
			end
		end
		if selectedcol == nil then
			selectedcol = 0
		end
		if wraparound == nil then
			wraparound = false
		end
		if skiptabchange == nil then
			skiptabchange = false
		end
		if defaultinteractiveobject == nil then
			defaultinteractiveobject = false
		end

		local content = self:createTableContent(numcolumns)
		Helper.autoFrameHeight = math.max(Helper.autoFrameHeight, offsety + height)
		local initialSelection = {
			toprow		= math.min(toprow, #content) <= fixedrows and 0 or math.min(toprow, #content),
			selectedrow	= math.min(selectedrow, #content - self.numFillRows),
			selectedcol	= math.min(selectedcol, numcolumns)
		}

		local desc = Helper.createTable(self.header, content, numcolumns, borderenabled, taborder, skiptabchange, defaultinteractiveobject, fixedrows, offsetx, offsety, height, initialSelection, wraparound, highlightmode)
		if taborder == 1 then
			menu.defaulttable = desc
		end
		Helper.addTableDescRowDataMap(menu, desc, self.rowDataMap)
		return desc
	end

	function setup:createCustomWidthTable(columnwidths, columnwidthpercent, noscaling, borderenabled, taborder, fixedrows, offsetx, offsety, height, ignorefixedrowchanges, toprow, selectedrow, selectedcol, wraparound, highlightmode, skiptabchange, defaultinteractiveobject)
		if borderenabled == nil then
			borderenabled = true
		end
		if taborder == nil then
			taborder = 0
		end
		if fixedrows == nil then
			fixedrows = 0
		end
		if offsetx == nil then
			offsetx = 0
		end
		if offsety == nil then
			offsety = 0
		end
		if height == nil then
			height = 0
		end

		if not noscaling then
			offsetx		= Helper.scaleX(offsetx)
			offsety		= Helper.scaleY(offsety)
			height		= Helper.scaleY(height)
			if not columnwidthpercent then
				for i, width in ipairs(columnwidths) do
					columnwidths[i] = Helper.scaleX(width)
				end
			end
		end
		if toprow == nil and selectedrow == nil and taborder == 1 then
			if menu.param then
				toprow = menu.param[1]
				selectedrow = menu.param[2]
			else
				toprow = 0
				selectedrow = 0
			end
		end
		if toprow == nil then
			toprow = 0
		end
		if selectedrow == nil then
			selectedrow = 0
		end
		if selectedcol == nil then
			selectedcol = 0
		end
		if wraparound == nil then
			wraparound = false
		end
		if highlightmode == nil then
			highlightmode = "on"
		end
		if skiptabchange == nil then
			skiptabchange = false
		end
		if defaultinteractiveobject == nil then
			defaultinteractiveobject = false
		end

		local content = self:createTableContent(#columnwidths)
		--[[
		for i, row in ipairs(content) do
			print(i .. ": " .. (row.color and "Color: r = " .. tostring(row.color.r) .. ", g = " .. tostring(row.color.g) .. ", b = " .. tostring(row.color.b) .. "; " or "") .. "Selectable: " .. tostring(row.selectable))
			for j, col in ipairs(row.cols) do
				print("   " .. j .. ": Colspan: " .. tostring(col.colspan) .. "; Content: " .. tostring(col.content))
			end
		end --]]
		Helper.autoFrameHeight = math.max(Helper.autoFrameHeight, offsety + height)
		local initialSelection = {
			toprow		= math.min(toprow, #content) <= fixedrows and 0 or math.min(toprow, #content),
			selectedrow	= math.min(selectedrow, #content - self.numFillRows),
			selectedcol	= math.min(selectedcol, #columnwidths)
		}

		local desc = Helper.createCustomWidthTable(self.header, content, columnwidths, columnwidthpercent, borderenabled, taborder, skiptabchange, defaultinteractiveobject, fixedrows, offsetx, offsety, height, initialSelection, wraparound, highlightmode)
		if taborder == 1 then
			menu.defaulttable = desc
		end
		Helper.addTableDescRowDataMap(menu, desc, self.rowDataMap)
		return desc
	end

	return setup
end

---------------------------------------------------------------------------------
-- Widget setup helper
---------------------------------------------------------------------------------

-- Widget setup interface is exposed via Helper.createFrameHandle()

local createTextPropertyInfo
local createIconPropertyInfo
local createHotkeyPropertyInfo
local initTableCell
local setTableColumnWidthData
local finalizeTableColumnWidths
local finalizeFlowchartCellSlots
local onFrameHandleViewCreated

-- for optional non-boolean properties
local propertyDefaultValue = false
local propertyBooleanDefaultValue = 0

-- Prototypes of widget handle member functions
local widgetPrototypes = { }
-- Metatables of widget handles, e.g. for providing member functions
local widgetMetatables = { }
-- Metatables of widget properties, for providing default properties
local widgetPropertyMetatables = { }
-- Type-specific widget handle helper functions (not member functions)
local widgetHelpers = { }

-- Definitions of available *simple* widget properties and their default values. Table members are either real widget types (and derive
-- from the "widget" member via "_basetype"), or definitions of complex properties of other widgets. Widgets can have complex
-- properties, defined separately below. For example, while "text" is a widget with properties "color" and "font", "button" is a widget
-- with a complex property "text", which in turn has simple properties defined by "textproperty", such as "color" and "font".
--
-- NOTE: All simple properties must have non-nil default values, nil values do not count.
local defaultWidgetProperties = {
	["widget"] = {
		-- base type, used for all widgets (default values can be overwritten by derived types)
		scaling = true,											-- apply scaling to coordinates, widths and heights (ignored on frame widgets, but propagated to table rows and cells)
		width = 0,												-- widget width
		height = 0,												-- widget height
		x = 0,													-- X offset
		y = 0,													-- Y offset
		mouseOverText = "",										-- mouse-over text string
		helpOverlayText = "",
		helpOverlayID = "",
		helpOverlayX = 0,
		helpOverlayY = 0,
		helpOverlayWidth = 0,
		helpOverlayHeight = 0,
		helpOverlayHighlightOnly = false,
		helpOverlayScaling = propertyBooleanDefaultValue,
		helpOverlayUseBackgroundSpan = false,
	},
	["frame"] = {
		layer = 4,												-- frame layer index
		exclusiveInteractions = false,							-- whether interactions (i.e. any input) will be exclusive to the view
		backgroundID = "",										-- the background texture (using an icon ID) to be used (empty = no background)
		backgroundColor = Helper.color.white,					-- color of the background texture
		background2ID = "",										-- the background2 texture (using an icon ID) to be used (empty = no background)
		background2Color = Helper.color.white,					-- color of the background2 texture
		overlayID = "",											-- the texture to be used for the overlay effect (empty = no overlay)
		overlayColor = Helper.color.white,						-- color of the overlay texture
		standardButtons = Helper.standardButtons_CloseBack,		-- which standard buttons should be displayed (close / back / minimize)
		standardButtonX = 0,									-- x offset for the standardbuttons
		standardButtonY = 0,									-- y offset for the standardbuttons
		standardButtonHelpOverlays = {},						-- add a highlightmode only helpoverlay to any specified standard button
		showBrackets = false,									-- whether to display frame brackets
		autoFrameHeight = false,								-- whether to use automatically calculated height of all content instead of height property
		closeOnUnhandledClick = false,							-- whether the the onHide event should be fired if the user clicks outside the view
		playerControls = false,									-- whether player controls are allowed
		startAnimation = true,									-- whether the start animation is played
		enableDefaultInteractions = true,						-- whether default input handling (f.e. ESC/DEL) is enabled
		useMiniWidgetSystem = false,							-- whether the frame should use the mini widgetsystem
		viewHelperType = "Helper",
		_basetype = "widget"
	},
	["rendertarget"] = {
		alpha = 100,											-- render target alpha
		clear = true,											-- clear rendertarget on init
		startnoise = false,										-- whether the rendertarget starts with noise or not
		_basetype = "widget"
	},
	["table"] = {
		header = "",											-- header text
		tabOrder = 0,											-- tab order of the table (0 means non-interactive, 1 means default interactive table)
		skipTabChange = false,									-- skips the table when tabbing if true
		defaultInteractiveObject = false,						-- Set this object as the interactive object of the frame on creation if true
		borderEnabled = true,									-- whether table cells have a background color
		maxVisibleHeight = 0,									-- maximum height of table (enables scrollbar if required height for all rows exceeds max height, 0 = no maximum)
		reserveScrollBar = true,								-- whether the table width should include the required space for a potential scrollbar (otherwise the last column may be shortened)
		wraparound = false,										-- whether the table selection should wrap around when moving beyond the first/last row
		highlightMode = "on",									-- how to highlight the table selection ("on", "column", "off", "grey")
		multiSelect = false,									-- whether the the table allows multiselection
		backgroundID = "",										-- the background texture (using an icon ID) to be used (empty = no background)
		backgroundColor = Helper.color.white,					-- color of the background texture
		prevTable = 0,											-- point to the index of the previous connected table (aka pressing UP on the first row jumps the input to the last row of the prevTable)
		nextTable = 0,											-- point to the index of the next connected table (aka pressing DOWN on the last row jumps the input to the first row of the nextTable)
		prevHorizontalTable = 0,								-- point to the index of the previous horizontal connected table (aka pressing LEFT on the first selectable column jumps the input to the prevHorizontalTable)
		nextHorizontalTable = 0,								-- point to the index of the next horizontal connected table (aka pressing RIGHT on the last selectable column jumps the input to the nextHorizontalTable)
		_basetype = "widget"
	},
	["row"] = {
		scaling = true,											-- default value for cell scaling, applied to cell coordinates, widths and heights (note that column widths are not affected)
		fixed = false,											-- row is fixed, not scrollable (requires all previous rows to be fixed as well)
		borderBelow = true,										-- show border between this and the following row (ignored on the last row)
		interactive = true,										-- non-interactive, but selectable rows (rowdata ~= nil or false) (used for grey highlight border)
		bgColor = Helper.defaultSimpleBackgroundColor,			-- row background color
		multiSelected = false									-- row is part of preselection in a multiselect table
	},
	-- table cells
	["cell"] = {
		cellBGColor = Helper.defaultSimpleBackgroundColor,		-- background color
		uiTriggerID = propertyDefaultValue,						-- ID for UITriggered events
		_basetype = "widget"
	},
	["text"] = {
		text = "",												-- text string
		halign = Helper.standardHalignment,						-- horizontal text alignment ("left", "center", "right")
		color = Helper.standardColor,							-- text color
		titleColor = propertyDefaultValue,						-- title line color, also enables the title mode of the fontstring widget
		font = Helper.standardFont,								-- font
		fontsize = Helper.standardFontSize,						-- font size
		wordwrap = false,										-- word wrap
		x = Helper.standardTextOffsetx,							-- text X offset (overrides basetype X offset)
		y = Helper.standardTextOffsety,							-- text Y offset (overrides basetype Y offset)
		minRowHeight = Helper.standardTextHeight,				-- minimal row height (including Y offset)
		_basetype = "cell"
	},
	["icon"] = {
		icon = "",												-- icon ID
		color = Helper.standardColor,							-- icon color
		affectRowHeight = true,									-- whether the icon height is allowed to affect the rowHeight
		_basetype = "cell"
	},
	["button"] = {
		active = true,											-- whether the button is active
		bgColor = Helper.defaultButtonBackgroundColor,			-- button backbround color
		highlightColor = Helper.defaultButtonHighlightColor,	-- button highlight color
		height = Helper.standardButtonHeight,					-- button height (overrides basetype height)
		_basetype = "cell"
	},
	["editbox"] = {
		bgColor = Helper.defaultEditBoxBackgroundColor,			-- editbox background color
		closeMenuOnBack = false,								-- whether the menu should be closed on back while the editbox is active
		defaultText = "",										-- the text to be displayed if text is empty
		description = "",										-- description shown in input overlay when using Steam Big Picture
		textHidden = false,										-- whether the text is shown in the clear or hidden (aka password-style)
		encrypted = false,										-- whether the input is encrypted (aka password-style)
		selectTextOnActivation = true,							-- whether the text is pre-selected when activating the editbox
		active = true,											-- whether the editbox is active
		restoreInteractiveObject = false,						-- whether the input focus is restored to the previous object after the editbox is deactivated
		maxChars = 50,											-- max characters that can be entered
		_basetype = "cell"
	},
	["shieldhullbar"] = {
		shield = 0,
		hull = 0,
		_basetype = "cell"
	},
	["graph"] = {
		-- HACK
		graphdesc = propertyDefaultValue,
		_basetype = "cell"
	},
	["slidercell"] = {
		bgColor = Helper.defaultSliderCellBackgroundColor,					-- slidercell background color
		inactiveBGColor = Helper.defaultSliderCellInactiveBackgroundColor,	-- slidercell background color for inactive directions if fromCenter is set
		valueColor = Helper.defaultSliderCellValueColor,					-- slidercell value color
		posValueColor = Helper.defaultSliderCellPositiveValueColor,			-- slidercell positive value color if fromCenter is set
		negValueColor = Helper.defaultSliderCellNegativeValueColor,			-- slidercell negative value color if fromCenter is set
		min = 0,															-- minimum value
		minSelect = propertyDefaultValue,									-- min selectable value (optional, defaults to min)
		max = 0,															-- maximum value
		maxSelect = propertyDefaultValue,									-- max selectable value (optional, defaults to max - do not use with exceedmax)
		start = 0,															-- start value
		step = 1,															-- step size
		accuracyOverride = propertyDefaultValue,							-- override the accuracy calculated from the step with this (optional, defaults to -1 -> no override)
		infiniteValue = 0,													-- Value at which the slider shows infinity
		suffix = "",														-- suffix to be displayed
		exceedMaxValue = false,												-- allow player to exceed the max value (requires min >= 0)
		hideMaxValue = false,												-- Hide the max value in the number display
		rightToLeft = false,												-- Right-to-left (mirrored) scale
		fromCenter = false,													-- Slider bar extends from zero in the center
		readOnly = false,													-- Slider is read-only (non-interactive), only used as output
		useInfiniteValue = false,											-- Slider shows infinity symbol if value == InfiniteValue
		useTimeFormat = false,												-- Slider uses time format
		_basetype = "cell"
	},
	["dropdown"] = {
		options = {},
		startOption = "",
		active = true,
		bgColor = Helper.defaultButtonBackgroundColor,
		highlightColor = Helper.defaultButtonHighlightColor,
		optionColor = Helper.color.black,
		optionWidth = 0,
		optionHeight = 0,
		allowMouseOverInteraction = false,
		textOverride = "",
		text2Override = "",
		_basetype = "cell"
	},
	["checkbox"] = {
		checked = false,
		bgColor = Helper.defaultCheckBoxBackgroundColor,
		active = true,
		symbol = "circle",													-- The symbol the checkbox uses. Valid values: "circle", "arrow" (optional - default to "circle")
		_basetype = "cell"
	},
	["statusbar"] = {
		current = 0,
		start = 0,
		max = 0,
		valueColor = Helper.defaultStatusBarValueColor,
		posChangeColor = Helper.defaultStatusBarPosChangeColor,
		negChangeColor = Helper.defaultStatusBarNegChangeColor,
		markerColor = Helper.defaultStatusBarMarkerColor,
		titleColor = propertyDefaultValue,
		_basetype = "cell"
	},
	["boxtext"] = {
		text = "",												-- text string
		halign = Helper.standardHalignment,						-- horizontal text alignment ("left", "center", "right")
		color = Helper.standardColor,							-- text color
		boxColor = Helper.defaultBoxTextBoxColor,				-- title line color, also enables the title mode of the fontstring widget
		font = Helper.standardFont,								-- font
		fontsize = Helper.standardFontSize,						-- font size
		wordwrap = false,										-- word wrap
		textX = Helper.standardTextOffsetx,						-- text X offset
		textY = Helper.standardTextOffsety,						-- text Y offset
		minRowHeight = Helper.standardTextHeight,				-- minimal row height (including Y offset)
		_basetype = "cell"
	},
	-- flowchart widgets
	["flowchart"] = {
		tabOrder = 0,											-- tab order of the flowchart (0 means non-interactive, 1 means default interactive table)
		skipTabChange = false,									-- skips the flowchart when tabbing if true
		defaultInteractiveObject = false,						-- Set this object as the interactive object of the frame on creation if true
		borderHeight = 0,										-- height of flowchart border at top and bottom (default 0 = no border)
		borderColor = Helper.color.transparent,					-- flowchart border color
		maxVisibleHeight = 0,									-- maximum visible height of flowchart (enables scrollbar if required height for all rows exceeds max height, 0 = use available height in frame)
		minRowHeight = 0,										-- minimal row height
		minColWidth = 0,										-- minimal column width (can be overridden with flowchart:setColWidthMin())
		edgeWidth = 1,											-- edge width
		firstVisibleRow = 1,									-- first visible row
		firstVisibleCol = 1,									-- first visible column
		selectedRow = 1,										-- selected row
		selectedCol = 1,										-- selected column
		_basetype = "widget"
	},
	["flowchartcell"] = {
		_basetype = "widget"
	},
	["flowchartnode"] = {
		-- x = 0,												-- flowchartnode-specific: minimal left and right spacing in cell (node is centered)
		-- y = 0,												-- flowchartnode-specific: minimal top and bottom spacing in cell (node is centered)
		-- width = 0,											-- flowchartnode-specific: width of node outline - value required, must be greater than height
		height = Helper.standardFlowchartNodeHeight,			-- flowchartnode-specific: height of node outline (default overrides basetype default), must be at least 10
		shape = "rectangle",									-- shape ("rectangle", "stadium", "hexagon")
		expandedFrameLayer = 0,									-- layer for created menu frame when node is expanded (required for expansion)
		expandedFrameNumTables = 1,								-- number of tables in created menu frame when node is expanded (1 or 2)
		expandedTableNumColumns = 0,							-- number of columns in created menu frame table when node is expanded (required for expansion)
		value = 0,												-- current value
		max = 0,												-- maximum value
		slider1 = -1,											-- slider 1 value (position of top slider handle, diff-range highlighted if greater than current value, negative = disabled)
		slider2 = -1,											-- slider 2 value (position of bottom slider handle, diff-range highlighted if less than current value, negative = disabled)
		step = 0,												-- step size for sliders (0 = sliders are fixed and non-interactive, no handles are shown)
		connectorSize = Helper.standardFlowchartConnectorSize,	-- size of input/output connectors
		statusColor = propertyDefaultValue,						-- override color for statustext or statusicon
		statusBgIconID = "",									-- optional ID of background icon behind statusicon, with same size, position and color as statusicon
		statusBgIconRotating = false,							-- whether status background icon is rotating, if statusBgIconID provided
		bgColor = Helper.defaultFlowchartBackgroundColor,		-- color of node background
		outlineColor = Helper.defaultFlowchartOutlineColor,		-- color of node outline
		valueColor = Helper.defaultFlowchartValueColor,			-- color of value bar
		slider1Color = Helper.defaultFlowchartSlider1Color,		-- color of interactive top slider handle
		slider2Color = Helper.defaultFlowchartSlider2Color,		-- color of interactive bottom slider handle
		diff1Color = Helper.defaultFlowchartDiff1Color,			-- color of diff-range between current value and top slider handle (if greater than current value)
		diff2Color = Helper.defaultFlowchartDiff2Color,			-- color of diff-range between current value and bottom slider handle (if less than current value)
		slider1MouseOverText = "",								-- mouse-over text string for the top slider handle
		slider2MouseOverText = "",								-- mouse-over text string for the bottom slider handle
		statusIconMouseOverText = "",							-- mouse-over text string for the status icon
		_basetype = "flowchartcell"
	},
	["flowchartjunction"] = {
		-- x = 0,												-- flowchartjunction-specific: minimal left and right spacing in cell (X distance from center to border is junctionXOff + x)
		-- y = 0,												-- flowchartjunction-specific: minimal top and bottom spacing in cell (junction is vertically centered)
		junctionXOff = -1,										-- X offset from center of column (negative value means that the offset is calculated automatically, taking the rightmost position of any node in the column)
		junctionSize = Helper.standardFlowchartConnectorSize,	-- junction size
		_basetype = "flowchartcell"
	},
	["flowchartedge"] = {
		color = Helper.standardColor,							-- edge color
		sourceSlotColor = propertyDefaultValue,					-- color of output slot of source node/junction (if provided, the same color must be used by all outgoing edges from that slot)
		sourceSlotRank = 1,										-- rank value from 1 to 3, used for assignment of an output slot at the source node, in case there are multiple outgoing edges (edges of same rank connect to the same slot)
		destSlotColor = propertyDefaultValue,					-- color of input slot of destination node/junction (if provided, the same color must be used by all incoming edges to that slot)
		destSlotRank = 1,										-- rank value from 1 to 3, used for assignment of an input slot at the destination node, in case there are multiple incoming edges (edges of same rank connect to the same slot)
		_basetype = "widget"
	},
	-- complex properties
	["textproperty"] = {
		text = "",												-- text string
		x = 0,													-- X offset
		y = 0,													-- Y offset
		halign = Helper.standardHalignment,						-- horizontal text alignment ("left", "center", "right")
		color = Helper.standardColor,							-- text color
		font = Helper.standardFont,								-- font
		fontsize = Helper.standardFontSize,						-- font size
		scaling = true,											-- scaling
	},
	["iconproperty"] = {
		icon = "",												-- icon ID
		swapicon = "",											-- swap icon ID
		width = 0,												-- widget width
		height = 0,												-- widget height
		x = 0,													-- X offset
		y = 0,													-- Y offset
		color = Helper.standardColor,							-- icon color
		scaling = true,											-- scaling
	},
	["hotkeyproperty"] = {
		hotkey = "",											-- the associated hotkey action (must correspond to a valid INPUT_STATE - for instance "INPUT_STATE_FOO")
		displayIcon = false,									-- whether the widget using the hotkey displays the associated icon as a hotkey
		x = 0,													-- X offset for the hotkey icon (only used if displayIcon is set to true)
		y = 0													-- Y offset for the hotkey icon (only used if displayIcon is set to true)
	},
	["frametextureproperty"] = {
		-- TODO Florian - move icon and color here
		width = 0,												-- override texture width (0 -> use frame width)
		height = 0,												-- override texture height (0 -> use frame width)
		rotationRate = 0,										-- rate of rotation in deg/s
		rotationStart = 0,										-- start of the rotation in deg
		rotationDuration = 0,									-- duration of rotation (0 -> never stop)
		rotationInterval = 0,									-- time until rotation repeats (0 -> never repeat)
		initialScaleFactor = 1,									-- scale change relative to end scale
		scaleDuration = 0,										-- duration of the scale change
	},
}

-- Definition of complex widget properties. Table value references a type defined above in defaultWidgetProperties.
local complexCellProperties = {
	["frame"] = {
		background =	"frametextureproperty",
		background2 =	"frametextureproperty",
		overlay =		"frametextureproperty",
	},
	["icon"] = {
		text =			"textproperty",
		text2 =			"textproperty"
	},
	["button"] = {
		text =			"textproperty",
		text2 =			"textproperty",
		icon =			"iconproperty",
		icon2 =			"iconproperty",
		hotkey =		"hotkeyproperty"
	},
	["editbox"] = {
		text =			"textproperty",
		hotkey =		"hotkeyproperty"
	},
	["slidercell"] = {
		text =			"textproperty"
	},
	["dropdown"] = {
		text =			"textproperty",
		text2 =			"textproperty",
		icon =			"iconproperty",
		hotkey =		"hotkeyproperty"
	},
	["flowchartnode"] = {
		text =			"textproperty",
		statustext =	"textproperty",
		statusicon =	"iconproperty",
	},
}

-- create widget metatables and prototype tables (to be filled with member functions below), and tables for helper functions
for widgettype, properties in pairs(defaultWidgetProperties) do
	widgetPrototypes[widgettype] = { }
	widgetMetatables[widgettype] = {
		__index = widgetPrototypes[widgettype]
	}
	-- TODO: Allow property adjustments after frame creation (e.g. using SetCellContent())
	widgetPropertyMetatables[widgettype] = {
		__index = function(proptable, prop)
			if prop == "apply" then
				-- allow properties:apply({ prop = value })
				return function (self, input)
					if input then
						for prop, value in pairs(input) do
							self[prop] = value
						end
					end 
				end
			end
			local v = properties[prop]
			if v == nil then
				DebugError(string.format("Widget setup error: Tried to access non-existing property '%s' on widget of type '%s'\n\n%s", tostring(prop), tostring(widgettype), TraceBack()))
			end
			return v
		end,
		__newindex = function(proptable, prop, propvalue)
			if properties[prop] ~= nil then
				rawset(proptable, prop, propvalue)
			else
				DebugError(string.format("Widget setup error: Tried to set non-existing property '%s' on widget of type '%s'\n\n%s", tostring(prop), tostring(widgettype), TraceBack()))
			end
		end
	}
	widgetHelpers[widgettype] = { }
end

-- set up inheritance via metatables: widget types that derive from "cell" should inherit the default properties and member functions
for widgettype, properties in pairs(defaultWidgetProperties) do
	local basetype = properties._basetype
	if basetype then
		-- remove basetype entry
		properties._basetype = nil
		-- inherit prototypes from basetype
		setmetatable(widgetPrototypes[widgettype], widgetMetatables[basetype])
		-- inherit default properties from basetype
		setmetatable(properties, { __index = defaultWidgetProperties[basetype] })
	end
end

function createTextPropertyInfo(cell, textproperty)
	local text = textproperty.text
	if not text then
		return nil
	end
	if type(text) == "function" then
		text = text(cell)
	end
	local color = textproperty.color
	if type(color) == "function" then
		color = color(cell)
	end
	local halign = textproperty.halign
	local font = textproperty.font
	local fontsize = Helper.scaleFont(font, textproperty.fontsize, textproperty.scaling)
	local offsetx = Helper.scaleX(textproperty.x, textproperty.scaling)
	local offsety = Helper.scaleY(textproperty.y, textproperty.scaling)
	return { text = text, alignment = halign, fontname = font, fontsize = fontsize, color = color, x = offsetx, y = offsety }
end

function createIconPropertyInfo(cell, iconproperty)
	local icon = iconproperty.icon
	if icon == "" then
		return nil
	end
	if type(icon) == "function" then
		icon = icon(cell)
	end
	local color = iconproperty.color
	if type(color) == "function" then
		color = color(cell)
	end
	local swapicon = iconproperty.swapicon
	local width = Helper.scaleX(iconproperty.width, iconproperty.scaling)
	local height = Helper.scaleY(iconproperty.height, iconproperty.scaling)
	local offsetx = Helper.scaleX(iconproperty.x, iconproperty.scaling)
	local offsety = Helper.scaleY(iconproperty.y, iconproperty.scaling)
	if height ~= 0 then
		width = width - 2 * Helper.configButtonBorderSize
		height = height - 2 * Helper.configButtonBorderSize
		offsetx = offsetx + Helper.configButtonBorderSize
		offsety = offsety + Helper.configButtonBorderSize
	end
	return { iconID = icon, swapIconID = swapicon, color = color, width = width, height = height, x = offsetx, y = offsety }
end

function createHotkeyPropertyInfo(cell, hotkeyproperty, width, height, scaling)
	local state = hotkeyproperty.hotkey
	if state == "" then
		return nil
	end
	local displayicon = hotkeyproperty.displayIcon
	local offsetx = rawget(hotkeyproperty, "x")
	local offsety = hotkeyproperty.y

	if not offsetx then
		offsetx = math.max(0, width)
	elseif scaling then
		offsetx = Helper.scaleX(offsetx)
	end
	if scaling then
		offsety = Helper.scaleY(offsety)
	end
	return { action = state, displayIcon = displayicon, x = offsetx, y = offsety }
end

function createOverlayPropertyInfo(widget)
	local text = widget.properties.helpOverlayText
	if not text then
		return nil
	end
	if type(text) == "function" then
		text = text(widget)
	end

	local scaling = widget.properties.helpOverlayScaling
	if scaling == propertyBooleanDefaultValue then
		scaling = widget.properties.scaling
	end

	local width = Helper.scaleX(widget.properties.helpOverlayWidth, scaling)
	local height = Helper.scaleX(widget.properties.helpOverlayHeight, scaling)
	local offsetx = Helper.scaleX(widget.properties.helpOverlayX, scaling)
	local offsety = Helper.scaleY(widget.properties.helpOverlayY, scaling)
	return { text = text, id = widget.properties.helpOverlayID, size = { width = width, height = height }, offset = { x = offsetx, y = offsety }, highlightOnly = widget.properties.helpOverlayHighlightOnly, useBackgroundSpan = widget.properties.helpOverlayUseBackgroundSpan }
end

function createFrameTexturePropertyInfo(icon, color, textureproperty)
	return {
		icon = icon,
		color = color,
		size = {
			width = textureproperty.width,
			height = textureproperty.height,
		},
		rotation = {
			rate = textureproperty.rotationRate,
			start = textureproperty.rotationStart,
			duration = textureproperty.rotationDuration,
			interval = textureproperty.rotationInterval,
		},
		initScale = {
			factor = textureproperty.initialScaleFactor,
			duration = textureproperty.scaleDuration,
		},
	}
end

---------- Create frame handle ----------

-- Example usage:
--   local frame = Helper.createFrameHandle()
--   local frame = Helper.createFrameHandle(nil, { layer = 4, backgroundID = "solid", standardButtons = Helper.standardButtons_Close })
function Helper.createFrameHandle(menu, properties)
	local frame = {
		menu = menu,
		type = "frame",						-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- frame ID, valid while displayed
		properties = { },					-- frame properties
		content = { },
		functionCells = { },				-- contained table cells with text functions
		expandedFlowchartNodeData = nil		-- data associating frame with flowchartnode if frame was created by expanding the node
	}
	-- set metatables to enable member functions and default properties
	setmetatable(frame, widgetMetatables.frame)
	setmetatable(frame.properties, widgetPropertyMetatables.frame)
	
	-- create complex frame properties
	local complexprops = complexCellProperties.frame
	if complexprops then
		for complexprop, simpleprop in pairs(complexprops) do
			local complexproptable = { }
			setmetatable(complexproptable, widgetPropertyMetatables[simpleprop])
			rawset(frame.properties, complexprop, complexproptable)
		end
	end

	-- Default size
	frame.properties.width = Helper.viewWidth
	frame.properties.height = Helper.viewHeight
	frame.properties.x = 0
	frame.properties.y = 0

	-- apply custom properties if provided
	frame.properties:apply(properties)

	return frame
end

---------- Frame member functions ----------

-- Example usage:
--   local rendertarget = frame:addRenderTarget({ width = 427, height = 320, alpha = 90 })
function widgetPrototypes.frame:addRenderTarget(properties)
	local rendertarget = {
		frame = self,
		index = nil,						-- index in frame content (set below)
		type = "rendertarget",				-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- widget ID, valid while displayed
		properties = { }					-- rendertarget properties
	}
	table.insert(self.content, rendertarget)
	rendertarget.index = #self.content

	-- set metatables to enable member functions and default properties
	setmetatable(rendertarget, widgetMetatables.rendertarget)
	setmetatable(rendertarget.properties, widgetPropertyMetatables.rendertarget)

	-- apply properties if provided
	rendertarget.properties:apply(properties)
	return rendertarget
end

--   local flowchart = frame:addFlowchart(5, { borderHeight = 4, borderColor = Helper.defaultSimpleBackgroundColor })
function widgetPrototypes.frame:addFlowchart(numrows, numcolumns, properties)
	local flowchart = {
		frame = self,
		index = nil,						-- index in frame content (set below)
		type = "flowchart",					-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- widget ID, valid while displayed
		numrows = numrows,					-- number of rows
		numcolumns = numcolumns,			-- number of columns
		columndata = { },					-- column widths and other metadata
		rows = { },							-- row table
		edges = { },						-- edge widgets
		expandedNodes = { },				-- expanded flowchartnodes (mapping node -> expanded frame handle)
		defaultNodeProperties = nil,		-- default values for properties of contained nodes (applied when created)
		defaultEdgeProperties = nil,		-- default values for properties of flowchart edges (applied when created)
		defaultTextProperties = nil,		-- default values for properties of contained node texts (applied when set)
		defaultIconProperties = nil,		-- default values for properties of contained node status icons (applied when set)
		properties = { },					-- flowchart properties
	}
	table.insert(self.content, flowchart)
	flowchart.index = #self.content

	-- set metatables to enable member functions and default properties
	setmetatable(flowchart, widgetMetatables.flowchart)
	setmetatable(flowchart.properties, widgetPropertyMetatables.flowchart)

	-- propagate scaling from frame to flowchart
	if not self.properties.scaling then
		flowchart.properties.scaling = false
	end

	-- apply properties if provided
	flowchart.properties:apply(properties)

	-- set up columndata
	for i = 1, flowchart.numcolumns do
		flowchart.columndata[i] = { bgcolor = nil, minwidth = -1, weight = 1, scaling = nil, junctionxoff = 0 }
	end

	-- prepare rows
	if numrows < 1 or numcolumns < 1 then
		flowchart.numrows = 0
		flowchart.numcolumns = 0
	end
	for i = 1, flowchart.numrows do
		local row = { }
		for j = 1, flowchart.numcolumns do
			row[j] = false
		end
		flowchart.rows[i] = row
	end

	return flowchart
end

-- Example usage:
--   local ftable = frame:addTable(5, { tabOrder = 1 })
function widgetPrototypes.frame:addTable(numcolumns, properties)
	local ftable = {
		frame = self,
		index = nil,						-- index in frame content (set below)
		type = "table",						-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- widget ID, valid while displayed
		numcolumns = numcolumns,			-- number of columns
		columndata = { final = false },		-- column widths and other metadata
		rows = { },							-- row objects
		numfixedrows = nil,					-- number of fixed rows, will be determined on display
		toprow = nil,						-- first visible row
		selectedrow = nil,					-- selected row
		selectedcol = 0,					-- selected column
		properties = { },					-- table properties
		defaultCellProperties = nil,		-- default values for properties of contained cells (applied when created)
		defaultComplexCellProperties = nil,	-- default values for complex properties of contained cells (applied when created)
		createdWithScrollBar = nil,			-- return value of hasScrollBar() at descriptor creation
	}
	table.insert(self.content, ftable)
	ftable.index = #self.content

	-- set metatables to enable member functions and default properties
	setmetatable(ftable, widgetMetatables.table)
	setmetatable(ftable.properties, widgetPropertyMetatables.table)

	-- propagate scaling from frame to table
	if not self.properties.scaling then
		ftable.properties.scaling = false
	end

	-- apply properties if provided
	ftable.properties:apply(properties)

	-- set up columndata
	for i = 1, numcolumns do
		ftable.columndata[i] = { width = 0, percent = false, min = true, weight = 1, colspan = 1, bgcolspan = 1, scaling = nil }
	end

	return ftable
end

function widgetPrototypes.frame:setBackground(icon, properties)
	self.properties.backgroundID = icon
	-- remove when we moved icon and color to complex property
	if properties.color then
		self.properties.backgroundColor = properties.color
		properties.color = nil
	end
	self.properties.background:apply(properties)
	return self
end

function widgetPrototypes.frame:setBackground2(icon, properties)
	self.properties.background2ID = icon
	-- remove when we moved icon and color to complex property
	if properties.color then
		self.properties.background2Color = properties.color
		properties.color = nil
	end
	self.properties.background2:apply(properties)
	return self
end

function widgetPrototypes.frame:setOverlay(icon, properties)
	self.properties.overlayID = icon
	-- remove when we moved icon and color to complex property
	if properties.color then
		self.properties.overlayColor = properties.color
		properties.color = nil
	end
	self.properties.overlay:apply(properties)
	return self
end

function widgetPrototypes.frame:getAvailableHeight()
	if self.properties.autoFrameHeight then
		return Helper.viewHeight - self.properties.y
	end
	return self.properties.height
end

function widgetPrototypes.frame:getUsedHeight()
	local height = 0
	-- minimal height required for standard buttons
	local standardbuttons = self.properties.standardButtons
	if standardbuttons and (standardbuttons.back or standardbuttons.close or standardbuttons.minimize or standardbuttons.help) then
		height = Helper.standardButtons_Size
	end
	-- minimal height required for each top-level widget
	for _, widget in ipairs(self.content) do
		if widget.type == "table" or widget.type == "flowchart" then
			height = math.max(height, widget.properties.y + widget:getVisibleHeight())
		elseif widget.type == "rendertarget" then
			height = math.max(height, widget.properties.y + widget.properties.height)
		end
	end
	return height
end

function widgetPrototypes.frame:display()
	local framewidgetdescriptors = { }
	self.hastable = false
	for widgetidx, widget in ipairs(self.content) do
		if widget.type == "table" then
			self.hastable = true
		end
		local desc = widgetHelpers[widget.type].createDescriptor(widget)
		if desc == nil then
			DebugError("Frame content of type '" .. widget.type .. "' was not created successfully! Aborting display of frame!")
			return
		end
		if widget.descriptor then
			ReleaseDescriptor(widget.descriptor)
		end
		widget.descriptor = desc
		framewidgetdescriptors[widgetidx] = desc
	end

	local menu = self.menu
	local layer = self.properties.layer
	local exclusiveInteractions = self.properties.exclusiveInteractions
	local closeOnUnhandledClick = self.properties.closeOnUnhandledClick
	local playerControls = self.properties.playerControls
	local startAnimation = self.properties.startAnimation
	local enableDefaultInteractions = self.properties.enableDefaultInteractions
	local helpoverlay = createOverlayPropertyInfo(self)
	local standardButtonHelpOverlays = {}
	for button, helpoverlayID in pairs(self.properties.standardButtonHelpOverlays) do
		standardButtonHelpOverlays[button] = { text = " ", id = helpoverlayID, size = { width = 0, height = 0 }, offset = { x = 0, y = 0 }, highlightOnly = true }
	end

	menu.frameData[layer] = {
		width = self.properties.width,
		height = self.properties.autoFrameHeight and self:getUsedHeight() or self.properties.height,
		x = self.properties.x,
		y = self.properties.y,
	}

	local frameDescriptor = {
		offset = {
			x = menu.frameData[layer].x,
			y = menu.frameData[layer].y,
		},
		size = {
			width = menu.frameData[layer].width,
			height = menu.frameData[layer].height,
		},
		contentdescriptors = framewidgetdescriptors,
		layer = layer,
		background = createFrameTexturePropertyInfo(self.properties.backgroundID, self.properties.backgroundColor, self.properties.background),
		background2 = createFrameTexturePropertyInfo(self.properties.background2ID, self.properties.background2Color, self.properties.background2),
		overlay = createFrameTexturePropertyInfo(self.properties.overlayID, self.properties.overlayColor, self.properties.overlay),
		standardButtons = self.properties.standardButtons,
		standardButtonOffset = {
			x = self.properties.standardButtonX,
			y = self.properties.standardButtonY
		},
		standardButtonHelpOverlays = standardButtonHelpOverlays,
		showBrackets = self.properties.showBrackets,
		enableDefaultInteractions = enableDefaultInteractions,
		closeOnUnhandledClick = closeOnUnhandledClick,
		helpoverlay = helpoverlay,
	}

	local framedesc = CreateFrame2(frameDescriptor)

	if self.descriptor then
		ReleaseDescriptor(self.descriptor)
	end
	self.descriptor = framedesc
	-- TODO
	if self.hastable then
		Helper.handleTableDesc(menu, framewidgetdescriptors)
	end

	Helper.closeMinimizedMenus()
	-- TODO: Adjust callbacks
	View.registerMenu("Helper" .. layer, self.properties.viewHelperType, function (frames) return onFrameHandleViewCreated(self, frames) end, function () return menu.onCloseElement("close", nil, true) end, {[layer] = framedesc}, exclusiveInteractions, closeOnUnhandledClick, nil, playerControls, self.properties.useMiniWidgetSystem, startAnimation)
end

function onFrameHandleViewCreated(framehandle, frames)
	local frameid = frames[1]
	local menu = framehandle.menu
	if frameid then
		local layer = framehandle.properties.layer
		menu.frames = menu.frames or {}
		menu.frames[layer] = frameid
		local children = table.pack(GetChildren(frameid))
		Helper.setScripts(menu, layer, frameid, children)
		if framehandle.hastable then
			Helper.handleCreatedTables(menu, children)
		end

		-- store IDs in widget handles, release descriptors and set up event handlers
		framehandle.id = frameid
		for i, widgetid in ipairs(children) do
			local widget = framehandle.content[i]
			ReleaseDescriptor(widget.descriptor)
			widget.descriptor = nil
			widget.id = widgetid
			if widget.type == "table" then
				for rowidx, row in ipairs(widget.rows) do
					do
						local expectedheight = row:getHeight()
						local actualheight = GetTableRowHeight(widgetid, rowidx)
						if expectedheight ~= actualheight then
							DebugError(string.format("Table row height mismatch in row %d: expected height = %s, actualheight = %s [Klaus]", rowidx, expectedheight, actualheight))
						end
					end
					for cellidx, cell in ipairs(row) do
						if cell.colspan ~= 0 then
							ReleaseDescriptor(cell.descriptor)
							cell.descriptor = nil
							cell.id = GetCellContent(widgetid, rowidx, cellidx)
							local triggerid = cell.properties.uiTriggerID or nil
							if cell.type == "checkbox" then
								Helper.setCheckBoxScript(menu, triggerid, widgetid, rowidx, cellidx, cell.handlers.onClick)
							elseif cell.type == "button" then
								Helper.setButtonScript(menu, triggerid, widgetid, rowidx, cellidx, cell.handlers.onClick, cell.handlers.onRightClick)
							elseif cell.type == "editbox" then
								Helper.setEditBoxScript(menu, triggerid, widgetid, rowidx, cellidx, cell.handlers.onEditBoxDeactivated, cell.handlers.onTextChanged, cell.handlers.onEditBoxActivated, cell.handlers.onCursorChanged)
							elseif cell.type == "slidercell" then
								Helper.setSliderCellScript(menu, triggerid, widgetid, rowidx, cellidx, cell.handlers.onSliderCellChanged, cell.handlers.onSliderCellActivated, cell.handlers.onSliderCellDeactivated, cell.handlers.onRightClick, cell.handlers.onSliderCellConfirm)
							elseif cell.type == "dropdown" then
								Helper.setDropDownScript(menu, triggerid, widgetid, rowidx, cellidx, cell.handlers.onDropDownActivated, cell.handlers.onDropDownConfirmed, cell.handlers.onDropDownRemoved)
							elseif cell.type == "graph" then
								Helper.setGraphScript(menu, triggerid, widgetid, rowidx, cellidx, cell.handlers.onClick)
							end
						end
					end
				end
				if widget.properties.prevTable ~= 0 then
					C.SetTablePreviousConnectedTable(widgetid, children[widget.properties.prevTable])
				end
				if widget.properties.nextTable ~= 0 then
					C.SetTableNextConnectedTable(widgetid, children[widget.properties.nextTable])
				end
				if widget.properties.prevHorizontalTable ~= 0 then
					C.SetTablePreviousHorizontalConnectedTable(widgetid, children[widget.properties.prevHorizontalTable])
				end
				if widget.properties.nextHorizontalTable ~= 0 then
					C.SetTableNextHorizontalConnectedTable(widgetid, children[widget.properties.nextHorizontalTable])
				end
			elseif widget.type == "flowchart" then
				local flowchartData = GetFlowchartData(widgetid)
				for rowidx, row in ipairs(widget.rows) do
					do
						local expectedheight = widget:getRowHeight(rowidx)
						local actualheight = flowchartData.rowHeights[rowidx]
						if expectedheight ~= actualheight then
							DebugError(string.format("Flowchart row height mismatch in row %d: expected height = %s, actualheight = %s [Klaus]", rowidx, expectedheight, actualheight))
						end
					end
					for cellidx, cell in ipairs(row) do
						if cell then
							ReleaseDescriptor(cell.descriptor)
							cell.descriptor = nil
							cell.id = GetFlowchartNodeID(widgetid, rowidx, cellidx)
							if cell.type == "flowchartnode" then
								widgetHelpers.flowchartnode.setScripts(cell)
							end
						end
					end
				end
				for edgeidx, edge in ipairs(widget.edges) do
					ReleaseDescriptor(edge.descriptor)
					edge.descriptor = nil
					edge.id = GetFlowchartEdgeID(widgetid, edgeidx)
				end
			end
		end

		if framehandle.expandedFlowchartNodeData then
			-- this frame was created by expanding a flowchartnode in another frame
			local node = framehandle.expandedFlowchartNodeData.node
			if node.flowchart.expandedNodes[node] == framehandle then
				C.SetFlowchartNodeExpanded(node.id, frameid, framehandle.expandedFlowchartNodeData.expandedAbove)
			else
				-- this should not happen (flowchartnode being collapsed immediately before view is created)
				DebugError("onFrameHandleViewCreated(): Expanded menu frame was created for flowchartnode that is not expanded")
			end
		end

		if menu.tableConnections and menu.tableConnections.refresh then
			menu.tableConnections.refresh = nil

			local connections = {}
			for _, tables in Helper.orderedPairs(menu.tableConnections) do
				local compacted_tables = {}
				for _, ftable in Helper.orderedPairs(tables) do
					table.insert(compacted_tables, ftable)
				end
				table.insert(connections, compacted_tables)
			end

			for i, tables in ipairs(connections) do
				for j, table in ipairs(tables) do
					if table.id then
						if j ~= 1 then
							if tables[j - 1].id then
								C.SetTablePreviousConnectedTable(table.id, tables[j - 1].id)
							end
						end
						if j ~= #tables then
							if tables[j + 1].id then
								C.SetTableNextConnectedTable(table.id, tables[j + 1].id)
							end
						end
						if i ~= 1 then
							if connections[i - 1][1] and connections[i - 1][1].id then
								C.SetTablePreviousHorizontalConnectedTable(table.id, connections[i - 1][1].id)
							end
						end
						if i ~= #connections then
							if connections[i + 1][1] and connections[i + 1][1].id then
								C.SetTableNextHorizontalConnectedTable(table.id, connections[i + 1][1].id)
							end
						end
					end
				end
			end
		end

		if menu.viewCreated then
			menu.viewCreated(layer, table.unpack(children))
		end
	else
		DebugError(TraceBack())
		ScheduleReloadUI()
		error("Failed to create view for menu " .. menu.name .. ". Reloading UI ...")
	end
end

function widgetPrototypes.frame:update()
	if self.id then
		for _, cell in ipairs(self.functionCells) do
			if cell.id then
				local mouseovertext = cell.properties.mouseOverText
				if type(mouseovertext) == "function" then
					C.SetMouseOverText(cell.id, mouseovertext(cell))
				end
				if cell.type == "text" then
					local text = cell.properties.text
					if type(text) == "function" then
						SetText(cell.id, text(cell))
					end
					local color = cell.properties.color
					if type(color) == "function" then
						color = color(cell)
						SetTextColor(cell.id, color.r, color.g, color.b, color.a)
					end
				elseif cell.type == "boxtext" then
					local text = cell.properties.text
					if type(text) == "function" then
						C.SetBoxText(cell.id, text(cell))
					end
					local color = cell.properties.color
					if type(color) == "function" then
						color = color(cell)
						C.SetBoxTextColor(cell.id, Helper.ffiColor(color))
					end
					local boxcolor = cell.properties.boxColor
					if type(boxcolor) == "function" then
						boxcolor = boxcolor(cell)
						C.SetBoxTextBoxColor(cell.id, Helper.ffiColor(boxcolor))
					end
				elseif cell.type == "button" then
					local textproperty = cell.properties.text
					local text = textproperty.text
					if type(text) == "function" then
						text = text(cell)
						local scaling = textproperty.scaling
						local font = textproperty.font
						local fontsize = Helper.scaleFont(font, textproperty.fontsize, scaling)
						local width = cell:getWidth()
						local offsetx = Helper.scaleX(cell.properties.x, scaling)
						SetButtonText(cell.id, TruncateText(text, font, fontsize, width - 2 * offsetx))
					end
					local color = textproperty.color
					if type(color) == "function" then
						color = color(cell)
						C.SetButtonTextColor(cell.id, Helper.ffiColor(color))
					end
					local text2property = cell.properties.text2
					local text2 = text2property.text
					if type(text2) == "function" then
						text2 = text2(cell)
						local scaling = text2property.scaling
						local font = text2property.font
						local fontsize = Helper.scaleFont(font, text2property.fontsize, scaling)
						local width = cell:getWidth()
						local offsetx = Helper.scaleX(cell.properties.x, scaling)
						C.SetButtonText2(cell.id, TruncateText(text2, font, fontsize, width - 2 * offsetx))
					end
					local color2 = text2property.color
					if type(color2) == "function" then
						color2 = color2(cell)
						C.SetButtonTextColor(cell.id, Helper.ffiColor(color2))
					end
					local iconproperty = cell.properties.icon
					local iconid = iconproperty.icon
					if type(iconid) == "function" then
						iconid = iconid(cell)
						C.SetButtonIconID(cell.id, iconid)
					end
					local iconcolor = iconproperty.color
					if type(iconcolor) == "function" then
						iconcolor = iconcolor(cell)
						C.SetButtonIconColor(cell.id, Helper.ffiColor(iconcolor))
					end
					local icon2property = cell.properties.icon2
					local icon2id = icon2property.icon
					if type(icon2id) == "function" then
						icon2id = icon2id(cell)
						C.SetButtonIcon2ID(cell.id, icon2id)
					end
					local icon2color = icon2property.color
					if type(icon2color) == "function" then
						icon2color = icon2color(cell)
						C.SetButtonIcon2Color(cell.id, Helper.ffiColor(icon2color))
					end
					local active = cell.properties.active
					if type(active) == "function" then
						C.SetButtonActive(cell.id, active(cell) and true or false)
					end
					local bgColor = cell.properties.bgColor
					if type(bgColor) == "function" then
						bgColor = bgColor(cell)
						SetButtonColor(cell.id, bgColor.r, bgColor.g, bgColor.b, bgColor.a)
					end
					local highlightColor = cell.properties.highlightColor
					if type(highlightColor) == "function" then
						highlightColor = highlightColor(cell)
						C.SetButtonHighlightColor(cell.id, Helper.ffiColor(highlightColor))
					end
				elseif cell.type == "editbox" then
					local active = cell.properties.active
					if type(active) == "function" then
						C.SetEditBoxActive(cell.id, active(cell))
					end
					local textHidden = cell.properties.textHidden
					if type(textHidden) == "function" then
						C.SetEditBoxTextHidden(cell.id, textHidden(cell))
					end
				elseif cell.type == "shieldhullbar" then
					local shield = cell.properties.shield
					if type(shield) == "function" then
						C.SetShieldHullBarShieldPercent(cell.id, shield(cell))
					end
					local hull = cell.properties.hull
					if type(hull) == "function" then
						C.SetShieldHullBarHullPercent(cell.id, hull(cell))
					end
				elseif cell.type == "statusbar" then
					local current = cell.properties.current
					if type(current) == "function" then
						C.SetStatusBarCurrentValue(cell.id, current(cell))
					end
					local start = cell.properties.start
					if type(start) == "function" then
						C.SetStatusBarStartValue(cell.id, start(cell))
					end
					local max = cell.properties.max
					if type(max) == "function" then
						C.SetStatusBarMaxValue(cell.id, max(cell))
					end
				elseif cell.type == "icon" then
					local textproperty = cell.properties.text
					local text = textproperty.text
					if type(text) == "function" then
						C.SetIconText(cell.id, text(cell))
					end
					local text2property = cell.properties.text2
					local text2 = text2property.text
					if type(text2) == "function" then
						C.SetIconText2(cell.id, text2(cell))
					end
					local color = cell.properties.color
					if type(color) == "function" then
						color = color(cell)
						C.SetIconColor(cell.id, Helper.ffiColor(color))
					end
					local icon = cell.properties.icon
					if type(icon) == "function" then
						C.SetIcon(cell.id, icon(cell))
					end
				elseif cell.type == "dropdown" then
					local curOption = cell.properties.startOption
					if type(curOption) == "function" then
						C.SetDropDownCurOption(cell.id, curOption(cell))
					end
				elseif cell.type == "flowchartnode" then
					local color = cell.properties.outlineColor
					if type(color) == "function" then
						color = color(cell)
						C.SetFlowChartNodeOutlineColor(cell.id, Helper.ffiColor(color))
					end
					local text = cell.properties.text.text
					if type(text) == "function" then
						C.SetFlowChartNodeCaptionText(cell.id, tostring(text(cell)))
					end
					local color = cell.properties.text.color
					if type(color) == "function" then
						color = color(cell)
						C.SetFlowChartNodeCaptionTextColor(cell.id, Helper.ffiColor(color))
					end
					-- status
					local statuscolor = cell.properties.statusColor
					local text = cell.properties.statustext.text
					if type(text) == "function" then
						text = text(cell)
						if text ~= "" and not statuscolor then
							statuscolor = cell.properties.statustext.color
						end
						C.SetFlowChartNodeStatusText(cell.id, tostring(text))
					elseif text ~= "" and not statuscolor then
						statuscolor = cell.properties.statustext.color
					end
					local icon = cell.properties.statusicon.icon
					if type(icon) == "function" then
						C.SetFlowChartNodeStatusIcon(cell.id, icon(cell))
					end
					local bgicon = cell.properties.statusBgIconID
					if type(bgicon) == "function" then
						C.SetFlowChartNodeStatusBgIcon(cell.id, bgicon(cell))
					end
					if type(statuscolor) == "function" then
						statuscolor = statuscolor(cell)
						C.SetFlowChartNodeStatusColor(cell.id, Helper.ffiColor(statuscolor))
					end
					-- value
					local value = cell.properties.value
					if type(value) == "function" then
						C.SetFlowChartNodeCurValue(cell.id, value(cell))
					end
				elseif cell.type == "flowchartedge" then
					local color = cell.properties.color
					if type(color) == "function" then
						color = color(cell)
						C.SetFlowChartEdgeColor(cell.id, Helper.ffiColor(color))
					end
				elseif cell.type == "checkbox" then
					local checked = cell.properties.checked
					if type(checked) == "function" then
						C.SetCheckBoxChecked2(cell.id, checked(cell), true)
					end
					local bgcolor = cell.properties.bgColor
					if type(bgcolor) == "function" then
						C.SetCheckBoxColor(cell.id, Helper.ffiColor(bgcolor(cell)))
					end
				end
			end
		end
	end
end

---------- RenderTarget member functions ----------

function widgetHelpers.rendertarget:createDescriptor()
	local helpoverlay = createOverlayPropertyInfo(self)

	return CreateRenderTarget(
		self.properties.width,
		self.properties.height,
		self.properties.x,
		self.properties.y,
		self.properties.alpha,
		self.properties.mouseOverText,
		helpoverlay,
		self.properties.clear,
		self.properties.startnoise)
end

---------- Table member functions ----------

function widgetPrototypes.table:setDefaultCellProperties(widgettype, properties)
	if not defaultWidgetProperties[widgettype] then
		DebugError(string.format("ftable:setDefaultCellProperties(): Invalid widget type '%s'", widgettype))
		return self
	end
	self.defaultCellProperties = self.defaultCellProperties or { }
	local defaultproperties = self.defaultCellProperties[widgettype]
	if not defaultproperties then
		defaultproperties = { }
		setmetatable(defaultproperties, widgetPropertyMetatables[widgettype])
		self.defaultCellProperties[widgettype] = defaultproperties
	end
	defaultproperties:apply(properties)
	return self
end

function widgetPrototypes.table:setDefaultComplexCellProperties(widgettype, complexproperty, properties)
	if not complexCellProperties[widgettype] or not complexCellProperties[widgettype][complexproperty] then
		DebugError(string.format("ftable:setDefaultComplexCellProperties(): Invalid widget type '%s' or widget type has no complex property '%s'", widgettype, complexproperty))
		return self
	end
	self.defaultComplexCellProperties = self.defaultComplexCellProperties or { }
	self.defaultComplexCellProperties[widgettype] = self.defaultComplexCellProperties[widgettype] or { }
	local defaultproperties = self.defaultComplexCellProperties[widgettype][complexproperty]
	if not defaultproperties then
		defaultproperties = { }
		setmetatable(defaultproperties, widgetPropertyMetatables[complexCellProperties[widgettype][complexproperty]])
		self.defaultComplexCellProperties[widgettype][complexproperty] = defaultproperties
	end
	defaultproperties:apply(properties)
	return self
end

-- private column width helper
function setTableColumnWidthData(ftable, col, width, percent, min, weight, scaling)
	local coldata = ftable.columndata[col]
	if ftable.columndata.final then
		DebugError("ftable:setColWidth*(): Columns are already final and cannot be changed any more")
	elseif not coldata then
		DebugError(string.format("ftable:setColWidth*(): Column %s does not exist", col))
	else
		coldata.width = width
		coldata.percent = percent
		coldata.min = min
		coldata.weight = weight or 1
		coldata.scaling = scaling
	end
	return ftable
end

-- human-readable interface functions
function widgetPrototypes.table:setColWidth(col, width, scaling)						return setTableColumnWidthData(self, col, width, false, false, nil, scaling) end
function widgetPrototypes.table:setColWidthMin(col, width, weight, scaling)				return setTableColumnWidthData(self, col, width, false, true, weight, scaling) end
function widgetPrototypes.table:setColWidthPercent(col, width)							return setTableColumnWidthData(self, col, width, true, false) end
function widgetPrototypes.table:setColWidthMinPercent(col, width, weight)				return setTableColumnWidthData(self, col, width, true, true, weight) end

-- default colspan can be undone with cell:setColSpan(1)
function widgetPrototypes.table:setDefaultColSpan(col, colspan)
	self.columndata[col].colspan = colspan
	return self
end

-- default bgcolspan can be undone with cell:setBackgroundColSpan(1)
function widgetPrototypes.table:setDefaultBackgroundColSpan(col, bgcolspan)
	self.columndata[col].bgcolspan = bgcolspan
	return self
end

function finalizeTableColumnWidths(ftable)
	-- calculate exact column widths
	if not ftable.columndata.final then
		local scaling = ftable.properties.scaling
		local usablewidth = math.floor(ftable.properties.width)
		if usablewidth == 0 then
			usablewidth = math.floor(ftable.frame.properties.width) - math.ceil(ftable.properties.x)
		end
		-- determine total usable width of all columns, without borders
		local totalborderwidth = 0
		for i = 1, ftable.numcolumns - 1 do
			totalborderwidth = totalborderwidth + Helper.borderSize
		end
		usablewidth = math.max(0, usablewidth - totalborderwidth)
		-- convert provided "min" and "percent" values, apply scaling
		local usedwidth = 0
		local varcolumnweight = 0
		for i = 1, ftable.numcolumns do
			local coldata = ftable.columndata[i]
			if coldata.percent then
				coldata.width = coldata.width * usablewidth / 100
				coldata.percent = false
			elseif coldata.scaling or (scaling and coldata.scaling == nil) then		-- coldata.scaling takes precedence if non-nil
				coldata.width = Helper.scaleX(coldata.width)
			end
			coldata.width = math.floor(coldata.width)
			usedwidth = usedwidth + coldata.width
			if coldata.min and coldata.weight > 0 then
				varcolumnweight = varcolumnweight + coldata.weight
			else
				coldata.min = false
				coldata.weight = 0
			end
		end
		if ftable.properties.reserveScrollBar then
			if varcolumnweight == 0 then
				DebugError("table column finalization with reserveScrollBar: No column with variable width defined, cannot reserve additional space")
				ftable.properties.reserveScrollBar = false
			elseif usedwidth + Helper.scrollbarWidth > usablewidth then
				DebugError(string.format("table column finalization with reserveScrollBar: Cannot reserve enough space for scroll bar, width available=%d, required=%d", usablewidth, usedwidth + Helper.scrollbarWidth))
				ftable.properties.reserveScrollBar = false
			else
				usedwidth = usedwidth + Helper.scrollbarWidth
			end
		end
		if usedwidth < usablewidth and varcolumnweight > 0 then
			for i = 1, ftable.numcolumns do
				local coldata = ftable.columndata[i]
				if coldata.min and coldata.weight > 0 then
					local addedwidth = math.ceil((usablewidth - usedwidth) * coldata.weight / varcolumnweight)
					coldata.width = coldata.width + addedwidth
					usedwidth = usedwidth + addedwidth
					varcolumnweight = varcolumnweight - coldata.weight
					if varcolumnweight <= 0 then break end
				end
			end
		end
		-- make sure that there are no 0 columns if the table width is defined
		if ftable.properties.width ~= 0 then
			for i = 1, ftable.numcolumns do
				local coldata = ftable.columndata[i]
				if coldata.width == 0 then
					local addedwidth = 1
					coldata.width = addedwidth
					usedwidth = usedwidth + addedwidth
				end
			end
		end
		ftable.properties.width = usedwidth + totalborderwidth
		ftable.columndata.final = true
	end
end

function widgetPrototypes.table:getFullHeight()
	local fullheight = 0
	local numrows = #self.rows
	for rowindex, row in ipairs(self.rows) do
		fullheight = fullheight + row:getHeight()
		if rowindex < numrows and row.properties.borderBelow then
			fullheight = fullheight + Helper.borderSize
		end
	end
	return fullheight
end

function widgetPrototypes.table:getMaxVisibleHeight()
	local maxheight = self.properties.maxVisibleHeight
	local availableheight = self.frame:getAvailableHeight() - self.properties.y
	if maxheight > 0 and maxheight < availableheight then
		return maxheight
	end
	return availableheight
end

function widgetPrototypes.table:getVisibleHeight()
	local height = self:getFullHeight()
	local maxheight = self:getMaxVisibleHeight()
	if maxheight > 0 and height > maxheight then
		-- Not all rows will be visible, we'll get a scrollbar
		-- TODO: Check spacing below the last visible row and whether it can be removed safely
		return maxheight
	end
	return height
end

function widgetPrototypes.table:hasScrollBar()
	local height = self:getFullHeight()
	local maxheight = self:getMaxVisibleHeight()
	return maxheight > 0 and height > maxheight
end

-- Example usage:
--   local row = ftable:addRow("foo", { fixed = true, bgColor = Helper.defaultHeaderBackgroundColor })
-- (rowdata == nil or false: Not selectable. For selectable row without specific rowdata, use e.g. true)
function widgetPrototypes.table:addRow(rowdata, properties)
	finalizeTableColumnWidths(self)
	local row = {
		table = self,
		index = nil,						-- row index in table (set below)
		rowdata = rowdata,					-- data associated with row, passed to callbacks
		properties = { }					-- row properties
	}
	table.insert(self.rows, row)
	row.index = #self.rows

	-- set metatables to enable member functions and default properties
	setmetatable(row, widgetMetatables.row)
	setmetatable(row.properties, widgetPropertyMetatables.row)

	-- propagate scaling from table to row
	if not self.properties.scaling then
		row.properties.scaling = false
	end
	-- apply properties if provided
	row.properties:apply(properties)

	-- create "pluripotent" cell representation for each column (each cell can be specialized for specific widget type)
	for i = 1, self.numcolumns do
		local cell = {
			row = row,
			index = i,						-- column index in row
			descriptor = nil,				-- descriptor (used temporarily)
			id = nil,						-- widget ID, valid while displayed
			type = "cell",					-- widget type (set on initialization)
			colspan = 1,					-- column span
			bgcolspan = 1,					-- background column span
			properties = { },				-- cell properties
			handlers = { }					-- event handlers
		}
		row[i] = cell

		-- set metatables to enable member functions and default properties
		setmetatable(cell, widgetMetatables.cell)
		setmetatable(cell.properties, widgetPropertyMetatables.cell)

		-- propagate scaling from row to cell
		if not row.properties.scaling then
			cell.properties.scaling = false
		end

		-- propagate bgColor from row to cell
		cell.properties.cellBGColor = row.properties.bgColor
	end
	-- apply default colspans in reverse order to deal safely with bad input
	for i = self.numcolumns, 1, -1 do
		local cell = row[i]
		local colspan = self.columndata[i].colspan
		if colspan > 1 then
			cell:setColSpan(colspan)
		end
		local bgcolspan = self.columndata[i].bgcolspan
		if bgcolspan > 1 then
			cell:setBackgroundColSpan(bgcolspan)
		end
	end

	return row
end

function widgetPrototypes.table:addEmptyRow(height)
	local row = self:addRow(nil, { bgColor = Helper.color.transparent })
	row[1]:createText(" ", { fontsize = 1, minRowHeight = height })
	return row
end

function widgetPrototypes.table:setTopRow(row)
	self.toprow = row
	return self
end
function widgetPrototypes.table:setSelectedRow(row)
	self.selectedrow = row
	return self
end
function widgetPrototypes.table:setSelectedCol(col)
	self.selectedcol = col
	return self
end
function widgetPrototypes.table:setShiftStartEnd(startrow, endrow)
	self.shiftstart = startrow
	self.shiftend   = endrow
	return self
end

function widgetPrototypes.table:addConnection(row, col, clearCol)
	local menu = self.frame.menu
	menu.tableConnections = menu.tableConnections or {}
	if menu.tableConnections[col] then
		if clearCol then
			menu.tableConnections[col] = {}
		end
		menu.tableConnections[col][row] = self
	else
		menu.tableConnections[col] = { [row] = self }
	end
	menu.tableConnections.refresh = true
end

function Helper.clearTableConnectionColumn(menu, col)
	menu.tableConnections = menu.tableConnections or {}
	menu.tableConnections[col] = nil
end

function widgetHelpers.table:createDescriptor()
	local header = self.properties.header
	local taborder = self.properties.tabOrder
	local skiptabchange = self.properties.skipTabChange
	local defaultinteractiveobject = self.properties.defaultInteractiveObject
	local borderenabled = self.properties.borderEnabled
	local numfixedrows = 0
	local offsetx = self.properties.x
	local offsety = self.properties.y
	local maxheight = self:getMaxVisibleHeight()
	local selectedcol = math.min(self.selectedcol, self.numcolumns)
	local wraparound = self.properties.wraparound
	local highlightmode = self.properties.highlightMode
	local multiselect = self.properties.multiSelect
	local backgroundid = self.properties.backgroundID
	local backgroundcolor = self.properties.backgroundColor
	local helpoverlay = createOverlayPropertyInfo(self)

	-- init toprow / selectedrow
	local menu = self.frame.menu
	local toprow = self.toprow
	local selectedrow = self.selectedrow
	if taborder == 1 and menu.param then
		toprow = toprow or menu.param[1]
		selectedrow = selectedrow or menu.param[2]
	end
	toprow = math.min(toprow or 0, #self.rows)
	selectedrow = math.min(selectedrow or 0, #self.rows)

	local columnwidths = self.numcolumns > 0 and { } or { 0 }
	local columnwidthpercent = false
	for colidx, coldata in ipairs(self.columndata) do
		columnwidths[colidx] = coldata.width
	end
	if self.numcolumns > 0 then
		self.createdWithScrollBar = self:hasScrollBar()
		if self.createdWithScrollBar then
			if not self.properties.reserveScrollBar then
				-- Reduce width of rightmost column to make room for the scrollbar
				if columnwidths[self.numcolumns] >= Helper.scrollbarWidth then
					columnwidths[self.numcolumns] = columnwidths[self.numcolumns] - Helper.scrollbarWidth
				else
					DebugError(string.format("ftable:createDescriptor(): Table requires scrollbar but rightmost column [%d] is not wide enough. width=%d, required=%d", self.numcolumns, columnwidths[self.numcolumns], Helper.scrollbarWidth))
					columnwidths[self.numcolumns] = 0
				end
			end
		else
			if self.properties.reserveScrollBar then
				-- Scrollbar was reserved but not needed, make columns wider
				local varcolumnweight = 0
				for i, coldata in ipairs(self.columndata) do
					if coldata.min then
						varcolumnweight = varcolumnweight + coldata.weight
					end
				end
				if varcolumnweight > 0 then
					local totaladdedwidth = 0
					for i, coldata in ipairs(self.columndata) do
						if coldata.min then
							local addedwidth = math.ceil((Helper.scrollbarWidth - totaladdedwidth) * coldata.weight / varcolumnweight)
							coldata.width = coldata.width + addedwidth
							totaladdedwidth = totaladdedwidth + addedwidth
							columnwidths[i] = coldata.width
							varcolumnweight = varcolumnweight - coldata.weight
							if varcolumnweight <= 0 then break end
						end
					end
				end
			end
		end
	end

	local tablecontent = { }
	local bestselectablerow = 0
	local multiselectedrows = {}	-- determine selected rows in multi-select case
	local rowDataMap = {}
	for rowidx, row in ipairs(self.rows) do
		if row.properties.fixed then
			numfixedrows = rowidx
		end
		local contentcells = { }
		for cellidx, cell in ipairs(row) do
			local desc = nil
			if cell.colspan ~= 0 then
				desc = widgetHelpers[cell.type].createDescriptor(cell)
			end
			if cell.descriptor then
				ReleaseDescriptor(cell.descriptor)
			end
			cell.descriptor = desc
			contentcells[cellidx] = { colspan = cell.colspan, bgcolspan = cell.bgcolspan, cellbgcolor = cell.properties.cellBGColor, content = desc }
		end
		tablecontent[rowidx] = {
			color = row.properties.bgColor,
			selectable = not not row.rowdata,
			borderbelow = row.properties.borderBelow,
			interactive = row.properties.interactive,
			cols = contentcells
		}
		if row.rowdata then
			if rowidx <= selectedrow then
				bestselectablerow = rowidx
			end
			rowDataMap[rowidx] = row.rowdata
		end
		-- check if multi-selected
		if row.properties.multiSelected then
			table.insert(multiselectedrows, rowidx)
		end
	end
	self.numfixedrows = numfixedrows
	selectedrow = bestselectablerow
	if selectedrow > 0 and toprow > selectedrow then
		-- TODO Klaus: check - this kept scroling the table up if you didn't change the selection, what was it's purpose?
		--toprow = selectedrow
	end 
	if toprow <= numfixedrows then
		toprow = 0
	end
	if selectedcol > 0 then
		if selectedrow > 0 then
			local cell = self.rows[selectedrow][selectedcol]
			if (cell.type ~= "button") and (cell.type ~= "checkbox") and (cell.type ~= "dropdown") and (cell.type ~= "editbox") and (cell.type ~= "slidercell") then
				DebugError("table:createDescriptor(): Initial selected cell '" .. selectedrow .. " / " .. selectedcol .. "' specified, but is not interactive. Skipping selection. (widget type = '" .. cell.type .. "')")
				selectedcol = 0
			end
		end 
	end

	local initialSelection = {
		toprow				= toprow,
		selectedrow			= selectedrow,
		selectedcol			= selectedcol,
		multiselectedrows	= multiselectedrows,
		shiftstart			= self.shiftstart,
		shiftend			= self.shiftend
	}
	local desc = CreateTable(header, tablecontent, columnwidths, columnwidthpercent, borderenabled, taborder, skiptabchange, defaultinteractiveobject, numfixedrows, offsetx, offsety, maxheight, initialSelection, wraparound, highlightmode, multiselect, backgroundid, backgroundcolor, helpoverlay)
	if desc == nil then
		DebugError(TraceBack())
		return
	end
	
	if taborder == 1 then
		-- TODO
		self.frame.menu.defaulttable = desc
	end
	Helper.addTableDescRowDataMap(menu, desc, rowDataMap)
	return desc
end

---------- Row member functions ----------

function widgetPrototypes.row:getHeight()
	local height = 0
	for _, cell in ipairs(self) do
		if cell.colspan ~= 0 then
			local celloffsety = Helper.scaleY(cell.properties.y, cell.properties.scaling)		-- 0 for uninitialised cells
			if (cell.type == "icon") and (cell.properties.affectRowHeight == false) then
				celloffsety = 0
			end
			local cellheight = cell:getHeight()
			height = math.max(height, celloffsety + cellheight)
		end
	end
	return height
end

---------- Generic cell member functions ----------

-- NOTE: All set*() functions of cells return self to allow chaining

function widgetPrototypes.cell:setColSpan(colspan)
	if colspan < 1 then
		DebugError(string.format("cell:setColSpan(%d) Invalid colspan", colspan))
	elseif self.colspan == 0 then
		DebugError(string.format("cell:setColSpan(%d) Invalid, existing colspan on cell [%d][%d]", colspan, self.row.index, self.index))
	else
		local prevcolspan = self.colspan			-- In case setColSpan() was called before on this or a following cell, track how many cols are affected
		self.colspan = math.min(math.floor(colspan), self.row.table.numcolumns - self.index + 1)
		if self.colspan < colspan then
			DebugError(string.format("cell:setColSpan(%d) colspan too high", colspan))
		end
		for i = 1, self.colspan - 1 do
			local cell = self.row[self.index + i]
			if cell.type ~= "cell" then
				DebugError(string.format("cell:setColSpan(%d) on [%d][%d] hides already created cell [%d][%d]", colspan, self.row.index, self.index, cell.row.index, cell.index))
			end
			prevcolspan = prevcolspan + cell.colspan
			cell.colspan = 0
		end
		-- In case the following columns were included in a previous colspan that we overwrote, repair them
		-- (particularly, calling setColSpan(1) on an existing colspan cell should undo the colspan)
		for i = self.colspan, prevcolspan - 1 do
			self.row[self.index + i].colspan = 1
		end
	end
	return self
end

function widgetPrototypes.cell:setBackgroundColSpan(bgcolspan)
	if bgcolspan < 1 then
		DebugError(string.format("cell:setBackgroundColSpan(%d) Invalid background colspan", bgcolspan))
	elseif self.bgcolspan == 0 then
		DebugError(string.format("cell:setBackgroundColSpan(%d) Invalid, existing background colspan on cell [%d][%d]", bgcolspan, self.row.index, self.index))
	else
		local prevbgcolspan = self.bgcolspan		-- In case setBackgroundColSpan() was called before on this or a following cell, track how many cols are affected
		self.bgcolspan = math.min(math.floor(bgcolspan), self.row.table.numcolumns - self.index + 1)
		if self.bgcolspan < bgcolspan then
			DebugError(string.format("cell:setBackgroundColSpan(%d) background colspan too high", bgcolspan))
		end
		for i = 1, self.bgcolspan - 1 do
			local cell = self.row[self.index + i]
			prevbgcolspan = prevbgcolspan + cell.bgcolspan
			cell.bgcolspan = 0
		end
		-- In case the following columns were included in a previous bgcolspan that we overwrote, repair them
		-- (particularly, calling setBackgroundColSpan(1) on an existing bgcolspan cell should undo the bgcolspan)
		for i = self.bgcolspan, prevbgcolspan - 1 do
			self.row[self.index + i].bgcolspan = 1
		end
	end
	return self
end

function widgetPrototypes.cell:getColSpanWidth()
	if self.colspan < 1 then
		return 0
	end
	local columndata = self.row.table.columndata
	local colspanwidth = columndata[self.index].width
	for i = 1, self.colspan - 1 do
		local cell = self.row[self.index + i]
		colspanwidth = colspanwidth + columndata[cell.index].width + Helper.borderSize
	end
	-- add reserved scrollbar width if fixed row and last column included (NOTE: Only do this when we know that there will be a scrollbar)
	if self.row.table.createdWithScrollBar then
		if self.row.properties.fixed then
			if self.row.table.properties.reserveScrollBar then
				if self.index + self.colspan - 1 == self.row.table.numcolumns then
					colspanwidth = colspanwidth + Helper.scrollbarWidth
				end
			end
		end
	end
	return colspanwidth
end

function widgetPrototypes.cell:getWidth()
	if self.properties.width ~= 0 then
		return Helper.scaleX(self.properties.width, self.properties.scaling)
	end
	return self:getColSpanWidth() - Helper.scaleX(self.properties.x, self.properties.scaling)
end

function widgetPrototypes.cell:getHeight()
	local scaling = self.properties.scaling
	local height = Helper.scaleY(self.properties.height, scaling)	-- 0 for uninitialised cells
	if height == 0 then
		if (self.type == "text") or (self.type == "boxtext") then
			return self:getMinTextHeight(scaling)
		elseif self.type == "cell" then
			return 1
		end
	end
	return height
end

function widgetHelpers.cell:createDescriptor()
	-- create empty cell descriptor
	local color = Helper.standardColor
	local font = Helper.standardFont
	local fontsize = Helper.scaleFont(font, Helper.standardFontSize, self.properties.scaling)
	-- force cell size to minimum 1x1
	return CreateFontString("", Helper.standardHalignment, color.r, color.g, color.b, color.a, font, fontsize, false, 0, 0, 1, 1)
end

function initTableCell(cell, widgettype, properties)
	if cell.colspan == 0 then
		DebugError(string.format("initTableCell: Cannot create cell [%d][%d] due to colspan", cell.row.index, cell.index))
		return false
	end
	if cell.type ~= "cell" then
		-- TODO: Support this, including use of SetCellContent() with existing table cell
		DebugError(string.format("initTableCell: Trying to overwrite existing cell [%d][%d], not supported yet", cell.row.index, cell.index))
		return false
	end
	cell.type = widgettype

	-- update metatables for type-specific member functions and default properties
	setmetatable(cell, widgetMetatables[widgettype])
	setmetatable(cell.properties, widgetPropertyMetatables[widgettype])

	-- create complex cell properties
	local complexprops = complexCellProperties[widgettype]
	if complexprops then
		for complexprop, simpleprop in pairs(complexprops) do
			local complexproptable = { }
			setmetatable(complexproptable, widgetPropertyMetatables[simpleprop])
			rawset(cell.properties, complexprop, complexproptable)
		end
	end
	-- apply default cell properties
	local ftable = cell.row.table
	if ftable.defaultCellProperties and ftable.defaultCellProperties[widgettype] then
		cell.properties:apply(ftable.defaultCellProperties[widgettype])
	end
	if ftable.defaultComplexCellProperties and ftable.defaultComplexCellProperties[widgettype] then
		for complexprop, simpleprops in pairs(ftable.defaultComplexCellProperties[widgettype]) do
			cell.properties[complexprop]:apply(simpleprops)
		end
	end
	-- apply custom properties
	cell.properties:apply(properties)
	return true
end

---------- Specialized cell member functions and specialization functions ----------

-- text
function widgetPrototypes.cell:createText(text, properties)
	if initTableCell(self, "text", properties) then
		self.properties.text = text
	end
	return self
end

function widgetPrototypes.text:getTextHeight(scaling)
	local text = self.properties.text
	if type(text) == "function" then
		text = text(self)
	end
	local font = self.properties.font
	if scaling == nil then
		scaling = self.properties.scaling
	end
	local fontsize = Helper.scaleFont(font, self.properties.fontsize, scaling)
	return math.ceil(C.GetTextHeight(tostring(text), font, math.floor(fontsize), self.properties.wordwrap and math.floor(self:getWidth()) or 0))
end

function widgetPrototypes.text:getMinTextHeight(scaling)
	local mintextheight = Helper.scaleY(self.properties.minRowHeight, scaling) - Helper.scaleY(self.properties.y, scaling)
	return math.max(self:getTextHeight(scaling), mintextheight)
end

function widgetHelpers.text:createDescriptor()
	local text = self.properties.text
	local isfunctioncell = false
	if type(text) == "function" then
		text = text(self)
		isfunctioncell = true
	end
	local color = self.properties.color
	if type(color) == "function" then
		color = color(self)
		isfunctioncell = true
	end
	local mouseovertext = self.properties.mouseOverText
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end
	local titlecolor = self.properties.titleColor
	if titlecolor == propertyDefaultValue then
		titlecolor = nil
	end
	local scaling = self.properties.scaling
	local halign = self.properties.halign
	local font = self.properties.font
	local fontsize = Helper.scaleFont(font, self.properties.fontsize, scaling)
	local wordwrap = self.properties.wordwrap
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()
	local helpoverlay = createOverlayPropertyInfo(self)

	return CreateFontString(text, halign, color.r, color.g, color.b, color.a, font, fontsize, wordwrap, offsetx, offsety, height, width, mouseovertext, titlecolor, helpoverlay)
end

-- boxtext
function widgetPrototypes.cell:createBoxText(text, properties)
	if initTableCell(self, "boxtext", properties) then
		self.properties.text = text
	end
	return self
end

function widgetPrototypes.boxtext:getTextHeight(scaling)
	local text = self.properties.text
	if type(text) == "function" then
		text = text(self)
	end
	local font = self.properties.font
	if scaling == nil then
		scaling = self.properties.scaling
	end
	local fontsize = Helper.scaleFont(font, self.properties.fontsize, scaling)
	return math.ceil(C.GetTextHeight(tostring(text), font, math.floor(fontsize), self.properties.wordwrap and math.floor(self:getWidth()) or 0)) + 2 * Helper.borderSize
end

function widgetPrototypes.boxtext:getMinTextHeight(scaling)
	local mintextheight = Helper.scaleY(self.properties.minRowHeight, scaling) - Helper.scaleY(self.properties.textY, scaling)
	return math.max(self:getTextHeight(scaling), mintextheight)
end

function widgetHelpers.boxtext:createDescriptor()
	local text = self.properties.text
	local isfunctioncell = false
	if type(text) == "function" then
		text = text(self)
		isfunctioncell = true
	end
	local color = self.properties.color
	if type(color) == "function" then
		color = color(self)
		isfunctioncell = true
	end
	local boxcolor = self.properties.boxColor
	if type(boxcolor) == "function" then
		boxcolor = boxcolor(self)
		isfunctioncell = true
	end
	local mouseovertext = self.properties.mouseOverText
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end
	local scaling = self.properties.scaling
	local halign = self.properties.halign
	local font = self.properties.font
	local fontsize = Helper.scaleFont(font, self.properties.fontsize, scaling)
	local wordwrap = self.properties.wordwrap
	local textoffsetx = Helper.scaleX(self.properties.textX, scaling)
	local textoffsety = Helper.scaleY(self.properties.textY, scaling)
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()

	local boxTextDescriptor = {}
	boxTextDescriptor.text = {
		text = text,
		alignment = halign,
		fontname = font,
		fontsize = fontsize,
		color = color,
		x = textoffsetx,
		y = textoffsety
	}
	boxTextDescriptor.wordwrap = wordwrap
	boxTextDescriptor.boxcolor = boxcolor
	boxTextDescriptor.mouseovertext = mouseovertext
	boxTextDescriptor.offset = { x = offsetx, y = offsety }
	boxTextDescriptor.size = { width = width, height = height }

	return CreateBoxText(boxTextDescriptor)
end

-- icon
function widgetPrototypes.cell:createIcon(icon, properties)
	if (icon == nil) or (icon == "") then
		DebugError("widget createIcon(): Texture name is empty! Using solid icon.")
		DebugError(TraceBack())
		icon = "solid"
	end
	-- Complex properties: text, text2
	if initTableCell(self, "icon", properties) then
		self.properties.icon = icon
	end
	return self
end

function widgetPrototypes.icon:setText(text, properties)
	self.properties.text.text = text
	self.properties.text.scaling = self.properties.scaling
	self.properties.text:apply(properties)
	return self
end

function widgetPrototypes.icon:setText2(text, properties)
	self.properties.text2.text = text
	self.properties.text2.scaling = self.properties.scaling
	self.properties.text2:apply(properties)
	return self
end

function widgetPrototypes.icon:getHeight(raw)
	-- super call
	local height = widgetPrototypes.cell.getHeight(self)
	if raw or self.properties.affectRowHeight then
		return height
	end
	return 1
end

function widgetHelpers.icon:createDescriptor()
	local scaling = self.properties.scaling
	local icon = self.properties.icon
	local color = self.properties.color
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight(true)
	local mouseovertext = self.properties.mouseOverText
	local affectrowheight = self.properties.affectRowHeight

	local isfunctioncell = false
	if type(self.properties.text.text) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.text2.text) == "function" then
		isfunctioncell = true
	end
	if (icon == nil) or (icon == "") then
		DebugError("widget icon:createDescriptor(): Texture name is empty! Falling back to solid icon.")
		icon = "solid"
	elseif type(icon) == "function" then
		icon = icon(self)
		isfunctioncell = true
	end
	if type(color) == "function" then
		color = color(self)
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local text = createTextPropertyInfo(self, self.properties.text)
	local text2 = createTextPropertyInfo(self, self.properties.text2)

	return CreateIcon(icon, color.r, color.g, color.b, color.a, offsetx, offsety, height, width, mouseovertext, text, text2, nil, affectrowheight)
end

-- button
-- LEGACY NOTE: new default height = Helper.standardButtonHeight
-- LEGACY NOTE: new default width = cell width
function widgetPrototypes.cell:createButton(properties)
	-- Complex properties: text, icon, icon2, hotkey
	initTableCell(self, "button", properties)
	return self
end

function widgetPrototypes.button:setText(text, properties)
	self.properties.text.text = text
	self.properties.text.scaling = self.properties.scaling
	self.properties.text:apply(properties)
	return self
end

function widgetPrototypes.button:setText2(text, properties)
	self.properties.text2.text = text
	self.properties.text2.scaling = self.properties.scaling
	self.properties.text2:apply(properties)
	return self
end

function widgetPrototypes.button:setIcon(icon, properties)
	self.properties.icon.icon = icon
	self.properties.icon.scaling = self.properties.scaling
	self.properties.icon:apply(properties)
	return self
end

function widgetPrototypes.button:setIcon2(icon, properties)
	self.properties.icon2.icon = icon
	self.properties.icon2.scaling = self.properties.scaling
	self.properties.icon2:apply(properties)
	return self
end

function widgetPrototypes.button:setHotkey(hotkey, properties)
	self.properties.hotkey.hotkey = hotkey
	self.properties.hotkey:apply(properties)
	return self
end

function widgetPrototypes.button:getHeight()
	-- super call
	local height = widgetPrototypes.cell.getHeight(self)
	-- enforce min height if the button contains a hotkey icon
	local hotkeyproperty = self.properties.hotkey
	if hotkeyproperty.hotkey ~= "" and hotkeyproperty.displayIcon and height < Helper.buttonMinHeight then
		return Helper.buttonMinHeight
	end
	return height
end

function widgetHelpers.button:createDescriptor()
	local active = self.properties.active
	local bgColor = self.properties.bgColor
	local highlightColor = self.properties.highlightColor
	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()
	local mouseovertext = self.properties.mouseOverText
	local helpoverlay = createOverlayPropertyInfo(self)

	local isfunctioncell = false
	if type(self.properties.text.text) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.text2.text) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.text.color) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.text2.color) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.icon.icon) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.icon.color) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.icon2.icon) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.icon2.color) == "function" then
		isfunctioncell = true
	end
	if type(active) == "function" then
		active = active(self)
		isfunctioncell = true
	end
	if type(bgColor) == "function" then
		bgColor = bgColor(self)
		isfunctioncell = true
	end
	if type(highlightColor) == "function" then
		highlightColor = highlightColor(self)
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local buttonDescriptor = {}
	buttonDescriptor.text = createTextPropertyInfo(self, self.properties.text)
	buttonDescriptor.text2 = createTextPropertyInfo(self, self.properties.text2)
	buttonDescriptor.icon = createIconPropertyInfo(self, self.properties.icon)
	buttonDescriptor.icon2 = createIconPropertyInfo(self, self.properties.icon2)
	buttonDescriptor.hotkey = createHotkeyPropertyInfo(self, self.properties.hotkey, width, height, scaling)
	buttonDescriptor.mouseovertext = mouseovertext
	buttonDescriptor.color = bgColor
	buttonDescriptor.highlightcolor = highlightColor
	buttonDescriptor.helpoverlay = helpoverlay

	if buttonDescriptor.text.text ~= "" then
		buttonDescriptor.text.text = TruncateText(buttonDescriptor.text.text, buttonDescriptor.text.fontname, buttonDescriptor.text.fontsize, width - 2 * buttonDescriptor.text.x)
	end
	if buttonDescriptor.text2.text ~= "" then
		buttonDescriptor.text2.text = TruncateText(buttonDescriptor.text2.text, buttonDescriptor.text2.fontname, buttonDescriptor.text2.fontsize, width - 2 * buttonDescriptor.text2.x)
	end

	buttonDescriptor.active = active
	buttonDescriptor.offset = { x = offsetx, y = offsety }
	buttonDescriptor.size = { width = width, height = height }
	return CreateButton(buttonDescriptor)
end

-- shieldhullbar
function widgetPrototypes.cell:createShieldHullBar(shield, hull, properties)
	if initTableCell(self, "shieldhullbar", properties) then
		self.properties.shield = shield
		self.properties.hull = hull
	end
	return self
end

function widgetPrototypes.cell:createObjectShieldHullBar(object, properties)
	local object64 = ConvertStringTo64Bit(tostring(object))
	local shield = function() return IsComponentOperational(object64) and GetComponentData(object64, "shieldpercent") or 0 end
	local hull = function() return IsComponentOperational(object64) and GetComponentData(object64, "hullpercent") or 0 end
	local mouseovertext = function (cell, basetext)
			if type(basetext) == "function" then
				basetext = basetext(cell)
			end
			local shieldvalue = shield()
			return (basetext and (basetext .. "\n") or "") .. ((shieldvalue > 0) and (ReadText(1001, 2) .. ReadText(1001, 120) .. " " .. shieldvalue .. "%\n") or "") .. ReadText(1001, 1) .. ReadText(1001, 120) .. " " .. hull() .. "%"
		end
	if properties then
		if properties.mouseOverText then
			properties.mouseOverText = function (cell) return mouseovertext(cell, properties.mouseOverText) end
		else
			properties.mouseOverText = mouseovertext
		end
	else
		properties = { mouseOverText = mouseovertext }
	end
	return self:createShieldHullBar(shield, hull, properties)
end

function widgetHelpers.shieldhullbar:createDescriptor()
	local shield = self.properties.shield
	local hull = self.properties.hull
	local mouseovertext = self.properties.mouseOverText

	local isfunctioncell = false
	if type(shield) == "function" then
		shield = shield()
		isfunctioncell = true
	end
	if type(hull) == "function" then
		hull = hull()
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = rawget(self.properties, "y")
	if not offsety then
		offsety = self.row:getHeight() / 2
	else
		offsety = Helper.scaleY(self.properties.y, scaling)
	end

	local width = self:getWidth()
	local height = self:getHeight()

	local shieldHullBarDescriptor = {}
	shieldHullBarDescriptor.shield = shield
	shieldHullBarDescriptor.hull = hull
	shieldHullBarDescriptor.mouseovertext = mouseovertext
	shieldHullBarDescriptor.offset = { x = offsetx, y = offsety }
	shieldHullBarDescriptor.size = { width = width , height = height }
	return CreateShieldHullBar(shieldHullBarDescriptor)
end

-- editbox
function widgetPrototypes.cell:createEditBox(properties)
	-- Complex properties: text, hotkey
	initTableCell(self, "editbox", properties)
	return self
end

function widgetPrototypes.editbox:setText(text, properties)
	self.properties.text.text = text
	self.properties.text.scaling = self.properties.scaling
	self.properties.text:apply(properties)
	return self
end

function widgetPrototypes.editbox:setHotkey(hotkey, properties)
	self.properties.hotkey.hotkey = hotkey
	self.properties.hotkey:apply(properties)
	return self
end

function widgetPrototypes.editbox:getHeight()
	-- super call
	local height = widgetPrototypes.cell.getHeight(self)
	-- enforce min height if the editbox contains a hotkey icon
	local hotkeyproperty = self.properties.hotkey
	if hotkeyproperty.hotkey ~= "" and hotkeyproperty.displayIcon and height < Helper.editboxMinHeight then
		return Helper.editboxMinHeight
	end
	return height
end

function widgetHelpers.editbox:createDescriptor()
	local bgColor = self.properties.bgColor
	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()
	local mouseovertext = self.properties.mouseOverText
	local closeMenuOnBack = self.properties.closeMenuOnBack
	local defaultText = self.properties.defaultText
	local description = self.properties.description
	local textHidden = self.properties.textHidden
	local encrypted = self.properties.encrypted
	local helpoverlay = createOverlayPropertyInfo(self)
	local selectTextOnActivation = self.properties.selectTextOnActivation
	local active = self.properties.active
	local restoreInteractiveObject = self.properties.restoreInteractiveObject
	local maxchars = self.properties.maxChars

	local isfunctioncell = false
	if type(active) == "function" then
		active = active()
		isfunctioncell = true
	end
	if type(textHidden) == "function" then
		textHidden = textHidden()
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end
	
	local editboxDescriptor = {}
	editboxDescriptor.text = createTextPropertyInfo(self, self.properties.text)
	editboxDescriptor.defaulttext = defaultText
	editboxDescriptor.description = description
	editboxDescriptor.hotkey = createHotkeyPropertyInfo(self, self.properties.hotkey, width, height, scaling)
	editboxDescriptor.mouseovertext = mouseovertext
	editboxDescriptor.color = bgColor
	
	editboxDescriptor.closemenu = closeMenuOnBack
	editboxDescriptor.texthidden = textHidden
	editboxDescriptor.encrypted = encrypted
	editboxDescriptor.selectonactivation = selectTextOnActivation
	editboxDescriptor.active = active
	editboxDescriptor.restoreInteractiveObject = restoreInteractiveObject
	editboxDescriptor.offset = { x = offsetx, y = offsety }
	editboxDescriptor.size = { width = width, height = height }
	editboxDescriptor.helpoverlay = helpoverlay
	editboxDescriptor.maxchars = maxchars
	return CreateEditBox(editboxDescriptor)
end

-- slidercell
function widgetPrototypes.cell:createSliderCell(properties)
	initTableCell(self, "slidercell", properties)
	return self
end

function widgetPrototypes.slidercell:setText(text, properties)
	self.properties.text.text = text
	self.properties.text.scaling = self.properties.scaling
	self.properties.text:apply(properties)
	return self
end

function widgetPrototypes.slidercell:updateMaxSelectValue(value)
	if self.id then
		self.properties.max = value
		C.SetSliderCellMaxSelectValue(self.id, value)
	end
end

function widgetPrototypes.slidercell:updateMaxValue(value)
	if self.id then
		self.properties.max = value
		C.SetSliderCellMaxValue(self.id, value)
	end
end

function widgetPrototypes.slidercell:getHeight()
	-- super call
	local height = widgetPrototypes.cell.getHeight(self)
	if height < Helper.slidercellMinHeight then
		return Helper.slidercellMinHeight
	end
	return height
end

function widgetHelpers.slidercell:createDescriptor()
	local scaling = self.properties.scaling
	local bgColor = self.properties.bgColor
	local inactiveBGColor = self.properties.inactiveBGColor
	local valueColor = self.properties.valueColor
	local posValueColor = self.properties.posValueColor
	local negValueColor = self.properties.negValueColor
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()
	local helpoverlay = createOverlayPropertyInfo(self)

	local isfunctioncell = false
	local mouseovertext = self.properties.mouseOverText
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local slidercellDescriptor = {}
	slidercellDescriptor.text = createTextPropertyInfo(self, self.properties.text)
	slidercellDescriptor.scale = {
		min = self.properties.min,
		minselect = self.properties.minSelect,
		max = self.properties.max,
		maxselect = self.properties.maxSelect,
		start = self.properties.start,
		step = self.properties.step,
		accuracyoverride = self.properties.accuracyOverride,
		suffix = self.properties.suffix,
		exceedmax = self.properties.exceedMaxValue,
		hidemaxvalue = self.properties.hideMaxValue,
		righttoleft = self.properties.rightToLeft,
		fromcenter = self.properties.fromCenter,
		readonly = self.properties.readOnly,
		useinfinitevalue = self.properties.useInfiniteValue,
		infinitevalue = self.properties.infiniteValue,
		usetimeformat = self.properties.useTimeFormat,
	}
	if slidercellDescriptor.scale.minselect == propertyDefaultValue then
		slidercellDescriptor.scale.minselect = slidercellDescriptor.scale.min
	end
	if slidercellDescriptor.scale.maxselect == propertyDefaultValue then
		slidercellDescriptor.scale.maxselect = slidercellDescriptor.scale.max
	end
	if slidercellDescriptor.scale.accuracyoverride == propertyDefaultValue then
		slidercellDescriptor.scale.accuracyoverride = nil
	end

	slidercellDescriptor.mouseovertext = mouseovertext
	slidercellDescriptor.bgcolor = bgColor
	slidercellDescriptor.inactivebgcolor = inactiveBGColor
	if slidercellDescriptor.scale.fromcenter then
		slidercellDescriptor.valuecolor = posValueColor
		slidercellDescriptor.negativevaluecolor = negValueColor
	else
		slidercellDescriptor.valuecolor = valueColor
	end

	slidercellDescriptor.offset = {x = offsetx, y = offsety}
	slidercellDescriptor.size = {width = width , height = height}
	slidercellDescriptor.helpoverlay = helpoverlay
	return CreateSliderCell(slidercellDescriptor)
end

-- dropdown
function widgetPrototypes.cell:createDropDown(options, properties)
	if initTableCell(self, "dropdown", properties) then
		self.properties.options = options
	end
	return self
end

function widgetPrototypes.dropdown:setTextProperties(properties)
	self.properties.text.scaling = self.properties.scaling
	self.properties.text:apply(properties)
	return self
end

function widgetPrototypes.dropdown:setText2Properties(properties)
	self.properties.text2.scaling = self.properties.scaling
	self.properties.text2:apply(properties)
	return self
end

function widgetPrototypes.dropdown:setIconProperties(properties)
	self.properties.icon.scaling = self.properties.scaling
	-- dropdown icons are defined per option, set a dummy icon for the global properties
	self.properties.icon.icon = "solid"
	self.properties.icon:apply(properties)
	return self
end

function widgetPrototypes.dropdown:setHotkey(hotkey, properties)
	self.properties.hotkey.hotkey = hotkey
	self.properties.hotkey:apply(properties)
	return self
end

function widgetHelpers.dropdown:createDescriptor()
	local scaling = self.properties.scaling
	local bgColor = self.properties.bgColor
	local highlightColor = self.properties.highlightColor
	local optionColor = self.properties.optionColor
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()
	local mouseovertext = self.properties.mouseOverText
	local startOption = self.properties.startOption
	local helpoverlay = createOverlayPropertyInfo(self)

	local isfunctioncell = false
	if type(startOption) == "function" then
		startOption = startOption()
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local dropdownDescriptor = {}
	dropdownDescriptor.options = self.properties.options
	dropdownDescriptor.startoption = startOption
	dropdownDescriptor.text = createTextPropertyInfo(self, self.properties.text)
	dropdownDescriptor.textoverride = self.properties.textOverride
	dropdownDescriptor.text2 = createTextPropertyInfo(self, self.properties.text2)
	dropdownDescriptor.text2override = self.properties.text2Override
	dropdownDescriptor.icon = createIconPropertyInfo(self, self.properties.icon)
	dropdownDescriptor.hotkey = createHotkeyPropertyInfo(self, self.properties.hotkey, width, height, scaling)

	dropdownDescriptor.mouseovertext = mouseovertext
	dropdownDescriptor.color = bgColor
	dropdownDescriptor.highlightcolor = highlightColor
	dropdownDescriptor.optioncolor = optionColor
	dropdownDescriptor.active = self.properties.active
	dropdownDescriptor.allowmouseoverinteraction = self.properties.allowMouseOverInteraction
	dropdownDescriptor.helpoverlay = helpoverlay

	dropdownDescriptor.offset = {x = offsetx, y = offsety}
	dropdownDescriptor.size = {width = width , height = height}
	dropdownDescriptor.optionwidth = self.properties.optionWidth
	dropdownDescriptor.optionheight = self.properties.optionHeight

	return CreateDropDown(dropdownDescriptor)
end

-- checkbox
function widgetPrototypes.cell:createCheckBox(checked, properties)
	if initTableCell(self, "checkbox", properties) then
		self.properties.checked = checked
	end
	return self
end

function widgetHelpers.checkbox:createDescriptor()
	local scaling = self.properties.scaling
	local bgColor = self.properties.bgColor
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()
	local mouseovertext = self.properties.mouseOverText
	local checked = self.properties.checked

	local isfunctioncell = false
	if type(checked) == "function" then
		checked = checked()
		isfunctioncell = true
	end
	if type(bgColor) == "function" then
		bgColor = bgColor()
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local checkboxDescriptor = {}
	checkboxDescriptor.mouseovertext = mouseovertext
	checkboxDescriptor.color = bgColor
	checkboxDescriptor.active = self.properties.active
	checkboxDescriptor.checked = checked
	checkboxDescriptor.symbol = self.properties.symbol

	checkboxDescriptor.offset = { x = offsetx, y = offsety }
	checkboxDescriptor.size = { width = width , height = height }

	return CreateCheckBox(checkboxDescriptor)
end

-- statusbar
function widgetPrototypes.cell:createStatusBar(properties)
	initTableCell(self, "statusbar", properties)
	return self
end

function widgetHelpers.statusbar:createDescriptor()
	local current = self.properties.current
	local start = self.properties.start
	local max = self.properties.max
	local valueColor = self.properties.valueColor
	local posChangeColor = self.properties.posChangeColor
	local negChangeColor = self.properties.negChangeColor
	local markerColor = self.properties.markerColor
	local mouseovertext = self.properties.mouseOverText

	local titleColor = self.properties.titleColor
	if titleColor == propertyDefaultValue then
		titleColor = nil
	end

	local isfunctioncell = false
	if type(current) == "function" then
		current = current()
		isfunctioncell = true
	end
	if type(start) == "function" then
		start = start()
		isfunctioncell = true
	end
	if type(max) == "function" then
		max = max()
		isfunctioncell = true
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.row.table.frame.functionCells, self)
	end

	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = self:getWidth()
	local height = self:getHeight()

	local statusBarDescriptor = {}
	if current < 0 then
		print("statusbar:createDescriptor(): Statusbar in row " .. self.row.index .. ", col " .. self.index .. " has a negative current value. Check what is causing this.")
	end
	statusBarDescriptor.current = math.max(0, current)
	if start < 0 then
		print("statusbar:createDescriptor(): Statusbar in row " .. self.row.index .. ", col " .. self.index .. " has a negative start value. Check what is causing this.")
	end
	statusBarDescriptor.start = math.max(0, start)
	if max < 0 then
		print("statusbar:createDescriptor(): Statusbar in row " .. self.row.index .. ", col " .. self.index .. " has a negative max value. Check what is causing this.")
	end
	statusBarDescriptor.max = math.max(0, max)
	statusBarDescriptor.valueColor = valueColor
	statusBarDescriptor.posChangeColor = posChangeColor
	statusBarDescriptor.negChangeColor = negChangeColor
	statusBarDescriptor.markerColor = markerColor
	statusBarDescriptor.titleColor = titleColor
	statusBarDescriptor.mouseovertext = mouseovertext
	statusBarDescriptor.offset = { x = offsetx, y = offsety }
	statusBarDescriptor.size = { width = width , height = height }
	return CreateStatusBar(statusBarDescriptor)
end

-- graph
function widgetPrototypes.cell:createGraph(graphtype, noscaling, bgcolor, title, xaxis, yaxis, datarecords, offsetx, offsety, width, height, mouseovertext, helpOverlayID, helpOverlayText)
	initTableCell(self, "graph", { scaling = (noscaling == false), x = offsetx, y = offsety, width = width, height = height, mouseOverText = mouseovertext })
	self.selected = {}

	local graphDescriptor = {}
	graphDescriptor.type = graphtype
	graphDescriptor.bgcolor = bgcolor
	graphDescriptor.title = title
	graphDescriptor.xAxis = xaxis
	graphDescriptor.yAxis = yaxis
	graphDescriptor.offset = { x = offsetx or 0, y = offsety or 0 }
	graphDescriptor.size = { width = width or 0, height = height or 0 }
	graphDescriptor.mouseovertext = mouseovertext
	graphDescriptor.helpoverlay = { text = helpOverlayText, id = helpOverlayID, size = { width = 0, height = 0 }, offset = { x = 0, y = 0 } }

	graphDescriptor.datarecords = {}
	graphDescriptor.icons = {}
	for datarecordidx, datarecord in ipairs(datarecords) do
		for dataidx, datapoint in ipairs(datarecord.data) do
			if datapoint.icon then
				table.insert(graphDescriptor.icons, { datarecord = datarecordidx, data = dataidx, icon = datapoint.icon, mouseovertext = datapoint.mouseovertext })
				datarecord.data.icon = nil
				datarecord.data.mouseovertext = nil
			end
		end
		table.insert(graphDescriptor.datarecords, datarecord)
	end

	if self.properties.scaling then
		graphDescriptor.offset.x		= Helper.scaleX(graphDescriptor.offset.x)
		graphDescriptor.offset.y		= Helper.scaleY(graphDescriptor.offset.y)
		graphDescriptor.size.width		= Helper.scaleX(graphDescriptor.size.width)
		graphDescriptor.size.height		= Helper.scaleY(graphDescriptor.size.height)

		if graphDescriptor.title then
			graphDescriptor.title.size = Helper.scaleFont(graphDescriptor.title.font, graphDescriptor.title.size)
		end
		if graphDescriptor.xAxis.label then
			graphDescriptor.xAxis.label.size = Helper.scaleFont(graphDescriptor.xAxis.label.font, graphDescriptor.xAxis.label.size)
		end
		if graphDescriptor.yAxis.label then
			graphDescriptor.yAxis.label.size = Helper.scaleFont(graphDescriptor.yAxis.label.font, graphDescriptor.yAxis.label.size)
		end
		for _, datarecord in ipairs(graphDescriptor.datarecords) do
			if datarecord.marker then
				datarecord.marker.size = Helper.scaleX(datarecord.marker.size)
			end
			if datarecord.line then
				datarecord.line.width = math.floor(Helper.scaleY(datarecord.line.width) / 2) * 2
			end
		end
	end

	self.properties.graphdesc = graphDescriptor
	return self
end

function widgetHelpers.graph:createDescriptor()
	return CreateGraph(self.properties.graphdesc)
end

function widgetPrototypes.graph:selectDataPoint(recordIdx, dataIdx, selected)
	if self.id then
		if (recordIdx ~= self.selected.recordIdx) or (dataIdx ~= self.selected.dataIdx) then
			self.selected = { recordIdx = recordIdx, dataIdx = dataIdx }
			SelectGraphDataPoint(self.id, recordIdx, dataIdx, selected)
		end
	end
end

---------- Flowchart member functions ----------

function widgetPrototypes.flowchart:setDefaultNodeProperties(properties)
	if not self.defaultNodeProperties then
		self.defaultNodeProperties = { }
		setmetatable(self.defaultNodeProperties, widgetPropertyMetatables.flowchartnode)
	end
	self.defaultNodeProperties:apply(properties)
	return self
end

function widgetPrototypes.flowchart:setDefaultEdgeProperties(properties)
	if not self.defaultEdgeProperties then
		self.defaultEdgeProperties = { }
		setmetatable(self.defaultEdgeProperties, widgetPropertyMetatables.flowchartedge)
	end
	self.defaultEdgeProperties:apply(properties)
	return self
end

function widgetPrototypes.flowchart:setDefaultTextProperties(properties)
	if not self.defaultTextProperties then
		self.defaultTextProperties = { }
		setmetatable(self.defaultTextProperties, widgetPropertyMetatables.textproperty)
	end
	self.defaultTextProperties:apply(properties)
	return self
end

function widgetPrototypes.flowchart:setDefaultIconProperties(properties)
	if not self.defaultIconProperties then
		self.defaultIconProperties = { }
		setmetatable(defaultIconProperties, widgetPropertyMetatables.iconproperty)
	end
	self.defaultIconProperties:apply(properties)
	return self
end

function widgetPrototypes.flowchart:setColWidthMin(col, minwidth, extensionweight, scaling)
	-- In contrast to tables, we don't have to finalize column widths in the flowchart before content is added.
	-- Eventually the column width will be determined by the widest node in the column, and possibly by the visible flowchart width.
	-- Since we can scroll horizontally, there are less restrictions than in a table widget.
	local coldata = self.columndata[col]
	if not coldata then
		DebugError(string.format("flowchart:setColWidthMin(): Column %s does not exist", col))
	else
		coldata.minwidth = minwidth
		coldata.weight = extensionweight or 1
		coldata.scaling = scaling
	end
	return self
end

function widgetPrototypes.flowchart:setColBackgroundColor(col, bgcolor)
	local coldata = self.columndata[col]
	if not coldata then
		DebugError(string.format("flowchart:setColBackgroundColor(): Column %s does not exist", col))
	else
		coldata.bgcolor = bgcolor
	end
	return self
end

-- height functions
function widgetPrototypes.flowchart:getRowHeight(row)
	local rowcells = self.rows[row]
	if not rowcells then
		DebugError(string.format("flowchart:getRowHeight(): Row %s does not exist", row))
		return 0
	end
	local height = Helper.scaleY(self.properties.minRowHeight, self.properties.scaling)
	for _, cell in ipairs(rowcells) do
		if cell then
			height = math.max(height, cell:getCellMinHeight())
		end
	end
	return height
end

function widgetPrototypes.flowchart:getCaptionHeight(col)
	local coldata = self.columndata[col]
	if not coldata then
		DebugError(string.format("flowchart:getCaptionHeight(): Column %s does not exist", col))
		return 0
	end
	if coldata.caption then
		local fontsize = Helper.scaleFont(coldata.caption.fontname, coldata.caption.fontsize, self.properties.scaling)
		return math.ceil(C.GetTextHeight(tostring(coldata.caption.text), coldata.caption.fontname, math.floor(fontsize), 0))
	end
	return 0
end

function widgetPrototypes.flowchart:getFullHeight()
	local fullwidth, fullheight, hasverticalscrollbar, hashorizontalscrollbar = widgetHelpers.flowchart.getFullSizeAndScrollBarData(self)
	return fullheight
end

function widgetPrototypes.flowchart:getMaxVisibleHeight()
	local maxheight = self.properties.maxVisibleHeight
	local availableheight = self.frame:getAvailableHeight() - self.properties.y
	if maxheight > 0 and maxheight < availableheight then
		return maxheight
	end
	return availableheight
end

function widgetPrototypes.flowchart:getVisibleHeight()
	local height = self:getFullHeight()
	local maxheight = self:getMaxVisibleHeight()
	if maxheight > 0 and height > maxheight then
		-- Not all rows will be visible, we'll get a scrollbar
		return maxheight
	end
	return height
end

function widgetPrototypes.flowchart:hasScrollBar()
	local fullwidth, fullheight, hasverticalscrollbar, hashorizontalscrollbar = widgetHelpers.flowchart.getFullSizeAndScrollBarData(self)
	return hasverticalscrollbar
end

-- width functions
function widgetPrototypes.flowchart:getColMinWidth(col)
	local coldata = self.columndata[col]
	if not coldata then
		DebugError(string.format("flowchart:getColMinWidth(): Column %s does not exist", col))
		return 0
	end
	local scaling = coldata.scaling or (self.properties.scaling and coldata.scaling == nil)	-- coldata.scaling takes precedence if non-nil
	local minwidth = Helper.scaleX(coldata.minwidth >= 0 and coldata.minwidth or self.properties.minColWidth, scaling)
	for row = 1, self.numrows do
		local cell = self.rows[row][col]
		if cell then
			minwidth = math.max(minwidth, cell:getCellMinWidth())
		end
	end
	-- note: actual width can be larger because columns can be stretched, in case minFullWidth is lower than visible width
	return math.ceil(minwidth)
end

function widgetPrototypes.flowchart:getMinFullWidth()
	local fullwidth, fullheight, hasverticalscrollbar, hashorizontalscrollbar = widgetHelpers.flowchart.getFullSizeAndScrollBarData(self)
	return fullwidth
end

function widgetPrototypes.flowchart:getVisibleWidth()
	local visiblewidth = math.floor(self.properties.width)
	local availablewidth = math.floor(self.frame.properties.width) - math.ceil(self.properties.x)
	if visiblewidth > 0 and visiblewidth < availablewidth then
		return visiblewidth
	end
	return availablewidth
end

function widgetPrototypes.flowchart:hasHorizontalScrollBar()
	local fullwidth, fullheight, hasverticalscrollbar, hashorizontalscrollbar = widgetHelpers.flowchart.getFullSizeAndScrollBarData(self)
	return hashorizontalscrollbar
end

function widgetHelpers.flowchart:getFullSizeAndScrollBarData()
	-- determine full (minimal) width and height and whether scrollbars exist, also include scrollbar size in width/height
	local fullheight = 2 * (Helper.scaleY(self.properties.borderHeight, self.properties.scaling) + Helper.borderSize)
	local maxCaptionHeight = 0
	for col = 1, self.numcolumns do
		maxCaptionHeight = math.max(maxCaptionHeight, self:getCaptionHeight(col))
	end
	fullheight = fullheight + maxCaptionHeight
	for row = 1, self.numrows do
		fullheight = fullheight + self:getRowHeight(row)
	end
	local fullwidth = 0
	for col, coldata in ipairs(self.columndata) do
		fullwidth = fullwidth + self:getColMinWidth(col)
	end
	local maxvisibleheight = self:getMaxVisibleHeight()
	local maxvisiblewidth = self:getVisibleWidth()
	local hashorizontalscrollbar = false
	local hasverticalscrollbar = false
	-- use same scrollbar logic as in flowchart widget implementation
	if fullheight > maxvisibleheight then
		-- take width of vertical scrollbar into account - this could make a horizontal scrollbar required
		hasverticalscrollbar = true
		fullwidth = fullwidth + Helper.scrollbarWidth
	end
	if fullwidth > maxvisiblewidth then
		-- take height of horizontal scrollbar into account - this could make a vertical scrollbar required, if not required already
		hashorizontalscrollbar = true
		fullheight = fullheight + Helper.scrollbarWidth
		if (not hasverticalscrollbar) and fullheight > maxvisibleheight then
			-- horizontal scrollbar increases full height beyond visible height, so that we need a vertical scrollbar as well
			hasverticalscrollbar = true
			fullwidth = fullwidth + Helper.scrollbarWidth
		end
	end
	-- min flowchart height
	fullheight = math.max(fullheight, Helper.scaleY(self.properties.minRowHeight, self.properties.scaling) + 2 * Helper.scaleY(self.properties.borderHeight, self.properties.scaling))
	return fullwidth, fullheight, hasverticalscrollbar, hashorizontalscrollbar
end

-- content handling (celltype = "flowchartnode" or "flowchartjunction" or nil)
function widgetPrototypes.flowchart:getCell(row, col, celltype)
	local rowcells = self.rows[row]
	if rowcells and rowcells[col] and (not celltype or rowcells[col].type == celltype) then
		return rowcells[col]
	end
	return nil
end

function finalizeFlowchartCellSlots(cell, slottype, edges, colorprop, rankprop, slotfield)
	-- assign slots to connected edges, and slot colors to the used slots.
	-- for input slots: slottype = "input", colorprop = "destSlotColor", rankprop = "destSlotRank", slotfield = "destslot"
	-- for output slots: slottype = "output", colorprop = "sourceSlotColor", rankprop = "sourceSlotRank", slotfield = "sourceslot"
	local rankcolors = { }
	local flowchartCellError = false
	if #edges == 0 then
		return 0
	end
	-- table for identifying duplicate edges, only used with slottype "output" (look for edges with identical destcell/sourceSlotRank/destSlotRank)
	local connectedcellsbyslotranks = { }
	for _, edge in ipairs(edges) do
		-- determine unique color per slot rank and identify collisions (multiple edges with same rank, but different colors)
		local color = edge.properties[colorprop]
		local rank = edge.properties[rankprop]
		local prevcolor = rankcolors[rank]
		if not flowchartCellError and color and prevcolor then
			if color.r ~= prevcolor.r or color.g ~= prevcolor.g or color.b ~= prevcolor.b or color.a ~= prevcolor.a then
				DebugError(string.format("flowchart slot finalization (row %d, column %d): There are multiple connected %s edges using the same slot rank %d with different colors",
					cell.row, cell.col, (slottype == "input" and "incoming" or "outgoing"), rank))
				flowchartCellError = true
			end
		end
		-- set color or false, but not nil
		rankcolors[rank] = prevcolor or color or false
		-- identify and mark duplicates
		if slottype == "output" then
			local rankcombination = edge.properties.sourceSlotRank * 10 + edge.properties.destSlotRank
			local connectedcells = connectedcellsbyslotranks[rankcombination]
			if not connectedcells then
				connectedcells = { }
				connectedcellsbyslotranks[rankcombination] = connectedcells
			end
			if connectedcells[edge.destcell] then
				edge.duplicate = true
			else
				connectedcells[edge.destcell] = edge
			end
		end
	end
	local usedranks = { }						-- sequence of used ranks
	local rankslotassignment = { }				-- rankslotassignment[rank] = slot
	for rank = 1, 3 do
		if rankcolors[rank] ~= nil then
			table.insert(usedranks, rank)
		end
	end
	if #usedranks == 0 then
		-- This would mean that rank was not a number from 1 to 3
		DebugError(string.format("flowchart slot finalization (row %d, column %d): Connected edges have invalid slot ranks", cell.row, cell.col))
	elseif cell.type == "flowchartjunction" then
		-- junction
		if #usedranks > 1 then
			DebugError(string.format("flowchart slot finalization (row %d, column %d): There are edges connected to multiple slots on a junction, only one slot is supported", cell.row, cell.col))
		end
		-- Use slot 2
		rankslotassignment[usedranks[1]] = 2
		-- validate and set junction color
		local color = rankcolors[usedranks[1]] or Helper.standardColor
		local prevcolor = cell.junctionColor
		if color and prevcolor then
			if color.r ~= prevcolor.r or color.g ~= prevcolor.g or color.b ~= prevcolor.b or color.a ~= prevcolor.a then
				DebugError(string.format("flowchart slot finalization (row %d, column %d): Junction has different input and output colors", cell.row, cell.col))
			end
		end
		cell.junctionColor = prevcolor or color
	else
		if #usedranks == 1 then
			-- node with one slot: Use slot 2
			rankslotassignment[usedranks[1]] = 2
		elseif #usedranks == 2 then
			-- node with two slots: Use slots 1 and 3
			rankslotassignment[usedranks[1]] = 1
			rankslotassignment[usedranks[2]] = 3
		elseif #usedranks == 3 then
			-- node with three slots: Use all slots
			rankslotassignment[usedranks[1]] = 1
			rankslotassignment[usedranks[2]] = 2
			rankslotassignment[usedranks[3]] = 3
		end
		for rank, slot in pairs(rankslotassignment) do
			cell.slotcolors[slottype][slot] = rankcolors[rank] or Helper.standardColor
		end
	end
	-- Store assigned slot also in edges
	for _, edge in ipairs(edges) do
		local rank = edge.properties[rankprop]
		edge[slotfield] = rankslotassignment[rank]
	end
end

-- Example usage:
--   local node = flowchart:addNode(1, 1, { custom = "foo", bar = "baz" }, { shape = "stadium", bgColor = Helper.color.black })
function widgetPrototypes.flowchart:addNode(row, col, customdata, properties)
	local rowcells = self.rows[row]
	if not rowcells then
		DebugError(string.format("flowchart:addNode(): Row %s does not exist", row))
		return nil
	end
	if rowcells[col] ~= false then
		if rowcells[col] then
			DebugError(string.format("flowchart:addNode(): Node or junction already exists in row %d, column %d", row, col))
		else
			DebugError(string.format("flowchart:addNode(): Column %s does not exist", col))
		end
		return nil
	end
	local node = {
		flowchart = self,
		row = row,							-- row index in flowchart
		col = col,							-- column index in flowchart
		customdata = customdata,			-- user-provided data
		type = "flowchartnode",				-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- widget ID, valid while displayed
		slotcolors = {						-- color tables of input/output slots (false if slot is not used)
			input = { false, false, false },	-- set in finalizeFlowchartCellSlots()
			output = { false, false, false }	-- set in finalizeFlowchartCellSlots()
		},
		incomingEdges = { },				-- flowchart edges whose destination is this cell
		outgoingEdges = { },				-- flowchart edges whose source is this cell
		properties = { },					-- node properties
		handlers = { }						-- event handlers
	}
	rowcells[col] = node

	-- set metatables to enable member functions and default properties
	setmetatable(node, widgetMetatables.flowchartnode)
	setmetatable(node.properties, widgetPropertyMetatables.flowchartnode)

	-- propagate scaling from flowchart to node
	if not self.properties.scaling then
		node.properties.scaling = false
	end
	-- create complex properties
	for complexprop, simpleprop in pairs(complexCellProperties.flowchartnode) do
		local complexproptable = { }
		setmetatable(complexproptable, widgetPropertyMetatables[simpleprop])
		rawset(node.properties, complexprop, complexproptable)
	end
	-- apply default node properties
	if self.defaultNodeProperties then
		node.properties:apply(self.defaultNodeProperties)
	end
	-- apply custom properties
	node.properties:apply(properties)
	return node
end

-- Example usage:
--   local node = flowchart:addJunction(1, 1)
function widgetPrototypes.flowchart:addJunction(row, col, properties)
	local rowcells = self.rows[row]
	if not rowcells then
		DebugError(string.format("flowchart:addJunction(): Row %s does not exist", row))
		return nil
	end
	if rowcells[col] ~= false then
		if rowcells[col] then
			DebugError(string.format("flowchart:addJunction(): Node or junction already exists in row %d, column %d", row, col))
		else
			DebugError(string.format("flowchart:addJunction(): Column %s does not exist", col))
		end
		return nil
	end
	local junction = {
		flowchart = self,
		row = row,							-- row index in flowchart
		col = col,							-- column index in flowchart
		type = "flowchartjunction",			-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- widget ID, valid while displayed
		incomingEdges = { },				-- flowchart edges whose destination is this cell
		outgoingEdges = { },				-- flowchart edges widgets whose source is this cell
		junctionColor = nil,				-- set in finalizeFlowchartCellSlots()
		properties = { }					-- junction properties
	}
	rowcells[col] = junction

	-- set metatables to enable member functions and default properties
	setmetatable(junction, widgetMetatables.flowchartjunction)
	setmetatable(junction.properties, widgetPropertyMetatables.flowchartjunction)

	-- propagate scaling from flowchart to junction
	if not self.properties.scaling then
		junction.properties.scaling = false
	end
	-- apply custom properties
	junction.properties:apply(properties)
	return junction
end

function widgetPrototypes.flowchart:setColumnCaption(col, text, properties)
	if (col <= 0) or (col > self.numcolumns) then
		DebugError(string.format("flowchart:setColumnCaption(): Col %s does not exist", col))
		return
	end

	if type(properties) ~= "table" then
		if properties ~= nil then
			DebugError(string.format("flowchart:setColumnCaption(): Invalid properties format", col))
		end
		properties = {}
	end

	self.columndata[col].caption = {
		text = text,
		fontname = properties.font or Helper.standardFont,
		fontsize = properties.fontsize or Helper.headerRow1FontSize,
		color = properties.color or Helper.color.white,
	}
end

function widgetHelpers.flowchart:createDescriptor()
	-- note: scaling is not applied to offset and size of the flowchart itself
	local offsetx = self.properties.x
	local offsety = self.properties.y
	local width = self:getVisibleWidth()
	local height = self:getVisibleHeight()
	local scaling = self.properties.scaling
	local taborder = self.properties.tabOrder
	local skiptabchange = self.properties.skipTabChange
	local defaultinteractiveobject = self.properties.defaultInteractiveObject
	local helpoverlay = createOverlayPropertyInfo(self)

	-- finalize junction offsets and node/junction slots
	for col, coldata in ipairs(self.columndata) do
		-- determine best x offset for junctions in each column
		local bestxoff = 0
		for row, cols in ipairs(self.rows) do
			local cell = cols[col]
			if cell then
				finalizeFlowchartCellSlots(cell, "input", cell.incomingEdges, "destSlotColor", "destSlotRank", "destslot")
				finalizeFlowchartCellSlots(cell, "output", cell.outgoingEdges, "sourceSlotColor", "sourceSlotRank", "sourceslot")
				if cell.type == "flowchartnode" then
					bestxoff = math.max(bestxoff, Helper.scaleX(cell.properties.width, cell.properties.scaling) / 2)
				elseif cell.properties.junctionXOff >= 0 then
					bestxoff = math.max(bestxoff, Helper.scaleX(cell.properties.junctionXOff, cell.properties.scaling))
				end
			end
		end
		coldata.junctionxoff = bestxoff
	end

	local flowchartDescriptor = { }
	flowchartDescriptor.taborder = taborder
	flowchartDescriptor.skiptabchange = skiptabchange
	flowchartDescriptor.offset = { x = offsetx, y = offsety }
	flowchartDescriptor.size = { width = width, height = height }
	flowchartDescriptor.border = { height = Helper.scaleY(self.properties.borderHeight, scaling), color = self.properties.borderColor }
	flowchartDescriptor.minrowheight = Helper.scaleY(self.properties.minRowHeight, scaling)
	flowchartDescriptor.edgewidth = math.max(1, Helper.scaleY(self.properties.edgeWidth))
	flowchartDescriptor.firstvisiblerow = self.properties.firstVisibleRow
	flowchartDescriptor.firstvisiblecol = self.properties.firstVisibleCol
	flowchartDescriptor.selectedrow = self.properties.selectedRow
	flowchartDescriptor.selectedcol = self.properties.selectedCol
	flowchartDescriptor.helpoverlay = helpoverlay
	-- columns
	flowchartDescriptor.columns = { }
	local totalwidth = 0
	local varcolumnweight = 0
	for col, coldata in ipairs(self.columndata) do
		local colminwidth = self:getColMinWidth(col)
		if coldata.caption then
			coldata.caption.fontsize = Helper.scaleFont(coldata.caption.fontname, coldata.caption.fontsize, scaling)
		end
		flowchartDescriptor.columns[col] = { minwidth = colminwidth, bgcolor = coldata.bgcolor, caption = coldata.caption }
		totalwidth = totalwidth + colminwidth
		varcolumnweight = varcolumnweight + coldata.weight
	end
	if totalwidth < width then
		-- Stretch columns to fit width
		--[[
		if varcolumnweight > 0 then
			for col, coldata in ipairs(self.columndata) do
				if coldata.weight > 0 then
					local desccoldata = flowchartDescriptor.columns[col]
					local addedwidth = math.ceil((width - totalwidth) * coldata.weight / varcolumnweight)
					desccoldata.minwidth = desccoldata.minwidth + addedwidth
					totalwidth = totalwidth + addedwidth
					varcolumnweight = varcolumnweight - coldata.weight
					if varcolumnweight <= 0 then break end
				end
			end
		else
			DebugError(string.format("flowchart:createDescriptor(): Total width %s of flowchart columns is less than flowchart width %s, but stretching columns is not allowed", totalwidth, width))
		end
		]]
	end
	-- content
	flowchartDescriptor.content = { }
	for row, cols in ipairs(self.rows) do
		local descriptorrow = { }
		for col, cell in ipairs(cols) do
			local desc = nil
			if cell then
				desc = widgetHelpers[cell.type].createDescriptor(cell)
				if cell.descriptor then
					ReleaseDescriptor(cell.descriptor)
				end
				cell.descriptor = desc
			end
			descriptorrow[col] = desc or false
		end
		flowchartDescriptor.content[row] = descriptorrow
	end
	-- edges
	flowchartDescriptor.edges = { }
	local lastduplicateidx = nil
	for edgeidx, edge in ipairs(self.edges) do
		local edgedesc
		-- if it's a duplicate, don't create descriptor, instead create linked list of duplicates for removal
		if edge.duplicate then
			DebugError(string.format("flowchart:createDescriptor(): Removing duplicate edge between (%d,%d) and (%d,%d)", edge.sourcecell.row, edge.sourcecell.col, edge.destcell.row, edge.destcell.col))
			edge.lastduplicateidx = lastduplicateidx
			lastduplicateidx = edgeidx
		else
			edgedesc = widgetHelpers.flowchartedge.createDescriptor(edge)
		end
		if edge.descriptor then
			ReleaseDescriptor(edge.descriptor)
		end
		edge.descriptor = edgedesc
		if edgedesc then
			table.insert(flowchartDescriptor.edges, edgedesc)
		end
	end
	-- clean up duplicates
	while lastduplicateidx do
		local duplicateidx = lastduplicateidx
		lastduplicateidx = self.edges[duplicateidx].lastduplicateidx
		table.remove(self.edges, duplicateidx)
	end
	return CreateFlowchart(flowchartDescriptor)
end

function widgetPrototypes.flowchart:collapseAllNodes()
	while next(self.expandedNodes) do
		next(self.expandedNodes):collapse()
	end
end

---------- Generic flowchart cell member functions ----------

-- Example usage:
--   local edge = flowchartcell:addEdgeTo(destcell, { color = Helper.color.red })
function widgetPrototypes.flowchartcell:addEdgeTo(destcell, properties)
	if not (destcell and destcell.flowchart and destcell.flowchart == self.flowchart and destcell.row and destcell.col) then
		DebugError(string.format("flowchartcell:addEdgeTo(): Invalid destination cell %s (source row %d, column %d)", tostring(destcell), self.row, self.col))
		return nil
	end
	if destcell == self then
		DebugError(string.format("flowchartcell:addEdgeTo(): Source and destination are identical (row %d, column %d)", self.row, self.col))
		return nil
	end
	local edge = {
		flowchart = self.flowchart,
		type = "flowchartedge",				-- widget type
		descriptor = nil,					-- descriptor (used temporarily)
		id = nil,							-- widget ID, valid while displayed
		sourcecell = self,					-- source cell
		destcell = destcell,				-- destination cell
		sourceslot = nil,					-- determined and set by finalizeFlowchartCellSlots()
		destslot = nil,						-- determined and set by finalizeFlowchartCellSlots()
		duplicate = nil,					-- determined and set by finalizeFlowchartCellSlots()
		properties = { }					-- edge properties
	}
	table.insert(self.flowchart.edges, edge)

	-- set metatables to enable member functions and default properties
	setmetatable(edge, widgetMetatables.flowchartedge)
	setmetatable(edge.properties, widgetPropertyMetatables.flowchartedge)

	-- propagate scaling from flowchart to edge
	if not self.flowchart.properties.scaling then
		edge.properties.scaling = false
	end
	-- apply default edge properties
	if self.flowchart.defaultEdgeProperties then
		edge.properties:apply(self.flowchart.defaultEdgeProperties)
	end
	-- apply custom properties
	edge.properties:apply(properties)
	-- link edge to source/dest nodes
	table.insert(self.outgoingEdges, edge)
	table.insert(destcell.incomingEdges, edge)
	return edge
end

---------- Specialized flowchart cell member functions and specialization functions ----------

-- getCellMinWidth() for either cell type
function widgetPrototypes.flowchartnode:getCellMinWidth()
	local offsetx = Helper.scaleX(self.properties.x, self.properties.scaling)
	local nodewidth = Helper.scaleX(self.properties.width, self.properties.scaling)
	return offsetx * 2 + nodewidth
end

function widgetPrototypes.flowchartjunction:getCellMinWidth()
	local offsetx = Helper.scaleX(self.properties.x, self.properties.scaling)
	local junctionxoff = Helper.scaleX(math.max(0, self.properties.junctionXOff), self.properties.scaling)
	return offsetx * 2 + junctionxoff * 2
end

-- getCellMinHeight() for either cell type
function widgetPrototypes.flowchartnode:getCellMinHeight()
	local offsety = Helper.scaleY(self.properties.y, self.properties.scaling)
	local nodeheight = Helper.scaleY(self.properties.height, self.properties.scaling)
	return offsety * 2 + nodeheight
end

function widgetPrototypes.flowchartjunction:getCellMinHeight()
	local offsety = Helper.scaleY(self.properties.y, self.properties.scaling)
	return offsety * 2
end

-- flowchartnode
function widgetPrototypes.flowchartnode:setText(text, properties)
	self.properties.text.scaling = self.properties.scaling
	-- apply default text properties
	if self.flowchart.defaultTextProperties then
		self.properties.text:apply(self.flowchart.defaultTextProperties)
	end
	-- apply custom properties
	self.properties.text.text = text
	self.properties.text:apply(properties)
	return self
end

function widgetPrototypes.flowchartnode:setStatusText(text, properties)
	-- apply default text properties
	if self.flowchart.defaultTextProperties then
		self.properties.statustext:apply(self.flowchart.defaultTextProperties)
	end
	-- apply custom properties
	self.properties.statustext.text = text
	self.properties.statustext:apply(properties)
	return self
end

function widgetPrototypes.flowchartnode:setStatusIcon(icon, properties)
	-- apply default icon properties
	if self.flowchart.defaultIconProperties then
		self.properties.statusicon:apply(self.flowchart.defaultIconProperties)
	end
	-- apply custom properties
	self.properties.statusicon.icon = icon
	self.properties.statusicon:apply(properties)
	return self
end

function widgetHelpers.flowchartnode:createDescriptor()
	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = Helper.scaleX(self.properties.width, scaling)
	local height = Helper.scaleY(self.properties.height, scaling)
	local mouseovertext = self.properties.mouseOverText
	local connectorsize = Helper.scaleY(self.properties.connectorSize, scaling)
	local outlineColor = self.properties.outlineColor
	local value = self.properties.value
	local helpoverlay = createOverlayPropertyInfo(self)

	local isfunctioncell = false
	if type(self.properties.text.text) == "function" or type(self.properties.text.color) == "function" then
		isfunctioncell = true
	end
	if type(self.properties.statustext.text) == "function" or type(self.properties.statustext.color) == "function" or type(self.properties.statusColor) == "function" then
		isfunctioncell = true
	end
	if type(value) == "function" then
		isfunctioncell = true
		value = value(self)
	end
	if type(outlineColor) == "function" then
		isfunctioncell = true
		outlineColor = outlineColor(self)
	end
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.flowchart.frame.functionCells, self)
	end

	local flowchartNodeDescriptor = { }
	flowchartNodeDescriptor.offset = { x = offsetx, y = offsety }
	flowchartNodeDescriptor.size = { width = width, height = height }
	flowchartNodeDescriptor.helpoverlay = helpoverlay
	flowchartNodeDescriptor.connectorsize = connectorsize
	flowchartNodeDescriptor.mouseovertext = mouseovertext
	flowchartNodeDescriptor.expandable = (self.properties.expandedFrameLayer >= 1 and self.properties.expandedTableNumColumns >= 1)
	flowchartNodeDescriptor.caption = createTextPropertyInfo(self, self.properties.text)
	flowchartNodeDescriptor.statustext = createTextPropertyInfo(self, self.properties.statustext)
	flowchartNodeDescriptor.statusicon = createIconPropertyInfo(self, self.properties.statusicon)
	flowchartNodeDescriptor.statusbgiconid = self.properties.statusBgIconID
	flowchartNodeDescriptor.statusbgiconrotating = self.properties.statusBgIconRotating
	flowchartNodeDescriptor.statusiconmouseovertext = self.properties.statusIconMouseOverText
	if self.properties.statusColor then
		if flowchartNodeDescriptor.statustext then
			flowchartNodeDescriptor.statustext.color = self.properties.statusColor
		end
		if flowchartNodeDescriptor.statusicon then
			flowchartNodeDescriptor.statusicon.color = self.properties.statusColor
		end
	end
	-- shape
	local shape = self.properties.shape
	if shape == "rectangle" then
		flowchartNodeDescriptor.shape = 1
	elseif shape == "stadium" then
		flowchartNodeDescriptor.shape = 2
	elseif shape == "hexagon" then
		flowchartNodeDescriptor.shape = 3
	else
		DebugError(string.format("flowchartnode:createDescriptor(): Unknown shape '%s', using fallback 'rectangle'", shape))
		flowchartNodeDescriptor.shape = 1
	end
	-- slot colors
	flowchartNodeDescriptor.input = self.slotcolors.input
	flowchartNodeDescriptor.output = self.slotcolors.output
	-- scale
	flowchartNodeDescriptor.scale = {
		value = value,
		max = self.properties.max,
		slider1 = self.properties.slider1,
		slider2 = self.properties.slider2,
		slider1mouseovertext = self.properties.slider1MouseOverText,
		slider2mouseovertext = self.properties.slider2MouseOverText,
		step = self.properties.step,
	}
	-- colors
	flowchartNodeDescriptor.colors = {
		background = self.properties.bgColor,
		outline = outlineColor,
		value = self.properties.valueColor,
		slider1 = self.properties.slider1Color,
		slider2 = self.properties.slider2Color,
		diff1 = self.properties.diff1Color,
		diff2 = self.properties.diff2Color,
	}
	return CreateFlowchartNode(flowchartNodeDescriptor)
end

function widgetHelpers.flowchartnode:setScripts()
	if not self.id then
		DebugError("flowchartnode:setScripts(): Widget ID not available yet")
		return
	end
	local menu = self.flowchart.frame.menu
	local layer = GetFrameLayer(self.flowchart.frame.id)
	menu.flowchartNodeScriptMap = menu.flowchartNodeScriptMap or {}
	local scriptmap = {
		["onFlowchartNodeExpanded"] = function() self:expand() end,
		["onFlowchartNodeCollapsed"] = function() self:collapse() end,
		["onFlowchartNodeSliderActivated"] = self.handlers.onSliderActivated,
		["onFlowchartNodeSliderChanged"] = function(_, slideridx, slidervalue) widgetHelpers.flowchartnode.onSliderChanged(self, slideridx, slidervalue) end,
		["onFlowchartNodeSliderDeactivated"] = self.handlers.onSliderDeactivated,
	}
	for scriptHandle, script in pairs(scriptmap) do
		table.insert(menu.flowchartNodeScriptMap, { layer = layer, flowchartid = self.flowchart.id, row = self.row, col = self.col, type = scriptHandle, script = script })
		SetScript(self.id, scriptHandle, script)
	end
end

function widgetHelpers.flowchartnode:onSliderChanged(slideridx, slidervalue)
	if slideridx == 1 then
		self.properties.slider1 = slidervalue
	else
		self.properties.slider2 = slidervalue
	end
	if self.handlers.onSliderChanged then
		self.handlers.onSliderChanged(self.id, slideridx, slidervalue)
	end
end

function widgetPrototypes.flowchartnode:expand()
	if not self.id then
		DebugError("flowchartnode:expand(): Widget ID not available yet")
		return
	end
	if self.flowchart.expandedNodes[self] then
		DebugError("flowchartnode:expand(): Flowchart node was already expanded")
		return
	end
	if not self.handlers.onExpanded or self.properties.expandedFrameLayer < 1 or self.properties.expandedTableNumColumns < 1 then
		-- no handler, nothing to do
		return
	end

	-- create expanded menu frame
	local nodex, nodey, framepaddingx, framepaddingy = GetFlowchartNodeExpandedFrameData(self.id)
	if nodex == nil then
		return
	end
	local nodewidth, nodeheight = GetSize(self.id)
	local framewidth = nodewidth - 2 * framepaddingx
	-- determine max height: maxframeheight + 2 * framepaddingy == length of either [0, nodetop] or [nodebottom, viewheight]
	local maxframeheight = math.max(nodey - nodeheight / 2, Helper.viewHeight - (nodey + nodeheight / 2)) - 2 * framepaddingy

	local frame = Helper.createFrameHandle(self.flowchart.frame.menu, {
		layer = self.properties.expandedFrameLayer,
		x = nodex - framewidth / 2,
		y = 0,						-- determined later
		width = framewidth,
		height = maxframeheight,	-- adjusted later
		standardButtons = { },		-- no standard buttons
		closeOnUnhandledClick = true,
	})
	local numTables = self.properties.expandedFrameNumTables
	if (numTables <= 0) or (numTables > 2) then
		DebugError("flowchartnode:expand(): Flowchart node property expandedFrameNumTables is out of range [1, 2]. Defaulting to 1")
		numTables = 1
	end
	local ftable = frame:addTable(self.properties.expandedTableNumColumns, { tabOrder = 1, borderEnabled = true, wraparound = true })
	local ftable2
	if numTables == 2 then
		ftable2 = frame:addTable(self.properties.expandedTableNumColumns, { tabOrder = 2, borderEnabled = true, wraparound = true })
	end
	-- frame will be shown if handler adds at least one row to ftable
	self.handlers.onExpanded(self, frame, ftable, ftable2)
	if #ftable.rows > 0 then
		-- Shrink frame height
		frame.properties.height = frame:getUsedHeight()

		-- Determine Y offset of frame (expand below node if possible, otherwise above node)
		local expandedAbove = false
		if nodey + nodeheight / 2 + frame.properties.height > Helper.viewHeight then
			expandedAbove = true
			frame.properties.y = nodey - nodeheight / 2 - framepaddingy - frame.properties.height
		else
			frame.properties.y = nodey + nodeheight / 2 + framepaddingy
		end

		-- link node and frame, register node as (being) expanded, and draw frame
		frame.expandedFlowchartNodeData = { node = self, expandedAbove = expandedAbove }
		self.flowchart.expandedNodes[self] = frame
		-- the frame will trigger the node expansion and drawing of the popup background on the same layer as the frame
		frame:display()

		-- TODO #flowchart: onUpdate handler for function widgets
	else
		-- expansion failed, allow menu to clean up
		if self.handlers.onCollapsed then
			self.handlers.onCollapsed(self, frame)
		end
	end
end

function widgetPrototypes.flowchartnode:collapse()
	local frame = self.flowchart.expandedNodes[self]
	if self.id then
		C.SetFlowchartNodeExpanded(self.id, 0, false)
	end
	if frame then
		if not frame.id then
			DebugError("flowchartnode:collapse(): Collapsing flowchartnode before expanded menu frame is created")
		end
		self.flowchart.expandedNodes[self] = nil
		if self.handlers.onCollapsed then
			self.handlers.onCollapsed(self, frame)
		end
	end
end

function widgetPrototypes.flowchartnode:getExpandedFrame()
	if self.id then
		return self.flowchart.expandedNodes[self]
	end
	return nil
end

function widgetPrototypes.flowchartnode:updateOutlineColor(color)
	if self.id then
		self.properties.outlineColor = color
		C.SetFlowChartNodeOutlineColor(self.id, Helper.ffiColor(color))
	end
end

function widgetPrototypes.flowchartnode:updateText(text, color)
	if self.id then
		if text then
			self.properties.text.text = text
			C.SetFlowChartNodeCaptionText(self.id, tostring(text))
		end
		if color then
			self.properties.text.color = color
			C.SetFlowChartNodeCaptionTextColor(self.id, Helper.ffiColor(color))
		end
	end
end

function widgetPrototypes.flowchartnode:updateStatus(text, icon, bgicon, color, mouseovertext)
	if self.id then
		text = text or ""
		icon = icon or ""
		bgicon = bgicon or ""
		self.properties.statustext.text = text
		self.properties.statusicon.icon = icon
		self.properties.statusBgIconID = bgicon
		C.SetFlowChartNodeStatusText(self.id, tostring(text))
		C.SetFlowChartNodeStatusIcon(self.id, icon)
		C.SetFlowChartNodeStatusBgIcon(self.id, bgicon)
		if color then
			self.properties.statusColor = color
			C.SetFlowChartNodeStatusColor(self.id, Helper.ffiColor(color))
		end
		if mouseovertext then
			if icon ~= "" then
				self.properties.statusIconMouseOverText = mouseovertext
				C.SetFlowChartNodeStatusIconMouseOverText(self.id, mouseovertext)
			end
		end
	end
end

function widgetPrototypes.flowchartnode:updateValue(value)
	if self.id then
		self.properties.value = value
		C.SetFlowChartNodeCurValue(self.id, value)
	end
end

function widgetPrototypes.flowchartnode:updateMaxValue(value)
	if self.id then
		self.properties.max = value
		C.SetFlowChartNodeMaxValue(self.id, value)
	end
end

function widgetPrototypes.flowchartnode:updateSlider1(value)
	if self.id then
		value = value or -1		-- allow passing nil value to disable slider
		self.properties.slider1 = value
		C.SetFlowChartNodeSlider1Value(self.id, value)
	end
end

function widgetPrototypes.flowchartnode:updateSlider2(value)
	if self.id then
		value = value or -1		-- allow passing nil value to disable slider
		self.properties.slider2 = value
		C.SetFlowChartNodeSlider2Value(self.id, value)
	end
end

function widgetPrototypes.flowchartnode:updateSliderStep(step)
	if self.id then
		self.properties.step = step
		C.SetFlowChartNodeSliderStep(self.id, step)
	end
end

-- flowchartjunction
function widgetHelpers.flowchartjunction:createDescriptor()
	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local mouseovertext = self.properties.mouseOverText

	local junctionsize = Helper.scaleY(self.properties.junctionSize, scaling)
	local junctionxoff = self.properties.junctionXOff
	if junctionxoff < 0 then
		-- use the column's junctionxoff
		junctionxoff = self.flowchart.columndata[self.col].junctionxoff
	else
		junctionxoff = Helper.scaleX(junctionxoff, scaling)
	end

	local isfunctioncell = false
	if type(mouseovertext) == "function" then
		mouseovertext = mouseovertext(self)
		isfunctioncell = true
	end
	if isfunctioncell then
		table.insert(self.flowchart.frame.functionCells, self)
	end

	local flowchartJunctionDescriptor = { }
	flowchartJunctionDescriptor.shape = 0
	flowchartJunctionDescriptor.offset = { x = offsetx, y = offsety }
	flowchartJunctionDescriptor.size = { width = 2 * math.ceil(junctionxoff), height = 0 }
	flowchartJunctionDescriptor.mouseovertext = mouseovertext
	flowchartJunctionDescriptor.junctionsize = junctionsize
	flowchartJunctionDescriptor.junctioncolor = self.junctionColor

	-- A flowchart junction is actually just a FlowchartNode widget with shape == 0
	return CreateFlowchartNode(flowchartJunctionDescriptor)
end

-- flowchartedge
function widgetHelpers.flowchartedge:createDescriptor()
	-- Position and size shouldn't be relevant, but keep it consistent
	local scaling = self.properties.scaling
	local offsetx = Helper.scaleX(self.properties.x, scaling)
	local offsety = Helper.scaleY(self.properties.y, scaling)
	local width = Helper.scaleX(self.properties.width, scaling)
	local height = Helper.scaleY(self.properties.height, scaling)
	local color = self.properties.color

	local isfunctioncell = false		-- technically not a cell, but let's keep it consistent
	if type(color) == "function" then
		isfunctioncell = true
		color = color(self)
	end
	if isfunctioncell then
		table.insert(self.flowchart.frame.functionCells, self)
	end

	local flowchartEdgeDescriptor = { }
	flowchartEdgeDescriptor.offset = { x = offsetx, y = offsety }
	flowchartEdgeDescriptor.size = { width = width, height = height }

	flowchartEdgeDescriptor.source = { row = self.sourcecell.row, col = self.sourcecell.col, slot = self.sourceslot }
	flowchartEdgeDescriptor.dest   = { row = self.destcell.row,   col = self.destcell.col,   slot = self.destslot }
	flowchartEdgeDescriptor.color = color
	return CreateFlowchartEdge(flowchartEdgeDescriptor)
end

function widgetPrototypes.flowchartedge:updateColor(color)
	if self.id then
		self.properties.color = color
		C.SetFlowChartEdgeColor(self.id, Helper.ffiColor(color))
	end
end

---------------------------------------------------------------------------------
-- Flowchart setup
---------------------------------------------------------------------------------

local setupDAGLayoutHelper = { }

-- Input:
-- Array of nodes, connected as a directed acyclic graph (DAG). Each node is a table containing custom data and an optional table
-- called predecessors. The predecessors table maps other nodes in the table to an input slot number, e.g. 1.
-- If a node has different slots for incoming edges, a higher number indicates a higher slot offset (towards the bottom of the node).
-- This is necessary because it puts constraints on the row indices of predecessors to avoid edge crossings.
-- Nodes can have the following additional keys:
-- - numrows: Number of rows this node occupies (default is 1), used for abstract nodes that contain several other nodes themselves.
-- - numcols: Number of columns this node occupies (default is 1).
-- - halign: Horizontal alignment within a tier, which can span multiple columns ("left" or "right", default is "right")
-- Note: If numrows > 1 then the row offset of outgoing edges is assumed to be math.floor((numrows - 1) / 2), see slotrowoffset
-- Example:
--	local nodes = { }
--	nodes.foo = { foo = 1 },
--	nodes.bar = { foo = 2, predecessors = { nodes.foo = 1 } },
--	nodes.baz = { foo = 3, predecessors = { nodes.foo = 2 } },
--	nodes.foobar = { foo = 4, predecessors = { nodes.bar = 1, nodes.baz = 1 } }
--	nodes.foobaz = { foo = 5, predecessors = { nodes.foo = 1, nodes.baz = 2 } }
-- Result:
-- The function calculates a graph layout and assigns row/col coordinates to the DAG nodes so that
-- all flowchart edges point from left to right. It can also add junction nodes for aesthetic reasons.
-- Predecessors change on insertion of junctions, but the junctions are returned in a separate table.
-- Example:
--	local numrows, numcols, junctions = Helper.setupDAGLayout(nodes)
--	print(nodes.foo.row, nodes.foo.col)
--   |    1        2          3     |
-- 1 | [foo]-+--->[*]-+             |
--   |      \ \        \            |
-- 2 |       \ \>[baz]--+->[foobaz] |
--   |        \       \             |
-- 3 |         \>[bar]-+-->[foobar] |
function Helper.setupDAGLayout(nodes)
	local setup = { }
	setmetatable(setup, { __index = setupDAGLayoutHelper })
	return setup:process(nodes)
end

function setupDAGLayoutHelper:process(nodes)
	self:init(nodes)
	self:buildTiers()
	self:reduceEdgeCrossings()
	self:assignPositions()
	self:buildJunctions()
	return self.numrows, self.numcols, self.junctions
end

-- init members
function setupDAGLayoutHelper:init(nodes)
	self.originalnodes = nodes
	-- map the original nodes to our own node structs
	self.nodes = { }
	for originalidx, originalnode in ipairs(nodes) do
		self.nodes[originalnode] = {
			originalnode = originalnode,
			predecessors = { },
			numpredecessors = 0,
			successors = { },
			numsuccessors = 0,
			numrows = originalnode.numrows or 1,
			numcols = originalnode.numcols or 1,
			slotrowoffset = math.floor(((originalnode.numrows or 1) - 1) / 2),
			halign = originalnode.halign or "right",
			slotweight = 1,
			-- the following values are set later
			realnode = nil,					-- ancestor node that is not virtual (valid for virtual nodes)
			virtualdescendants = nil,		-- table of all virtual descendents, mapped by tier (valid for ancestor node of virtual nodes)
			tieridx = nil,					-- index of tier
			tiernodeidx = nil,				-- index of node in tier
			rowweight = nil,				-- row weight, temporarily used in reduceEdgeCrossings()
			minrow = nil,					-- minimal row number, temporarily used in improveRowAssignments()
			favrow = nil,					-- favourite row number, temporarily used in improveRowAssignments()
			row = nil,
			col = nil,
		}
	end
	self.virtualnodes = { }
	self.numrows = 0
	self.numcols = 0
	-- register predecessors and successors
	for _, node in pairs(self.nodes) do
		if node.originalnode.predecessors then
			for originalpredecessor, slot in pairs(node.originalnode.predecessors) do
				local predecessor = self.nodes[originalpredecessor]
				if predecessor then
					node.predecessors[predecessor] = slot
					node.numpredecessors = node.numpredecessors + 1
					predecessor.successors[node] = slot
					predecessor.numsuccessors = predecessor.numsuccessors + 1
				else
					DebugError(string.format("setupDAGLayoutHelper: Found a node with an invalid predecessor, ignoring"))
				end
			end
		end
	end
	-- determine slot weights (average input slot value of all predecessors)
	-- note: a higher input slot value indicates an edge from below, so to reduce edge crossings, the node should be placed
	-- further down compared to nodes with lower slot values.
	for _, node in pairs(self.nodes) do
		local totalslots = node.numpredecessors + node.numsuccessors
		local slotsum = 0
		for predecessor, slot in pairs(node.predecessors) do
			slotsum = slotsum + slot
		end
		for successor, slot in pairs(node.successors) do
			slotsum = slotsum + slot
		end
		if totalslots > 0 then
			node.slotweight = slotsum / totalslots
		end
	end
end

-- build tier table and assign corresponding tier values to nodes
function setupDAGLayoutHelper:buildTiers()
	local remainingnodes = { }
	for _, node in pairs(self.nodes) do
		remainingnodes[node] = true
	end
	local showerror = true
	while not self:attemptBuildTiers(remainingnodes) do
		-- a cycle was detected (in the simplest case: edge to self), attempt recovery by breaking the cycle
		if showerror then
			DebugError(string.format("setupDAGLayoutHelper: Cyclic dependencies detected. Removing dependencies to create a DAG."))
			showerror = false
		end
		if not self:removeCyclicEdge(remainingnodes) then
			-- recovery failed (this should not happen, but best prevent an accidental infinite loop)
			break
		end
		-- start over with one removed predecessor edge
		for _, node in pairs(self.nodes) do
			remainingnodes[node] = true
		end
	end
end

-- helper for buildTiers(): separate DAG into tiers
function setupDAGLayoutHelper:attemptBuildTiers(remainingnodes)
	-- - tier 1 contains all nodes without predecessors (leftmost column)
	-- - tier n+1 contains all nodes that are not in tiers 1 to n, but have all their predecessors in tiers 1 to n
	self.tiers = { }
	-- loop until there are no more remaining nodes
	while next(remainingnodes) do
		local tier = self:getNextTier(remainingnodes)
		-- the new tier must be non-empty if the graph is really a DAG
		if #tier == 0 then
			return false
		end
		table.insert(self.tiers, tier)
		for nodeidx, node in ipairs(tier) do
			remainingnodes[node] = nil
			node.tieridx = #self.tiers
			node.tiernodeidx = nodeidx
		end
	end
	return true
end

-- helper for attemptBuildTiers(): return array of nodes that have no predecessors in remainingnodes
function setupDAGLayoutHelper:getNextTier(remainingnodes)
	local tier = { }
	-- note: iterating over remainingnodes would be more efficient but would produce random results
	for _, originalnode in pairs(self.originalnodes) do
		local node = self.nodes[originalnode]
		if remainingnodes[node] then
			local ok = true
			for predecessor, _ in pairs(node.predecessors) do
				if remainingnodes[predecessor] then
					ok = false
					break
				end
			end
			if ok then
				table.insert(tier, node)
			end
		end
	end
	return tier
end

-- helper function for buildTiers(): remove a predecessor of node that is in remainingnodes, indicating a cycle
function setupDAGLayoutHelper:removeCyclicEdge(remainingnodes)
	local node = next(remainingnodes)
	for predecessor, _ in pairs(node.predecessors) do
		if remainingnodes[predecessor] then
			node.predecessors[predecessor] = nil
			node.numpredecessors = node.numpredecessors - 1
			predecessor.successors[node] = nil
			predecessor.numsuccessors = predecessor.numsuccessors - 1
			return true
		end
	end
	return false
end

-- partially based on dot's algorithm (1993): http://www.graphviz.org/Documentation/TSE93.pdf
function setupDAGLayoutHelper:reduceEdgeCrossings()
	-- first, go through the tiers from left to right and arrange nodes in each tier, minimising edge crossings to tiers on the left side
	-- (note: for the Logical Station Overview case, this step is not strictly needed, since there are usually fewer nodes on the right side than on the left side)
	for tieridx = 1, #self.tiers do
		local tier = self.tiers[tieridx]
		--print(string.format("reduceEdgeCrossings() left-to-right, tier %d", tieridx))
		for nodeidx, node in ipairs(tier) do
			-- determine rowweight that we can use for sorting (higher value = higher row number)
			local indexmedian = self:getTierNodeIndexMedian(node.predecessors, tieridx - 1) or 1000
			-- sort by indexmedian first; in case of equal median use the slotweight; and if in doubt, keep the original node order
			node.rowweight = (indexmedian * 100) + node.slotweight + (nodeidx / 100)
			--print(string.format("  node '%s' median=%s, slotweight=%s, rowweight=%s", node.originalnode.text, indexmedian, node.slotweight, node.rowweight))
		end
		-- arrange tier nodes according to rowweights
		table.sort(tier, function (a, b) return a.rowweight < b.rowweight end)
	end

	local fixedordernodes = { }
	-- second, go through the tiers from right to left and arrange nodes in each tier, minimising edge crossings to tiers on the right side
	-- (in this step, virtual nodes can be created and have to be taken into account)
	for tieridx = #self.tiers, 1, -1 do
		local tier = self.tiers[tieridx]
		--print(string.format("reduceEdgeCrossings() right-to-left, tier %d", tieridx))
		-- collect predecessors of virtual nodes in this tier (because their relative ordering is determined by the ordering of the virtual nodes)
		for nodeidx, node in ipairs(tier) do
			-- prepare for the next tier iteration: if necessary, add virtual node to the tier on the left
			do
				-- do this in a reproducible manner - using node.predecessors directly results in random orders and random outcomes
				local virtualnodedata = { }
				for predecessor, _ in pairs(node.predecessors) do
					if predecessor.tieridx < node.tieridx - 1 then
						table.insert(virtualnodedata, predecessor)
					end
				end
				table.sort(virtualnodedata, function (a, b) return a.tieridx * 1000 + a.tiernodeidx < b.tieridx * 1000 + b.tiernodeidx end)
				for _, predecessor in ipairs(virtualnodedata) do
					self:insertVirtualNode(node.tieridx - 1, predecessor, node)
				end
			end
			-- determine rowweight that we can use for sorting (higher value = higher row number)
			local indexmedian = self:getTierNodeIndexMedian(node.successors, tieridx + 1) or 1000
			-- sort by indexmedian first; in case of equal median use the slotweight; and if in doubt, keep the original node order
			node.rowweight = (indexmedian * 100) + node.slotweight + (nodeidx / 100)
			--print(string.format("  node '%s' median=%s, slotweight=%s, rowweight=%s", node.originalnode.text, indexmedian, node.slotweight, node.rowweight))
		end
		if #fixedordernodes >= 2 then
			-- the relative ordering of nodes in fixedordernodes is fixed, so adjust the rowweights accordingly
			-- (current simple implementation, ignoring node relevance: keep first node unchanged and adjust ordering of following nodes)
			local lastrowweight = nil
			for _, node in ipairs(fixedordernodes) do
				if lastrowweight then
					if node.rowweight <= lastrowweight then
						node.rowweight = lastrowweight + 0.001
					end
				end
				lastrowweight = node.rowweight
			end
		end
		-- arrange tier nodes according to rowweights
		table.sort(tier, function (a, b) return a.rowweight < b.rowweight end)
		-- some cleanup and preparation for next tier iteration
		fixedordernodes = { }
		for nodeidx, node in ipairs(tier) do
			-- restore node indices in tier array
			node.tiernodeidx = nodeidx
			node.rowweight = nil	-- not needed any more
			-- if node is virtual, add its (only) predecessor to fixedordernodes
			if node.realnode then
				table.insert(fixedordernodes, (next(node.predecessors)))
			end
		end
	end
end

-- helper function for reduceEdgeCrossings(): add virtual node to the specified tier for an edge that goes through it
function setupDAGLayoutHelper:insertVirtualNode(tieridx, predecessor, successor)
	local slot = predecessor.successors[successor]
	if not slot then
		DebugError("setupDAGLayoutHelper:insertVirtualNode() Internal error: Function called with invalid predecessor/successor")
		return
	end
	-- first remove original edge (but don't decrement the successor's number of predecessors, later we'll add the virtual node as predecessor anyway)
	successor.predecessors[predecessor] = nil
	successor.originalnode.predecessors[predecessor.originalnode] = nil
	predecessor.successors[successor] = nil
	predecessor.numsuccessors = predecessor.numsuccessors - 1
	-- find the "real" predecessor
	local realnode = predecessor.realnode or predecessor
	-- virtualdescendants are all virtual nodes between realnode and its "real" successors
	-- but each tier can have only one virtual successor of the predecessor
	-- (the predecessor and all virtual successors will end up in the same row)
	-- note: table key is the tier index, so the table is not necessarily a valid sequence
	realnode.virtualdescendants = realnode.virtualdescendants or { }
	-- is there already a virtual successor of predecessor in this tier?
	local virtualnode = realnode.virtualdescendants[tieridx]
	if not virtualnode then
		-- create new virtual node in the tier and connect it to predecessor
		virtualnode = {
			originalnode = { predecessors = { [predecessor.originalnode] = slot } },
			realnode = predecessor.realnode or predecessor,
			predecessors = { [predecessor] = slot },
			numpredecessors = 1,
			successors = { },
			numsuccessors = 0,
			numrows = 1,
			numcols = 1,
			slotrowoffset = 0,
			slotweight = predecessor.slotweight,
			tieridx = tieridx,
			tiernodeidx = #self.tiers[tieridx],
		}
		predecessor.successors[virtualnode] = slot
		predecessor.numsuccessors = predecessor.numsuccessors + 1
		realnode.virtualdescendants[tieridx] = virtualnode
		table.insert(self.tiers[tieridx], virtualnode)
		self.virtualnodes[virtualnode] = true
	end
	-- connect virtual node to successor
	successor.predecessors[virtualnode] = slot
	successor.originalnode.predecessors[virtualnode.originalnode] = slot
	virtualnode.successors[successor] = slot
	virtualnode.numsuccessors = virtualnode.numsuccessors + 1
end

-- helper for reduceEdgeCrossings(): return median of index median of nodes in the specified tier, or nil if there are no nodes
function setupDAGLayoutHelper:getTierNodeIndexMedian(nodes, tieridx)
	-- look at successor indices in next tier and determine median
	local indices = { }
	for successor, _ in pairs(nodes) do
		if successor.tieridx == tieridx then
			table.insert(indices, successor.tiernodeidx)
		end
	end
	if #indices == 0 then
		return nil
	end
	table.sort(indices)
	if #indices % 2 == 1 then
		return indices[(#indices + 1) / 2]
	end
	local medianidx = #indices / 2
	return (indices[medianidx] + indices[medianidx + 1]) / 2
end

function setupDAGLayoutHelper:assignPositions()
	-- initial assignment of rows and columns
	-- taking into account that a sequence of virtual nodes must be on the same row
	for tieridx, tier in ipairs(self.tiers) do
		-- determine tier colspan
		local colspan = 1
		for _, node in ipairs(tier) do
			colspan = math.max(colspan, node.numcols)
		end
		local row = 1
		local col = self.numcols + 1
		for _, node in ipairs(tier) do
			node.row = row
			node.col = col + (node.halign == "left" and 0 or (colspan - node.numcols))
			if node.realnode then
				local outrow = node.realnode.row + node.realnode.slotrowoffset
				-- this is a virtual node, it must be on the same row as the original node
				if node.row > outrow then
					-- we have to shift the predecessors in the previous tiers down to match the higher row number
					local rowdiff = node.row - outrow
					self:insertEmptyRowsAboveVirtualNodes(node.realnode, tieridx - 1, rowdiff)
				elseif node.row < outrow then
					-- shift current node down
					node.row = outrow
				end
			end
			row = node.row + node.numrows
		end
		self.numrows = math.max(self.numrows, row - 1)
		self.numcols = col + colspan - 1
	end

	-- improve row assignment
	local firstusedrow = self.numrows
	for tieridx, tier in ipairs(self.tiers) do
		-- virtual nodes and their ancestors are now fixed, all other nodes can still be shifted up or down
		-- determine boundaries for shifting
		local topnodeidx = 1
		local toprow = 1
		local numusedrows = 0
		for nodeidx, node in ipairs(tier) do
			if node.virtualdescendants or node.realnode then
				-- found a fixed node, improve positions of nodes above
				self:improveRowAssignments(tieridx, topnodeidx, toprow, nodeidx - 1, node.row - 1, numusedrows)
				topnodeidx = nodeidx + 1
				toprow = node.row + node.numrows
				numusedrows = 0
			else
				numusedrows = numusedrows + node.numrows
			end
		end
		local bottomnode = tier[#tier]
		if bottomnode then
			local bottomrow = bottomnode.row + bottomnode.numrows - 1
			-- allow incrementing number of rows by half num rows of the last node, because it could make sense to move the slot for incoming/outgoing edges down
			self:improveRowAssignments(tieridx, topnodeidx, toprow, #tier, math.max(self.numrows, bottomrow + math.floor(bottomnode.numrows / 2)), numusedrows)
			self.numrows = math.max(self.numrows, bottomnode.row + bottomnode.numrows - 1)
			firstusedrow = math.min(firstusedrow, tier[1].row)
		end
	end

	-- write rows and columns to original nodes
	for _, tier in ipairs(self.tiers) do
		for _, node in ipairs(tier) do
			-- remove possible empty rows at the top (can occur as rare side-effect of increasing number of allowed rows above)
			if firstusedrow and firstusedrow > 1 then
				node.row = node.row - firstusedrow + 1
			end
			node.originalnode.row = node.row
			node.originalnode.col = node.col
		end
	end
end

-- helper for assignPositions(): shift row numbers of a virtual node sequence down, covering all tiers from righttieridx until realnode (from right to left)
function setupDAGLayoutHelper:insertEmptyRowsAboveVirtualNodes(realnode, righttieridx, numemptyrows)
	for prevtieridx = righttieridx, realnode.tieridx + 1, -1 do
		local descendant = realnode.virtualdescendants[prevtieridx]
		if descendant then
			self:insertEmptyTierRows(descendant, numemptyrows)
		end
	end
	self:insertEmptyTierRows(realnode, numemptyrows)
	-- by changing row numbers, we may have broken another virtual node sequence below realnode
	local tier = self.tiers[realnode.tieridx]
	for nodeidx = realnode.tiernodeidx + 1, #tier do
		local node = tier[nodeidx]
		if node.realnode then
			-- continue recursively, fixing previous tiers
			self:insertEmptyRowsAboveVirtualNodes(node.realnode, realnode.tieridx - 1, numemptyrows)
			break
		end
	end
end

-- helper for assignPositions(): shift row numbers in a tier down, starting at abovenode, and returns new number of rows
function setupDAGLayoutHelper:insertEmptyTierRows(abovenode, numemptyrows)
	if numemptyrows < 0 then
		DebugError("setupDAGLayoutHelper:insertEmptyTierRows() Internal error: Invalid call")
		return
	end
	local tier = self.tiers[abovenode.tieridx]
	for nodeidx = abovenode.tiernodeidx, #tier do
		tier[nodeidx].row = tier[nodeidx].row + numemptyrows
	end
	-- update number of rows
	local lastnode = tier[#tier]
	self.numrows = math.max(self.numrows, lastnode.row + lastnode.numrows - 1)
end

-- helper for assignPositions(): try shifting nodes in a tier up or down to keep edges short and ideally horizontal
function setupDAGLayoutHelper:improveRowAssignments(tieridx, topnodeidx, toprow, bottomnodeidx, bottomrow, numusedrows)
	local maxshift = (bottomrow - toprow + 1) - numusedrows
	if maxshift <= 0 then
		return
	end
	local tier = self.tiers[tieridx]
	for nodeidx = topnodeidx, bottomnodeidx do
		local node = tier[nodeidx]
		node.minrow = node.row
		node.favrow = self:getBestRowAssignment(node, next(node.predecessors) and node.predecessors or node.successors, node.minrow, node.minrow + maxshift)
		-- the favrow assignment may overlap a previous node - re-visit previous nodes, group adjacent nodes together and assign rows to the whole group until there's no overlap
		local sumfavrows = node.favrow
		-- current node is first element in the group of adjacent nodes
		local groupsize = 1
		local groupnumrows = node.numrows
		local groupstartfavrow = node.favrow
		-- check for previous nodes to be added to the group
		for groupstartnodeidx = nodeidx - 1, topnodeidx, -1 do
			local groupstartnode = tier[groupstartnodeidx]
			if groupstartfavrow >= groupstartnode.row + groupstartnode.numrows then
				-- this node is actually not part of the group, we've found the best group size and row assignment
				break
			end
			-- include this node in the group
			groupsize = groupsize + 1
			groupnumrows = groupnumrows + groupstartnode.numrows
			sumfavrows = sumfavrows + groupstartnode.favrow
			groupstartfavrow = (sumfavrows / groupsize) - ((groupnumrows - 1) / 2)
			groupstartfavrow = math.min(math.max(math.ceil(groupstartfavrow - 0.5), groupstartnode.minrow), groupstartnode.minrow + maxshift)
		end
		local favrow = groupstartfavrow
		local groupstartnodeidx = nodeidx - groupsize + 1
		for groupnodeidx = groupstartnodeidx, nodeidx do
			local groupnode = tier[groupnodeidx]
			groupnode.row = favrow
			favrow = favrow + groupnode.numrows
		end
	end
end

-- helper for improveRowAssignments(): determine most preferred row assignment, based on connections to adjacent tier
function setupDAGLayoutHelper:getBestRowAssignment(node, connections, minrow, maxrow)
	local bestrow
	if next(connections) then
		local bestlengths
		for row = minrow, maxrow do
			local slotrow = row + node.slotrowoffset
			local edgelengths = 0
			for adjacentnode, _ in pairs(connections) do
				local adjacentslotrow = adjacentnode.row + adjacentnode.slotrowoffset
				local edgelength = math.sqrt((adjacentslotrow - slotrow) ^ 2 + 1)
				edgelengths = edgelengths + edgelength
			end
			if not bestlengths or edgelengths < bestlengths then
				bestlengths = edgelengths
				bestrow = row
			end
		end
	end
	return bestrow or math.floor((minrow + maxrow) / 2)
end

function setupDAGLayoutHelper:buildJunctions()
	self.junctions = { }
	for vnode, _ in pairs(self.virtualnodes) do
		if vnode.numsuccessors == 1 and next(vnode.successors).row == vnode.row then
			-- virtual node just connects left and right column in the same row, we can skip it
			local successor, succslot = next(vnode.successors)
			local predecessor, predslot = next(vnode.predecessors)
			-- detach vnode from graph
			predecessor.successors[vnode] = nil
			successor.predecessors[vnode] = nil
			successor.originalnode.predecessors[vnode.originalnode] = nil
			vnode.successors[successor] = nil
			vnode.predecessors[predecessor] = nil
			vnode.originalnode.predecessors[predecessor.originalnode] = nil
			vnode.numpredecessors = 0
			vnode.numsuccessors = 0
			-- connect predecessor and successor directly
			predecessor.successors[successor] = succslot
			successor.predecessors[predecessor] = predslot
			successor.originalnode.predecessors[predecessor.originalnode] = predslot
		else
			-- keep this virtual node as a junction
			table.insert(self.junctions, vnode.originalnode)
		end
	end
end

---------------------------------------------------------------------------------
-- Cell Formatting
---------------------------------------------------------------------------------

-- Don't use the result in calculations! If ReadText(1001, 105) is not ".", lua will not be able to interpret this as a number!
function Helper.roundStr(x, digits)
	-- round with optional number of decimal digits
	if digits and digits > 0 then
		local mult = 10^digits
		local strdecimalpoint = ReadText(1001, 105)
		if (x < 0) then
			x = math.floor((-x) * mult + 0.5)
			local i = math.floor(x / mult)
			x = x - i * mult
			return string.format("%s%d%s%0"..digits.."d", "-", i, strdecimalpoint, x)
		else
			x = math.floor(x * mult + 0.5)
			local i = math.floor(x / mult)
			x = x - i * mult
			return string.format("%d%s%0"..digits.."d", i, strdecimalpoint, x)
		end
	else
		return math.floor(x + 0.5)
	end
end
	
function Helper.percent(x, digits)
	-- Convert from decimal fraction to percent number 
	-- and round with optional number of decimal digits
	return Helper.round(x * 100, digits)
end

function Helper.diffpercent(x, isbuyoffer)
	-- Convert from decimal fraction to percent number
	-- and round with optional number of decimal digits
	-- and prefix with + or -
	local val
	if isbuyoffer then
		val = math.floor(x)
	else
		val = math.ceil(x)
	end
	if x > 0 then
		val = "+" .. val
	end
	return val
end

function Helper.interpolatePriceColor(ware, price, isselloffer, darkbasecolor)
	-- In case both selloffer and buyoffer exist, we can show both offer amounts, but everything else can be shown only for one offer.
	-- In that case prefer selloffer data (for buying - change to buyoffer when player attempts to sell)
	local avgprice, minprice, maxprice = GetWareData(ware, "avgprice", "minprice", "maxprice")
	-- Get interpolated price color
	local avgcolor = Helper.color.white
	local mincolor = (isselloffer and Helper.color.lightgreen or Helper.color.orange)
	local maxcolor = (isselloffer and Helper.color.orange or Helper.color.lightgreen)
	local color = avgcolor
	local lerpfactor = 0
	if avgprice ~= 0 and minprice < avgprice and maxprice > avgprice and price ~= avgprice then
		price = math.min(maxprice, math.max(minprice, price))
		if price > avgprice then
			color = maxcolor
			lerpfactor = (price - avgprice) / (maxprice - avgprice)
		else
			color = mincolor
			lerpfactor = (price - avgprice) / (minprice - avgprice)
		end
		--print(ware .. " min=" .. minprice .. " avg=" .. avgprice .. " max=" .. maxprice .. " (price=" .. price .. " => lerpfactor " .. lerpfactor .. ")")
	end
	-- Make price color darker if requested
	darkbasecolor = darkbasecolor or Helper.color.white
	return {
		r = (avgcolor.r - lerpfactor * (avgcolor.r - color.r)) * darkbasecolor.r / Helper.color.white.r,
		g = (avgcolor.g - lerpfactor * (avgcolor.g - color.g)) * darkbasecolor.g / Helper.color.white.g,
		b = (avgcolor.b - lerpfactor * (avgcolor.b - color.b)) * darkbasecolor.b / Helper.color.white.b,
		a = (avgcolor.a - lerpfactor * (avgcolor.a - color.a)) * darkbasecolor.a / Helper.color.white.a
	}
end

function Helper.timeDuration(x)
	-- Convert from XTIME to days, hours, minutes or seconds
	x = Helper.round(x)
	if x > 119 then
		x = Helper.round(x / 60)
		if x > 119 then
			x = Helper.round(x / 60)
			if x > 47 then
				x = Helper.round(x / 24)
				return x .. " " .. ReadText(1001, 104) -- days
			else
				return x .. " " .. ReadText(1001, 102) -- hours
			end
		else
			return x .. " " .. ReadText(1001, 103) -- minutes
		end
	else
		return x .. " " .. ReadText(1001, 100) -- seconds
	end
end
		
function Helper.getStatusBar(hullpercentage, height, fullwidth, noscaling, nogradient)
	local color = Helper.color.slidervalue
	if not nogradient then
		if hullpercentage <= 33 then
			color = Helper.statusRed
		elseif hullpercentage <= 66 then
			color = Helper.statusOrange
		elseif hullpercentage <= 99 then
			color = Helper.statusYellow
		else
			color = Helper.statusGreen
		end
	end
	if hullpercentage == 0 then
		hullpercentage = 1
	end
	return Helper.createIcon("solid", noscaling, color.r, color.g, color.b, color.a, 0, 0, height, hullpercentage * fullwidth / 100)
end
		
function Helper.unlockInfo(unlocked, cellcontent)
	if unlocked then
		return cellcontent
	else
		return ReadText(1001, 3210)
	end
end
		
function Helper.estimateString(estimated)
	if estimated then
		return ReadText(1001, 70) .. " "
	else
		return ""
	end
end

function Helper.sortName(a, b, invert)
	if invert then
		return a.name > b.name
	else
		return a.name < b.name
	end
end

function Helper.sortHullAndName(a, b, invert)
	if a.hull == b.hull then
		return Helper.sortName(a, b)
	end
	if invert then
		return a.hull > b.hull
	else
		return a.hull < b.hull
	end
end

function Helper.sortRelationAndName(a, b, invert)
	if a.relation == b.relation then
		return Helper.sortName(a, b)
	end
	if invert then
		return a.relation > b.relation
	else
		return a.relation < b.relation
	end
end

function Helper.sortNameSectorAndObjectID(a, b, invert)
	local sector_a_name = a.sector or ""
	local sector_b_name = b.sector or ""
	if sector_a_name == sector_b_name then
		return Helper.sortNameAndObjectID(a, b, invert)
	else
		if invert then
			return sector_a_name > sector_b_name
		else
			return sector_a_name < sector_b_name
		end
	end
end

function Helper.sortNameAndObjectID(a, b, invert)
	if (a.fleetname or b.fleetname) and (a.fleetname ~= b.fleetname) then
		if a.fleetname and b.fleetname then
			if invert then
				return a.fleetname > b.fleetname
			else
				return a.fleetname < b.fleetname
			end
		end
		return a.fleetname ~= nil
	end
	if a.name == b.name then
		if invert then
			return a.objectid > b.objectid
		else
			return a.objectid < b.objectid
		end
	end
	if invert then
		return a.name > b.name
	else
		return a.name < b.name
	end
end

function Helper.sortShipsByClassAndPurpose(a, b, invert)
	local aclass = Helper.classOrder[a.class] or 0
	local bclass = Helper.classOrder[b.class] or 0
	if aclass == bclass then
		local apurpose = (a.purpose ~= "") and Helper.purposeOrder[a.purpose] or 0
		local bpurpose = (b.purpose ~= "") and Helper.purposeOrder[b.purpose] or 0
		if apurpose == bpurpose then
			if invert then
				return a.name .. a.objectid > b.name .. b.objectid
			else
				return a.name .. a.objectid < b.name .. b.objectid
			end
		end
		if invert then
			return apurpose > bpurpose
		else
			return apurpose < bpurpose
		end
	else
		if invert then
			return aclass > bclass
		else
			return aclass < bclass
		end
	end
end

function Helper.sortID(a, b)
	return a.id < b.id
end

function Helper.sortWareName(a, b)
	local aname = GetWareData(a, "name")
	local bname = GetWareData(b, "name")

	return aname < bname
end

function Helper.sortWareSortOrder(a, b)
	local asortorder, aname = GetWareData(a, "sortorder", "name")
	local bsortorder, bname = GetWareData(b, "sortorder", "name")

	if asortorder == bsortorder then
		return aname < bname
	end
	return asortorder > bsortorder
end

function Helper.sortComponentName(a, b)
	local aname = GetComponentData(a, "name")
	local bname = GetComponentData(b, "name")

	return aname < bname
end

function Helper.sortMacroName(a, b)
	local aname = GetMacroData(a, "name")
	local bname = GetMacroData(b, "name")

	return aname < bname
end

function Helper.sortMacroRaceAndShortname(a, b)
	local ashortname, amakerrace, amk = GetMacroData(a, "shortname", "makerrace", "mk")
	local aracestring = ""
	for i, racestring in ipairs(amakerrace) do
		aracestring = aracestring .. ((i == 1) and "\n" or " - ") .. racestring
	end
	local bshortname, bmakerrace, bmk = GetMacroData(b, "shortname", "makerrace", "mk")
	local bracestring = ""
	for i, racestring in ipairs(bmakerrace) do
		bracestring = bracestring .. ((i == 1) and "\n" or " - ") .. racestring
	end

	if aracestring == bracestring then
		if ashortname == bshortname then
			return amk < bmk
		end
		return ashortname < bshortname
	end
	return aracestring < bracestring
end

function Helper.sortFactionName(a, b)
	local aname = GetFactionData(a, "name")
	local bname = GetFactionData(b, "name")

	return aname < bname
end

function Helper.sortUniverseIDName(a, b)
	local aname = ffi.string(C.GetComponentName(a))
	local bname = ffi.string(C.GetComponentName(b))

	if aname == bname then
		if C.IsComponentClass(a, "object") and C.IsComponentClass(b, "object") then
			return ffi.string(C.GetObjectIDCode(a)) < ffi.string(C.GetObjectIDCode(b))
		end
	end

	return aname < bname
end

function Helper.sortEntityTypeAndName(a, b)
	local a_entitytype, a_name = GetComponentData(a, "typename", "name")
	local b_entitytype, b_name = GetComponentData(b, "typename", "name")
	if a_entitytype == b_entitytype then
		return a_name < b_name
	else
		return a_entitytype < b_entitytype
	end
end

function Helper.sortETA(a, b)
	if (a.eta < 0) then
		return false
	elseif (b.eta < 0) then
		return true
	end
	return a.eta < b.eta
end

function Helper.sortPlayerMacro(a, b)
	if a.race == b.race then
		if a.gender == b.gender then
			return a.macro > b.macro
		else
			local agender = Helper.genderSorting[a.gender] or 0
			local bgender = Helper.genderSorting[b.gender] or 0
			return agender < bgender
		end
	else
		local arace = Helper.raceSorting[a.race] or 0
		local brace = Helper.raceSorting[b.race] or 0
		return arace < brace
	end
end

-- compare slots by their upgradetype first, slotsize in descending order second and by sizecount in ascending order third
function Helper.sortSlots(a, b)
	local atype = 0
	local btype = 0
	-- upgradetype is only added in the ship modification menu
	if a.upgradetype then
		atype = Helper.slotTypeOrder[a.upgradetype] or 0
	end
	if b.upgradetype then
		btype = Helper.slotTypeOrder[b.upgradetype] or 0
	end

	local asize = Helper.slotSizeOrder[a.slotsize] or 0
	local bsize = Helper.slotSizeOrder[b.slotsize] or 0
	if atype == btype then
		if asize == bsize then
			return a.sizecount < b.sizecount
		end
		return asize < bsize
	end
	return atype < btype
end

function Helper.orderedKeys(t, sorter)
	local orderedKey = {}
	for key in pairs(t) do
		table.insert(orderedKey, key)
	end
	table.sort(orderedKey, sorter)
	return orderedKey
end

function Helper.orderedNext(t, state)
	if state == nil then
		t.orderedKeys = Helper.orderedKeys(t)
		key = t.orderedKeys[1]
		if key then
			return key, t[key]
		end
		t.orderedKeys = nil
		return
	end
	key = nil
	for i = 1,table.getn(t.orderedKeys) do
		if t.orderedKeys[i] == state then
			key = t.orderedKeys[i + 1]
		end
	end
	if key then
		return key, t[key]
	end
	t.orderedKeys = nil
	return
end

function Helper.orderedPairs(t)
	return Helper.orderedNext, t, nil
end

function Helper.revOrderedNext(t, state)
	if state == nil then
		t.orderedKeys = Helper.orderedKeys(t)
		key = t.orderedKeys[table.getn(t.orderedKeys)]
		return key, t[key]
	end
	key = nil
	for i = table.getn(t.orderedKeys), 1, -1 do
		if t.orderedKeys[i] == state then
			key = t.orderedKeys[i-1]
		end
	end
	if key then
		return key, t[key]
	end
	t.orderedKeys = nil
	return
end

function Helper.revOrderedPairs(t)
	return Helper.revOrderedNext, t, nil
end

function Helper.orderedNextByWareName(t, state)
	if state == nil then
		t.orderedKeys = Helper.orderedKeys(t, sortWareName)
		key = t.orderedKeys[1]
		if key then
			return key, t[key]
		end
		t.orderedKeys = nil
		return
	end
	key = nil
	for i = 1,table.getn(t.orderedKeys) do
		if t.orderedKeys[i] == state then
			key = t.orderedKeys[i + 1]
		end
	end
	if key then
		return key, t[key]
	end
	t.orderedKeys = nil
	return
end

function Helper.orderedPairsByWareName(t)
	return Helper.orderedNextByWareName, t, nil
end

function Helper.convertGameTimeToXTimeString(time)
	-- offset to 825-02-08 11:00
	time = time + 824 * 31104000 + 1 * 2592000 + 7 * 86400 + 11 * 3600

	local timestring = math.ceil(time / 31104000) .. "-"
	time = time % 31104000
	timestring = timestring .. string.format("%02d", math.ceil(time / 2592000)) .. "-"
	time = time % 2592000
	timestring = timestring .. string.format("%02d", math.ceil(time / 86400)) .. " "
	time = time % 86400
	timestring = timestring .. string.format("%02d", math.floor(time / 3600)) .. ":"
	time = time % 3600
	timestring = timestring .. string.format("%02d", math.floor(time / 60))

	return timestring
end

function Helper.getPassedTime(time)
	local passedtime = C.GetCurrentGameTime() - time
	if passedtime < 0 then
		print("Helper.getPassedTime(): given time is in the future. Returning empty result")
		return ""
	end

	-- kuertee start:
	if passedtime < 60 * 60 then
		local timeformat = ReadText(1001, 209)
		return ConvertTimeString(passedtime, timeformat)
	end
	-- kuertee end

	local timeformat = ReadText(1001, 211)
	if passedtime < 3600 then
		timeformat = ReadText(1001, 213)
	elseif passedtime < 3600 * 24 then
		timeformat = ReadText(1001, 212)
	end

	return ConvertTimeString(passedtime, timeformat)
end

function Helper.getPassedUTCTime(time)
	local passedtime = tonumber(C.GetCurrentUTCDataTime() - time)
	if passedtime < 0 then
		print("Helper.getPassedUTCTime(): given time is in the future. Returning empty result")
		return ""
	end

	local timeformat = ReadText(1001, 216)
	if passedtime < 3600 then
		timeformat = ReadText(1001, 213)
	elseif passedtime < 3600 * 24 then
		timeformat = ReadText(1001, 212)
	end

	return ConvertTimeString(passedtime, timeformat)
end

function Helper.getUTCTime(time)
	local passedtime = tonumber(time - C.GetCurrentUTCDataTime())
	if passedtime < 0 then
		print("Helper.getUTCTime(): given time is in the past. Returning empty result")
		return ""
	end

	local timeformat = ReadText(1001, 206)
	if passedtime < 3600 then
		timeformat = ReadText(1001, 207)
	elseif passedtime < 3600 * 24 then
		timeformat = ReadText(1001, 210)
	end

	return ConvertTimeString(passedtime, timeformat)
end

function Helper.getSuitableControlEntities(object, getshiptrader, onlynpcs)
	local entities = {}

	local pilot, tradenpc, shiptrader = GetComponentData(object, "pilot", "tradenpc", "shiptrader")
	if (not onlynpcs) or IsComponentClass(pilot, "npc") then
		table.insert(entities, pilot)
	end
	if (not onlynpcs) or IsComponentClass(tradenpc, "npc") then
		table.insert(entities, tradenpc)
	end
	if getshiptrader and ((not onlynpcs) or IsComponentClass(shiptrader, "npc")) then
		table.insert(entities, shiptrader)
	end

	return entities
end

function Helper.parseAICommand(entity)
	local poststring, aicommand, aicommandparam = GetComponentData(entity, "poststring", "aicommand", "aicommandparam")
	local container = GetContextByClass(entity, "container")
	if poststring == "manager" then
		aicommand = string.format(ReadText(1001, 4204), GetComponentData(container, "name"))
	elseif poststring == "defence" then
		local blackboard_attackenemies = GetNPCBlackboard(entity, "$config_attackenemies")
		blackboard_attackenemies = blackboard_attackenemies and blackboard_attackenemies ~= 0
		if blackboard_attackenemies then
			aicommand = ReadText(1001, 4214)
		else
			aicommand = ReadText(1001, 4213)
		end
	else
		aicommand = string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)
	end

	return aicommand
end

function Helper.comparePositions(pos1, pos2, deviation)
	local diff = { x = pos1[1] - pos2[1], y = pos1[2] - pos2[2] }
	local lengthsq = diff.x * diff.x + diff.y * diff.y

	return lengthsq > (deviation * deviation)
end

function Helper.convertColorToText(color)
	return string.format("\027#FF%02x%02x%02x#", color.r, color.g, color.b)
end

function Helper.formatOptionalShortcut(format, inputtype, inputid, fallback)
	local inputname = GetLocalizedKeyName(inputtype, inputid)
	if inputname ~= "" then
		return string.format(format, inputname)
	end
	-- input is not mapped, return fallback or empty string
	return fallback or ""
end

-- skill: 0-15
function Helper.displaySkill(skill, usebold, noemptystars)
	local result = ""

	local bold = ""
	if usebold then
		bold = "_bold"
	end

	local int, frac = math.modf(skill / 3)

	-- full stars
	result = result .. string.rep("\27[menu_star_04" .. bold .. "]", int)
	if frac > 0.66 then
		-- 2/3 star
		result = result .. "\27[menu_star_03" .. bold .. "]"
	elseif frac > 0.33 then
		-- 1/3 star
		result = result .. "\27[menu_star_02" .. bold .. "]"
	elseif 5 - int > 0 then
		-- empty star
		if not noemptystars then
			result = result .. "\27[menu_star_01" .. bold .. "]"
		end
	end
	-- empty stars
	if not noemptystars then
		if 5 - int - 1 > 0 then
			result = result .. string.rep("\27[menu_star_01" .. bold .. "]", 5 - int - 1)
		end
	end

	return result
end

-- keeping it simple, no metatables, using __pairs method
function Helper.tableCopy(orig, levels)
	if levels == nil then
		levels = 2
	end

	local result
	if (levels > 0) and (type(orig) == "table") then
		result = {}
		for k, v in pairs(orig) do
			result[k] = Helper.tableCopy(orig[k], levels - 1)
		end
	else
		result = orig
	end
	return result
end

function Helper.tableLength(value)
	local count = 0
	for _ in pairs(value) do
		count = count + 1
	end
	return count
end

-- DO NOT USE with string datatypes
function Helper.ffiVLA(result, vlaType, vlaSizeFunction, vlaFunction, ...)
	local n = vlaSizeFunction(...)
	if n > 0 then
		local buf = ffi.new(vlaType .. "[?]", n)
		n = vlaFunction(buf, n, ...)

		for i = 0, n - 1 do
			table.insert(result, buf[i])
		end
	end
end

Helper.ffiTempStorage = { }

-- Keep a lua reference for every variable created by ffi.new() - otherwise it may be gc'd too early
function Helper.ffiNewHelper(...)
	local result = ffi.new(...)
	table.insert(Helper.ffiTempStorage, result)
	return result
end

function Helper.ffiNewString(string)
	return Helper.ffiNewHelper("const char[?]", #string + 1, string)
end

function Helper.ffiClearNewHelper()
	Helper.ffiTempStorage = {}
end

function Helper.textArrayHelper(texts, func, keyword)
	local textArray
	if #texts > 0 then
		textArray = ffi.new("const char*[?]", #texts)
		for i, entry in ipairs(texts) do
			local text = entry
			if keyword then
				text = entry[keyword]
			end
			textArray[i - 1] = Helper.ffiNewString(text)
		end
	end

	local result = func(#texts, textArray)
	Helper.ffiClearNewHelper()
	return result
end

-- Result can be used as Color argument in FFI function calls
function Helper.ffiColor(color)
	return { red = color.r, green = color.g, blue = color.b, alpha = color.a }
end

---------------------------------------------------------------------------------
-- Loadouts
---------------------------------------------------------------------------------

Helper.upgradetypes = { 
	{ supertype = "macro",			type = "engine",			category = "engines",			mergeslots = true,	allowempty = false,	emode = "Equipment",								pseudogroup = true, 
		text =			{ small = ReadText(1001, 8087),	medium = ReadText(1001, 8088),	large = ReadText(1001, 8089),	extralarge = ReadText(1001, 8090) },
		shorttext =		{ small = ReadText(1001, 51),	medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
	},
	{ supertype = "group",			type = "enginegroup",		category = "engines",			mergeslots = true,	allowempty = false,	emode = "Equipment",	grouptype = "engine",		pseudogroup = true, 
		text =			{ default = ReadText(1001, 8071),	small = ReadText(1001, 8504),	medium = ReadText(1001, 8505),	large = ReadText(1001, 8506),	extralarge = ReadText(1001, 8507) },
		shorttext =		{ default = "",						small = ReadText(1001, 51),		medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
		headertext =	{ default = ReadText(1001, 1103),	small = ReadText(1001, 8087),	medium = ReadText(1001, 8088),	large = ReadText(1001, 8089),	extralarge = ReadText(1001, 8090) },
		nonetext =		{ default = ReadText(1001, 8565) },
	},
	{ supertype = "virtualmacro",	type = "thruster",			category = "thrusters",			mergeslots = true,	allowempty = false,	emode = "Equipment", 
		text =			{ small = ReadText(1001, 8091),	medium = ReadText(1001, 8092),	large = ReadText(1001, 8093),	extralarge = ReadText(1001, 8094) },
		shorttext =		{ small = ReadText(1001, 51),	medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
	},
	{ supertype = "macro",			type = "shield",			category = "shields",			mergeslots = false,	allowempty = true,	emode = "Equipment", 
		text =			{ default = ReadText(1001, 1317),	small = ReadText(1001, 8083),	medium = ReadText(1001, 8084),	large = ReadText(1001, 8085),	extralarge = ReadText(1001, 8086) },
		shorttext =		{ default = "",						small = ReadText(1001, 51),		medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
	},
	{ supertype = "macro",			type = "weapon",			category = "weapons",			mergeslots = false,	allowempty = true,	emode = "Weapons", 
		text =			{ small = ReadText(1001, 8075),	medium = ReadText(1001, 8076),	large = ReadText(1001, 8077),	extralarge = ReadText(1001, 8078) },
		shorttext =		{ small = ReadText(1001, 51),	medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
	}, 
	{ supertype = "macro",			type = "turret",			category = "turrets",			mergeslots = false,	allowempty = true,	emode = "Weapons", 
		text =			{ small = ReadText(1001, 8079),	medium = ReadText(1001, 8080),	large = ReadText(1001, 8081),	extralarge = ReadText(1001, 8082) },
		shorttext =		{ small = ReadText(1001, 51),	medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
	}, 
	{ supertype = "group",			type = "turretgroup",		category = "turretgroups",		mergeslots = false,	allowempty = true,	emode = "Weapons",		grouptype = "turret",		pseudogroup = false, 
		text =			{ default = ReadText(1001, 8070),	small = ReadText(1001, 8095),	medium = ReadText(1001, 8096),	large = ReadText(1001, 8097),	extralarge = ReadText(1001, 8098) },
		shorttext =		{ default = "", 					small = ReadText(1001, 51),		medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
		headertext =	{ default = ReadText(1001, 1319),	small = ReadText(1001, 8079),	medium = ReadText(1001, 8080),	large = ReadText(1001, 8081),	extralarge = ReadText(1001, 8082) },
		nonetext =		{ default = ReadText(1001, 8564) },
	},
	{ supertype = "group",			type = "shieldgroup",		category = "shieldgroups",		mergeslots = false,	allowempty = true,	emode = "Equipment",	grouptype = "shield",		pseudogroup = false, 
		text =			{ default = ReadText(1001, 8072),	small = ReadText(1001, 8099),	medium = ReadText(1001, 8501),	large = ReadText(1001, 8502),	extralarge = ReadText(1001, 8503) },
		shorttext =		{ default = "",						small = ReadText(1001, 51),		medium = ReadText(1001, 50),	large = ReadText(1001, 49),		extralarge = ReadText(1001, 48) },
		headertext =	{ default = ReadText(1001, 1317),	small = ReadText(1001, 8083),	medium = ReadText(1001, 8084),	large = ReadText(1001, 8085),	extralarge = ReadText(1001, 8086) },
		nonetext =		{ default = ReadText(1001, 8566) },
	},
	{ supertype = "ammo",			type = "missile",			category = "missiles",			mergeslots = false,	allowempty = true,	emode = "Weapons",		exclude = {} },
	{ supertype = "ammo",			type = "drone",				category = "drones",			mergeslots = false,	allowempty = true,	emode = "Ships",		exclude = { "marine", "police" } },
	{ supertype = "ammo",			type = "deployable",		category = "deployables",		mergeslots = false,	allowempty = true,	emode = "Equipment",	exclude = {} },
	{ supertype = "ammo",			type = "countermeasure",	category = "countermeasures",	mergeslots = false,	allowempty = true,	exclude = {} },
	{ supertype = "software",		type = "software",			category = "software",			mergeslots = false,	allowempty = true,	emode = "Equipment" },
	{ supertype = "crew",			type = "crew",				category = "crew",				mergeslots = false,	allowempty = true },
}

function Helper.findUpgradeType(type)
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.type == type then
			return upgradetype
		end
	end
end

function Helper.findUpgradeTypeByGroupType(grouptype)
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.grouptype == grouptype then
			return upgradetype
		end
	end
end

function Helper.getSlotSizeText(slotsize)
	if slotsize == "extralarge" then
		return ReadText(1001, 48)
	elseif slotsize == "large" then
		return ReadText(1001, 49)
	elseif slotsize == "medium" then
		return ReadText(1001, 50)
	elseif slotsize == "small" then
		return ReadText(1001, 51)
	end

	return ""
end

function Helper.getClassText(class)
	if class == "ship_xl" then
		return ReadText(1001, 48)
	elseif class == "ship_l" then
		return ReadText(1001, 49)
	elseif class == "ship_m" then
		return ReadText(1001, 50)
	elseif class == "ship_s" then
		return ReadText(1001, 51)
	elseif class == "ship_xs" then
		return ReadText(1001, 52)
	end

	return ""
end

function Helper.getLoadoutHelper(getLoadout, getLoadoutCounts, ...)
	return Helper.getLoadoutHelper2(getLoadout, getLoadoutCounts, nil, ...)
end

function Helper.getLoadoutHelper2(getLoadout, getLoadoutCounts, loadoutType, ...)
	if loadoutType == nil then
		loadoutType = "UILoadout"
	end
	local countsType = "UILoadoutCounts"
	local macroDataType = "UILoadoutMacroData"
	local groupDataType = "UILoadoutGroupData"
	if loadoutType == "UILoadout2" then
		countsType = "UILoadoutCounts2"
		macroDataType = "UILoadoutMacroData2"
		groupDataType = "UILoadoutGroupData2"
	end

	local loadout = ffi.new(loadoutType)
	local counts = ffi.new(countsType)
	local n = getLoadoutCounts(counts, ...)
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			local cat = upgradetype.category
			loadout["num" .. cat] = counts["num" .. cat]
			loadout[cat] = Helper.ffiNewHelper(macroDataType .. "[?]", counts["num" .. cat])
		elseif upgradetype.supertype == "group" then
			if not upgradetype.pseudogroup then
				local cat = upgradetype.category
				loadout["num" .. cat] = counts["num" .. cat]
				loadout[cat] = Helper.ffiNewHelper(groupDataType .. "[?]", counts["num" .. cat])
			end
		elseif upgradetype.supertype == "ammo" then
			if upgradetype.type == "missile" or upgradetype.type == "deployable" or upgradetype.type == "countermeasure" then
				loadout.numammo = counts.numammo
				loadout.ammo = Helper.ffiNewHelper("UILoadoutAmmoData[?]", counts.numammo)
			elseif upgradetype.type == "drone" then
				loadout.numunits = counts.numunits
				loadout.units = Helper.ffiNewHelper("UILoadoutAmmoData[?]", counts.numunits)
			end
		elseif upgradetype.supertype == "software" then
			local cat = upgradetype.category
			loadout["num" .. cat] = counts["num" .. cat]
			loadout[cat] = Helper.ffiNewHelper("UILoadoutSoftwareData[?]", counts["num" .. cat])
		elseif upgradetype.supertype == "virtualmacro" then
			if upgradetype.type == "thruster" then
				loadout.thruster = Helper.ffiNewHelper("UILoadoutVirtualMacroData")
				loadout.thruster.macro = ""
			end
		elseif upgradetype.supertype == "crew" then
			if loadoutType == "UILoadout2" then
				local cat = upgradetype.category
				loadout["num" .. cat] = counts["num" .. cat]
				loadout[cat] = Helper.ffiNewHelper("UILoadoutCrewData[?]", counts["num" .. cat])
			end
		end
	end
	getLoadout(loadout, ...)

	return loadout
end

function Helper.convertLoadout(object, macro, loadout, softwaredata, loadoutType)
	if loadoutType == nil then
		loadoutType = "UILoadout"
	end

	local upgradeplan = {}

	local groups = {}
	local groupdata = {}
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		upgradeplan[upgradetype.type] = {}
		if upgradetype.supertype == "macro" then
			local cat = upgradetype.category
			for i = 0, loadout["num" .. cat] - 1 do
				local slot = tonumber(loadout[cat][i].slot) + 1
				local macro = ffi.string(loadout[cat][i].macro)
				if loadoutType == "UILoadout2" then
					local ammomacro = ffi.string(loadout[cat][i].weaponsetting.ammomacroname)
					local weaponmode = ffi.string(loadout[cat][i].weaponsetting.weaponmode)
					upgradeplan[upgradetype.type][slot] = { macro = macro, ammomacro = ammomacro, weaponmode = weaponmode }
				else
					upgradeplan[upgradetype.type][slot] = macro
				end
			end
		elseif upgradetype.supertype == "group" then
			-- just generate group data here and put it in the plan later
			if not upgradetype.pseudogroup then
				local cat = upgradetype.category
				groupdata[upgradetype.type] = {}
				for i = 0, loadout["num" .. cat] - 1 do
					groups[ffi.string(loadout[cat][i].group)] = { path = ffi.string(loadout[cat][i].path), group = ffi.string(loadout[cat][i].group) }
					local ammomacro, weaponmode
					if loadoutType == "UILoadout2" then
						ammomacro = ffi.string(loadout[cat][i].weaponsetting.ammomacroname)
						weaponmode = ffi.string(loadout[cat][i].weaponsetting.weaponmode)
					end
					table.insert(groupdata[upgradetype.type], { macro = ffi.string(loadout[cat][i].macro), count = loadout[cat][i].count, path = ffi.string(loadout[cat][i].path), group = ffi.string(loadout[cat][i].group), ammomacro = ammomacro, weaponmode = weaponmode })
				end
			end
		elseif upgradetype.supertype == "ammo" then
			if upgradetype.type == "missile" or upgradetype.type == "deployable" or upgradetype.type == "countermeasure" then
				for i = 0, loadout.numammo - 1 do
					local macro = ffi.string(loadout.ammo[i].macro)
					local amount = tonumber(loadout.ammo[i].amount)
					upgradeplan[upgradetype.type][macro] = amount
				end
			elseif upgradetype.type == "drone" then
				for i = 0, loadout.numunits - 1 do
					local macro = ffi.string(loadout.units[i].macro)
					local amount = tonumber(loadout.units[i].amount)
					upgradeplan[upgradetype.type][macro] = amount
				end
			end
		elseif upgradetype.supertype == "software" then
			local cat = upgradetype.category
			if (loadout["num" .. cat] > 0) and (softwaredata ~= nil) then
				for i = 0, loadout["num" .. cat] - 1 do
					local ware = ffi.string(loadout[cat][i].ware)
					local maxware = ffi.string(C.GetSoftwareMaxCompatibleVersion(object, macro, ware))
					for i, entry in ipairs(softwaredata[upgradetype.type]) do
						if entry.maxsoftware == maxware then
							upgradeplan[upgradetype.type][i] = ware
							break
						end
					end
				end
			elseif (loadout["num" .. cat] > 0) then
				DebugError("Converting a loadout containing software information with invalid software data in the menu. [Florian]")
			end
		elseif upgradetype.supertype == "virtualmacro" then
			if upgradetype.type == "thruster" then
				if loadoutType == "UILoadout2" then
					upgradeplan[upgradetype.type][1] = { macro = ffi.string(loadout.thruster.macro) }
				else
					upgradeplan[upgradetype.type][1] = ffi.string(loadout.thruster.macro)
				end
			end
		elseif upgradetype.supertype == "crew" then
			if loadoutType == "UILoadout2" then
				local cat = upgradetype.category
				if loadout["num" .. cat] > 0 then
					for i = 0, loadout["num" .. cat] - 1 do
						local role = ffi.string(loadout[cat][i].roleid)
						local count = loadout[cat][i].count
						upgradeplan[upgradetype.type][role] = count
					end
				end
			end
		end
	end

	-- crew experience
	if loadoutType == "UILoadout2" then
		upgradeplan.hascrewexperience = loadout.hascrewexperience
	end

	-- put group data into the plan
	local i = 1
	for group, groupinfo in pairs(groups) do
		for _, upgradetype in ipairs(Helper.upgradetypes) do
			if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
				local found = false
				for _, data in ipairs(groupdata[upgradetype.type]) do
					if data.group == group then
						upgradeplan[upgradetype.type][i] = data
						found = true
						break
					end
				end
				if not found then
					upgradeplan[upgradetype.type][i] = { macro = "", count = 0, path = groupinfo.path, group = groupinfo.group }
				end
			end
		end
		i = i + 1
	end

	-- handle pseudogroups
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if (upgradetype.supertype == "group") and upgradetype.pseudogroup then
			local i = 1
			for slot, slotdata in pairs(upgradeplan[upgradetype.grouptype]) do
				local slotmacro = slotdata
				if loadoutType == "UILoadout2" then
					slotmacro = slotdata.macro
				end
				local groupinfo = C.GetUpgradeSlotGroup(object, macro, upgradetype.grouptype, slot)
				local path = ffi.string(groupinfo.path)
				local group = ffi.string(groupinfo.group)
				if (path ~= "..") or (group ~= "") then
					if upgradetype.mergeslots then
						upgradeplan[upgradetype.type][i] = { macro = slotmacro, count = #upgradeplan[upgradetype.grouptype], path = path, group = group }
						break
					else
						local found = false
						for j, groupdata in ipairs(upgradeplan[upgradetype.type]) do
							if (groupdata.path == path) and (groupdata.group == group) then
								found = true
								upgradeplan[upgradetype.type][j].count = upgradeplan[upgradetype.type][j].count + 1
								break
							end
						end
						if not found then
							upgradeplan[upgradetype.type][i] = { macro = slotmacro, count = 1, path = path, group = group }
							i = i + 1
						end
					end
				end
			end
		end
	end

	return upgradeplan
end

function Helper.callLoadoutFunction(upgradeplan, crewplan, func, clear, loadoutType)
	if loadoutType == nil then
		loadoutType = "UILoadout"
	end
	local macroDataType = "UILoadoutMacroData"
	local groupDataType = "UILoadoutGroupData"
	if loadoutType == "UILoadout2" then
		macroDataType = "UILoadoutMacroData2"
		groupDataType = "UILoadoutGroupData2"
	end

	local loadout = ffi.new(loadoutType)

	local ammocount = 0
	local unitcount = 0

	for plantype, slots in pairs(upgradeplan) do
		local upgradetype = Helper.findUpgradeType(plantype)
		if upgradetype then
			if upgradetype.supertype == "macro" then
				local cat = upgradetype.category

				local count = 0
				if next(slots) then
					if type(slots[next(slots)]) == "table" then
						for slot, data in pairs(slots) do
							if data.macro ~= "" then
								count = count + 1
							end
						end
					else
						for slot, macro in pairs(slots) do
							if macro ~= "" then
								count = count + 1
							end
						end
					end
				end

				loadout["num" .. cat] = count
				loadout[cat] = Helper.ffiNewHelper(macroDataType .. "[?]", count)

				if next(slots) then
					local i = 0
					if type(slots[next(slots)]) == "table" then
						for slot, data in pairs(slots) do
							if data.macro ~= "" then
								loadout[cat][i].macro = Helper.ffiNewString(data.macro)
								loadout[cat][i].upgradetypename = Helper.ffiNewString(plantype)
								loadout[cat][i].slot = slot - 1
								loadout[cat][i].optional = false
								if loadoutType == "UILoadout2" then
									loadout[cat][i].weaponsetting.ammomacroname = Helper.ffiNewString(data.ammomacro)
									loadout[cat][i].weaponsetting.weaponmode = Helper.ffiNewString(data.weaponmode)
								end
								i = i + 1
							end
						end
					else
						for slot, macro in pairs(slots) do
							if macro ~= "" then
								loadout[cat][i].macro = Helper.ffiNewString(macro)
								loadout[cat][i].upgradetypename = Helper.ffiNewString(plantype)
								loadout[cat][i].slot = slot - 1
								loadout[cat][i].optional = false
								i = i + 1
							end
						end
					end
				end
			elseif upgradetype.supertype == "group" then
				if not upgradetype.pseudogroup then
					local cat = upgradetype.category

					local count = 0
					for slot, data in pairs(slots) do
						if data.macro ~= "" then
							count = count + 1
						end
					end

					loadout["num" .. cat] = count
					loadout[cat] = Helper.ffiNewHelper(groupDataType .. "[?]", count)

					if next(slots) then
						local i = 0
						for slot, data in pairs(slots) do
							if data.macro ~= "" then
								loadout[cat][i].macro = Helper.ffiNewString(data.macro)
								loadout[cat][i].path = Helper.ffiNewString(data.path)
								loadout[cat][i].group = Helper.ffiNewString(data.group)
								loadout[cat][i].count = data.count
								loadout[cat][i].optional = false
								if loadoutType == "UILoadout2" then
									loadout[cat][i].weaponsetting.ammomacroname = Helper.ffiNewString(data.ammomacro)
									loadout[cat][i].weaponsetting.weaponmode = Helper.ffiNewString(data.weaponmode)
								end
								i = i + 1
							end
						end
					end
				end
			elseif upgradetype.supertype == "ammo" then
				if upgradetype.type == "missile" or upgradetype.type == "deployable" or upgradetype.type == "countermeasure" then
					for macro, amount in pairs(slots) do
						if amount > 0 then
							ammocount = ammocount + 1
						end
					end
				elseif upgradetype.type == "drone" then
					for macro, amount in pairs(slots) do
						if amount > 0 then
							unitcount = unitcount + 1
						end
					end
				end
			elseif upgradetype.supertype == "software" then
				local cat = upgradetype.category

				local count = 0
				for slot, ware in pairs(slots) do
					if ware ~= "" then
						count = count + 1
					end
				end

				loadout["num" .. cat] = count
				loadout[cat] = Helper.ffiNewHelper("UILoadoutSoftwareData[?]", count)

				if next(slots) then
					local i = 0
					for slot, ware in pairs(slots) do
						if ware ~= "" then
							loadout[cat][i].ware = Helper.ffiNewString(ware)
							i = i + 1
						end
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				if upgradetype.type == "thruster" then
					if slots[1] then
						if type(slots[1]) == "table" then
							loadout.thruster = Helper.ffiNewHelper("UILoadoutVirtualMacroData")
							loadout.thruster.macro = Helper.ffiNewString(slots[1].macro)
							loadout.thruster.optional = false
						else
							loadout.thruster = Helper.ffiNewHelper("UILoadoutVirtualMacroData")
							loadout.thruster.macro = Helper.ffiNewString(slots[1])
							loadout.thruster.optional = false
						end
					end
				end
			elseif upgradetype.supertype == "crew" then
				if loadoutType == "UILoadout2" then
					local cat = upgradetype.category

					local count = 0
					for slot, ware in pairs(slots) do
						if ware ~= "" then
							count = count + 1
						end
					end

					loadout["num" .. cat] = count
					loadout[cat] = Helper.ffiNewHelper("UILoadoutCrewData[?]", count)

					if next(slots) then
						local i = 0
						for role, count in pairs(slots) do
							if role ~= "" then
								loadout[cat][i].roleid = Helper.ffiNewString(role)
								loadout[cat][i].count = count
								loadout[cat][i].optional = false
								i = i + 1
							end
						end
					end
				end
			end
		end
	end

	loadout.numammo = ammocount
	loadout.ammo = Helper.ffiNewHelper("UILoadoutAmmoData[?]", ammocount)

	local i = 0
	for plantype, slots in pairs(upgradeplan) do
		local upgradetype = Helper.findUpgradeType(plantype)
		if upgradetype and upgradetype.supertype == "ammo" then
			if upgradetype.type == "missile" or upgradetype.type == "deployable" or upgradetype.type == "countermeasure" then
				for macro, amount in pairs(slots) do
					if amount > 0 then
						loadout.ammo[i].macro = Helper.ffiNewString(macro)
						loadout.ammo[i].amount = amount
						loadout.ammo[i].optional = false
						i = i + 1
					end
				end
			end
		end
	end

	loadout.numunits = unitcount
	loadout.units = Helper.ffiNewHelper("UILoadoutAmmoData[?]", unitcount)

	local i = 0
	for plantype, slots in pairs(upgradeplan) do
		local upgradetype = Helper.findUpgradeType(plantype)
		if upgradetype and upgradetype.supertype == "ammo" then
			if upgradetype.type == "drone" then
				for macro, amount in pairs(slots) do
					if amount > 0 then
						loadout.units[i].macro = Helper.ffiNewString(macro)
						loadout.units[i].amount = amount
						loadout.units[i].optional = false
						i = i + 1
					end
				end
			end
		end
	end

	-- crew experience
	if loadoutType == "UILoadout2" then
		loadout.hascrewexperience = upgradeplan.hascrewexperience == true
	end

	local crewtransfer = ffi.new("CrewTransferInfo2")
	if crewplan then
		-- added
		crewtransfer.numadded = #crewplan.hireddetails
		crewtransfer.added = Helper.ffiNewHelper("CrewTransferContainer2[?]", #crewplan.hireddetails)
		for i, entry in pairs(crewplan.hireddetails) do
			crewtransfer.added[i - 1].newroleid = Helper.ffiNewString(entry.newrole)
			crewtransfer.added[i - 1].amount = entry.amount
			crewtransfer.added[i - 1].price = entry.price
		end
		-- removed
		crewtransfer.numremoved = #crewplan.fired
		crewtransfer.removed = Helper.ffiNewHelper("CrewTransferContainer2[?]", #crewplan.fired)
		for i, entry in pairs(crewplan.fired) do
			crewtransfer.removed[i - 1].seed = entry.npc
			crewtransfer.removed[i - 1].price = entry.price
		end
		-- transferred
		crewtransfer.numtransferred = #crewplan.transferdetails
		crewtransfer.transferred = Helper.ffiNewHelper("CrewTransferContainer2[?]", #crewplan.transferdetails)
		for i, entry in pairs(crewplan.transferdetails) do
			crewtransfer.transferred[i - 1].newroleid = Helper.ffiNewString(entry.newrole)
			crewtransfer.transferred[i - 1].seed = entry.npc
			crewtransfer.transferred[i - 1].price = entry.price
		end
	end

	local result = func(loadout, crewtransfer)
	if clear ~= false then
		Helper.ffiClearNewHelper()
	end
	return result
end

function Helper.convertLoadoutStats(stats)
	local result = {}
	result.HullValue = stats.HullValue
	result.ShieldValue = stats.ShieldValue
	result.ShieldRate = stats.ShieldRate
	result.ShieldDelay = stats.ShieldDelay
	result.GroupedShieldValue = stats.GroupedShieldValue
	result.GroupedShieldRate = stats.GroupedShieldRate
	result.GroupedShieldDelay = stats.GroupedShieldDelay
	result.BurstDPS = stats.BurstDPS
	result.SustainedDPS = stats.SustainedDPS
	result.TurretBurstDPS = stats.TurretBurstDPS
	result.TurretSustainedDPS = stats.TurretSustainedDPS
	result.GroupedTurretBurstDPS = stats.GroupedTurretBurstDPS
	result.GroupedTurretSustainedDPS = stats.GroupedTurretSustainedDPS
	result.ForwardSpeed = stats.ForwardSpeed
	result.BoostSpeed = stats.BoostSpeed
	result.TravelSpeed = stats.TravelSpeed
	result.YawSpeed = stats.YawSpeed * 180 / math.pi				-- rad -> deg conversion
	result.PitchSpeed = stats.PitchSpeed * 180 / math.pi			-- rad -> deg conversion
	result.RollSpeed = stats.RollSpeed * 180 / math.pi				-- rad -> deg conversion
	result.HorizontalStrafeSpeed = stats.HorizontalStrafeSpeed
	result.VerticalStrafeSpeed = stats.VerticalStrafeSpeed
	result.ForwardAcceleration = stats.ForwardAcceleration
	result.HorizontalStrafeAcceleration = stats.HorizontalStrafeAcceleration
	result.VerticalStrafeAcceleration = stats.VerticalStrafeAcceleration
	result.NumDocksShipMedium = stats.NumDocksShipMedium
	result.NumDocksShipSmall = stats.NumDocksShipSmall
	result.ShipCapacityMedium = stats.ShipCapacityMedium
	result.ShipCapacitySmall = stats.ShipCapacitySmall
	result.CrewCapacity = stats.CrewCapacity
	result.ContainerCapacity = stats.ContainerCapacity
	result.SolidCapacity = stats.SolidCapacity
	result.LiquidCapacity = stats.LiquidCapacity
	result.CondensateCapacity = stats.CondensateCapacity
	result.UnitCapacity = stats.UnitCapacity
	result.MissileCapacity = stats.MissileCapacity
	result.CountermeasureCapacity = stats.CountermeasureCapacity
	result.DeployableCapacity = stats.DeployableCapacity
	result.RadarRange = stats.RadarRange / 1000						-- m -> km conversíon

	return result
end

function Helper.modPropertyEvalFloat(basevalue, value)
	return string.format("%+.2f%%", (value - basevalue) * 100)
end

function Helper.modPropertyEvalUINT(basevalue, value)
	return string.format("%+d", value - basevalue)
end

function Helper.modPropertyEval2Float(basevalue, value, color, value2, color2)
	local colorstring  = Helper.convertColorToText(color)
	local colorstring2 = Helper.convertColorToText(color2)
	return string.format(ReadText(1001, 8041), colorstring, (value - basevalue) * 100, colorstring2, (value2 - basevalue) * 100)
end

function Helper.modPropertyEval2UINT(basevalue, value, color, value2, color2)
	local colorstring  = Helper.convertColorToText(color)
	local colorstring2 = Helper.convertColorToText(color2)
	return string.format(ReadText(1001, 8042), colorstring, value - basevalue, colorstring2, value2 - basevalue)
end

Helper.modProperties = {
	["engine"] = {},
	["shield"] = {},
	["ship"]   = {},
	["weapon"] = {},
}

for class, entries in pairs(Helper.modProperties) do
	local n = C.GetNumAllEquipmentModProperties(class)
	local buf = ffi.new("EquipmentModPropertyInfo[?]", n)
	n = C.GetAllEquipmentModProperties(buf, n, class)
	for i = 0, n - 1 do
		local entry = {
			key = ffi.string(buf[i].id),
			text = ffi.string(buf[i].name),
			pos_effect = buf[i].poseffect,
			basevalue = buf[i].basevalue,
			type = ffi.string(buf[i].propdatatype),
		}
		if entry.type == "Float" then
			entry.eval  = function (...) return Helper.modPropertyEvalFloat(entry.basevalue, ...) end
			entry.eval2 = function (...) return Helper.modPropertyEval2Float(entry.basevalue, ...) end
		elseif entry.type == "UINT" then
			entry.eval  = function (...) return Helper.modPropertyEvalUINT(entry.basevalue, ...) end
			entry.eval2 = function (...) return Helper.modPropertyEval2UINT(entry.basevalue, ...) end
		end
		table.insert(entries, entry)
	end
end

Helper.modQualities = {
	[1] = { name = ReadText(20110, 1001), nonetext = ReadText(1001, 8576), paintname = ReadText(1001, 8580), paintnonetext = ReadText(1001, 8511), icon = "mods_grade_circle_01", icon2 = "mods_grade_01", category = "basic",		color = { r =  30, g = 255, b =   0, a = 100 }, price =  50000 },
	[2] = { name = ReadText(20110, 1101), nonetext = ReadText(1001, 8577), paintname = ReadText(1001, 8581), paintnonetext = ReadText(1001, 8512), icon = "mods_grade_circle_02", icon2 = "mods_grade_02", category = "advanced",		color = { r =  64, g = 154, b = 255, a = 100 }, price = 100000 },
	[3] = { name = ReadText(20110, 1201), nonetext = ReadText(1001, 8578), paintname = ReadText(1001, 8582), paintnonetext = ReadText(1001, 8513), icon = "mods_grade_circle_03", icon2 = "mods_grade_03", category = "exceptional",	color = { r = 181, g =  72, b = 208, a = 100 }, price = 250000 },
}

function Helper.getInstalledModInfo(type, component, context, group, isgroup)
	local installedmod = {}
	local hasinstalledmod = false
	local buf
	local modtype
	if type == "engine" then
		buf = ffi.new("UIEngineMod")
		hasinstalledmod = C.GetInstalledEngineMod(component, buf)
	elseif type == "shield" then
		buf = ffi.new("UIShieldMod")
		hasinstalledmod = C.GetInstalledShieldMod(component, context, group, buf)
	elseif (type == "turret") and isgroup then
		buf = ffi.new("UIWeaponMod")
		hasinstalledmod = C.GetInstalledGroupedWeaponMod(component, context, group, buf)
		modtype = "weapon"
	elseif type == "ship" then
		buf = ffi.new("UIShipMod2")
		hasinstalledmod = C.GetInstalledShipMod2(component, buf)
	elseif (type == "weapon") or (type == "turret") then
		buf = ffi.new("UIWeaponMod")
		hasinstalledmod = C.GetInstalledWeaponMod(component, buf)
		modtype = "weapon"
	else
		DebugError("Unknown equipment mod type '" .. type .. "'.")
		return
	end

	if hasinstalledmod then
		installedmod.Name = ffi.string(buf.Name)
		installedmod.RawName = ffi.string(buf.RawName)
		installedmod.Ware = ffi.string(buf.Ware)
		installedmod.PropertyType = ffi.string(buf.PropertyType)

		installedmod.Quality = buf.Quality
		for _, entry in ipairs(Helper.modProperties[modtype or type]) do
			installedmod[entry.key] = buf[entry.key]
		end
	end

	return hasinstalledmod, installedmod
end

Helper.topLevelMenus = {
	{ id = "options",		name = ReadText(1001, 8105),	icon = "tlt_optionsmenu",		menu = "OptionsMenu",		helpOverlayID = "toplevel_options",			helpOverlayText = ReadText(1028, 8101), param = "toplevel", },
	{ id = "terraforming",	name = ReadText(1001, 3800),	icon = "tlt_terraforming",		menu = "TerraformingMenu",	helpOverlayID = "toplevel_terraforming",	helpOverlayText = ReadText(1028, 8109), param = {0, 0, "$hqcluster$" },						canterraform = true },
	{ id = "research",		name = ReadText(1001, 8103),	icon = "tlt_research",			menu = "ResearchMenu",		helpOverlayID = "toplevel_research",		helpOverlayText = ReadText(1028, 8102), param = {0, 0},										canresearch = true },
	{ id = "playerinfo",	name = ReadText(1001, 8102),	icon = "tlt_playerinfo",		menu = "PlayerInfoMenu",	helpOverlayID = "toplevel_playerinfo",		helpOverlayText = ReadText(1028, 8103), param = {0, 0} },
	{ id = "docked",		name = ReadText(1001, 8106),	icon = "tlt_docked",			menu = "DockedMenu",		helpOverlayID = "toplevel_docked",			helpOverlayText = ReadText(1028, 8104), param = {0, 0},										needsdock = true },
	{ id = "cockpit",		name = ReadText(1001, 8601),	icon = "tlt_shipinteractions",	menu = "DockedMenu",		helpOverlayID = "toplevel_cockpit",			helpOverlayText = ReadText(1028, 8105), param = {0, 0},										needsdock = false },
	{ id = "map",			name = ReadText(1001, 8101),	icon = "tlt_map",				menu = "MapMenu",			helpOverlayID = "toplevel_map",				helpOverlayText = ReadText(1028, 8106), param = {0, 0, true} },
	{ id = "multiversemap",	name = ReadText(1001, 11623),	icon = "vt_season",				menu = "MapMenu",			helpOverlayID = "toplevel_multiversemap",	helpOverlayText = ReadText(1028, 8110), param = {0, 0, true, nil, nil, nil, nil, true},		isonline = true },
	{ id = "encyclopedia",	name = ReadText(1001, 8104),	icon = "tlt_encyclopedia",		menu = "EncyclopediaMenu",	helpOverlayID = "toplevel_encyclopedia",	helpOverlayText = ReadText(1028, 8107), param = {0, 0} },
	{ id = "help",			name = ReadText(1001, 8701),	icon = "tlt_help",				menu = "HelpMenu",			helpOverlayID = "toplevel_help",			helpOverlayText = ReadText(1028, 8108), param = {0, 0},										demo = false },
}

function Helper.createTopLevelConfig()
	Helper.topLevelConfig = {
		numDisplayedIcons = 5,
		iconSize = Helper.scaleX(Helper.sidebarWidth),
		arrowWidth = Helper.scaleX(10),
		inputSize = Helper.scaleX(100),
		y = 25,
		font = Helper.standardFontOutlined,
		bgColor = Helper.color.transparent,
		scrolling = false,
	}
	Helper.topLevelConfig.numColumns = Helper.topLevelConfig.numDisplayedIcons + 4

	local width = Helper.topLevelConfig.numDisplayedIcons * Helper.topLevelConfig.iconSize + 2 * Helper.topLevelConfig.arrowWidth + 2 * Helper.topLevelConfig.inputSize + (Helper.topLevelConfig.numDisplayedIcons + 3) * Helper.borderSize
	Helper.topLevelConfig.x = Helper.viewWidth / 2 - width / 2
end

function Helper.checkTopLevelConditions(entry)
	local isdocked = false
	local currentplayership = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	if currentplayership ~= 0 then
		if GetComponentData(currentplayership, "isdocked") then
			isdocked = true
		end
	else
		local currentcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(C.GetPlayerID(), "container", false)))
		if (not C.IsComponentClass(currentcontainer, "ship")) or GetComponentData(currentcontainer, "isdocked") then
			isdocked = true
		end
	end

	if (entry.needsdock ~= nil) and (entry.needsdock ~= isdocked) then
		return false
	end
	if (entry.demo ~= nil) and (entry.demo ~= C.IsDemoVersion()) then
		return false
	end
	if (entry.canresearch ~= nil) and (entry.canresearch ~= C.CanResearch()) then
		return false
	end
	if (entry.canterraform ~= nil) then
		local stationhqlist = {}
		Helper.ffiVLA(stationhqlist, "UniverseID", C.GetNumHQs, C.GetHQs, "player")
		local hq = stationhqlist[1] or 0

		if hq == 0 then
			return not entry.canterraform
		end

		local hqcluster = C.GetContextByClass(hq, "cluster", false)
		return GetComponentData(ConvertStringTo64Bit(tostring(hqcluster)), "hasterraforming") and (C.GetNumTerraformingProjects(hqcluster, false) > 0)
	end
	if (entry.isonline ~= nil) and (entry.isonline ~= (C.AreVenturesCompatible() and (C.IsVentureSeasonSupported() or C.WasSessionOnline()))) then
		return false
	end
	return true
end

function Helper.getTopLevelMenuIndex(index, offset)
	local iteration = 0
	local newindex = index
	repeat
		if offset > 0 then
			if newindex + 1 > #Helper.topLevelMenus then
				newindex = 1
			else
				newindex = newindex + 1
			end
		elseif offset < 0 then
			if newindex - 1 < 1 then
				newindex = #Helper.topLevelMenus
			else
				newindex = newindex - 1
			end
		end

		local entry = Helper.topLevelMenus[newindex]
		if Helper.checkTopLevelConditions(entry) then
			iteration = iteration + 1
		end

		if iteration >= math.abs(offset) then
			return newindex
		end
	until newindex == index
end

function Helper.addDisplayedMenu(array, index, offset)
	if offset then
		local newindex = Helper.getTopLevelMenuIndex(index, offset)
		if newindex then
			array[3 + offset] = { index = newindex, data = Helper.topLevelMenus[newindex] }
		end
	else
		local entry = Helper.topLevelMenus[index]
		if Helper.checkTopLevelConditions(entry) then
			table.insert(array, { index = index, data = entry })
		end
	end
end

function Helper.createTopLevelTab(menu, id, frame, overrideText, locked, noreturn)
	if C.IsGameOver() then
		return 0, 0
	end
	local currentIndex = 0
	local displayedMenus = {}
	for i, menuEntry in ipairs(Helper.topLevelMenus) do
		if menuEntry.id == id then
			currentIndex = i
			if Helper.topLevelConfig.scrolling then
				Helper.addDisplayedMenu(displayedMenus, i, -2)
				Helper.addDisplayedMenu(displayedMenus, i, -1)
				Helper.addDisplayedMenu(displayedMenus, i,  0)
				Helper.addDisplayedMenu(displayedMenus, i,  1)
				Helper.addDisplayedMenu(displayedMenus, i,  2)
				break
			end
		end
		if not Helper.topLevelConfig.scrolling then
			Helper.addDisplayedMenu(displayedMenus, i)
		end
	end
	if (id ~= "") and (currentIndex == 0) then
		DebugError("Unknown top level menu id '" .. id .. "'.")
		return
	end

	local numDisplayedIcons = Helper.topLevelConfig.numDisplayedIcons
	local numColumns = Helper.topLevelConfig.numColumns
	local countoffset = 2
	local x = Helper.topLevelConfig.x
	local width = 0
	if not Helper.topLevelConfig.scrolling then
		numDisplayedIcons = #displayedMenus
		numColumns = numDisplayedIcons + 2
		countoffset = 1
		width = numDisplayedIcons * Helper.topLevelConfig.iconSize + 2 * Helper.topLevelConfig.inputSize + (numDisplayedIcons + 1) * Helper.borderSize
		x = Helper.viewWidth / 2 - width / 2
	end

	local ftable = frame:addTable(numColumns, { tabOrder = 20, x = x, y = Helper.topLevelConfig.y, scaling = false, reserveScrollBar = false, skipTabChange = true })
	ftable:setColWidth(1, Helper.topLevelConfig.inputSize)
	for i = 1, numDisplayedIcons do
		ftable:setColWidth(i + countoffset, Helper.topLevelConfig.iconSize)
	end
	ftable:setColWidth(numColumns, Helper.topLevelConfig.inputSize)
	ftable:setDefaultBackgroundColSpan(1, numColumns)
	if Helper.topLevelConfig.scrolling then
		ftable:setColWidth(2, Helper.topLevelConfig.arrowWidth)
		ftable:setColWidth(numColumns - 1, Helper.topLevelConfig.arrowWidth)
	end

	-- icons
	local row = ftable:addRow(true, { fixed = true, borderBelow = false, bgColor = Helper.topLevelConfig.bgColor })
	local name = ffi.string(C.GetMappedInputName("INPUT_ACTION_WIDGET_TABSCROLL_LEFT"))
	if GetControllerInfo() ~= "mouseCursor" then
		row[1]:createText(name, { scaling = true, fontsize = Helper.titleFontSize, y = (Helper.sidebarWidth - Helper.titleHeight) / 2, halign = "right" })
	end
	for i, menuEntry in ipairs(displayedMenus) do
		local color = Helper.color.grey
		if Helper.topLevelConfig.scrolling then
			if i == 3 then
				color = Helper.color.white
			end
		else
			if menuEntry.index == currentIndex then
				color = Helper.color.white
			end
		end
		row[i + countoffset]:createButton({ active = not locked, height = Helper.topLevelConfig.iconSize, bgColor = Helper.color.transparent, mouseOverText = menuEntry.data.name, helpOverlayID = menuEntry.data.helpOverlayID, helpOverlayText = menuEntry.data.helpOverlayText }):setIcon(menuEntry.data.icon, { color = color })
		if Helper.topLevelConfig.scrolling then
			if i ~= 3 then
				row[i + countoffset].handlers.onClick = function() return Helper.scrollTopLevelInternal(menu, currentIndex, i - 3, noreturn) end
			else
				row[i + countoffset].properties.active = true
			end
		else
			if menuEntry.index ~= currentIndex then
				row[i + countoffset].handlers.onClick = function() return Helper.scrollTopLevelInternal(menu, menuEntry.index, nil, noreturn) end
			else
				row[i + countoffset].properties.active = true
			end
		end
	end
	local name = ffi.string(C.GetMappedInputName("INPUT_ACTION_WIDGET_TABSCROLL_RIGHT"))
	if GetControllerInfo() ~= "mouseCursor" then
		row[numColumns]:createText(name, { scaling = true, fontsize = Helper.titleFontSize, y = (Helper.sidebarWidth - Helper.titleHeight) / 2 })
	end
	if Helper.topLevelConfig.scrolling then
		row[2]:createButton({ height = Helper.topLevelConfig.iconSize, bgColor = Helper.color.transparent }):setIcon("table_arrow_inv_left")
		row[2].handlers.onClick = function() return Helper.scrollTopLevelInternal(menu, currentIndex, -1) end
		row[numColumns - 1]:createButton({ height = Helper.topLevelConfig.iconSize, bgColor = Helper.color.transparent }):setIcon("table_arrow_inv_right")
		row[numColumns - 1].handlers.onClick = function() return Helper.scrollTopLevelInternal(menu, currentIndex, 1) end
	end

	-- menu name
	local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Helper.topLevelConfig.bgColor, scaling = true })
	local name = (currentIndex ~= 0) and Helper.topLevelMenus[currentIndex].name or ""
	if overrideText ~= "" then
		name = overrideText
	end
	row[1]:setColSpan(numColumns):createText(name, { halign = "center", x = 0, font = Helper.topLevelConfig.font })

	return ftable:getFullHeight() + ftable.properties.y, width
end

function Helper.scrollTopLevel(menu, id, offset)
	for i, menuEntry in ipairs(Helper.topLevelMenus) do
		if menuEntry.id == id then
			Helper.scrollTopLevelInternal(menu, i, offset, true)
			break
		end
	end
end

function Helper.evaluateTopLevelParamHelper(param)
	if param == "$hqcluster$" then
		local stationhqlist = {}
		Helper.ffiVLA(stationhqlist, "UniverseID", C.GetNumHQs, C.GetHQs, "player")
		local hq = stationhqlist[1] or 0
		if hq ~= 0 then
			param = C.GetContextByClass(hq, "cluster", false)
		end
	end
	return param
end

function Helper.evaluateTopLevelParam(params)
	local locparams
	if type(params) == "table" then
		locparams = {}
		for i, param in pairs(params) do
			locparams[i] = Helper.evaluateTopLevelParamHelper(param)
		end
	else
		locparams = Helper.evaluateTopLevelParamHelper(params)
	end
	return locparams
end

function Helper.scrollTopLevelInternal(menu, index, offset, noreturn)
	if offset then
		local newindex = Helper.getTopLevelMenuIndex(index, offset)
		if newindex then
			local param = Helper.evaluateTopLevelParam(Helper.topLevelMenus[newindex].param)
			Helper.closeMenuAndOpenNewMenu(menu, Helper.topLevelMenus[newindex].menu, param, noreturn)
			menu.cleanup()
		end
	else
		local param = Helper.evaluateTopLevelParam(Helper.topLevelMenus[index].param)
		Helper.closeMenuAndOpenNewMenu(menu, Helper.topLevelMenus[index].menu, param, noreturn)
		menu.cleanup()
	end
end

function Helper.createPlayerInfoConfig()
	Helper.playerInfoConfig = {
		width = math.min(0.3 * Helper.viewWidth, Helper.scaleX(960)),
		height = 3 * (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize),
		offsetX = Helper.frameBorder,
		offsetY = Helper.frameBorder,
		fontname = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
	}
end

function Helper.playerInfoConfigTextLeft(_, width, ismultiverse)
	local playername = ffi.string(C.GetPlayerName())
	if Helper.isPlayerCovered() then
		playername = Helper.convertColorToText(Helper.color.cover) .. GetFactionData(ffi.string(C.GetPlayerCoverFaction()), "name") .. " (" .. ReadText(1001, 11603) .. ")\27X"
	end

	local connectionStatus = ""
	if C.IsOnlineEnabled() then
		connectionStatus = (Helper.isOnlineGame() and OnlineHasSession()) and (ReadText(1001, 11624) .. " \27[vt_connected]") or (ReadText(1001, 11625) .. " \27[vt_disconnected]")
	end
	local connectedtextwidth = C.GetTextWidth(connectionStatus .. " ", Helper.playerInfoConfig.fontname, Helper.playerInfoConfig.fontsize)
	playername = TruncateText(playername, Helper.playerInfoConfig.fontname, Helper.playerInfoConfig.fontsize, width or Helper.playerInfoConfig.width - Helper.playerInfoConfig.height - 2 * Helper.borderSize - connectedtextwidth)

	if ismultiverse then
		return playername .. "\n" .. ReadText(1001, 11340) .. ReadText(1001, 120) .. "\n" .. ReadText(1001, 11325) .. ReadText(1001, 120)
	else
		local playermoney = ConvertMoneyString(GetPlayerMoney(), false, true, nil, true) .. " " .. ReadText(1001, 101)
		local gametime = Helper.convertGameTimeToXTimeString(C.GetCurrentGameTime()) .. (C.IsSetaActive() and " \27G(" .. ReadText(1001, 3255) .. ")\27X" or "")

		return playername .. "\n" .. gametime .. "\n" .. playermoney
	end
end

function Helper.playerInfoConfigTextRight(_, ismultiverse)
	local connectionStatus = ""
	if C.AreVenturesEnabled() then
		if OnlineIsCurrentTeamValid() then
			connectionStatus = (Helper.isOnlineGame() and OnlineHasSession()) and "\27[vt_connected]" or "\27O\27[vt_disconnected]\27X"
		else
			connectionStatus = (Helper.isOnlineGame() and OnlineHasSession()) and (ReadText(1001, 11624) .. " \27[vt_connected]") or ("\27O" .. ReadText(1001, 11625) .. " \27[vt_disconnected]\27X")
		end
	end

	if ismultiverse then
		return connectionStatus .. "\n" .. Helper.ventureSeasonTimeLeftText() .. "\n" .. Helper.ventureOperationTimeLeftText()
	else
		local curtime = getElapsedTime()
		local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
		local playerhighway = C.GetContextByClass(C.GetPlayerID(), "highway", false)
		if (playersector == 0) and (playerhighway ~= 0) then
			-- super-highway case, show destination sector
			playersector = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(playerhighway)), "destinationsector"))
		end
		-- expensive, only check every 5 seconds
		if (not Helper.playerInfoConfigTimer) or (Helper.playerInfoConfigTimer < curtime) then
			Helper.playerInfoConfigTimer = curtime + 5
			local trademoneydue = tonumber(C.GetCreditsDueFromPlayerTrades())
			local buildmoneydue = tonumber(C.GetCreditsDueFromPlayerBuilds())

			if (trademoneydue > 0) and (buildmoneydue > 0) then
				Helper.playermoneyduetext = ReadText(1001, 7747)
			elseif trademoneydue > 0 then
				Helper.playermoneyduetext = ReadText(1001, 7704)
			elseif buildmoneydue > 0 then
				Helper.playermoneyduetext = ReadText(1001, 7746)
			else
				Helper.playermoneyduetext = nil
			end
			Helper.rawplayermoneydue = trademoneydue + buildmoneydue
		end
		local playermoneyduetext = ""
		if Helper.rawplayermoneydue > 0 then
			local playermoneydue = ConvertMoneyString(Helper.rawplayermoneydue, false, true, nil, true) .. " " .. ReadText(1001, 101)

			local playermoney = ConvertMoneyString(GetPlayerMoney(), false, true, nil, true) .. " " .. ReadText(1001, 101)
			local playermoneywidth = C.GetTextWidth(playermoney .. " ", Helper.playerInfoConfig.fontname, Helper.playerInfoConfig.fontsize)
			playermoneyduetext = TruncateText("(" .. string.format(Helper.playermoneyduetext, playermoneydue) .. ")", Helper.playerInfoConfig.fontname, Helper.playerInfoConfig.fontsize, Helper.playerInfoConfig.width - Helper.playerInfoConfig.height - 2 * Helper.borderSize - playermoneywidth)
		end

		return connectionStatus .. "\n" .. ffi.string(C.GetComponentName(playersector)) .. "\n" .. playermoneyduetext
	end
end

function Helper.getPlayerLogoColor()
	local color = Helper.color.white
	if Helper.isPlayerCovered() then
		color = Helper.color.cover
	end
	return color
end

Helper.shipComparisonData = {}

function Helper.clearShipComparisonData()
	Helper.shipComparisonData = {}
end

function Helper.getShipComparisonMacro(id)
	return Helper.shipComparisonData[id] and Helper.shipComparisonData[id].macro
end

function Helper.getShipComparisonUpgradeplan(id)
	return Helper.shipComparisonData[id] and Helper.shipComparisonData[id].upgradeplan
end

function Helper.addShipComparison(id, macro, upgradeplan)
	Helper.shipComparisonData[id] = { macro = macro, upgradeplan = upgradeplan }
end

function Helper.removeShipComparison(id)
	table.remove(Helper.shipComparisonData, id)
end

function Helper.createScriptValueWrapper(type, value)
	return { __egoScriptValueWrapper = true, type = type, value = value }
end

Helper.equipmentCompatibilities = {
	[1] = { tag = "standard",		color = { r = 255, g = 255, b = 255, a = 100 } },
	[2] = { tag = "missile",		color = { r = 129, g = 214, b = 139, a = 100 } },
	[3] = { tag = "mining",			color = { r = 52,  g = 129, b = 187, a = 100 } },
	[4] = { tag = "highpower",		color = { r = 214, g = 129, b = 187, a = 100 } },
	[5] = { tag = "venture",		color = { r = 196, g = 147, b = 84,  a = 100 } },
	[6] = { tag = "boron",			color = { r = 84,  g = 196, b = 188, a = 100 } },
}

Helper.transactionLogConfig = {
	numdatapoints = 100,
	factors = { 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000 },
	point = {
		type = "square",
		size = 8,
		highlightSize = 8,
	},
	line = {
		type = "normal",
		size = 2,
		highlightSize = 4,
	},
	zoomSteps = {
		{ zoom = 1,			granularity = 5 },
		{ zoom = 2,			granularity = 10 },
		{ zoom = 5,			granularity = 30 },
		{ zoom = 10,		granularity = 60 },
		{ zoom = 30,		granularity = 180 },
		{ zoom = 60,		granularity = 300 },
		{ zoom = 180,		granularity = 1200 },
		{ zoom = 360,		granularity = 1800 },
		{ zoom = 720,		granularity = 3600 },
		{ zoom = 1440,		granularity = 7200 },
		{ zoom = 2880,		granularity = 21600 },
		{ zoom = 5040,		granularity = 43200 },
		{ zoom = 10080,		granularity = 86400 },
	},
	transactionLogPage = 100,
}

function Helper.buttonExpandTransactionEntry(buttondata, row, refreshCallback)
	if Helper.transactionLogData.expandedEntries[buttondata] then
		Helper.transactionLogData.expandedEntries[buttondata] = nil
	else
		Helper.transactionLogData.expandedEntries[buttondata] = true
	end
	Helper.transactionLogData.curEntry = buttondata
	refreshCallback()
end

function Helper.buttonTransactionLogZoom(direction, refreshCallback)
	Helper.transactionLogData.xZoom = math.max(0, math.min(#Helper.transactionLogConfig.zoomSteps, Helper.transactionLogData.xZoom + direction))
	local zoom = Helper.transactionLogConfig.zoomSteps[Helper.transactionLogData.xZoom].zoom
	Helper.transactionLogData.xGranularity = Helper.transactionLogConfig.zoomSteps[Helper.transactionLogData.xZoom].granularity
	if Helper.transactionLogData.xZoom <= 2 then
		Helper.transactionLogData.xScale = 1
		Helper.transactionLogData.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 100) .. "]"
	elseif Helper.transactionLogData.xZoom <= 7 then
		Helper.transactionLogData.xScale = 60
		Helper.transactionLogData.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 103) .. "]"
	elseif Helper.transactionLogData.xZoom <= 11 then
		Helper.transactionLogData.xScale = 3600
		Helper.transactionLogData.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 102) .. "]"
	else
		Helper.transactionLogData.xScale = 24 * 3600
		Helper.transactionLogData.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 104) .. "]"
	end

	refreshCallback()
end

function Helper.editboxTransactionLogPage(text, textchanged, refreshCallback)
	local newpage = tonumber(text)
	if newpage and (newpage ~= Helper.transactionLogData.curPage) then
		Helper.transactionLogData.curEntry = nil
		Helper.transactionLogData.curPage = math.max(1, math.min(newpage, Helper.transactionLogData.numPages))
		refreshCallback()
	else
		C.SetEditBoxText(Helper.transactionLogData.pageEditBox.id, Helper.transactionLogData.curPage .. " / " .. Helper.transactionLogData.numPages)
	end
end

function Helper.transactionLogSearchHelper(entry, text)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.eventtypename), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.description), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.partnername), text, 1, true) then
		return true
	end

	return false
end

function Helper.graphDataSelection(data, refreshCallback)
	local entryid = Helper.transactionLogData.graphdata[data[4]].entryid
	local preventryid
	if data[4] > 1 then
		preventryid = Helper.transactionLogData.graphdata[data[4] - 1].entryid
	end
	local transactionIndex = Helper.transactionLogData.transactionsByIDUnfiltered[entryid]
	if not transactionIndex and entryid < 0 and #Helper.transactionLogData.accountLogUnfiltered > 0 then
		-- no transaction found for condensed entry - use first non-condensed entry
		transactionIndex = 1
	end
	local prevTransactionIndex = 1
	if preventryid then
		prevTransactionIndex = Helper.transactionLogData.transactionsByIDUnfiltered[preventryid]
	end
	if not prevTransactionIndex and preventryid < 0 and #Helper.transactionLogData.accountLogUnfiltered > 0 then
		-- no transaction found for condensed entry - use first non-condensed entry
		prevTransactionIndex = 1
	end

	local mostSignificantEntry
	if transactionIndex and prevTransactionIndex then
		if prevTransactionIndex < transactionIndex then
			-- if the previous transactionlog index is smaller than the current, skip this index, as it is part of the previous data point not the current
			--  prevTimeInterval  |  curTimeInterval
			-- [ ..., prevEntry ] | [ ..., curEntry ]
			prevTransactionIndex = prevTransactionIndex + 1
		end
		for i = prevTransactionIndex, transactionIndex do
			local entry = Helper.transactionLogData.accountLogUnfiltered[i]
			if (Helper.transactionLogData.searchtext == "") or Helper.transactionLogData.transactionsByID[entry.entryid] then
				if (mostSignificantEntry == nil) or (mostSignificantEntry.value < math.abs(entry.money)) then
					mostSignificantEntry = { entry = entry.entryid, value = math.abs(entry.money) }
				end
			end
		end
	end

	Helper.transactionLogData.curEntry = mostSignificantEntry and mostSignificantEntry.entry or entryid
	refreshCallback()
end

function Helper.onTransactionLogUpdate()
	if Helper.transactionLogData.curEntry then
		local dataIdx
		for i, point in pairs(Helper.transactionLogData.graphdata) do
			dataIdx = i
			if point.entryid > 0 and point.entryid >= Helper.transactionLogData.curEntry then
				break
			elseif Helper.transactionLogData.curEntry < 0 and point.entryid <= Helper.transactionLogData.curEntry then
				break
			end
		end
		if dataIdx then
			Helper.transactionLogData.graph:selectDataPoint(1, dataIdx, true)
		end
	end
end

function Helper.onTransactionLogRowChanged(rowdata)
	if rowdata and (type(rowdata) ~= "string") then
		Helper.transactionLogData.curEntry = rowdata
	end
end

function Helper.onTransactionLogEditBoxActivated(widget)
	Helper.transactionLogData.noupdate = true
	if Helper.transactionLogData.pageEditBox and (widget == Helper.transactionLogData.pageEditBox.id) then
		C.SetEditBoxText(Helper.transactionLogData.pageEditBox.id, tostring(Helper.transactionLogData.curPage))
	end
end

function Helper.createTransactionLog(frame, container, tableProperties, refreshCallback, selectionData)
	Helper.transactionLogData = {
		accountLog = {},
		accountLogUnfiltered = {},
		transactionsByID = {},
		transactionsByIDUnfiltered = {},
		graphdata = {},

		xZoom = Helper.transactionLogData and Helper.transactionLogData.xZoom or 6,
		xScale = Helper.transactionLogData and Helper.transactionLogData.xScale or 60,
		xGranularity = Helper.transactionLogData and Helper.transactionLogData.xGranularity or 300,
		xTitle = Helper.transactionLogData and Helper.transactionLogData.xTitle or (ReadText(1001, 6519) .. " [" .. ReadText(1001, 103) .. "]"),
		expandedEntries = Helper.transactionLogData and Helper.transactionLogData.expandedEntries or {},
		searchtext = Helper.transactionLogData and Helper.transactionLogData.searchtext or "",
		curPage = Helper.transactionLogData and Helper.transactionLogData.curPage or 1,
		curEntry = Helper.transactionLogData and Helper.transactionLogData.curEntry or nil,

		numPages = 1,
		pageEditBox = nil,
		graph = nil,
		noupdate = nil,
	}

	local endtime = C.GetCurrentGameTime()
	local starttime = math.max(0, endtime - 60 * Helper.transactionLogConfig.zoomSteps[Helper.transactionLogData.xZoom].zoom)

	-- transaction entries with data
	local n = C.GetNumTransactionLog(container, starttime, endtime)
	local buf = ffi.new("TransactionLogEntry[?]", n)
	n = C.GetTransactionLog(buf, n, container, starttime, endtime)
	for i = 0, n - 1 do
		local partnername = ffi.string(buf[i].partnername)

		table.insert(Helper.transactionLogData.accountLogUnfiltered, { 
			time = buf[i].time,
			money = tonumber(buf[i].money) / 100,
			entryid = ConvertStringTo64Bit(tostring(buf[i].entryid)),
			eventtype = ffi.string(buf[i].eventtype),
			eventtypename = ffi.string(buf[i].eventtypename),
			partner = buf[i].partnerid,
			partnername = (partnername ~= "") and (partnername .. " (" .. ffi.string(buf[i].partneridcode) .. ")") or "",
			tradeentryid = ConvertStringTo64Bit(tostring(buf[i].tradeentryid)),
			tradeeventtype = ffi.string(buf[i].tradeeventtype),
			tradeeventtypename = ffi.string(buf[i].tradeeventtypename),
			buyer = buf[i].buyerid,
			seller = buf[i].sellerid,
			ware = ffi.string(buf[i].ware),
			amount = buf[i].amount,
			price = tonumber(buf[i].price) / 100,
			complete = buf[i].complete,
			description = "",
		})

		local entry = Helper.transactionLogData.accountLogUnfiltered[#Helper.transactionLogData.accountLogUnfiltered]
		if (entry.buyer ~= 0) and (entry.seller ~= 0) then
			if entry.seller == container then
				entry.description = string.format(ReadText(1001, 7780), ffi.string(C.GetComponentName(entry.seller)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.seller)) .. ")", entry.amount, GetWareData(entry.ware, "name"), ffi.string(C.GetComponentName(entry.buyer)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.buyer)) .. ")", ConvertMoneyString(Helper.round(entry.price, 2), true, true, 0, true) .. " " .. ReadText(1001, 101))
			else
				entry.description = string.format(ReadText(1001, 7770), ffi.string(C.GetComponentName(entry.buyer)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.buyer)) .. ")", entry.amount, GetWareData(entry.ware, "name"), ffi.string(C.GetComponentName(entry.seller)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.seller)) .. ")", ConvertMoneyString(Helper.round(entry.price, 2), true, true, 0, true) .. " " .. ReadText(1001, 101))
			end
		elseif entry.buyer ~= 0 then
			entry.description = string.format(ReadText(1001, 7772), ffi.string(C.GetComponentName(entry.buyer)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.buyer)) .. ")", entry.amount, GetWareData(entry.ware, "name"), ConvertMoneyString(Helper.round(entry.price, 2), true, true, 0, true) .. " " .. ReadText(1001, 101))
		elseif entry.seller ~= 0 then
			entry.description = string.format(ReadText(1001, 7771), ffi.string(C.GetComponentName(entry.seller)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.seller)) .. ")", entry.amount, GetWareData(entry.ware, "name"), ConvertMoneyString(Helper.round(entry.price, 2), true, true, 0, true) .. " " .. ReadText(1001, 101))
		elseif entry.ware ~= "" then
			entry.description = entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name") .. " - " .. ConvertMoneyString(entry.price, false, true, 0, true) .. " " .. ReadText(1001, 101)
		end
		if entry.partner ~= 0 then
			entry.partnername = ffi.string(C.GetComponentName(entry.partner)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.partner)) .. ")"
			entry.destroyedpartner = not C.IsComponentOperational(entry.partner)
		else
			entry.destroyedpartner = entry.partnername ~= ""
		end
		if entry.eventtype == "trade" then
			if entry.seller and (entry.seller == container) then
				entry.eventtypename = ReadText(1001, 7781)
			elseif entry.buyer and (entry.buyer == container) then
				entry.eventtypename = ReadText(1001, 7782)
			end
		elseif entry.eventtype == "sellship" then
			if entry.partnername ~= "" then
				entry.eventtypename = ReadText(1001, 7783)
			else
				entry.eventtypename = entry.eventtypename .. ReadText(1001, 120) .. " " .. entry.partnername
				entry.partnername = ""
			end
		end

		table.insert(Helper.transactionLogData.accountLog, entry)
	end
	-- pure money stats for graph
	local buf = ffi.new("MoneyLogEntry[?]", Helper.transactionLogConfig.numdatapoints)
	local numdata = C.GetMoneyLog(buf, Helper.transactionLogConfig.numdatapoints, container, starttime, endtime)
	for i = 0, numdata - 1 do
		local money = tonumber(buf[i].money) / 100
		local prevmoney = (i > 0) and (tonumber(buf[i - 1].money) / 100) or nil
		local nextmoney = (i < numdata - 1) and (tonumber(buf[i + 1].money) / 100) or nil
		if (money ~= prevmoney) or (money ~= nextmoney) then
			table.insert(Helper.transactionLogData.graphdata, { 
				t = buf[i].time,
				y = money,
				entryid = ConvertStringTo64Bit(tostring(buf[i].entryid)),
			})
			local entry = Helper.transactionLogData.graphdata[#Helper.transactionLogData.graphdata]
		end
	end
	-- apply search
	if Helper.transactionLogData.searchtext ~= "" then
		Helper.transactionLogData.accountLog = {}
		for _, entry in ipairs(Helper.transactionLogData.accountLogUnfiltered) do
			if Helper.transactionLogSearchHelper(entry, Helper.transactionLogData.searchtext) then
				table.insert(Helper.transactionLogData.accountLog, entry)
			end
		end
	end
	-- create transaction index
	for i, entry in ipairs(Helper.transactionLogData.accountLogUnfiltered) do
		Helper.transactionLogData.transactionsByIDUnfiltered[entry.entryid] = i
	end
	for i, entry in ipairs(Helper.transactionLogData.accountLog) do
		Helper.transactionLogData.transactionsByID[entry.entryid] = i
	end
	-- make sure the page of the selected entry is shown
	if Helper.transactionLogData.curEntry then
		local transactionIndex = Helper.transactionLogData.transactionsByID[Helper.transactionLogData.curEntry]
		if transactionIndex then
			Helper.transactionLogData.curPage = math.ceil((#Helper.transactionLogData.accountLog - transactionIndex + 1) / Helper.transactionLogConfig.transactionLogPage)
		end
	end

	Helper.transactionLogData.numPages = math.max(1, math.ceil(#Helper.transactionLogData.accountLog / Helper.transactionLogConfig.transactionLogPage))
	Helper.transactionLogData.curPage = math.max(1, math.min(Helper.transactionLogData.numPages, Helper.transactionLogData.curPage))

	local startIndex = #Helper.transactionLogData.accountLog
	local endIndex = 1
	if #Helper.transactionLogData.accountLog <= Helper.transactionLogConfig.transactionLogPage then
		Helper.transactionLogData.curPage = 1
	else
		endIndex = #Helper.transactionLogData.accountLog - Helper.transactionLogConfig.transactionLogPage * Helper.transactionLogData.curPage + 1
		startIndex = Helper.transactionLogConfig.transactionLogPage + endIndex - 1
		if endIndex < 1 then
			endIndex = 1
		end
	end

	local editboxHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
	local buttonsize = Helper.scaleY(Helper.standardTextHeight)

	local table_data = frame:addTable(9, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	table_data:setColWidth(1, Helper.standardTextHeight)
	table_data:setColWidth(3, Helper.standardTextHeight)
	table_data:setColWidth(4, Helper.standardTextHeight)
	table_data:setColWidth(5, Helper.standardTextHeight)
	table_data:setColWidth(6, tableProperties.width / 6 - 2 * (buttonsize + Helper.borderSize), false)
	table_data:setColWidth(7, tableProperties.width / 6 - 2 * (buttonsize + Helper.borderSize), false)
	table_data:setColWidth(8, Helper.standardTextHeight)
	table_data:setColWidth(9, Helper.standardTextHeight)

	local row = table_data:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(9):createText(ReadText(1001, 7702), Helper.titleTextProperties)

	local row = table_data:addRow("search", { fixed = true })
	-- searchbar
	row[1]:setColSpan(2):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250), height = Helper.subHeaderHeight }):setText(Helper.transactionLogData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= Helper.transactionLogData.searchtext then Helper.transactionLogData.searchtext = text; Helper.transactionLogData.noupdate = nil; refreshCallback() end end
	-- clear search
	local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
	row[3]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setText("X", { halign = "center", font = Helper.standardFontBold })
	row[3].handlers.onClick = function () Helper.transactionLogData.searchtext = ""; refreshCallback() end
	-- pages
	row[4]:createButton({ scaling = false, active = Helper.transactionLogData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[4].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = 1; refreshCallback() end
	row[5]:createButton({ scaling = false, active = Helper.transactionLogData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[5].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.curPage - 1; refreshCallback() end
	Helper.transactionLogData.pageEditBox = row[6]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(Helper.transactionLogData.curPage .. " / " .. Helper.transactionLogData.numPages, { halign = "center" })
	row[6].handlers.onEditBoxDeactivated = function (_, text, textchanged) Helper.transactionLogData.noupdate = nil; return Helper.editboxTransactionLogPage(text, textchanged, refreshCallback) end
	row[8]:createButton({ scaling = false, active = Helper.transactionLogData.curPage < Helper.transactionLogData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[8].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.curPage + 1; refreshCallback() end
	row[9]:createButton({ scaling = false, active = Helper.transactionLogData.curPage < Helper.transactionLogData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[9].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.numPages; refreshCallback() end

	local headerHeight = table_data:getFullHeight()

	if #Helper.transactionLogData.accountLog > 0 then
		local total = 0
		for i = startIndex, endIndex, -1 do
			local entry = Helper.transactionLogData.accountLog[i]
			local row = table_data:addRow(entry.entryid, { bgColor = Helper.color.transparent })
			if Helper.transactionLogData.curEntry == entry.entryid then
				local numLines = (table_data.properties.maxVisibleHeight - headerHeight) / (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize)
				if selectionData.toprow and ((selectionData.toprow > row.index - numLines) and (selectionData.toprow < row.index + numLines + 1)) then
					table_data:setTopRow(selectionData.toprow)
				else
					table_data:setTopRow(row.index)
				end
				table_data:setSelectedRow(row.index)
				selectionData = {}
			end
			if entry.ware ~= "" then
				row[1]:createButton({ height = Helper.standardTextHeight }):setText(function() return Helper.transactionLogData.expandedEntries[entry.entryid] and "-" or "+" end, { halign = "center" })
				row[1].handlers.onClick = function() return Helper.buttonExpandTransactionEntry(entry.entryid, row.index, refreshCallback) end
			end
			row[2]:createText(((entry.partnername ~= "") and (entry.partnername .. " - ") or "") .. entry.eventtypename, { color = entry.destroyedpartner and Helper.color.grey or nil, mouseOverText = entry.destroyedpartner and ReadText(1026, 5701) or "" })
			row[3]:setColSpan(4):createText(Helper.getPassedTime(entry.time), { halign = "right" })
			row[7]:setColSpan(3):createText(((entry.money > 0) and "+" or "") .. ConvertMoneyString(entry.money, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (entry.money > 0) and Helper.color.green or Helper.color.red })
			total = total + entry.money
			if Helper.transactionLogData.expandedEntries[entry.entryid] then
				local row = table_data:addRow(nil, { bgColor = Helper.color.unselectable })
				row[1].properties.cellBGColor = Helper.color.transparent
				row[2]:setColSpan(8):createText(entry.description, { x = Helper.standardTextHeight, wordwrap = true, color = entry.destroyedpartner and Helper.color.grey or nil })
			end
		end

		if Helper.transactionLogData.xZoom < #Helper.transactionLogConfig.zoomSteps then
			local row = table_data:addRow("showmore", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(9):createButton({ bgColor = Helper.color.transparent }):setText(ReadText(1001, 7778), { halign = "center" })
			if endIndex == 1 then
				row[1].handlers.onClick = function () return Helper.buttonTransactionLogZoom(1, refreshCallback) end
			else
				row[1].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.curPage + 1; refreshCallback(_, 1) end
			end
		end

		local table_total = frame:addTable(2, { tabOrder = 0, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
		table_total:setColWidthPercent(1, 75)

		table_total:addEmptyRow()

		local row = table_total:addRow(nil, { bgColor = Helper.color.lightgrey })
		row[1]:setColSpan(2):createText("", { fontsize = 1, minRowHeight = 2 })

		local row = table_total:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 7776) .. ReadText(1001, 120))
		row[2]:createText(((total > 0) and "+" or "") .. ConvertMoneyString(total, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (total > 0) and Helper.color.green or Helper.color.red })

		local maxVisibleHeight = table_data.properties.maxVisibleHeight - table_total:getFullHeight() - Helper.frameBorder
		table_total.properties.y = table_total.properties.y + math.min(maxVisibleHeight, table_data:getFullHeight())
		table_data.properties.maxVisibleHeight = table_total.properties.y - table_data.properties.y

		table_data:addConnection(1, 2, true)
		table_total:addConnection(2, 2)
	else
		local row = table_data:addRow("none", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })

		if Helper.transactionLogData.xZoom < #Helper.transactionLogConfig.zoomSteps then
			local row = table_data:addRow("showmore", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(9):createButton({ bgColor = Helper.color.transparent }):setText(ReadText(1001, 7778), { halign = "center" })
			row[1].handlers.onClick = function () return Helper.buttonTransactionLogZoom(1, refreshCallback) end
		end

		table_data:addConnection(1, 2, true)
	end

	if selectionData.selectedrow then
		table_data:setTopRow(selectionData.toprow)
		table_data:setSelectedRow(selectionData.selectedrow)
	end

	-- graph table
	local xoffset = tableProperties.x + tableProperties.width + Helper.borderSize + Helper.frameBorder
	local width = Helper.viewWidth - xoffset - tableProperties.x2

	-- kuertee start: ensure graph is only half viewHeight so that trade analytics can fit
	-- local height = math.min(Helper.viewHeight - tableProperties.y - Helper.frameBorder - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, math.floor(width * 9 / 16))
	-- local table_graph = frame:addTable(4, { tabOrder = 3, width = width, x = xoffset, y = tableProperties.y })
	local height = Helper.viewHeight * 0.5 - tableProperties.y - Helper.frameBorder - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize
	local table_graph = frame:addTable(4, { tabOrder = 3, width = width, height = height, x = xoffset, y = tableProperties.y })
	-- kuertee end: ensure graph is only half viewHeight so that trade analytics can fit

	table_graph:setColWidthPercent(2, 15)
	table_graph:setColWidthPercent(3, 15)

	-- graph cell
	local row = table_graph:addRow(false, { fixed = true, bgColor = Helper.color.transparent })

	local minY, maxY = 0, 1
	local datarecords = {}

	local data = {}
	local firstNonZeroY = true
	for i, point in pairs(Helper.transactionLogData.graphdata) do
		if (point.y > 0) or (minY > 0) then
			if firstNonZeroY then
				firstNonZeroY = false
				minY = point.y
			else
				minY = math.min(minY, point.y)
			end
		end
		maxY = math.max(maxY, point.y)
		local inactive
		if Helper.transactionLogData.searchtext ~= "" then
			inactive = true

			local transactionIndex = Helper.transactionLogData.transactionsByIDUnfiltered[point.entryid]
			local prevTransactionIndex = 1
			if i > 1 then
				prevTransactionIndex = Helper.transactionLogData.transactionsByIDUnfiltered[Helper.transactionLogData.graphdata[i -1].entryid]
			end

			if transactionIndex and prevTransactionIndex then
				if prevTransactionIndex < transactionIndex then
					-- if the previous transactionlog index is smaller than the current, skip this index, as it is part of the previous data point not the current
					--  prevTimeInterval  |  curTimeInterval
					-- [ ..., prevEntry ] | [ ..., curEntry ]
					prevTransactionIndex = prevTransactionIndex + 1
				end
				for i = prevTransactionIndex, transactionIndex do
					local entry = Helper.transactionLogData.accountLogUnfiltered[i]
					if Helper.transactionLogData.transactionsByID[entry.entryid] then
						inactive = false
						break
					end
				end
			end
		end
		table.insert(data, Helper.createGraphDataPoint((point.t - endtime) / Helper.transactionLogData.xScale, point.y, nil, nil, inactive))
	end

	table.insert(datarecords, Helper.createGraphDataRecord(Helper.transactionLogConfig.point.type, Helper.transactionLogConfig.point.size, Helper.color.brightyellow, Helper.transactionLogConfig.line.type, Helper.transactionLogConfig.line.size, Helper.color.brightyellow, data, false))

	local mingranularity = (maxY - minY) / 12
	local maxgranularity = (maxY - minY) / 8
	local granularity = 0.1
	for _, factor in ipairs(Helper.transactionLogConfig.factors) do
		local testgranularity = math.ceil(mingranularity / factor) * factor
		if testgranularity >= maxgranularity then
			break;
		end
		granularity = testgranularity
	end
	maxY = (math.ceil(maxY / granularity) + 0.5) * granularity
	minY = (math.floor(minY / granularity) - 0.5) * granularity

	local xRange = (endtime - starttime) / Helper.transactionLogData.xScale
	local xGranularity = Helper.transactionLogData.xGranularity
	if endtime > starttime then
		while (endtime - starttime) < xGranularity do
			xGranularity = xGranularity / 2
		end
	end
	xGranularity = Helper.round(xGranularity / Helper.transactionLogData.xScale, 3)
	local xOffset = xRange % xGranularity
	local yOffset = (math.ceil(minY / granularity) * granularity) - minY		-- offset is distance from minY to next multiple of granularity (value of first Y axis label)

	local xaxis = Helper.createGraphAxis(Helper.createGraphText(Helper.transactionLogData.xTitle, Helper.standardFont, 9, Helper.color.white), -xRange, 0, xGranularity, xOffset, true, Helper.color.white, { r = 96, g = 96, b = 96, a = 80 })
	local yaxis = Helper.createGraphAxis(Helper.createGraphText(ReadText(1001, 7773) .. " [" .. ReadText(1001, 101) .. "]", Helper.standardFont, 9, Helper.color.white), minY, maxY, granularity, yOffset, true, Helper.color.white, { r = 96, g = 96, b = 96, a = 80 })

	-- graph
	local title = ffi.string(C.GetComponentName(container))
	if container ~= C.GetPlayerID() then
		title = title .. " (" .. ffi.string(C.GetObjectIDCode(container)) .. ")"
	end
	Helper.transactionLogData.graph = row[1]:setColSpan(4):createGraph("line", true, Helper.color.semitransparent, { text = title, font = Helper.titleFont, size = Helper.scaleFont(Helper.titleFont, Helper.titleFontSize), color = Helper.color.white }, xaxis, yaxis, datarecords, 0, 0, nil, height)
	row[1].handlers.onClick = function (_, data) return Helper.graphDataSelection(data, refreshCallback) end

	-- zoom
	local row = table_graph:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton({ active = Helper.transactionLogData.xZoom > 1 }):setText(ReadText(1001, 7777), { halign = "center" })
	row[2].handlers.onClick = function () return Helper.buttonTransactionLogZoom(-1, refreshCallback) end
	row[3]:createButton({ active = Helper.transactionLogData.xZoom < #Helper.transactionLogConfig.zoomSteps }):setText(ReadText(1001, 7778), { halign = "center" })
	row[3].handlers.onClick = function () return Helper.buttonTransactionLogZoom(1, refreshCallback) end

	table_graph:addConnection(1, 3, true)
end

function Helper.getSyncPointName(id)
	if (id > 0) and (id <= 24) then
		return ReadText(20401, id)
	else
		return ReadText(1001, 3237) .. " " .. id
	end
end

function Helper.updateVenturePlatforms()
	Helper.ventureplatforms = {}
	Helper.dockedventureships = {}
	local playerstations = GetContainedStationsByOwner("player")
	for _, station in ipairs(playerstations) do
		local station64 = ConvertIDTo64Bit(station)
		local ventureplatforms = {}
		Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, station64)
		for i, platform in ipairs(ventureplatforms) do
			local docks = {}
			Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
		
			local isbusy = GetComponentData(ConvertStringTo64Bit(tostring(platform)), "isbusy")
			local ships = {}
			local missioninfo
			if isbusy then
				local info = C.GetCurrentVentureInfo(platform)
				missioninfo = { name = ffi.string(info.name), remainingtime = tonumber(info.remainingtime) }
				local n = info.numships
				local buf = ffi.new("UniverseID[?]", n)
				n = C.GetCurrentVentureShips(buf, n, platform)
				for i = 0, n - 1 do
					table.insert(ships, buf[i])
				end
			else
				for _, dock in ipairs(docks) do
					if C.IsComponentOperational(dock) then
						local dockedships = {}
						Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, dock, "player")
						Helper.dockedventureships[tostring(dock)] = dockedships

						for _, dockedship in ipairs(dockedships) do
							table.insert(ships, dockedship)
						end
					end
				end
			end

			table.insert(Helper.ventureplatforms, { id = platform, stationid = station64, docks = docks, ships = ships, errors = {}, isbusy = isbusy, missioninfo = missioninfo })
		end
	end
end

function Helper.isOnlineGame()
	return OnlineIsOnlineModeActive()
end

function Helper.hasVentureRewards()
   return OnlineHasVentureLogbookReward()
end

function Helper.getProjectEntry(cluster, buffer, isevent)
	local id = ffi.string(buffer.id)

	local predecessors = {}
	local buf_predecessors = ffi.new("const char*[?]", buffer.numpredecessors)
	local num_predecessors = C.GetTerraformingProjectPredecessors(buf_predecessors, buffer.numpredecessors, cluster, id)
	for j = 0, num_predecessors - 1 do
		table.insert(predecessors, ffi.string(buf_predecessors[j]))
	end

	local predecessorgroups = {}
	local buf_predecessorgroups = ffi.new("UITerraformingProjectPredecessorGroup[?]", buffer.numpredecessorgroups)
	local num_predecessorgroups = C.GetTerraformingProjectPredecessorGroups(buf_predecessorgroups, buffer.numpredecessorgroups, cluster, id)
	for j = 0, num_predecessorgroups - 1 do
		table.insert(predecessorgroups, {
			id = ffi.string(buf_predecessorgroups[j].id),
			anyproject = buf_predecessorgroups[j].anyproject,
		})
	end

	local blockingprojects = {}
	local buf_blockingprojects = ffi.new("const char*[?]", buffer.numblockingprojects)
	local num_blockingprojects = C.GetTerraformingProjectBlockingProjects(buf_blockingprojects, buffer.numblockingprojects, cluster, id)
	for j = 0, num_blockingprojects - 1 do
		table.insert(blockingprojects, ffi.string(buf_blockingprojects[j]))
	end

	local conditions = {}
	local buf_conditions = ffi.new("UITerraformingProjectCondition[?]", buffer.numconditions)
	local num_conditions = C.GetTerraformingProjectConditions(buf_conditions, buffer.numconditions, cluster, id)
	for j = 0, num_conditions - 1 do
		table.insert(conditions, {
			stat = ffi.string(buf_conditions[j].stat),
			min = buf_conditions[j].min,
			max = buf_conditions[j].max,
			minvalue = buf_conditions[j].minvalue,
			maxvalue = buf_conditions[j].maxvalue,
			issatisfied = buf_conditions[j].issatisfied,
		})
	end

	local primaryeffects, sideeffects = {}, {}
	local buf_effects = ffi.new("UITerraformingProjectEffect[?]", buffer.numprimaryeffects + buffer.numsideeffects)
	local num_effects = C.GetTerraformingProjectEffects(buf_effects, buffer.numprimaryeffects + buffer.numsideeffects, cluster, id)
	for j = 0, num_effects - 1 do
		table.insert(buf_effects[j].issideeffect and sideeffects or primaryeffects, {
			text = ffi.string(buf_effects[j].text),
			stat = ffi.string(buf_effects[j].stat),
			change = buf_effects[j].change,
			value = buf_effects[j].value,
			minvalue = buf_effects[j].minvalue,
			maxvalue = buf_effects[j].maxvalue,
			onfail = buf_effects[j].onfail,
			chance = buf_effects[j].chance,
			setbackpercent = buf_effects[j].setbackpercent,
			isbeneficial = buf_effects[j].isbeneficial,
		})
	end

	local rebates = {}
	local buf_rebates = ffi.new("UITerraformingProjectRebate[?]", buffer.numrebates)
	local num_rebates = C.GetTerraformingProjectRebates(buf_rebates,  buffer.numrebates, cluster, id)
	for j = 0, num_rebates - 1 do
		table.insert(rebates, {
			ware = ffi.string(buf_rebates[j].ware),
			waregroupname = ffi.string(buf_rebates[j].waregroupname),
			value = buf_rebates[j].value,
		})
	end

	local resources = {}
	if not isevent then
		local buf_resources = ffi.new("UIWareInfo[?]", buffer.numresources)
		local num_resources = C.GetTerraformingProjectRebatedResources(buf_resources, buffer.numresources, cluster, id)
		for j = 0, num_resources - 1 do
			local ware = ffi.string(buf_resources[j].ware)
			table.insert(resources, {
				ware = ware,
				name = GetWareData(ware, "name"),
				amount = buf_resources[j].amount,
			})
		end
		table.sort(resources, Helper.sortName)
	end

	local removedprojects = {}
	local buf_removedprojects = ffi.new("const char*[?]", buffer.numremovedprojects)
	local num_removedprojects = C.GetTerraformingProjectRemovedProjects(buf_removedprojects, buffer.numremovedprojects, cluster, id)
	for j = 0, num_removedprojects - 1 do
		table.insert(removedprojects, ffi.string(buf_removedprojects[j]))
	end

	local entry = {
		id = id,
		group = ffi.string(buffer.group),
		isevent = isevent,
		name = ffi.string(buffer.name),
		description = ffi.string(buffer.description),
		duration = buffer.duration,
		repeatcooldown = buffer.repeatcooldown,
		timescompleted = buffer.timescompleted,
		successchance = buffer.successchance,
		resilient = buffer.resilient,
		showalways = buffer.showalways,
		price = buffer.price,
		payoutfactor = buffer.payoutfactor,
		requiredresearch = ffi.string(buffer.requiredresearchid),
		pricescale = ffi.string(buffer.pricescale);
		pricescaletext = ffi.string(buffer.pricescaletext);
		anypredecessor = buffer.anypredecessor,
		predecessors = predecessors,
		predecessorgroups = predecessorgroups,
		blockingprojects = blockingprojects,
		conditions = conditions,
		primaryeffects = primaryeffects,
		sideeffects = sideeffects,
		rebates = rebates,
		resources = resources,
		isongoing = C.IsTerraformingProjectOngoing(cluster, id),
		removedprojects = removedprojects,
	}

	return entry
end

function Helper.ventureTimeLeft(timeleft)
	local timeformat = ReadText(1001, 205)
	if timeleft < 3600 then
		timeformat = ReadText(1001, 210)
	elseif timeleft < 3600 * 24 then
		timeformat = ReadText(1001, 207)
	end

	return ConvertTimeString(math.max(60, timeleft), timeformat)
end

function Helper.ventureOperationTimeLeftText()
	local operation = OnlineGetCurrentOperation()
	local operationtimestring = "---"
	if operation.isvalid then
		local timeleft = operation.remainingtime
		operationtimestring = Helper.ventureTimeLeft((timeleft > 0) and timeleft or 0)
	end
	return operationtimestring
end

function Helper.ventureSeasonTimeLeftText()
	local curtime = C.GetCurrentUTCDataTime()
	local season = OnlineGetCurrentSeason()
	local seasontimestring = ReadText(1001, 11581)
	if next(season) then
		if season.isrunning then
			local timeleft = tonumber(season.endtime - curtime)
			seasontimestring = Helper.ventureTimeLeft((timeleft > 0) and timeleft or 0)
		elseif season.endtime > curtime then
			seasontimestring = ReadText(1001, 11579)
		end
	end
	return seasontimestring
end

Helper.rightSideBar = {
	{ name = ReadText(1001, 7902), icon = "mapst_plotmanagement",			mode = "construction", 				helpOverlayID = "mapst_plotmanagement",			helpOverlayText = ReadText(1028, 3261) },
	{ name = ReadText(1001, 7903), icon = "stationbuildst_lsov",			mode = "logical",					helpOverlayID = "stationbuildst_lsov",			helpOverlayText = ReadText(1028, 3260) },
	{ name = ReadText(1001, 7702), icon = "pi_transactionlog",				mode = "transactions",				helpOverlayID = "pi_transactionlog",			helpOverlayText = ReadText(1028, 3262) },
	{ name = ReadText(1001, 7400), icon = "tlt_research",					mode = "research",					helpOverlayID = "tlt_research",					helpOverlayText = ReadText(1028, 8102),		canresearch = true },
	{ name = ReadText(1001, 3800), icon = "tlt_terraforming",				mode = "terraforming",				helpOverlayID = "tlt_terraforming",				helpOverlayText = ReadText(1028, 8109),		canterraform = true },
}

function Helper.createRightSideBar(frame, container, condition, currentmode, callback, selfcallback)
	local sidebarWidth = Helper.scaleX(Helper.sidebarWidth)
	local ftable = frame:addTable(1, { tabOrder = 4, width = sidebarWidth, height = 0, x = Helper.viewWidth - sidebarWidth - Helper.frameBorder, y = Helper.frameBorder + 20, scaling = false, borderEnabled = false, reserveScrollBar = false })

	local isplayerowned = GetComponentData(container, "isplayerowned")

	for _, entry in ipairs(Helper.rightSideBar) do
		local display = true
		if (entry.canresearch ~= nil) then
			if isplayerowned then
				if not C.IsHQ(container) then
					display = not entry.canresearch
				else
					display = C.CanResearch()
				end
			else
				display = false
			end
		end
		if (entry.canterraform ~= nil) then
			if isplayerowned then
				if not C.IsHQ(container) then
					display = not entry.canterraform
				else
					local cluster = C.GetContextByClass(container, "cluster", false)
					display = GetComponentData(ConvertStringTo64Bit(tostring(cluster)), "hasterraforming") and (C.GetNumTerraformingProjects(cluster, false) > 0)
				end
			else
				display = false
			end
		end

		if display then
			local row = ftable:addRow(true, { fixed = true })

			local active = (entry.active == nil) or entry.active
			if (entry.mode == "construction") or (entry.mode == "transactions") then
				active = active and isplayerowned and condition
			end

			local bgcolor = Helper.defaultTitleBackgroundColor
			if entry.mode == currentmode then
				bgcolor = Helper.defaultArrowRowBackgroundColor
			end
			row[1]:createButton({ active = active, height = sidebarWidth, mouseOverText = entry.name, bgColor = bgcolor, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon)
			row[1].handlers.onClick = function () return Helper.buttonRightBar(container, currentmode, callback, selfcallback, entry.mode, row.index) end
		end
	end

	return ftable
end

function Helper.buttonRightBar(container, currentmode, callback, selfcallback, mode, row)
	local newmenu, params
	if mode ~= currentmode then
		if mode == "construction" then
			newmenu = "StationConfigurationMenu"
			params = { 0, 0, container }
		elseif mode == "transactions" then
			newmenu = "TransactionLogMenu"
			params = { 0, 0, container }
		elseif mode == "logical" then
			newmenu = "StationOverviewMenu"
			params = { 0, 0, container }
		elseif mode == "research" then
			newmenu = "ResearchMenu"
			params = { 0, 0 }
		elseif mode == "terraforming" then
			newmenu = "TerraformingMenu"
			local cluster = C.GetContextByClass(container, "cluster", false)
			params = { 0, 0, ConvertStringTo64Bit(tostring(cluster)) }
		end
	elseif selfcallback then
		selfcallback()
	end

	if newmenu then
		callback(newmenu, params)
	end
end

function Helper.isPlayerCovered()
	local player = ConvertStringTo64Bit(tostring(C.GetPlayerID()))
	if player and (player ~= 0) then
		return GetComponentData(player, "iscovered")
	end
	return false
end

function Helper.formatTimeLeft(timeleft)
	local timeformat = ReadText(1001, 214)
	if timeleft < 60 then
		timeformat = ReadText(1001, 215)
	elseif timeleft < 3600 then
		timeformat = ReadText(1001, 209)
	end

	return ConvertTimeString(timeleft, timeformat)
end

Helper.extensions = {}

function Helper.registerExtension(extensionid, hook)
	Helper.extensions[extensionid] = hook
end

function Helper.callExtensionFunction(extensionid, functionname, ...)
	if Helper.extensions[extensionid] then
		local extensionfunc = Helper.extensions[extensionid][functionname]
		if extensionfunc then
			if type(extensionfunc) == "function" then
				return extensionfunc(...)
			end
		end
		DebugError("Helper.callExtensionFunction(): Function '".. tostring(functionname) .. "' not found in extension: " .. tostring(extensionid))
		print(TraceBack())
	else
		DebugError("Helper.callExtensionFunction(): Invalid extensionid: " .. tostring(extensionid) .. ", calling: " .. tostring(functionname))
		print(TraceBack())
	end
end

function Helper.hasExtension(extensionid)
	return Helper.extensions[extensionid] ~= nil
end

function Helper.updateTradeRules()
	local traderules = {}
	Helper.ffiVLA(traderules, "TradeRuleID", C.GetNumAllTradeRules, C.GetAllTradeRules)
	for i = #traderules, 1, -1 do
		local id = traderules[i]

		local counts = C.GetTradeRuleInfoCounts(id)
		local buf = ffi.new("TradeRuleInfo")
		buf.numfactions = counts.numfactions
		buf.factions = Helper.ffiNewHelper("const char*[?]", counts.numfactions)
		if C.GetTradeRuleInfo(buf, id) then
			local factions = {}
			local hasplayer = false
			for j = 0, buf.numfactions - 1 do
				local faction = ffi.string(buf.factions[j])
				if faction == "player" then
					hasplayer = true
				else
					table.insert(factions, faction)
				end
			end
			table.sort(factions, Helper.sortFactionName)
			if hasplayer then
				table.insert(factions, 1, "player")
			end

			traderules[i] = { id = id, name = ffi.string(buf.name), factions = factions, iswhitelist = buf.iswhitelist }
		else
			table.remove(traderules, i)
		end
	end
	table.sort(traderules, Helper.sortID)
	Helper.traderuleOptions = {
		{ id = -1, text = ReadText(1001, 11024), icon = "", displayremoveoption = false },
	}
	for _, traderule in ipairs(traderules) do
		local mouseovertext = (traderule.iswhitelist and ReadText(1001, 11027) or ReadText(1001, 11026)) .. ReadText(1001, 120)
		for _, faction in ipairs(traderule.factions) do
			mouseovertext = mouseovertext .. "\n· " .. ((faction == "player") and Helper.convertColorToText(Helper.color.green) or "") .. GetFactionData(faction, "name") .. "\27X"
		end
		table.insert(Helper.traderuleOptions, { id = traderule.id, text = traderule.name, icon = "", displayremoveoption = false, mouseovertext = mouseovertext })
	end
end

function Helper.getETAString(name, eta)
	local curtime = GetCurTime()
	if (eta > 0) then
		if (eta - curtime > 0) then
			return ConvertTimeString(eta - curtime, ReadText(1001, 204)) .. " - " .. name
		else
			return ConvertTimeString(0, ReadText(1001, 204)) .. " - " .. name
		end
	else
		return "- - : - -  - " .. name
	end
end

function Helper.createLSOStorageNode(menu, container, ware, planned, hasstorage, iscargo)
	local storageinfo_amounts  = C.IsInfoUnlockedForPlayer(container, "storage_amounts")
	local storageinfo_warelist = C.IsInfoUnlockedForPlayer(container, "storage_warelist")
	local storageinfo_capacity = C.IsInfoUnlockedForPlayer(container, "storage_capacity")

	local name, transporttype = GetWareData(ware, "name", "transport")

	-- kuertee start: callback
	if callbacks ["createLSOStorageNode_get_ware_name"] then
		for _, callback in ipairs (callbacks ["createLSOStorageNode_get_ware_name"]) do
			name = callback (ware)
		end
	end
	-- kuertee end: callback

	local cargo, isplayerowned = GetComponentData(container, "cargo", "isplayerowned")
	local productionlimit = 0
	if C.IsComponentClass(container, "container") then
		productionlimit = GetWareProductionLimit(container, ware)
	end
	local hasrestrictions = Helper.isTradeRestricted(container, ware)

	local shownamount = storageinfo_amounts and cargo[ware] or 0
	local shownmax = storageinfo_capacity and math.max(shownamount, productionlimit) or shownamount
	local buylimit, selllimit
	if isplayerowned then
		if C.HasContainerBuyLimitOverride(container, ware) then
			buylimit = math.max(0, math.min(shownmax, C.GetContainerBuyLimit(container, ware)))
		end
		if C.HasContainerSellLimitOverride(container, ware) then
			selllimit = math.max(buylimit or 0, math.min(shownmax, C.GetContainerSellLimit(container, ware)))
		end
	end

	local warenode = {
		cargo = iscargo,
		ware = ware,
		text = Helper.unlockInfo(storageinfo_warelist, name),
		type = transporttype,
		planned = planned,
		hasstorage = hasstorage,
		row = iscargo and 1 or nil,
		col = iscargo and 1 or nil,
		numrows = iscargo and 1 or nil,
		numcols = iscargo and 1 or nil,
		-- storage module
		{
			properties = {
				value = shownamount,
				max = shownmax,
				step = 1,
				slider1 = buylimit,
				slider2 = selllimit,
			},
			isstorage = true,
			expandedTableNumColumns = 3,
			expandHandler = function (...) return Helper.onExpandLSOStorageNode(menu, container, ...) end,
			collapseHandler = function (...) return Helper.onCollapseLSOStorageNode(menu, ...) end,
			sliderHandler = function (...) return Helper.onSliderChangedLSOStorageNode(container, ...) end,
			color = (not hasstorage) and Helper.color.grey or nil,
			statuscolor = (not iscargo) and ((not hasstorage) and Helper.color.red or (hasrestrictions and Helper.color.warningorange or nil) or nil),
			statusIcon = (not iscargo) and ((not hasstorage) and "lso_warning" or (hasrestrictions and "lso_error" or nil) or nil),
		}
	}
	return warenode
end

function Helper.updateLSOStorageNode(menu, node, container, ware)
	local hasrestrictions = Helper.isTradeRestricted(container, ware)
	local hasstorage = node.customdata.nodedata.hasstorage
	local edgecolor = Helper.color.white
	
	local statusicon = hasrestrictions and "lso_error" or nil
	local statusiconmouseovertext = hasrestrictions and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8404)) or ""
	local statuscolor = hasrestrictions and Helper.color.warningorange or nil

	if not hasstorage then
		statusicon = "lso_warning"
		statuscolor = Helper.color.red
		statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8416)
	elseif menu.resourcesmissing[ware] then
		statusicon = "lso_warning"
		statuscolor = Helper.color.red
		statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8437)
	elseif menu.storagemissing[ware] then
		statusicon = "lso_warning"
		statuscolor = Helper.color.red
		statusiconmouseovertext = Helper.convertColorToText(Helper.color.red) .. ReadText(1001, 8438)
	end

	if not statusicon then
		if C.IsComponentClass(container, "container") then
			if HasContainerStockLimitOverride(container, ware) then
				statusicon = "lso_override"
				statuscolor = Helper.defaultFlowchartOutlineColor
				statusiconmouseovertext = ReadText(1026, 8410)

				local currentlimit = GetWareProductionLimit(container, ware)
				local defaultlimit = C.GetContainerWareMaxProductionStorageForTime(container, ware, 7200, true)
				if currentlimit < defaultlimit then
					statuscolor = Helper.color.warningorange
					statusiconmouseovertext = Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1001, 8467)
				end
			end
		end
	end

	if not C.IsInfoUnlockedForPlayer(container, "storage_amounts") then
		statusicon = nil
		statusbgicon = nil
	end

	if menu.storagemissing[ware] then
		edgecolor = Helper.color.red
	end

	local storageinfo_amounts = C.IsInfoUnlockedForPlayer(container, "storage_amounts")
	local amount = 0
	if storageinfo_amounts then
		amount = GetComponentData(container, "cargo")[ware] or 0
	end
	local max = 0
	if C.IsComponentClass(container, "controllable") then
		max = math.max(amount, GetWareProductionLimit(container, ware))
	end
	if max < node.properties.value then
		node:updateValue(amount)
	end
	if max > node.properties.max then
		node:updateMaxValue(max)
	end
	if node.properties.slider1 >= 0 then
		local slider1 = math.max(0, math.min(max, C.GetContainerBuyLimit(container, ware)))
		node:updateSlider1(slider1)
	end
	if node.properties.slider2 >= 0 then
		local slider2 = math.max(0, math.min(max, C.GetContainerSellLimit(container, ware)))
		node:updateSlider2(slider2)
	end
	if max < node.properties.max then
		node:updateMaxValue(max)
	end
	node:updateValue(amount)
	node:updateStatus(nil, statusicon, nil, statuscolor, statusiconmouseovertext)

	for _, edge in ipairs(node.incomingEdges) do
		menu.updateEdgeColorRecursively(edge, edgecolor)
	end
end

Helper.wareTypeBuffer = {}
function Helper.getContainerWareType(container, ware)
	local curtime = getElapsedTime()
	if (not next(Helper.wareTypeBuffer)) or (container ~= Helper.wareTypeBuffer.container) or (Helper.wareTypeBuffer.lastUpdateTime + 5 < curtime) then
		local products, pureresources, intermediatewares = GetComponentData(container, "availableproducts", "pureresources", "intermediatewares")
		Helper.wareTypeBuffer.container = container
		Helper.wareTypeBuffer.lastUpdateTime = curtime

		Helper.wareTypeBuffer = {
			products = {},
			pureresources = {},
			intermediatewares = {},
		}

		for _, productware in ipairs(products) do
			Helper.wareTypeBuffer.products[productware] = true
		end
		for _, resourceware in ipairs(pureresources) do
			Helper.wareTypeBuffer.pureresources[resourceware] = true
		end
		for _, intermediateware in ipairs(intermediatewares) do
			Helper.wareTypeBuffer.intermediatewares[intermediateware] = true
		end
	end

	local waretype = "trade"
	if Helper.wareTypeBuffer.products[ware] then
		waretype = "product"
	elseif Helper.wareTypeBuffer.intermediatewares[ware] then
		waretype = "intermediate"
	elseif Helper.wareTypeBuffer.pureresources[ware] then
		waretype = "resource"
	end
	return waretype
end

function Helper.isTradeRestricted(container, ware)
	local waretype = Helper.getContainerWareType(container, ware)

	local buyrestricted, sellrestricted = false, false
	if (waretype == "resource") or (waretype == "intermediate") or (waretype == "product") or (waretype == "trade") then
		local istradewarebought = C.GetContainerWareIsBuyable(container, ware)
		local istradewaresold = C.GetContainerWareIsSellable(container, ware)
		local hasbuylimitoverride = C.HasContainerBuyLimitOverride(container, ware)
		local hasselllimitoverride = C.HasContainerSellLimitOverride(container, ware)
		if (waretype == "resource") or (waretype == "intermediate") or istradewarebought or hasbuylimitoverride then
			buyrestricted = C.GetContainerTradeRuleID(container, "buy", ware) > 0
		end
		if (waretype == "product") or (waretype == "intermediate") or istradewaresold or hasselllimitoverride then
			sellrestricted = C.GetContainerTradeRuleID(container, "sell", ware) > 0
		end
	end
	return buyrestricted or sellrestricted
end

Helper.dirtyreservations = {}

function Helper.onExpandLSOStorageNode(menu, container, _, ftable, _, nodedata)
	if not menu.wareReservationRegistered then
		RegisterEvent("newWareReservation", menu.newWareReservationCallback)
		menu.wareReservationRegistered = true
	end

	local storagename, minprice, maxprice, isprocessed = GetWareData(nodedata.ware, "storagename", "minprice", "maxprice", "isprocessed")
	local storageinfo_capacity =	C.IsInfoUnlockedForPlayer(container, "storage_capacity")
	local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(container, "storage_amounts")

	local waretype = Helper.getContainerWareType(container, nodedata.ware)
	
	local reservations = {}
	local n = C.GetNumContainerWareReservations2(container, false, false, true)
	local buf = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(buf, n, container, false, false, true)
	for i = 0, n - 1 do
		local ware = ffi.string(buf[i].ware)
		local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
		local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
		local tradedeal = buf[i].tradedealid
		if not Helper.dirtyreservations[tostring(tradedeal)] then
			if reservations[ware] then
				table.insert(reservations[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal })
			else
				reservations[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal } }, [invbuyflag] = {} }
			end
		end
	end
	for _, data in pairs(reservations) do
		table.sort(data.buyoffer, Helper.sortETA)
		table.sort(data.selloffer, Helper.sortETA)
	end

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	local row
	if storageinfo_amounts then
		if nodedata.hasstorage and (not nodedata.planned) then
			local shown = false
			if menu.resourcesmissing[nodedata.ware] then
				shown = true
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(ReadText(1001, 8437), { color = Helper.color.red })
			end
			if menu.storagemissing[nodedata.ware] then
				shown = true
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(ReadText(1001, 8438), { color = Helper.color.red })
			end
			if shown then
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText("")
			end
		end
	end

	local limitslider
	if isprocessed then
		-- resource buffer
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 2415) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(ReadText(20206, 1301), { halign = "right" })
		-- amount
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 6521) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(function () return Helper.getResourceBufferAmount(container, nodedata.ware, storageinfo_amounts) end, { halign = "right" })
	else
		-- storage
		row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 2415) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(storagename, { halign = "right" })
		-- missing storage type
		if not nodedata.hasstorage then
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 8416), { color = Helper.color.red, wordwrap = true })
		end
		if C.IsComponentClass(container, "container") then
			if not isprocessed then
				-- amount
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 6521) .. ReadText(1001, 120))
				row[2]:setColSpan(2):createText(function () return Helper.getStorageAmount(container, nodedata, storageinfo_amounts, storageinfo_capacity) end, { halign = "right", mouseOverText = function () return Helper.getStorageAmount(container, nodedata, storageinfo_amounts, storageinfo_capacity, 0, true) end })
		
				ftable:addEmptyRow(Helper.standardTextHeight / 2)

				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 1600) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
				row[2]:setColSpan(2):createText(function () local production = C.GetContainerWareProduction(container, nodedata.ware, false); return Helper.unlockInfo(storageinfo_amounts, (production > 0) and ConvertIntegerString(production, true, 3, true, true) or "-") end, { halign = "right" })
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:createText(ReadText(1001, 1609) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
				row[2]:setColSpan(2):createText(function () local consumption = C.GetContainerWareConsumption(container, nodedata.ware, false) + Helper.getWorkforceConsumption(container, nodedata.ware); return Helper.unlockInfo(storageinfo_amounts, (consumption > 0) and ConvertIntegerString(consumption, true, 3, true, true) or "-") end, { halign = "right" })
				ftable:addEmptyRow(Helper.standardTextHeight / 2)
			end

			if nodedata.hasstorage and (not nodedata.planned) and GetComponentData(container, "isplayerowned") then
				local currentlimit = GetWareProductionLimit(container, nodedata.ware)
				if (not nodedata.cargo) or (currentlimit > 0) then
					local haslimitoverride = HasContainerStockLimitOverride(container, nodedata.ware)
					-- Automatically allocated capacity
					local n = C.GetNumContainerStockLimitOverrides(container)
					if n > 0 then
						local name, capacity = "", 0
						local n = C.GetNumCargoTransportTypes(container, true)
						local buf = ffi.new("StorageInfo[?]", n)
						n = C.GetCargoTransportTypes(buf, n, container, true, false)
						for i = 0, n - 1 do
							if ffi.string(buf[i].transport) == nodedata.type then
								name = ffi.string(buf[i].name)
								capacity = buf[i].capacity
								break
							end
						end

						row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
						row[1]:setColSpan(3):createText(ReadText(1001, 8444) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8403) })
						row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
						row[1]:createText(name)
						row[2]:setColSpan(2):createText(
							function()
								local total = 0
								local n = C.GetNumContainerStockLimitOverrides(container)
								local buf = ffi.new("UIWareInfo[?]", n)
								n = C.GetContainerStockLimitOverrides(buf, n, container)
								for i = 0, n - 1 do
									local ware = ffi.string(buf[i].ware)
									local transporttype, volume = GetWareData(ware, "transport", "volume")
									if transporttype == nodedata.type then
										total = total + buf[i].amount * volume
									end
								end
								local available = math.max(0, capacity - total)
								local color = Helper.color.white
								if available == 0 then
									color = Helper.color.red
								elseif available < 0.1 * capacity then
									color = Helper.color.warningorange
								end
								return Helper.unlockInfo(storageinfo_amounts, Helper.convertColorToText(color) .. ConvertIntegerString(available, true, 3, true, true) .. " " .. ReadText(1001, 110))
							end,
							{ halign = "right" }
						)
					end
					-- automatic storage level
					local row = ftable:addRow("autostoragecheckbox", { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "autostoragecheckbox" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					row[1]:setColSpan(2):createText(ReadText(1001, 8439) .. ReadText(1001, 120))
					row[3]:createCheckBox(not haslimitoverride, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return Helper.checkboxStorageLevelOverride(menu, container, nodedata.ware, row.index, currentlimit, checked) end
					if haslimitoverride then
						-- price
						local row = ftable:addRow("autostorageslider", { bgColor = Helper.color.transparent })
						if menu.selectedRowData["nodeTable"] == "autostorageslider" then
							menu.selectedRows["nodeTable"] = row.index
							menu.selectedRowData["nodeTable"] = nil
						end
						local max = GetWareCapacity(container, nodedata.ware)
						limitslider = row[1]:setColSpan(3):createSliderCell({
							height = Helper.standardTextHeight,
							valueColor = haslimitoverride and Helper.defaultSliderCellValueColor or Helper.color.grey,
							min = 0,
							minSelect = 1,
							max = max,
							start = math.max(1, math.min(max, currentlimit)),
							hideMaxValue = true,
							readOnly = not haslimitoverride,
						})
					end
				end
			end
		end
	end
	if nodedata.hasstorage and (not nodedata.planned) and GetComponentData(container, "isplayerowned") then
		Helper.LSOStorageNodeBuySlider = nil
		Helper.LSOStorageNodeSellSlider = nil
		-- buy offer
		if (waretype == "resource") or (waretype == "intermediate") or (waretype == "product") or (waretype == "trade") then
			local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(container, nodedata.ware, true))))
			local haspriceoverride = HasContainerWarePriceOverride(container, nodedata.ware, true)
			local istradewarebought = C.GetContainerWareIsBuyable(container, nodedata.ware)
			local currentlimit = C.GetContainerBuyLimit(container, nodedata.ware)
			local haslimitoverride = C.HasContainerBuyLimitOverride(container, nodedata.ware)
			-- title
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 8309), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			if (waretype == "resource") or (waretype == "intermediate") or istradewarebought or haslimitoverride then
				-- automatic buy limit
				local row = ftable:addRow("autobuylimitcheckbox", { bgColor = Helper.color.transparent })
				if menu.selectedRowData["nodeTable"] == "autobuylimitcheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if (waretype == "product") and istradewarebought then
					-- Valid case, but we need to hide it from the player
					currentlimit = math.max(1, currentlimit)
					Helper.setBuyLimit(menu, container, nodedata.ware, currentlimit)
					haslimitoverride = true
				end
				if (waretype == "product") then
					row[1]:setColSpan(3):createText(ReadText(1001, 11281) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8401) })
				else
					if haslimitoverride then
						row[1]:setColSpan(2):createText(ReadText(1001, 11281) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8401) })
					else
						row[1]:setColSpan(2):createText(ReadText(1001, 8440), { mouseOverText = ReadText(1026, 8408) })
					end
					row[3]:createCheckBox(not haslimitoverride, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return Helper.checkboxBuyLimitOverride(menu, container, nodedata.ware, row.index, currentlimit, checked) end
				end
				if haslimitoverride then
					-- buy limit
					local row = ftable:addRow("autobuylimitslider", { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "autobuylimitslider" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local max = GetWareProductionLimit(container, nodedata.ware)
					Helper.LSOStorageNodeBuySlider = { ware = nodedata.ware, widget = row[1]:setColSpan(3):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haslimitoverride and Helper.defaultSliderCellValueColor or Helper.color.grey,
						min = 0,
						minSelect = max == 0 and 0 or 1,
						max = max,
						start = math.min(max, currentlimit),
						hideMaxValue = true,
						readOnly = not haslimitoverride,
					})}
				end
				-- automatic pricing
				local row = ftable:addRow("autobuypricecheckbox", { bgColor = Helper.color.transparent })
				if menu.selectedRowData["nodeTable"] == "autobuypricecheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if haspriceoverride then
					row[1]:setColSpan(2):createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
				else
					row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
					row[2]:createText(function () return math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(container, nodedata.ware, true)))) .. " " .. ReadText(1001, 101) end, { halign = "right" })
				end
				row[3]:createCheckBox(not haspriceoverride, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function (_, checked) return Helper.checkboxStorageWarePriceOverride(menu, container, nodedata.ware, row.index, true, currentprice, checked) end
				if haspriceoverride then
					-- price
					local row = ftable:addRow("autobuypriceslider", { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "autobuypriceslider" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					row[1]:setColSpan(3):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haspriceoverride and Helper.defaultSliderCellValueColor or Helper.color.grey,
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
					})
					row[1].handlers.onSliderCellChanged = function(_, value) return Helper.slidercellStorageWarePriceOverride(container, nodedata.ware, true, value) end
					row[1].handlers.onSliderCellActivated = function (id) menu.noupdate = true end
					row[1].handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
				end
				-- trade rule
				local hasownlist = C.HasContainerOwnTradeRule(container, "buy", nodedata.ware)
				local traderuleid = C.GetContainerTradeRuleID(container, "buy", nodedata.ware)
				local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
				-- global
				local row = ftable:addRow("buytraderule_global", { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createText(ReadText(1001, 11025) .. ReadText(1001, 120), textproperties)
				row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function(_, checked) return Helper.checkboxSetTradeRuleOverride(menu, container, "buy", nodedata.ware, checked) end
				-- current
				local row = ftable:addRow("buytraderule_current", { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
				row[1].handlers.onDropDownConfirmed = function (_, id) return Helper.dropdownTradeRule(menu, container, "buy", nodedata.ware, id) end
				row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
				row[3].handlers.onClick = function () return Helper.buttonEditTradeRule(menu) end
			end
			-- create / remove offer
			if (waretype == "trade") or (waretype == "product") then
				row = ftable:addRow("tradebuy", { bgColor = Helper.color.transparent })
				if menu.selectedRowData["nodeTable"] == "trade" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if waretype == "trade" then
					row[1]:setColSpan(3):createButton({  }):setText(istradewarebought and ReadText(1001, 8407) or ReadText(1001, 8406), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageBuyTradeWare(menu, container, nodedata.ware, istradewarebought) end
				elseif waretype == "product" then
					row[1]:setColSpan(3):createButton({  }):setText((haslimitoverride or istradewarebought) and ReadText(1001, 8407) or ReadText(1001, 8406), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageBuyProductWare(menu, container, nodedata.ware, haslimitoverride or istradewarebought, currentlimit) end
				end
			end
			-- reservations
			if reservations[nodedata.ware] and (#reservations[nodedata.ware].buyoffer > 0) then
				-- title
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(string.format(ReadText(1001, 7994), GetWareData(nodedata.ware, "name")) .. ReadText(1001, 120), { wordwrap = true })
				for i, reservation in ipairs(reservations[nodedata.ware].buyoffer) do
					row = ftable:addRow("buyreservation" .. i, { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "buyreservation" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
					local name = (isplayerowned and Helper.convertColorToText(Helper.color.green) or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"

					-- kuertee start: callback
					-- row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					if callbacks ["onExpandLSOStorageNode_list_incoming_trade"] then
						for _, callback in ipairs (callbacks ["onExpandLSOStorageNode_list_incoming_trade"]) do
							callback (row, name, reservation, isplayerowned)
						end
					else
						row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					end
					-- kuertee end: callback

					row[2]:createText(ConvertIntegerString(reservation.amount, true, 3, false), { halign = "right" })
					row[3]:createButton({ active = function () return Helper.buttonCancelTradeActive(menu, container, reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
					row[3].handlers.onClick = function () return Helper.buttonCancelTrade(menu, container, reservation.tradedeal) end
				end
			end
		end

		-- sell offer
		if (not isprocessed) and ((waretype == "resource") or (waretype == "product") or (waretype == "intermediate") or (waretype == "trade")) then
			local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(container, nodedata.ware, false))))
			local haspriceoverride = HasContainerWarePriceOverride(container, nodedata.ware, false)
			local istradewaresold = C.GetContainerWareIsSellable(container, nodedata.ware)
			local currentlimit = C.GetContainerSellLimit(container, nodedata.ware)
			local haslimitoverride = C.HasContainerSellLimitOverride(container, nodedata.ware)
			-- title
			row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(ReadText(1001, 8308), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			if (waretype == "product") or (waretype == "intermediate") or istradewaresold or haslimitoverride then
				-- automatic sell limit
				local row = ftable:addRow("autoselllimitcheckbox", { bgColor = Helper.color.transparent })
				if menu.selectedRowData["nodeTable"] == "autoselllimitcheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if (waretype == "resource") and istradewaresold then
					-- Valid case, but we need to hide it from the player
					Helper.setSellLimit(menu, container, nodedata.ware, currentlimit)
					haslimitoverride = true
				end
				if (waretype == "resource") then
					row[1]:setColSpan(3):createText(ReadText(1001, 11282 ) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8402) })
				else
					if haslimitoverride then
						row[1]:setColSpan(2):createText(ReadText(1001, 11282) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8402) })
					else
						row[1]:setColSpan(2):createText(ReadText(1001, 8441), { mouseOverText = ReadText(1026, 8409) })
					end
					row[3]:createCheckBox(not haslimitoverride, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return Helper.checkboxSellLimitOverride(menu, container, nodedata.ware, row.index, currentlimit, checked) end
				end
				if haslimitoverride then
					-- sell limit
					local row = ftable:addRow("autoselllimitslider", { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "autoselllimitslider" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local max = GetWareProductionLimit(container, nodedata.ware)
					Helper.LSOStorageNodeSellSlider = { ware = nodedata.ware, widget = row[1]:setColSpan(3):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haslimitoverride and Helper.defaultSliderCellValueColor or Helper.color.grey,
						min = 0,
						minSelect = max == 0 and 0 or 1,
						max = max,
						start = math.min(max, currentlimit),
						hideMaxValue = true,
						readOnly = not haslimitoverride,
					})}
				end
				-- automatic pricing
				local row = ftable:addRow("autosellpricecheckbox", { bgColor = Helper.color.transparent })
				if menu.selectedRowData["nodeTable"] == "autosellpricecheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if haspriceoverride then
					row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
				else
					row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
					row[2]:createText(function () return math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(container, nodedata.ware, false)))) .. " " .. ReadText(1001, 101) end, { halign = "right" })
				end
				row[3]:createCheckBox(not haspriceoverride, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function (_, checked) return Helper.checkboxStorageWarePriceOverride(menu, container, nodedata.ware, row.index, false, currentprice, checked) end
				if haspriceoverride then
					-- price
					local row = ftable:addRow("autosellpriceslider", { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "autosellpriceslider" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					row[1]:setColSpan(3):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haspriceoverride and Helper.defaultSliderCellValueColor or Helper.color.grey,
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
					})
					row[1].handlers.onSliderCellChanged = function(_, value) return Helper.slidercellStorageWarePriceOverride(container, nodedata.ware, false, value) end
					row[1].handlers.onSliderCellActivated = function (id) menu.noupdate = true end
					row[1].handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
				end
				-- trade rule
				local hasownlist = C.HasContainerOwnTradeRule(container, "sell", nodedata.ware)
				local traderuleid = C.GetContainerTradeRuleID(container, "sell", nodedata.ware)
				local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
				-- global
				local row = ftable:addRow("selltraderule_global", { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createText(ReadText(1001, 11025) .. ReadText(1001, 120), textproperties)
				row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function(_, checked) return Helper.checkboxSetTradeRuleOverride(menu, container, "sell", nodedata.ware, checked) end
				-- current
				local row = ftable:addRow("selltraderule_current", { bgColor = Helper.color.transparent })
				row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
				row[1].handlers.onDropDownConfirmed = function (_, id) return Helper.dropdownTradeRule(menu, container, "sell", nodedata.ware, id) end
				row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
				row[3].handlers.onClick = function () return Helper.buttonEditTradeRule(menu) end
			end
			-- create / remove offer
			if (waretype == "trade") or (waretype == "resource") then
				row = ftable:addRow("tradesell", { bgColor = Helper.color.transparent })
				if menu.selectedRowData["nodeTable"] == "trade" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if waretype == "trade" then
					row[1]:setColSpan(3):createButton({  }):setText(istradewaresold and ReadText(1001, 8405) or ReadText(1001, 8404), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageSellTradeWare(menu, container, nodedata.ware, istradewaresold) end
				elseif waretype == "resource" then
					row[1]:setColSpan(3):createButton({  }):setText((haslimitoverride or istradewaresold) and ReadText(1001, 8405) or ReadText(1001, 8404), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageSellResourceWare(menu, container, nodedata.ware, haslimitoverride or istradewaresold, currentlimit) end
				end
			end
			-- reservations
			if reservations[nodedata.ware] and (#reservations[nodedata.ware].selloffer > 0) then
				-- title
				row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
				row[1]:setColSpan(3):createText(string.format(ReadText(1001, 7993), GetWareData(nodedata.ware, "name")) .. ReadText(1001, 120), { wordwrap = true })
				for i, reservation in ipairs(reservations[nodedata.ware].selloffer) do
					row = ftable:addRow("sellreservation" .. i, { bgColor = Helper.color.transparent })
					if menu.selectedRowData["nodeTable"] == "sellreservation" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
					local name = (isplayerowned and Helper.convertColorToText(Helper.color.green) or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"

					-- kuertee start: callback
					-- row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					if callbacks ["onExpandLSOStorageNode_list_incoming_trade"] then
						for _, callback in ipairs (callbacks ["onExpandLSOStorageNode_list_incoming_trade"]) do
							callback (row, name, reservation, isplayerowned)
						end
					else
						row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					end
					-- kuertee end: callback

					row[2]:createText(ConvertIntegerString(reservation.amount, true, 3, false), { halign = "right" })
					row[3]:createButton({ active = function () return Helper.buttonCancelTradeActive(menu, container, reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
					row[3].handlers.onClick = function () return Helper.buttonCancelTrade(menu, container, reservation.tradedeal) end
				end
			end
		end

		-- buy/sell slider hooks
		if limitslider then
			limitslider.handlers.onSliderCellChanged = function (_, value) return Helper.slidercellStorageLevelOverride(menu, container, nodedata.ware, value, Helper.LSOStorageNodeBuySlider, Helper.LSOStorageNodeSellSlider) end
			limitslider.handlers.onSliderCellActivated = function (id) menu.noupdate = true end
			limitslider.handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
		end
		if Helper.LSOStorageNodeBuySlider then
			Helper.LSOStorageNodeBuySlider.widget.handlers.onSliderCellChanged = function(_, value) return Helper.slidercellBuyLimitOverride(menu, container, nodedata.ware, value) end
			Helper.LSOStorageNodeBuySlider.widget.handlers.onSliderCellActivated = function (id) menu.noupdate = true end
			Helper.LSOStorageNodeBuySlider.widget.handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
		end
		if Helper.LSOStorageNodeSellSlider then 
			Helper.LSOStorageNodeSellSlider.widget.handlers.onSliderCellChanged = function(_, value) return Helper.slidercellSellLimitOverride(menu, container, nodedata.ware, value) end
			Helper.LSOStorageNodeSellSlider.widget.handlers.onSliderCellActivated = function (id) menu.noupdate = true end
			Helper.LSOStorageNodeSellSlider.widget.handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
		end
	end

	if menu.selectedRowData["nodeTable"] then
		menu.selectedCols["nodeTable"] = nil
	end
	menu.restoreTableState("nodeTable", ftable)
end

function Helper.getStorageAmount(container, nodedata, storageinfo_amounts, storageinfo_capacity, accuracy, showvolume)
	local amount = GetComponentData(container, "cargo")[nodedata.ware] or 0
	local limit = GetWareProductionLimit(container, nodedata.ware)
	local defaultlimit = C.GetContainerWareMaxProductionStorageForTime(container, nodedata.ware, 7200, true)
	local volume = GetWareData(nodedata.ware, "volume")
	if nodedata.cargo and (limit == 0) then
		-- non-production, non-trade ware, don't show maximum
		return Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(amount, true, accuracy or 6, true, true) .. (showvolume and ("\n" .. ConvertIntegerString(volume * amount, true, accuracy or 6, true, true) .. " " .. ReadText(1001, 110)) or ""))
	else
		if showvolume then
			local extratext = ""
			if limit < defaultlimit then
				extratext = "\n\n" .. ReadText(1001, 8467)
			end
			return string.format("%s%s / %s\n%s / %s%s", ((amount > limit) or (limit < defaultlimit)) and Helper.convertColorToText(Helper.color.warningorange) or "", Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(amount, true, accuracy or 3, true, true)), Helper.unlockInfo(storageinfo_capacity, ConvertIntegerString(limit, true, accuracy or 3, true, true)), Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(volume * amount, true, accuracy or 3, true, true)), Helper.unlockInfo(storageinfo_capacity, ConvertIntegerString(volume * limit, true, accuracy or 3, true, true)) .. " " .. ReadText(1001, 110), extratext)
		else
			return string.format("%s%s / %s", ((amount > limit) or (limit < defaultlimit)) and Helper.convertColorToText(Helper.color.warningorange) or "", Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(amount, true, accuracy or 3, true, true)), Helper.unlockInfo(storageinfo_capacity, ConvertIntegerString(limit, true, accuracy or 3, true, true)))
		end
	end
end

function Helper.getResourceBufferAmount(container, ware, storageinfo_amounts, accuracy)
	local amount = GetComponentData(container, "resourcebuffer")[ware] or 0
	return Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(amount, true, accuracy or 6, true, true))
end

function Helper.getWorkforceConsumption(container, ware)
	local resourceinfos = {}
	if C.IsComponentClass(container, "container") then
		resourceinfos = GetWorkForceRaceResources(container)
	end
	local amount = 0
	for _, resourceinfo in ipairs(resourceinfos) do
		local workforceinfo = C.GetWorkForceInfo(container, resourceinfo.race)
		for i, resource in ipairs(resourceinfo.resources) do
			if resource.ware == ware then
				amount = amount + Helper.round(resource.cycle * 3600 / resource.cycleduration * workforceinfo.current / resourceinfo.productamount)
			end
		end
	end
	return amount
end

function Helper.updateStorageLevel(menu, container, ware, value, buyslider, sellslider)
	if C.HasContainerBuyLimitOverride(container, ware) and (value < C.GetContainerBuyLimit(container, ware)) then
		Helper.setBuyLimit(menu, container, ware, value)
		if buyslider and (buyslider.ware == ware) then
			SetSliderCellValue(buyslider.widget.id, value)
		end
	end
	if C.HasContainerSellLimitOverride(container, ware) and (value < C.GetContainerSellLimit(container, ware)) then
		Helper.setSellLimit(menu, container, ware, value)
		if sellslider and (sellslider.ware == ware) then
			SetSliderCellValue(sellslider.widget.id, value)
		end
	end
	if buyslider and (buyslider.ware == ware) then
		buyslider.widget:updateMaxSelectValue(value)
		buyslider.widget:updateMaxValue(value)
	end
	if sellslider and (sellslider.ware == ware) then
		sellslider.widget:updateMaxSelectValue(value)
		sellslider.widget:updateMaxValue(value)
	end
	menu.expandedNode:updateMaxValue(math.max(value, GetComponentData(container, "cargo")[ware] or 0))
end

function Helper.setBuyLimit(menu, container64, ware, limit)
	C.SetContainerBuyLimitOverride(container64, ware, limit)
	C.SetContainerWareIsBuyable(container64, ware, true)
	if menu.expandedNode and (menu.expandedNode.customdata.nodedata.ware == ware) then
		menu.expandedNode:updateSlider1(math.max(0, math.min(menu.expandedNode.properties.max, C.GetContainerBuyLimit(container64, ware))))
	end
end

function Helper.setSellLimit(menu, container64, ware, limit)
	C.SetContainerSellLimitOverride(container64, ware, limit)
	C.SetContainerWareIsSellable(container64, ware, true)
	if menu.expandedNode and (menu.expandedNode.customdata.nodedata.ware == ware) then
		menu.expandedNode:updateSlider2(math.max(0, math.min(menu.expandedNode.properties.max, C.GetContainerSellLimit(container64, ware))))
	end
end

function Helper.clearBuyLimit(menu, container64, ware)
	C.ClearContainerBuyLimitOverride(container64, ware)
	if menu.expandedNode and (menu.expandedNode.customdata.nodedata.ware == ware) then
		menu.expandedNode:updateSlider1(nil)
	end
end

function Helper.clearSellLimit(menu, container64, ware)
	C.ClearContainerSellLimitOverride(container64, ware)
	if menu.expandedNode and (menu.expandedNode.customdata.nodedata.ware == ware) then
		menu.expandedNode:updateSlider2(nil)
	end
end

function Helper.buttonCancelTradeActive(menu, container, tradeid)
	if not C.IsValidTrade(tradeid) then
		menu.refreshnode = getElapsedTime()
		return
	end
	return C.CancelPlayerInvolvedTradeDeal(container, tradeid, true)
end

function Helper.buttonCancelTrade(menu, container, tradeid)
	if C.CancelPlayerInvolvedTradeDeal(container, tradeid, false) then
		-- The ware reservation is only implicitly removed after the trade was purged which only happens with a delay in gametime. To avoid no change in the menu after pressing the button, we hide the reservation now.
		Helper.dirtyreservations[tostring(tradeid)] = true
	end
	menu.updateExpandedNode()
end

function Helper.buttonStorageBuyProductWare(menu, container64, ware, haslimitoverride, currentlimit)
	if haslimitoverride then
		Helper.clearBuyLimit(menu, container64, ware)
		C.SetContainerWareIsBuyable(container64, ware, false)
	else
		Helper.setBuyLimit(menu, container64, ware, math.max(1, currentlimit))
	end

	menu.updateExpandedNode()
end

function Helper.buttonStorageBuyTradeWare(menu, container64, ware, istradewarebought)
	local istradewaresold = C.GetContainerWareIsSellable(container64, ware)

	if not istradewaresold then
		if not istradewarebought then
			C.AddTradeWare(container64, ware)
		else
			ClearContainerStockLimitOverride(container64, ware)
		end
	end

	if istradewarebought then
		Helper.clearBuyLimit(menu, container64, ware)
	end
	C.SetContainerWareIsBuyable(container64, ware, not istradewarebought)

	menu.updateExpandedNode()
end

function Helper.buttonStorageSellResourceWare(menu, container64, ware, haslimitoverride, currentlimit)
	if haslimitoverride then
		Helper.clearSellLimit(menu, container64, ware)
		C.SetContainerWareIsSellable(container64, ware, false)
	else
		Helper.setSellLimit(menu, container64, ware, currentlimit)
	end

	menu.updateExpandedNode()
end

function Helper.buttonStorageSellTradeWare(menu, container64, ware, istradewaresold)
	local istradewarebought = C.GetContainerWareIsBuyable(container64, ware)

	if not istradewarebought then
		if not istradewaresold then
			C.AddTradeWare(container64, ware)
		else
			ClearContainerStockLimitOverride(container64, ware)
		end
	end

	if istradewaresold then
		Helper.clearSellLimit(menu, container64, ware)
	end
	C.SetContainerWareIsSellable(container64, ware, not istradewaresold)

	menu.updateExpandedNode()
end

function Helper.buttonEditTradeRule(menu)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders" })
	menu.cleanup()
end

function Helper.checkboxStorageLevelOverride(menu, container, ware, row, currentlimit, checked)
	if checked then
		ClearContainerStockLimitOverride(container, ware)
		local value = GetWareProductionLimit(container, ware)
		Helper.updateStorageLevel(menu, container, ware, value)
		menu.updateExpandedNode(row, 3)
	else
		SetContainerStockLimitOverride(container, ware, math.max(1, currentlimit))
		menu.updateExpandedNode(row, 3)
	end
end

function Helper.checkboxBuyLimitOverride(menu, container, ware, row, currentlimit, checked)
	if checked then
		Helper.clearBuyLimit(menu, container, ware)
	else
		currentlimit = math.min(currentlimit, C.GetContainerSellLimit(container, ware))
		if currentlimit == 0 then
			-- trade ware case. For tradewares a non-override buylimit of 0 means it buys until the "production" limit. So init with that value to keep functionality consistent.
			currentlimit = GetWareProductionLimit(container, ware)
		end
		Helper.setBuyLimit(menu, container, ware, currentlimit)
	end
	menu.updateExpandedNode(row, 3)
end

function Helper.checkboxSellLimitOverride(menu, container, ware, row, currentlimit, checked)
	if checked then
		Helper.clearSellLimit(menu, container, ware)
	else
		currentlimit = math.max(1, math.max(currentlimit, C.GetContainerBuyLimit(container, ware)))
		Helper.setSellLimit(menu, container, ware, currentlimit)
	end
	menu.updateExpandedNode(row, 3)
end

function Helper.checkboxStorageWarePriceOverride(menu, container, ware, row, buysellswitch, price, checked)
	if checked then
		ClearContainerWarePriceOverride(container, ware, buysellswitch)
	else
		SetContainerWarePriceOverride(container, ware, buysellswitch, price)
	end

	menu.updateExpandedNode(row, 3)
end
	 
function Helper.checkboxSetTradeRuleOverride(menu, container, type, ware, checked)
	if checked then 
		C.SetContainerTradeRule(container, -1, type, ware, false)
	else
		local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
		C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware, true)
	end

	if (type == "buy") or (type == "sell") then
		menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(container, ware) and "lso_error" or nil, nil, Helper.color.warningorange)
	end
	menu.updateExpandedNode()
end

function Helper.dropdownAssignment(_, ship, subordinategroupid, commander, newassignment)
	if (not ship and (not subordinategroupid or not commander)) then
		DebugError("Helper.dropdownAssignment called with neither ship nor valid subordinategroup specified. If working with subordinategroup, commander must also be specified.")
		return
	end

	local currentassignment
	if ship then
		currentassignment = GetComponentData(ship, "assignment")
	else
		currentassignment = ffi.string(C.GetSubordinateGroupAssignment(ConvertIDTo64Bit(commander), subordinategroupid))
	end

	--print("Helper.dropdownAssignment. changing assignment from " .. tostring(currentassignment) .. " to " .. tostring(newassignment))

	if newassignment ~= currentassignment then
		if ship then
			local commander = GetCommander(ship)
			local orderindex = C.CreateOrder(ship, "AssignCommander", false)
		
			if orderindex > 0 then
				-- commander
				SetOrderParam(ship, orderindex, 1, nil, ConvertStringToLuaID(tostring(commander)))
				-- assignment
				SetOrderParam(ship, orderindex, 2, nil, newassignment)

				C.EnableOrder(ship, orderindex)
				if orderindex ~= 1 then
					C.AdjustOrder(ship, orderindex, 1, true, false, false)
				end
			end
		else
			if newassignment == "positiondefence" then
				Helper.setIntersectorDefence(ConvertIDTo64Bit(commander), subordinategroupid)
			end

			local numsubordinates = C.GetNumSubordinatesOfGroup(commander, subordinategroupid)
			local subordinates = ffi.new("UniverseID[?]", numsubordinates)
			numsubordinates = C.GetSubordinatesOfGroup(subordinates, numsubordinates, commander, subordinategroupid)
			--print("got " .. tostring(numsubordinates) .. " subordinates in group " .. tostring(subordinategroupid))

			for i = 0, numsubordinates - 1 do
				local subordinate = ConvertStringTo64Bit(tostring(subordinates[i]))
				local orderindex = C.CreateOrder(subordinate, "AssignCommander", false)

				if orderindex > 0 then
					-- commander
					SetOrderParam(subordinate, orderindex, 1, nil, ConvertStringToLuaID(tostring(commander)))
					-- assignment
					SetOrderParam(subordinate, orderindex, 2, nil, newassignment)
					-- subordinategroupid
					SetOrderParam(subordinate, orderindex, 3, nil, subordinategroupid)

					C.EnableOrder(subordinate, orderindex)
					if orderindex ~= 1 then
						C.AdjustOrder(subordinate, orderindex, 1, true, false, false)
					end
				end
			end

			C.SetSubordinateGroupAssignment(commander, subordinategroupid, newassignment)
		end
	end
end

function  Helper.dropdownTradeRule(menu, container, type, ware, id)
	C.SetContainerTradeRule(container, tonumber(id), type, ware, true)
	
	if (type == "buy") or (type == "sell") then
		menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(container, ware) and "lso_error" or nil, nil, Helper.color.warningorange)
	end
end

function Helper.slidercellBuyLimitOverride(menu, container, ware, value)
	if value then
		Helper.setBuyLimit(menu, container, ware, value)
	end
end

function Helper.slidercellSellLimitOverride(menu, container, ware, value)
	if value then
		Helper.setSellLimit(menu, container, ware, value)
	end
end

function Helper.slidercellStorageLevelOverride(menu, container, ware, value, buyslider, sellslider)
	if value then
		SetContainerStockLimitOverride(container, ware, value)
		Helper.updateStorageLevel(menu, container, ware, value, buyslider, sellslider)
	end
end

function Helper.slidercellStorageWarePriceOverride(container, ware, buysellswitch, value)
	if value then
		SetContainerWarePriceOverride(container, ware, buysellswitch, value)
	end
end

function Helper.onCollapseLSOStorageNode(menu, nodedata)
	UnregisterEvent("newWareReservation", menu.newWareReservationCallback)
	menu.wareReservationRegistered = nil
	Helper.LSOStorageNodeBuySlider = nil
	Helper.LSOStorageNodeSellSlider = nil
end

function Helper.onSliderChangedLSOStorageNode(container, node, nodedata, slideridx, value)
	if value then
		if value == 0 then
			value = 1
			if slideridx == 1 then
				node:updateSlider1(value)
			else
				node:updateSlider2(value)
			end
		end

		local ware = nodedata.ware
		local productionlimit = GetWareProductionLimit(container, ware)
		if value > productionlimit then
			value = productionlimit
			if slideridx == 1 then
				node:updateSlider1(value)
			else
				node:updateSlider2(value)
			end
		end
		if slideridx == 1 then
			C.SetContainerBuyLimitOverride(container, ware, value)
			if Helper.LSOStorageNodeBuySlider and (Helper.LSOStorageNodeBuySlider.ware == ware) then
				SetSliderCellValue(Helper.LSOStorageNodeBuySlider.widget.id, value)
			end
		else
			C.SetContainerSellLimitOverride(container, ware, value)
			if Helper.LSOStorageNodeSellSlider and (Helper.LSOStorageNodeSellSlider.ware == ware) then
				SetSliderCellValue(Helper.LSOStorageNodeSellSlider.widget.id, value)
			end
		end
	end
end

Helper.turretModes = {
	[1] = { id = "defend",			text = ReadText(1001, 8613),	icon = "",	displayremoveoption = false,	forall = true },
	[2] = { id = "attackenemies",	text = ReadText(1001, 8614),	icon = "",	displayremoveoption = false,	forall = true },
	[3] = { id = "attackcapital",	text = ReadText(1001, 8624),	icon = "",	displayremoveoption = false,	forall = true },
	[4] = { id = "attackfighters",	text = ReadText(1001, 8625),	icon = "",	displayremoveoption = false,	forall = true },
	[5] = { id = "mining",			text = ReadText(1001, 8616),	icon = "",	displayremoveoption = false,	forall = true },
	[6] = { id = "missiledefence",	text = ReadText(1001, 8615),	icon = "",	displayremoveoption = false,	forall = true },
	[7] = { id = "autoassist",		text = ReadText(1001, 8617),	icon = "",	displayremoveoption = false,	forall = true },
	[8] = { id = "towing",			text = ReadText(1001, 8633),	icon = "",	displayremoveoption = false,	forall = false },
}

function Helper.getTurretModes(turret, forall)
	local options = {}
	for _, entry in ipairs(Helper.turretModes) do
		if (not forall) or (forall == entry.forall) then
			if (turret == nil) or C.IsWeaponModeCompatible(turret, "", entry.id) then
				table.insert(options, entry)
			end
		end
	end
	return options
end

function Helper.getMacroTurretModes(turret, forall)
	local options = {}
	for _, entry in ipairs(Helper.turretModes) do
		if (not forall) or (forall == entry.forall) then
			if (turret == "") or C.IsWeaponModeCompatible(0, turret, entry.id) then
				table.insert(options, entry)
			end
		end
	end
	return options
end

function Helper.createDropWaresContext(menu, frame, instance)
	local lockboxes = {}
	local player = C.GetPlayerID()
	local n = C.GetNumAvailableLockboxes(player)
	local buf = ffi.new("const char*[?]", n)
	n = C.GetAvailableLockboxes(buf, n, player)
	for i = 0, n - 1 do
		table.insert(lockboxes, GetWareData(ffi.string(buf[i]), "component"))
	end

	local curOption = menu.contextMenuData.dropLockbox or "none"
	local options = {
		{ id = "none", text = ReadText(1001, 7731), icon = "", displayremoveoption = false }
	}
	for _, box in ipairs(lockboxes) do
		if (menu.contextMenuData.dropLockbox == nil) and (curOption == "none") then
			menu.contextMenuData.dropLockbox = box
			curOption = box
		end
		table.insert(options, { id = box, text = GetMacroData(box, "name"), icon = "", displayremoveoption = false })
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	if menu.contextMenuData.mode == "ventureconvert" then
		ftable:setColWidthPercent(1, 40)
		ftable:setColWidthPercent(3, 40)
	end

	local row = ftable:addRow(false, { fixed = true })
	if menu.contextMenuData.mode == "venturedonate" then
		row[1]:setColSpan(3):createText(ReadText(1001, 11530), Helper.headerRowCenteredProperties)
	elseif menu.contextMenuData.mode == "ventureconvert" then
		row[1]:setColSpan(3):createText(ReadText(1001, 11381), Helper.headerRowCenteredProperties)
	else
		row[1]:setColSpan(3):createText(ReadText(1001, 7733), Helper.headerRowCenteredProperties)
	end

	for _, entry in ipairs(menu.contextMenuData.wares) do
		local conversionrate = entry.conversionrate or 1
		local slidermax = entry.amount * conversionrate

		local text = entry.name
		if menu.contextMenuData.mode == "ventureconvert" then
			text = string.format(ReadText(1001, 11385), entry.convertedname)
		end

		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(3):createSliderCell({ height = Helper.standardTextHeight, min = 0, max = slidermax, start = slidermax, step = conversionrate }):setText(text)
		row[1].handlers.onSliderCellChanged = function (_, value) return Helper.slidercellDropWares(menu, entry.ware, value / conversionrate) end
	end

	if menu.contextMenuData.mode == "ventureconvert" then
		local waredata = menu.contextMenuData.wares[1]
		if waredata then
			local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText("1" .. ReadText(1001, 42) .. " " .. waredata.name .. " = " .. waredata.conversionrate .. ReadText(1001, 42) .. " " .. waredata.convertedname, { halign = "right" })

			ftable:addEmptyRow()

			row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
			row[1]:setColSpan(3):createText(string.format(ReadText(1001, 11559), waredata.name, waredata.convertedname) .. "\n" .. string.format(ReadText(1001, 11562), waredata.convertedname), { wordwrap = true })
		end
	elseif menu.contextMenuData.mode ~= "venturedonate" then
		ftable:addEmptyRow()

		row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:createText(ReadText(1001, 7732))
		row[2]:setColSpan(2):createDropDown(options, { startOption = curOption })
		row[2].handlers.onDropDownConfirmed = function (_, id) return Helper.dropdownDropWaresLockbox(menu, id) end
	end

	row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	if menu.contextMenuData.mode == "venturedonate" then
		row[1]:createButton({  }):setText(ReadText(1001, 11530), { halign = "center" })
		row[1].handlers.onClick = function () return Helper.callExtensionFunction("multiverse", "donateVentureItem", menu) end
	elseif menu.contextMenuData.mode == "ventureconvert" then
		local name = ReadText(1001, 11381)
		if menu.contextMenuData.success ~= nil then
			name = menu.contextMenuData.success and ReadText(1001, 11383) or ReadText(1001, 11382)
		elseif menu.contextMenuData.converting ~= nil then
			name = ReadText(1001, 11384)
		end
		row[1]:createButton({ active = (menu.contextMenuData.success == nil) and (menu.contextMenuData.converting == nil) }):setText(((menu.contextMenuData.success ~= nil) and Helper.convertColorToText((menu.contextMenuData.success == -1) and Helper.color.green or Helper.color.red) or "") .. name, { halign = "center" })
		row[1].handlers.onClick = function () return Helper.callExtensionFunction("multiverse", "convertVentureItem", menu) end
	else
		row[1]:createButton({  }):setText((#menu.contextMenuData.wares > 1) and ReadText(1001, 7733) or ReadText(1001, 7705), { halign = "center" })
		row[1].handlers.onClick = function () return Helper.buttonDropWares(menu) end
	end
	row[3]:createButton({ active = (menu.contextMenuData.mode ~= "ventureconvert") or (not menu.contextMenuData.success) }):setText(ReadText(1001, 64), { halign = "center" })
	row[3].handlers.onClick = function () return menu.onCloseElement("back") end
end

function Helper.slidercellDropWares(menu, ware, value)
	for _, entry in ipairs(menu.contextMenuData.wares) do
		if entry.ware == ware then
			entry.amount = value
		end
	end
end

function Helper.dropdownDropWaresLockbox(menu, id)
	menu.contextMenuData.dropLockbox = id
end

function Helper.buttonDropWares(menu)
	local wares = ffi.new("UIWareAmount[?]", #menu.contextMenuData.wares)

	for i, entry in ipairs(menu.contextMenuData.wares) do
		wares[i - 1].wareid = Helper.ffiNewString(entry.ware)
		wares[i - 1].amount = entry.amount
	end

	local lockbox = menu.contextMenuData.dropLockbox
	if lockbox == "none" then
		lockbox = nil
	end
	if menu.contextMenuData.mode == "inventory" then
		C.DropInventory(menu.contextMenuData.entity, lockbox, wares, #menu.contextMenuData.wares)
	end

	menu.closeContextMenu()
end

-- indents given text with given char sequence
-- takes necessary linebreaks into account according to textboxwidth, font and fontsize
function Helper.indentText(text, indentstring, textboxwidth, font, fontsize)
	local width = textboxwidth - C.GetTextWidth(indentstring .. "\n", font, fontsize)
	local textTable = GetTextLines(text, font, fontsize, width)

	indentedText = ""
	for i, line in ipairs(textTable) do
		indentedText = indentedText .. indentstring .. line
		if i < #textTable then
			indentedText = indentedText .. "\n"
		end
	end

	return indentedText
end

function Helper.registerStationEditorChanges()
	Helper.confirmDiscardStationEditorChanges = true
end

function Helper.unregisterStationEditorChanges()
	Helper.confirmDiscardStationEditorChanges = nil
end

function Helper.checkDiscardStationEditorChanges(menu, dueToClose)
	if Helper.confirmDiscardStationEditorChanges then
		Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "discardstationeditor" })
		if menu.cleanup then
			menu.cleanup()
		end
		return true
	end
	Helper.clearStationEditorState()
	return false
end

function Helper.registerStationEditorState(menu)
	Helper.stationEditorState = menu
end

function Helper.clearStationEditorState()
	if Helper.stationEditorState then
		C.ReleaseConstructionMapState()
		Helper.stationEditorState.state = nil
		Helper.stationEditorState = nil
	end
end

function Helper.getBlackLists()
	local blacklists = {}
	Helper.ffiVLA(blacklists, "BlacklistID", C.GetNumAllBlacklists, C.GetAllBlacklists)
	for i = #blacklists, 1, -1 do
		local id = blacklists[i]

		local counts = C.GetBlacklistInfoCounts(id)
		local buf = ffi.new("BlacklistInfo2")
		buf.nummacros = counts.nummacros
		buf.macros = Helper.ffiNewHelper("const char*[?]", counts.nummacros)
		buf.numfactions = counts.numfactions
		buf.factions = Helper.ffiNewHelper("const char*[?]", counts.numfactions)
		if C.GetBlacklistInfo2(buf, id) then
			local type = ffi.string(buf.type)

			local spaces = {}
			for j = 0, buf.nummacros - 1 do
				table.insert(spaces, ConvertIDTo64Bit(GetMacroData(ffi.string(buf.macros[j]), "sectorcomponent")))
			end

			local factions = {}
			for j = 0, buf.numfactions - 1 do
				table.insert(factions, ffi.string(buf.factions[j]))
			end

			local defaults = {
				["civilian"] = C.IsPlayerBlacklistDefault(id, type, "civilian"),
				["military"] = C.IsPlayerBlacklistDefault(id, type, "military"),
			}

			blacklists[i] = { id = id, type = type, name = ffi.string(buf.name), spaces = spaces, factions = factions, relation = ffi.string(buf.relation), hazardous = buf.hazardous, defaults = defaults, usemacrowhitelist = buf.usemacrowhitelist, usefactionwhitelist = buf.usefactionwhitelist }
		else
			table.remove(blacklists, i)
		end
	end
	table.sort(blacklists, Helper.sortID)

	return blacklists
end

function Helper.getFightRules()
	local fightrules = {}
	Helper.ffiVLA(fightrules, "FightRuleID", C.GetNumAllFightRules, C.GetAllFightRules)
	for i = #fightrules, 1, -1 do
		local id = fightrules[i]

		local counts = C.GetFightRuleInfoCounts(id)
		local buf = ffi.new("FightRuleInfo")
		buf.numfactions = counts.numfactions
		buf.factions = Helper.ffiNewHelper("UIFightRuleSetting[?]", counts.numfactions)
		if C.GetFightRuleInfo(buf, id) then
			local settings = {}
			for j = 0, buf.numfactions - 1 do
				local faction = ffi.string(buf.factions[j].factionid)
				local civilian = ffi.string(buf.factions[j].civiliansetting)
				if civilian == "" then
					civilian = "default"
				end
				local military = ffi.string(buf.factions[j].militarysetting)
				if military == "" then
					military = "default"
				end
				settings[faction] = { civilian = civilian, military = military }
			end

			local defaults = {
				["attack"] = C.IsPlayerFightRuleDefault(id, "attack"),
			}

			fightrules[i] = { id = id, name = ffi.string(buf.name), settings = settings, defaults = defaults }
		else
			table.remove(fightrules, i)
		end
	end
	table.sort(fightrules, Helper.sortID)

	return fightrules
end

function Helper.setIntersectorDefence(controllable, group, reset, sectorid, pos_in)
	local locsectorid = sectorid or GetComponentData(controllable, "sectorid")
	local pos = pos_in or C.GetObjectPositionInSector(controllable)

	local int, frac = math.modf(group / 2)
	local zoffset = int * ((frac > 0) and 1 or -1)
	local locpos = ffi.new("UIPosRot", { x = pos.x + Helper.intersectorDefenceFactor, y = pos.y, z = pos.z + zoffset * Helper.intersectorDefenceFactor })
	C.SetSubordinateGroupProtectedLocation(controllable, group, reset and 0 or ConvertIDTo64Bit(locsectorid), locpos)
	if reset then
		C.ReleaseDetachedSubordinateGroup(controllable, group)
	else
		C.SetSubordinateGroupAssignment(controllable, group, "positiondefence")
	end
end

function Helper.getDisplayableGateDestinationSpace(gate)
	-- If jump gate leads to a different star system, only show system (cluster) name
	-- Note: See identical logic in MissionManager, Gate::GetSpokenName() and MD (Notifications.xml, cue "ChangedSpace")
	local destgate = GetComponentData(gate, "destination")
	if destgate then
		local origcluster = GetContextByClass(gate, "cluster")
		local destcluster = GetContextByClass(destgate, "cluster")
		if origcluster and destcluster then
			local origsystemid = GetComponentData(origcluster, "systemid")
			local destsystemid = GetComponentData(destcluster, "systemid")
			if origcluster == destcluster or (destsystemid ~= 0 and origsystemid == destsystemid) or (not IsInfoUnlockedForPlayer(destcluster, "name")) then
				-- Gate leads to same cluster or same system: Show sector name instead
				-- Gate leads to unknown cluster: Show sector name (which defaults to Unknown sector)
				-- Note: All clusters within a system are supposed to have the same name (the system name)
				return GetContextByClass(destgate, "sector")
			else
				return destcluster
			end
		end
	end
	return nil
end

function Helper.getHoloMapColors()
	local productioncolor, buildcolor, storagecolor, radarcolor, dronedockcolor, efficiencycolor, defencecolor, playercolor, friendcolor, enemycolor, missioncolor, currentplayershipcolor, visitorcolor, lowalertcolor, mediumalertcolor, highalertcolor, gatecolor, highwaygatecolor, missilecolor, superhighwaycolor, highwaycolor, hostilecolor = GetHoloMapColors()
	return { productioncolor = productioncolor, buildcolor = buildcolor, storagecolor = storagecolor, radarcolor = radarcolor, dronedockcolor = dronedockcolor, efficiencycolor = efficiencycolor, defencecolor = defencecolor, playercolor = playercolor, friendcolor = friendcolor, enemycolor = enemycolor, missioncolor = missioncolor, currentplayershipcolor = currentplayershipcolor, visitorcolor = visitorcolor, lowalertcolor = lowalertcolor, mediumalertcolor = mediumalertcolor, highalertcolor = highalertcolor, gatecolor = gatecolor, highwaygatecolor = highwaygatecolor, missilecolor = missilecolor, superhighwaycolor = superhighwaycolor, highwaycolor = highwaycolor, hostilecolor = hostilecolor }
end

Helper.chatParams = {}

-- kuertee start: custom graph menu
function Helper.createCustomGraph(frame, container, tableProperties, refreshCallback, selectionData, title_menu, title_graph, func_getGraphData, title_xAxis, title_yAxis, isYAxisMoney, isShowLogTotal)
	-- do this in func_getGraphData():
	-- ===============================
	-- for each log entry:
	-- ===================
	-- table.insert(Helper.transactionLogData.accountLogUnfiltered, {
	-- 	  time = time,
	-- 	  entryid = id (time is a good id),
	-- 	  eventtypename = text for unexpanded log entry,
	-- 	  value = value of entry,
	-- 	  description = text for expanded log entry,
	-- })
	-- local entry = Helper.transactionLogData.accountLogUnfiltered[#Helper.transactionLogData.accountLogUnfiltered]
	-- table.insert(Helper.transactionLogData.accountLog, entry)
	-- =====================
	-- for each graph entry:
	-- =====================
	-- table.insert(Helper.transactionLogData.graphdata, { 
	-- 	  entryid = id (time is a good id),
	-- 	  x = value of horizontal data from entry. time is a good value for x,
	-- 	  y = value of vertical data from entry,
	-- })
	Helper.transactionLogData = {
		isCustomGraph = true,

		title_menu = title_menu,
		title_graph = title_graph,
		xTitle = title_xAxis,
		yTitle = title_yAxis,

		accountLog = {},
		accountLogUnfiltered = {},
		transactionsByID = {},
		transactionsByIDUnfiltered = {},
		graphdata = {},
		graphdata2 = {},
		graphdata3 = {},

		xZoom = Helper.transactionLogData and Helper.transactionLogData.xZoom or 6,
		xScale = Helper.transactionLogData and Helper.transactionLogData.xScale or 60,
		xGranularity = Helper.transactionLogData and Helper.transactionLogData.xGranularity or 300,
		expandedEntries = Helper.transactionLogData and Helper.transactionLogData.expandedEntries or {},
		searchtext = Helper.transactionLogData and Helper.transactionLogData.searchtext or "",
		curPage = Helper.transactionLogData and Helper.transactionLogData.curPage or 1,
		curEntry = Helper.transactionLogData and Helper.transactionLogData.curEntry or nil,

		numPages = 1,
		pageEditBox = nil,
		graph = nil,
		noupdate = nil,
	}

	func_getGraphData()

	Helper.debugText_forced("helper.xpl.createCustomGraph accountLogUnfiltered", Helper.transactionLogData.accountLogUnfiltered)
	Helper.debugText_forced("helper.xpl.createCustomGraph accountLog", Helper.transactionLogData.accountLog)
	Helper.debugText_forced("helper.xpl.createCustomGraph graphdata", Helper.transactionLogData.graphdata)
	Helper.debugText_forced("helper.xpl.createCustomGraph graphdata2", Helper.transactionLogData.graphdata2)
	Helper.debugText_forced("helper.xpl.createCustomGraph graphdata3", Helper.transactionLogData.graphdata3)
	if #Helper.transactionLogData.accountLogUnfiltered < 1 then
		return
	end

	if #Helper.transactionLogData.accountLogUnfiltered then
		table.sort(Helper.transactionLogData.accountLogUnfiltered, function (a, b) return a.time < b.time end)
	end
	if #Helper.transactionLogData.accountLog then
		table.sort(Helper.transactionLogData.accountLog, function (a, b) return a.time < b.time end)
	end
	if #Helper.transactionLogData.graphdata then
		table.sort(Helper.transactionLogData.graphdata, function (a, b) return a.t < b.t end)
	end
	if #Helper.transactionLogData.graphdata2 then
		table.sort(Helper.transactionLogData.graphdata2, function (a, b) return a.t < b.t end)
	end
	if #Helper.transactionLogData.graphdata3 then
		table.sort(Helper.transactionLogData.graphdata3, function (a, b) return a.t < b.t end)
	end

	local endtime
	if Helper.transactionLogData.searchtext ~= "" then
		endtime = Helper.transactionLogData.accountLog[#Helper.transactionLogData.accountLog].time
	else
		endtime = Helper.transactionLogData.accountLogUnfiltered[#Helper.transactionLogData.accountLog].time
	end
	local starttime = math.max(0, endtime - 60 * Helper.transactionLogConfig.zoomSteps[Helper.transactionLogData.xZoom].zoom)

	-- apply search
	if Helper.transactionLogData.searchtext ~= "" then
		Helper.transactionLogData.accountLog = {}
		for _, entry in ipairs(Helper.transactionLogData.accountLogUnfiltered) do
			if Helper.transactionLogSearchHelper(entry, Helper.transactionLogData.searchtext) then
				table.insert(Helper.transactionLogData.accountLog, entry)
			end
		end
	end
	-- create transaction index
	for i, entry in ipairs(Helper.transactionLogData.accountLogUnfiltered) do
		Helper.transactionLogData.transactionsByIDUnfiltered[entry.entryid] = i
		-- set money = value so that other functions to work
		entry.money = entry.value
	end
	for i, entry in ipairs(Helper.transactionLogData.accountLog) do
		Helper.transactionLogData.transactionsByID[entry.entryid] = i
		-- set money = value so that other functions to work
		entry.money = entry.value
	end
	-- make sure the page of the selected entry is shown
	if Helper.transactionLogData.curEntry then
		local transactionIndex = Helper.transactionLogData.transactionsByID[Helper.transactionLogData.curEntry]
		if transactionIndex then
			Helper.transactionLogData.curPage = math.ceil((#Helper.transactionLogData.accountLog - transactionIndex + 1) / Helper.transactionLogConfig.transactionLogPage)
		end
	end

	Helper.transactionLogData.numPages = math.max(1, math.ceil(#Helper.transactionLogData.accountLog / Helper.transactionLogConfig.transactionLogPage))
	Helper.transactionLogData.curPage = math.max(1, math.min(Helper.transactionLogData.numPages, Helper.transactionLogData.curPage))

	local startIndex = #Helper.transactionLogData.accountLog
	local endIndex = 1
	if #Helper.transactionLogData.accountLog <= Helper.transactionLogConfig.transactionLogPage then
		Helper.transactionLogData.curPage = 1
	else
		endIndex = #Helper.transactionLogData.accountLog - Helper.transactionLogConfig.transactionLogPage * Helper.transactionLogData.curPage + 1
		startIndex = Helper.transactionLogConfig.transactionLogPage + endIndex - 1
		if endIndex < 1 then
			endIndex = 1
		end
	end

	local editboxHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
	local buttonsize = Helper.scaleY(Helper.standardTextHeight)

	local table_data = frame:addTable(9, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	table_data:setColWidth(1, Helper.standardTextHeight)
	table_data:setColWidth(3, Helper.standardTextHeight)
	table_data:setColWidth(4, Helper.standardTextHeight)
	table_data:setColWidth(5, Helper.standardTextHeight)
	table_data:setColWidth(6, tableProperties.width / 6 - 2 * (buttonsize + Helper.borderSize), false)
	table_data:setColWidth(7, tableProperties.width / 6 - 2 * (buttonsize + Helper.borderSize), false)
	table_data:setColWidth(8, Helper.standardTextHeight)
	table_data:setColWidth(9, Helper.standardTextHeight)

	local row = table_data:addRow(nil, { fixed = true, bgColor = Helper.defaultTitleBackgroundColor })
	row[1]:setColSpan(9):createText(title_menu, Helper.titleTextProperties)

	local row = table_data:addRow("search", { fixed = true })
	-- searchbar
	row[1]:setColSpan(2):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250), height = Helper.subHeaderHeight }):setText(Helper.transactionLogData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= Helper.transactionLogData.searchtext then Helper.transactionLogData.searchtext = text; Helper.transactionLogData.noupdate = nil; refreshCallback() end end
	-- clear search
	local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
	row[3]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setText("X", { halign = "center", font = Helper.standardFontBold })
	row[3].handlers.onClick = function () Helper.transactionLogData.searchtext = ""; refreshCallback() end
	-- pages
	row[4]:createButton({ scaling = false, active = Helper.transactionLogData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[4].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = 1; refreshCallback() end
	row[5]:createButton({ scaling = false, active = Helper.transactionLogData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[5].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.curPage - 1; refreshCallback() end
	Helper.transactionLogData.pageEditBox = row[6]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(Helper.transactionLogData.curPage .. " / " .. Helper.transactionLogData.numPages, { halign = "center" })
	row[6].handlers.onEditBoxDeactivated = function (_, text, textchanged) Helper.transactionLogData.noupdate = nil; return Helper.editboxTransactionLogPage(text, textchanged, refreshCallback) end
	row[8]:createButton({ scaling = false, active = Helper.transactionLogData.curPage < Helper.transactionLogData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[8].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.curPage + 1; refreshCallback() end
	row[9]:createButton({ scaling = false, active = Helper.transactionLogData.curPage < Helper.transactionLogData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Helper.color.transparent }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[9].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.numPages; refreshCallback() end

	local headerHeight = table_data:getFullHeight()

	if #Helper.transactionLogData.accountLog > 0 then
		local total = 0
		for i = startIndex, endIndex, -1 do
			local entry = Helper.transactionLogData.accountLog[i]
			local row = table_data:addRow(entry.entryid, { bgColor = Helper.color.transparent })
			if Helper.transactionLogData.curEntry == entry.entryid then
				local numLines = (table_data.properties.maxVisibleHeight - headerHeight) / (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize)
				if selectionData.toprow and ((selectionData.toprow > row.index - numLines) and (selectionData.toprow < row.index + numLines + 1)) then
					table_data:setTopRow(selectionData.toprow)
				else
					table_data:setTopRow(row.index)
				end
				table_data:setSelectedRow(row.index)
				selectionData = {}
			end
			-- if entry.description ~= "" then
			-- 	row[1]:createButton({ height = Helper.standardTextHeight }):setText(function() return Helper.transactionLogData.expandedEntries[entry.entryid] and "-" or "+" end, { halign = "center" })
			-- 	row[1].handlers.onClick = function() return Helper.buttonExpandTransactionEntry(entry.entryid, row.index, refreshCallback) end
			-- end
			local entryText = entry.eventtypename
			if entry.description ~= "" then
				-- entryText = entryText .. "\n" .. entry.description
				local description = ""
				for line in entry.description:gmatch("[^\r\n]+") do
					description = description .. "    " .. line .. "\n"
				end
				entryText = entryText .. "\n" .. description
			end
			if entry.color then
				row[2]:createText(entryText, {color = entry.color, wordwrap = true})
			else
				row[2]:createText(entryText, {wordwrap = true})
			end
			if entry.width then
				row[3]:setColSpan(4):createText(Helper.getPassedTime(entry.time) .. " to " .. Helper.getPassedTime(entry.time + entry.width), { halign = "right" })
			else
				row[3]:setColSpan(4):createText(Helper.getPassedTime(entry.time), { halign = "right" })
			end
			if entry.value then
				local entryValue = entry.value
				if entry.yMultiplier then
					entryValue = entryValue * entry.yMultiplier
				end
				if isYAxisMoney then
					row[7]:setColSpan(3):createText(((entryValue > 0) and "+" or "") .. ConvertMoneyString(entryValue, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (entryValue > 0) and Helper.color.green or Helper.color.red })
				else
					row[7]:setColSpan(3):createText(tostring(entryValue), { halign = "right", color = (entryValue >= 0) and Helper.color.green or Helper.color.red })
				end
				total = total + entryValue
			end
			-- if Helper.transactionLogData.expandedEntries[entry.entryid] then
			-- if entry.description ~= "" then
			-- 	local row = table_data:addRow(nil, { bgColor = Helper.color.transparent })
			-- 	-- row[1].properties.cellBGColor = Helper.color.transparent
			-- 	row[2]:setColSpan(8):createText(entry.description, { x = Helper.standardTextHeight, wordwrap = true})
			-- end
		end

		if Helper.transactionLogData.xZoom < #Helper.transactionLogConfig.zoomSteps then
			local row = table_data:addRow("showmore", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(9):createButton({ bgColor = Helper.color.transparent }):setText(ReadText(1001, 7778), { halign = "center" })
			if endIndex == 1 then
				row[1].handlers.onClick = function () return Helper.buttonTransactionLogZoom(1, refreshCallback) end
			else
				row[1].handlers.onClick = function () Helper.transactionLogData.curEntry = nil; Helper.transactionLogData.curPage = Helper.transactionLogData.curPage + 1; refreshCallback(_, 1) end
			end
		end

		local table_total = frame:addTable(2, { tabOrder = 0, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
		table_total:setColWidthPercent(1, 75)

		table_total:addEmptyRow()

		local row = table_total:addRow(nil, { bgColor = Helper.color.lightgrey })
		row[1]:setColSpan(2):createText("", { fontsize = 1, minRowHeight = 2 })

		if isShowLogTotal then
			local row = table_total:addRow(nil, { bgColor = Helper.color.transparent })
			row[1]:createText(ReadText(1001, 7776) .. ReadText(1001, 120))
			if isYAxisMoney then
				row[2]:createText(((total > 0) and "+" or "") .. ConvertMoneyString(total, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (total > 0) and Helper.color.green or Helper.color.red })
			else
				row[2]:createText(tostring(total), { halign = "right", color = (total > 0) and Helper.color.green or Helper.color.red })
			end
		end

		local maxVisibleHeight = table_data.properties.maxVisibleHeight - table_total:getFullHeight() - Helper.frameBorder
		table_total.properties.y = table_total.properties.y + math.min(maxVisibleHeight, table_data:getFullHeight())
		table_data.properties.maxVisibleHeight = table_total.properties.y - table_data.properties.y

		table_data:addConnection(1, 2, true)
		table_total:addConnection(2, 2)
	else
		local row = table_data:addRow("none", { bgColor = Helper.color.transparent })
		row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })

		if Helper.transactionLogData.xZoom < #Helper.transactionLogConfig.zoomSteps then
			local row = table_data:addRow("showmore", { bgColor = Helper.color.transparent })
			row[1]:setColSpan(9):createButton({ bgColor = Helper.color.transparent }):setText(ReadText(1001, 7778), { halign = "center" })
			row[1].handlers.onClick = function () return Helper.buttonTransactionLogZoom(1, refreshCallback) end
		end

		table_data:addConnection(1, 2, true)
	end

	if selectionData.selectedrow then
		table_data:setTopRow(selectionData.toprow)
		table_data:setSelectedRow(selectionData.selectedrow)
	end

	-- graph table
	local xoffset = tableProperties.x + tableProperties.width + Helper.borderSize + Helper.frameBorder
	local width = Helper.viewWidth - xoffset - tableProperties.x2

	local height = math.min(Helper.viewHeight - tableProperties.y - Helper.frameBorder - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, math.floor(width * 9 / 16))
	local table_graph = frame:addTable(4, { tabOrder = 3, width = width, x = xoffset, y = tableProperties.y })

	table_graph:setColWidthPercent(2, 15)
	table_graph:setColWidthPercent(3, 15)

	-- graph cell
	local row = table_graph:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
	-- local row = table_graph:addRow(false, { fixed = true, bgColor = Helper.color.lightgreen })

	local minY, maxY = 0, 1
	for i, point in pairs(Helper.transactionLogData.graphdata) do
		if point.y < minY then
			minY = point.y
		elseif point.y > maxY then
			maxY = point.y
		end
	end
	if #Helper.transactionLogData.graphdata2 then
		for i, point in pairs(Helper.transactionLogData.graphdata2) do
			if point.y < minY then
				minY = point.y
			elseif point.y > maxY then
				maxY = point.y
			end
		end
	end
	if #Helper.transactionLogData.graphdata3 then
		for i, point in pairs(Helper.transactionLogData.graphdata3) do
			if point.y < minY then
				minY = point.y
			elseif point.y > maxY then
				maxY = point.y
			end
		end
	end

	local datarecords = {}
	local data = {}
	for i, point in pairs(Helper.transactionLogData.graphdata) do
		local inactive
		if Helper.transactionLogData.searchtext ~= "" then
			inactive = true

			local transactionIndex = Helper.transactionLogData.transactionsByIDUnfiltered[point.entryid]
			local prevTransactionIndex = 1
			if i > 1 then
				prevTransactionIndex = Helper.transactionLogData.transactionsByIDUnfiltered[Helper.transactionLogData.graphdata[i -1].entryid]
			end

			if transactionIndex and prevTransactionIndex then
				if prevTransactionIndex < transactionIndex then
					-- if the previous transactionlog index is smaller than the current, skip this index, as it is part of the previous data point not the current
					--  prevTimeInterval  |  curTimeInterval
					-- [ ..., prevEntry ] | [ ..., curEntry ]
					prevTransactionIndex = prevTransactionIndex + 1
				end
				for i = prevTransactionIndex, transactionIndex do
					local entry = Helper.transactionLogData.accountLogUnfiltered[i]
					if Helper.transactionLogData.transactionsByID[entry.entryid] then
						inactive = false
						break
					end
				end
			end
		end
		table.insert(data, Helper.createGraphDataPoint((point.t - endtime) / Helper.transactionLogData.xScale, point.y, nil, nil, inactive))
	end

	table.insert(datarecords, Helper.createGraphDataRecord(Helper.transactionLogConfig.point.type, Helper.transactionLogConfig.point.size, Helper.color.brightyellow, Helper.transactionLogConfig.line.type, Helper.transactionLogConfig.line.size, Helper.color.brightyellow, data, false))

	local mingranularity = (maxY - minY) / 12
	local maxgranularity = (maxY - minY) / 8
	local granularity = 0.1
	for _, factor in ipairs(Helper.transactionLogConfig.factors) do
		local testgranularity = math.ceil(mingranularity / factor) * factor
		if testgranularity >= maxgranularity then
			break;
		end
		granularity = testgranularity
	end
	maxY = (math.ceil(maxY / granularity) + 0.5) * granularity
	minY = (math.floor(minY / granularity) - 0.5) * granularity

	local xRange = (endtime - starttime) / Helper.transactionLogData.xScale
	local xGranularity = Helper.transactionLogData.xGranularity
	if endtime > starttime then
		while (endtime - starttime) < xGranularity do
			xGranularity = xGranularity / 2
		end
	end
	xGranularity = Helper.round(xGranularity / Helper.transactionLogData.xScale, 3)
	local xOffset = xRange % xGranularity
	local yOffset = (math.ceil(minY / granularity) * granularity) - minY		-- offset is distance from minY to next multiple of granularity (value of first Y axis label)

	local xaxis = Helper.createGraphAxis(Helper.createGraphText(Helper.transactionLogData.xTitle, Helper.standardFont, 9, Helper.color.white), -xRange, 0, xGranularity, xOffset, true, Helper.color.white, { r = 96, g = 96, b = 96, a = 80 })
	local yaxis = Helper.createGraphAxis(Helper.createGraphText(Helper.transactionLogData.yTitle, Helper.standardFont, 9, Helper.color.white), minY, maxY, granularity, yOffset, true, Helper.color.white, { r = 96, g = 96, b = 96, a = 80 })

	Helper.transactionLogData.graph = row[1]:setColSpan(4):createGraph("line", true, Helper.color.semitransparent, { text = title_graph, font = Helper.titleFont, size = Helper.scaleFont(Helper.titleFont, Helper.titleFontSize), color = Helper.color.white }, xaxis, yaxis, datarecords, 0, 0, nil, height)
	row[1].handlers.onClick = function (_, data) return Helper.customGraphDataSelection(data, refreshCallback) end

	HideAllRects()
	if #Helper.transactionLogData.graphdata2 then
		Helper.graphOtherData(Helper.transactionLogData.graphdata2, table_graph, starttime, endtime, xRange, xGranularity, maxY, minY, granularity)
	end
	if #Helper.transactionLogData.graphdata3 then
		Helper.graphOtherData(Helper.transactionLogData.graphdata3, table_graph, starttime, endtime, xRange, xGranularity, maxY, minY, granularity)
	end

	-- zoom
	local row = table_graph:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
	row[2]:createButton({ active = Helper.transactionLogData.xZoom > 1 }):setText(ReadText(1001, 7777), { halign = "center" })
	row[2].handlers.onClick = function () return Helper.buttonTransactionLogZoom(-1, refreshCallback) end
	row[3]:createButton({ active = Helper.transactionLogData.xZoom < #Helper.transactionLogConfig.zoomSteps }):setText(ReadText(1001, 7778), { halign = "center" })
	row[3].handlers.onClick = function () return Helper.buttonTransactionLogZoom(1, refreshCallback) end

	table_graph:addConnection(1, 3, true)
end

local graphData2_startTime
local graphData2_x_forStartTime
local graphData2_x_for1Min
local graphData2_x_interval
-- xRange = total minutes
-- xGranularity = minutes for x grid
-- graphData2_x_forStartTime = x pixel for oldest time - at left edge of graph
-- graphData2_x_interval = x pixe for x grid
local graphData2_y_forLowestValue
local graphData2_y_interval
local graphData2_y_for1Value
-- maxY = highest y value
-- minY = lowest y value
-- granularity = y value for y grid
-- graphData2_y_forLowestValue = y pixel for lowest value - at bottom edge of graph
-- graphData2_y_interval = y pixel for y grid
function Helper.graphOtherData(graphData, table_graph, starttime, endtime, xRange, xGranularity, maxY, minY, granularity)
	-- local border_left = 46 -- eye-balled to the pixel with photoshop
	-- local border_right = 15 -- eye-balled to the pixel with photoshop
	-- local x_oldestTime = table_graph.properties.x + border_left
	-- local x_now = table_graph.properties.x + table_graph.properties.width - border_right
	-- local x_width = x_now - x_oldestTime
	-- local x_interval = x_width / math.floor(xRange / xGranularity)
	-- DebugError("x_interval: " .. tostring(x_interval))
	-- local startpos = {x = x_oldestTime, y = table_graph.properties.y + height - 400}
	-- local endpos = {x = x_now, y = table_graph.properties.y + height - 400}
	-- Helper.drawLine(startpos, endpos, nil, nil, Helper.color.orange)

	-- local border_top = 30
	-- local border_bottom = 41
	-- local y_maxValue = table_graph.properties.y + border_top
	-- local y_minValue = table_graph.properties.y + height - border_bottom
	-- local y_height = y_minValue - y_maxValue
	-- local y_interval = y_height / math.floor((maxY - minY) / granularity)
	-- DebugError("y_interval: " .. tostring(y_interval))
	-- local startpos = {x = x_oldestTime + 200, y = y_maxValue}
	-- local endpos = {x = x_oldestTime + 200, y = y_minValue}
	-- Helper.drawLine(startpos, endpos, nil, nil, Helper.color.orange)

	graphData2_startTime = starttime

	local border_left = 46 -- eye-balled to the pixel with photoshop
	local border_right = 15 -- eye-balled to the pixel with photoshop
	local x_forOldestTime = table_graph.properties.x + border_left + 2.5
	local x_forNewestTime = table_graph.properties.x + table_graph.properties.width - border_right - 2.5
	graphData2_x_forStartTime = x_forOldestTime
	graphData2_x_for1Min = (x_forNewestTime - x_forOldestTime) / xRange
	graphData2_x_interval = (x_forNewestTime - x_forOldestTime) / math.floor(xRange / xGranularity)

	local border_top = 30
	local border_bottom = 41
	local y_forMaxValue = table_graph.properties.y + border_top
	local height = table_graph:getVisibleHeight()
	local y_forMinValue = table_graph.properties.y + height - border_bottom
	graphData2_y_forLowestValue = y_forMinValue
	graphData2_y_for1Value = (y_forMinValue - y_forMaxValue) / (maxY - minY)
	graphData2_y_interval = (y_forMinValue - y_forMaxValue) / math.floor((maxY - minY) / granularity)

	local time_now = starttime
	local time_oldest = xRange * 60
	local entry_previous
	for i, entry in ipairs(graphData) do
		-- if (not entry.width) or entry.width < graphData2_x_for1Min then
		-- 	entry.width = graphData2_x_for1Min
		-- end
		if (not entry.width) or entry.width < 1 then
			entry.width = 1
		end
		-- function Helper.drawLine(startpos, endpos, thickness, z, color, noscaling)
		-- function Helper.drawRectangle(width, height, offsetx, offsety, angle, z, color, noscaling)
		if entry.t + entry.width >= starttime and entry.t <= endtime then
			local entry_width, entry_height, entry_x, entry_y
			if entry.type == "bar" or entry.type == "bar+line" then
				local color = entry.color
				if not color then
					color = {r = 255, g = 0, b = 0, a = 100}
				end
				local yValue = entry.y
				if entry.yMultiplier then
					yValue = yValue * entry.yMultiplier
				end
				local x_left, y_bottom = Helper.graphData2_getXY(starttime, minY, entry.t, 0)
				local x_right, y_top = Helper.graphData2_getXY(starttime, minY, entry.t + entry.width, yValue)
				if x_left < x_forOldestTime then
					x_left = x_forOldestTime
				elseif x_left > x_forNewestTime then
					x_left = x_forNewestTime
				end
				if x_right < x_forOldestTime then
					x_right = x_forOldestTime
				elseif x_right > x_forNewestTime then
					x_right = x_forNewestTime
				end
				entry_width = x_right - x_left
				entry_height = y_bottom - y_top
				entry_x = x_left
				entry_y = y_top
				-- Helper.debugText_forced("helper.xpl.graphOtherData entry_width: " .. tostring(entry_width) .. " entry_height: " .. tostring(entry_height) .. " entry_x: " .. tostring(entry_x) .. " entry_y: " .. tostring(entry_y))
				-- local startpos = {x = entry_x - 2, y = entry_y - 2}
				-- local endpos = {x = entry_x + entry_width + 2, y = entry_y - 2}
				-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
				-- local startpos = {x = entry_x + entry_width + 2, y = entry_y - 2}
				-- local endpos = {x = entry_x + entry_width + 2, y = entry_y + entry_height + 2}
				-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
				-- local startpos = {x = entry_x + entry_width + 2, y = entry_y + entry_height + 2}
				-- local endpos = {x = entry_x - 2, y = entry_y + entry_height + 2}
				-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
				-- local startpos = {x = entry_x - 2, y = entry_y + entry_height + 2}
				-- local endpos = {x = entry_x - 2, y = entry_y - 2}
				-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
				if entry.segments and #entry.segments > 0 then
					local entry_left = entry_x
					local entry_right = entry_left + entry_width
					local entry_top
					local entry_bottom
					if entry_height >= 0 then
						entry_top = entry_y
						entry_bottom = entry_top + entry_height
					else
						entry_top = entry_y - math.abs(entry_height)
						entry_bottom = entry_top + math.abs(entry_height)
					end
					-- local startpos = {x = entry_left - 2, y = entry_top - 2}
					-- local endpos = {x = entry_right + 2, y = entry_top - 2}
					-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
					-- local startpos = {x = entry_right + 2, y = entry_top - 2}
					-- local endpos = {x = entry_right + 2, y = entry_bottom + 2}
					-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
					-- local startpos = {x = entry_right + 2, y = entry_bottom + 2}
					-- local endpos = {x = entry_left - 2, y = entry_bottom + 2}
					-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
					-- local startpos = {x = entry_left - 2, y = entry_bottom + 2}
					-- local endpos = {x = entry_left - 2, y = entry_top - 2}
					-- Helper.drawLine(startpos, endpos, 2, 0, Helper.color.white)
					-- Helper.debugText_forced("helper.xpl.graphOtherData entry_left: " .. tostring(entry_left) .. " entry_top: " .. tostring(entry_top) .. " entry_right: " .. tostring(entry_right) .. " entry_bottom: " .. tostring(entry_bottom))
					local segment_width, segment_height, segment_x, segment_y
					segment_y = entry_bottom -- render moves up from bottom
					for j, segment in ipairs(entry.segments) do
						if segment.color then
							color = segment.color
						end
						segment_width = entry_right - entry_left
						segment_height = math.abs(segment.value / entry.y * entry_height)
						segment_x = entry_left
						if segment.segments and #segment.segments > 0 then
							local segment_left = segment_x
							local segment_top = segment_y - segment_height
							local segment_right = segment_left + segment_width
							local segment_bottom = segment_top + segment_height
							local s2_w, s2_h, s2_x, s2_y
							s2_x = segment_left
							for k, s2 in ipairs(segment.segments) do
								if s2.color then
									color = s2.color
								end
								s2_w = s2.value / segment.value * segment_width
								s2_h = segment_bottom - segment_top
								s2_y = segment_top
								Helper.debugText_forced("helper.xpl.graphOtherData s2.value: " .. tostring(s2.value) .. " segment.value: " .. tostring(segment.value) .. " segment_height: " .. tostring(segment_height) .. " s2_w: " .. tostring(s2_w) .. " s2_h: " .. tostring(s2_h) .. " s2_x: " .. tostring(s2_x) .. " s2_y: " .. tostring(s2_y))
								if j > 1 then
									if #segment.segments == 1 then
										Helper.drawRectangle(s2_w, s2_h - 2, s2_x, s2_y, nil, nil, color)
									elseif k < #segment.segments then
										-- offset x and width so that there are no gaps
										Helper.drawRectangle(s2_w + 2, s2_h - 2, s2_x - 1, s2_y, nil, nil, color)
									else
										Helper.drawRectangle(s2_w + 1, s2_h - 2, s2_x, s2_y, nil, nil, color)
									end
								else
									if #segment.segments == 1 then
										Helper.drawRectangle(s2_w, s2_h, s2_x, s2_y, nil, nil, color)
									elseif k < #segment.segments then
										-- offset x and width so that there are no gaps
										Helper.drawRectangle(s2_w + 2, s2_h, s2_x - 1, s2_y, nil, nil, color)
									else
										Helper.drawRectangle(s2_w + 1, s2_h, s2_x - 1, s2_y, nil, nil, color)
									end
								end
								s2_x = s2_x + s2_w
							end
						else
							Helper.drawRectangle(segment_width, segment_height, segment_x, segment_y - segment_height, nil, nil, color)
						end
						segment_y = segment_y - segment_height
					end
				else
					Helper.drawRectangle(entry_width, entry_height, entry_x, entry_y, nil, nil, color)
				end
			end
		end
	end
	for i, entry in ipairs(graphData) do
		if entry.t >= starttime and entry.t <= endtime then
			if not entry.width then
				entry.width = 1
			end
			if type == "line" or entry.type == "bar+line" then
				if entry_previous then
					local color = entry.color
					if not color then
						color = {r = 255, g = 0, b = 0, a = 100}
					end
					local xValue_previous = entry_previous.t
					if entry_previous.width then
						xValue_previous = xValue_previous + entry_previous.width * 0.5
					end
					local xValue = entry.t
					if entry.width then
						xValue = xValue + entry.width * 0.5
					end
					local yValue_previous = entry_previous.y
					local yValue = entry.y
					if entry.yMultiplier then
						yValue_previous = yValue_previous * entry.yMultiplier
						yValue = yValue * entry.yMultiplier
					end
					local x, y = Helper.graphData2_getXY(starttime, minY, xValue_previous, yValue_previous)
					local x2, y2 = Helper.graphData2_getXY(starttime, minY, xValue, yValue)
					local startpos = {x = x, y = y}
					local endpos = {x = x2, y = y2}
					if x < x_forOldestTime then
						x = x_forOldestTime
					elseif x > x_forNewestTime then
						x = x_forNewestTime
					end
					if x2 < x_forOldestTime then
						x2 = x_forOldestTime
					elseif x2 > x_forNewestTime then
						x2 = x_forNewestTime
					end
					y = Helper.getYAtXFromPoint1AndPoint2(x, startpos, endpos)
					y2 = Helper.getYAtXFromPoint1AndPoint2(x2, startpos, endpos)
					local startpos = {x = x, y = y}
					local endpos = {x = x2, y = y2}
					local thickness = 3
					Helper.drawLine(startpos, endpos, thickness, nil, color)
				end
			end
		end
		entry_previous = entry
	end
end

function Helper.graphData2_getXY(starttime, minY, time, value)
	local x = graphData2_x_forStartTime + (time - starttime) / 60 * graphData2_x_for1Min
	local y = graphData2_y_forLowestValue - (value - minY) * graphData2_y_for1Value
	return x, y
end

function Helper.getYAtXFromPoint1AndPoint2(x, point1, point2)
	local rise = point2.y - point1.y
	local run = point2.x - point1.x
	local m = rise / run
	-- y = mx + b
	-- b = y - mx
	local b = point1.y - m * point1.x
	local y = m * x + b
	return y
end

function Helper.customGraphDataSelection(data, refreshCallback)
	local entryId_selected = Helper.transactionLogData.graphdata[data[4]].entryid
	local entryId_first
	local entryId_prev
	local entryId_best
	for _, entryLog in ipairs(Helper.transactionLogData.accountLogUnfiltered) do
		if not entryId_first then
			entryId_first = entryLog.entryid
		end
		if entryLog.entryid == entryId_selected then
			entryId_best = entryLog.entryid
			break
		elseif entryLog.entryid > entryId_selected then
			if entryId_prev then
				entryId_best = entryId_prev
			else
				entryId_best = entryId_first
			end
			break
		else
			entryId_prev = entryLog.entryid
		end
	end

	Helper.transactionLogData.curEntry = entryId_best
	refreshCallback()
end

function Helper.getMenu(menuName)
	for _, menu in Menus do
		if menu.name == menuName then
			return menu
		end
	end
	return nil
end
-- kuertee end

---------------------------------------------------------------------------------
-- Init
---------------------------------------------------------------------------------

init()
﻿-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef uint64_t UniverseID;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		int x;
		int y;
	} Coord2D;
	typedef struct {
		float x;
		float y;
		float z;
	} Coord3D;
	typedef struct {
		float dps;
		uint32_t quadranttextid;
	} DPSData;
	typedef struct {
		UniverseID attacker;
		double time;
		const char* method;
	} LastAttackerInfo;
	typedef struct {
		UniverseID target;
		UIWareAmount* wares;
		uint32_t numwares;
	} MissionWareDeliveryInfo;
	// @since X4 4.10 - added
	typedef struct {
		UniverseID target;
		uint32_t numwares;
		MissionID missionid;
	} MissionWareDeliveryCounts;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		const char* id;
		const char* name;
		const char* icon;
		const char* description;
		const char* category;
		const char* categoryname;
		bool infinite;
		uint32_t requiredSkill;
	} OrderDefinition;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		uint32_t id;
		const char* text;
		const char* type;
		bool ispossible;
		bool istobedisplayed;
	} UIAction;
	typedef struct {
		UniverseID component;
		const char* connection;
	} UIComponentSlot;
	typedef struct {
		const char* shape;
		const char* name;
		uint32_t requiredSkill;
		float radius;
		bool rollMembers;
		bool rollFormation;
		size_t maxShipsPerLine;
	} UIFormationInfo;
	typedef struct {
		const float x;
		const float y;
		const float z;
		const float yaw;
		const float pitch;
		const float roll;
	} UIPosRot;
	typedef struct {
		const char* wareid;
		int32_t amount;
	} YieldInfo;
	void ActivateObject(UniverseID objectid, bool active);
	bool AdjustOrder(UniverseID controllableid, size_t idx, size_t newidx, bool enabled, bool forcestates, bool checkonly);
	bool CanAcceptSubordinate(UniverseID commanderid, UniverseID potentialsubordinateid);
	bool CanBeDismantled(UniverseID componentid);
	bool CanBeTowed(UniverseID componentid);
	bool CancelConstruction(UniverseID containerid, BuildTaskID id);
	bool CanCancelConstruction(UniverseID containerid, BuildTaskID id);
	bool CanContainerBuildShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerEquipShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerSupplyShip(UniverseID containerid, UniverseID shipid);
	bool CanDockAtDockingBay(UniverseID shipid, UniverseID dockingbayid);
	bool CanPutShipIntoStorage(UniverseID containerid, UniverseID shipid);
	bool CanSetPlayerCameraCinematicView(void);
	bool CanStartTravelMode(UniverseID objectid);
	const char* CanTeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool force);
	bool ClaimShip(UniverseID shipid, UniverseID shiptobeclaimedid);
	uint32_t CreateDeployToStationOrder(UniverseID controllableid);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool defaultorder);
	uint32_t CreateOrder3(UniverseID controllableid, const char* orderid, bool defaultorder, bool isoverride, bool istemp);
	bool DoesConstructionSequenceRequireBuilder(UniverseID containerid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetCompSlotPlayerActions(UIAction* result, uint32_t resultlen, UIComponentSlot compslot);
	Coord2D GetCompSlotScreenPos(UIComponentSlot compslot);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	float GetDistanceBetween(UniverseID component1id, UniverseID component2id);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetFormationShapes(UIFormationInfo* result, uint32_t resultlen);
	uint32_t GetHQs(UniverseID* result, uint32_t resultlen, const char* factionid);
	LastAttackerInfo GetLastAttackInfo(UniverseID destructibleid);
	uint32_t GetMineablesAtSectorPos(YieldInfo* result, uint32_t resultlen, UniverseID sectorid, Coord3D position);
	void GetMissionDeliveryWares(MissionWareDeliveryInfo* result, MissionID missionid);
	uint32_t GetMissionThreadSubMissions(MissionID* result, uint32_t resultlen, MissionID missionid);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumCompSlotPlayerActions(UIComponentSlot compslot);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumFormationShapes(void);
	uint32_t GetNumHQs(const char* factionid);
	uint32_t GetNumMineablesAtSectorPos(UniverseID sectorid, Coord3D position);
	uint32_t GetNumMissionThreadSubMissions(MissionID missionid);
	uint32_t GetNumObjectsWithSyncPoint(uint32_t syncid, bool onlyreached);
	uint32_t GetNumObjectsWithSyncPointFromOrder(UniverseID controllableid, size_t idx, bool onlyreached);
	uint32_t GetNumOrderDefinitions(void);
	uint32_t GetNumRequestedMissionNPCs(UniverseID containerid);
	uint32_t GetNumRequestedMissionWares(UniverseID containerid);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumSubordinatesOfGroup(UniverseID commanderid, int group);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumVenturePlatformDocks(UniverseID ventureplatformid);
	uint32_t GetNumVenturePlatforms(UniverseID defensibleid);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	UIPosRot GetObjectPositionInSector(UniverseID objectid);
	uint32_t GetOrderDefinitions(OrderDefinition* result, uint32_t resultlen);
	UniverseID GetPlayerContainerID(void);
	UniverseID GetPlayerID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	uint32_t GetRequestedMissionWares(MissionWareDeliveryCounts* result, uint32_t resultlen, UniverseID containerid);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	uint32_t GetSubordinatesOfGroup(UniverseID* result, uint32_t resultlen, UniverseID commanderid, int group);
	bool GetSyncPointAutoRelease(uint32_t syncid, bool checkall);
	bool GetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool checkall);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	float GetTextWidth(const char*const text, const char*const fontname, const float fontsize);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	UniverseID GetTowedObject(UniverseID shipid);
	uint32_t GetVenturePlatformDocks(UniverseID* result, uint32_t resultlen, UniverseID ventureplatformid);
	uint32_t GetVenturePlatforms(UniverseID* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	bool HasContainerFreeInternalShipStorage(UniverseID containerid, UniverseID shipid);
	bool HasContainerProcessingModule(UniverseID containerid);
	bool HasSubordinateAssignment(UniverseID controllableid, const char* assignment);
	bool HasVenturerDock(UniverseID containerid, UniverseID shipid, UniverseID ventureplatformid);
	bool IsBuilderBusy(UniverseID shipid);
	bool IsComponentWrecked(const UniverseID componentid);
	bool IsDefensibleBeingBoardedBy(UniverseID defensibleid, const char* factionid);
	bool IsMissionLimitReached(bool includeupkeep, bool includeguidance, bool includeplot);
	bool IsMouseEmulationActive(void);
	bool IsObjectKnown(const UniverseID componentid);
	bool IsOrderLoopable(const char* orderdefid);
	bool IsPlayerCameraTargetViewPossible(UniverseID targetid, bool force);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsUnit(UniverseID controllableid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	void MakePlayerOwnerOf(UniverseID objectid);
	void MovePlayerToSectorPos(UniverseID sectorid, UIPosRot position);
	void NotifyInteractMenuHidden(const uint32_t id, const bool allclosed);
	void NotifyInteractMenuShown(const uint32_t id);
	bool PerformCompSlotPlayerAction(UIComponentSlot compslot, uint32_t actionid);
	void PutShipIntoStorage(UniverseID containerid, UniverseID shipid);
	void ReleaseOrderSyncPoint(uint32_t syncid);
	void ReleaseOrderSyncPointFromOrder(UniverseID controllableid, size_t idx);
	bool RemoveCommander2(UniverseID controllableid);
	bool RemoveOrder(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly);
	bool RequestDockAt(UniverseID containerid, bool checkonly);
	const char* RequestDockAtReason(UniverseID containerid, bool checkonly);
	bool RequestShipFromInternalStorage2(UniverseID shipid, bool highpriority, UniverseID refcomponentid);
	void ResetOrderLoop(UniverseID controllableid);
	void SelfDestructComponent(UniverseID componentid);
	void SetAllDronesArmed(UniverseID defensibleid, bool arm);
	void SetDockingBayReservation(UniverseID dockingbayid, double duration);
	UIFormationInfo SetFormationShape(UniverseID objectid, const char* formationshape);
	void SetGroupAndAssignment(UniverseID controllableid, int group, const char* assignment);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetPlayerCameraCinematicView(UniverseID componentid);
	void SetRelationBoostToFaction(UniverseID componentid, const char* factionid, const char* reasonid, float boostvalue, float decayrate, double decaydelay);
	bool SetSofttarget(UniverseID componentid, const char*const connectionname);
	void SetSubordinateGroupAttackOnSight(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupProtectedLocation(UniverseID controllableid, int group, UniverseID sectorid, UIPosRot offset);
	void SetSubordinateGroupReinforceFleet(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupResupplyAtFleet(UniverseID controllableid, int group, bool value);
	void SetSyncPointAutoRelease(uint32_t syncid, bool all, bool any);
	void SetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool all, bool any);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	bool ShouldSubordinateGroupAttackOnSight(UniverseID controllableid, int group);
	bool ShouldSubordinateGroupReinforceFleet(UniverseID controllableid, int group);
	bool ShouldSubordinateGroupResupplyAtFleet(UniverseID controllableid, int group);
	void SpawnObjectAtPos(const char* macroname, UniverseID sectorid, UIPosRot offset);
	void StartPlayerActivity(const char* activityid);
	void StopPlayerActivity(const char* activityid);
	bool TakeShipFromInternalStorage(UniverseID shipid, bool highpriority, bool checkonly);
	bool TeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool instant, bool force);
]]

local utf8 = require("utf8")

local menu = {
	name = "InteractMenu",
	selectedRows = {},
	topRows = {},
	selectedplayerships = {},
}

local config = {
	layer = 2,
	width = 260,
	rowHeight = 16,
	entryFontSize = Helper.standardFontSize,
	entryX = 3,
	mouseOutRange = 100,
	border = 5,
	subsectionDelay = 0.5,

	sections = {
		{ id = "main",					text = "",						isorder = false },
		{ id = "interaction",			text = ReadText(1001, 7865),	isorder = false },
		{ id = "hiringbuilderoption",	text = "",						isorder = false,	subsections = {
			{ id = "hiringbuilder",		text = ReadText(1001, 7873) },
			{ id = "assigningbuilder",	text = ReadText(1001, 11141) },
		}},

		-- mycu start: add custom actions group
		{ id = "custom_actions",	text = ReadText(101475, 100),		isorder = false,	subsections = {}},
		-- mycu end: add custom actions group

		{ id = "trade",					text = ReadText(1001, 7104),	isorder = false },
		{ id = "playersquad_orders",	text = ReadText(1001, 1002),	isorder = false },	-- Broadcast
		{ id = "overrideorderoption",	text = ReadText(1001, 11118),	isorder = false,	subsections = {
			{ id = "overrideorder",		text = ReadText(1001, 11248) },
		}},
		{ id = "main_orders",			text = ReadText(1001, 7802),	isorder = false },
		{ id = "formationshapeoption",	text = "",						isorder = false,	subsections = {
			{ id = "formationshape",	text = ReadText(1001, 7862) },
		}},
		{ id = "main_assignments",		text = ReadText(1001, 7803),	isorder = false },
		{ id = "main_assignments_subsections",	text = ReadText(1001, 7805),	isorder = false,	subsections = {
			{ id = "main_assignments_defence",				text = ReadText(20208, 40304) },
			{ id = "main_assignments_positiondefence",		text = ReadText(20208, 41504) },
			{ id = "main_assignments_attack",				text = ReadText(20208, 40904) },
			{ id = "main_assignments_interception",			text = ReadText(20208, 41004) },
			{ id = "main_assignments_bombardment",			text = ReadText(20208, 41604) },
			{ id = "main_assignments_follow",				text = ReadText(20208, 41304) },
			{ id = "main_assignments_supplyfleet",			text = ReadText(20208, 40704) },
			{ id = "main_assignments_mining",				text = ReadText(20208, 40204) },
			{ id = "main_assignments_trade",				text = ReadText(20208, 40104) },
			{ id = "main_assignments_tradeforbuildstorage",	text = ReadText(20208, 40804) },
			{ id = "main_assignments_assist",				text = ReadText(20208, 41204) },
			{ id = "main_assignments_salvage",				text = ReadText(20208, 41404) },
		}},
		{ id = "order",					text = "",						isorder = nil },
		{ id = "syncpoint",				text = "",						isorder = nil },
		{ id = "intersectordefencegroup",	text = "",					isorder = nil },
		{ id = "guidance",				text = "",						isorder = nil,		isplayerinteraction = true },
		{ id = "player_interaction",	text = ReadText(1001, 7843),	isorder = false,	isplayerinteraction = true },
		{ id = "consumables",			text = ReadText(1001, 7846),	isorder = false,	subsections = {
			{ id = "consumables_civilian",	text = ReadText(1001, 7847) },
			{ id = "consumables_military",	text = ReadText(1001, 7848) },
		}},
		{ id = "venturereport",			text = ReadText(1001, 12110),	isorder = false },
		{ id = "cheats",				text = "Cheats",				isorder = false }, -- (cheat only)
		{ id = "selected_orders_all",	text = ReadText(1001, 7804),	isorder = true,		showloop = true },
		{ id = "selected_orders",		text = ReadText(1001, 7804),	isorder = true,		showloop = true },
		{ id = "mining_orders",			text = "",						isorder = true,		showloop = true,		subsections = {
			{ id = "mining",			text = "\27[order_miningplayer] " .. ReadText(1041, 351) },
		}},
		{ id = "venturedockoption",		text = "",						isorder = true,		showloop = true,		subsections = {
			{ id = "venturedock",	text = "\27[order_dockandwait] " .. ReadText(1001, 7844) },
		}},
		{ id = "selected_disable",	text = "",	isorder = true,		subsections = {
			{ id = "selected_disable_attack",		text = ReadText(1001, 11128),	orderid = "Attack" },
		}},

		-- mycu start: add custom orders group
		{ id = "custom_orders",	text = ReadText(101475, 101),		isorder = true,	showloop = true, subsections = {}},
		-- mycu end: add custom orders group

		{ id = "trade_orders",			text = ReadText(1001, 7861),	isorder = true,		showloop = true },
		{ id = "selected_assignments_all", text = ReadText(1001, 7886),	isorder = true },
		{ id = "selected_change_assignments",	text = ReadText(1001, 11119),	isorder = true,		subsections = {
			{ id = "selected_change_assignments_defence",				text = ReadText(20208, 40304),	helpOverlayID = "interactmenu_change_assign",	helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_positiondefence",		text = ReadText(20208, 41504) },
			{ id = "selected_change_assignments_attack",				text = ReadText(20208, 40904) },
			{ id = "selected_change_assignments_interception",			text = ReadText(20208, 41004) },
			{ id = "selected_change_assignments_bombardment",			text = ReadText(20208, 41604) },
			{ id = "selected_change_assignments_follow",				text = ReadText(20208, 41304) },
			{ id = "selected_change_assignments_supplyfleet",			text = ReadText(20208, 40704) },
			{ id = "selected_change_assignments_mining",				text = ReadText(20208, 40204) },
			{ id = "selected_change_assignments_trade",					text = ReadText(20208, 40104) },
			{ id = "selected_change_assignments_tradeforbuildstorage",	text = ReadText(20208, 40804) },
			{ id = "selected_change_assignments_assist",				text = ReadText(20208, 41204) },
			{ id = "selected_change_assignments_salvage",				text = ReadText(20208, 41404) },
		}},
		{ id = "selected_assignments",	text = ReadText(1001, 7805),	isorder = true,		subsections = {
			{ id = "selected_assignments_defence",				text = ReadText(20208, 40304),	helpOverlayID = "interactmenu_assign",	helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_positiondefence",		text = ReadText(20208, 41504) },
			{ id = "selected_assignments_attack",				text = ReadText(20208, 40904) },
			{ id = "selected_assignments_interception",			text = ReadText(20208, 41004) },
			{ id = "selected_assignments_bombardment",			text = ReadText(20208, 41604) },
			{ id = "selected_assignments_follow",				text = ReadText(20208, 41304) },
			{ id = "selected_assignments_supplyfleet",			text = ReadText(20208, 40704) },
			{ id = "selected_assignments_mining",				text = ReadText(20208, 40204) },
			{ id = "selected_assignments_trade",				text = ReadText(20208, 40104) },
			{ id = "selected_assignments_tradeforbuildstorage",	text = ReadText(20208, 40804) },
			{ id = "selected_assignments_assist",				text = ReadText(20208, 41204) },
			{ id = "selected_assignments_salvage",				text = ReadText(20208, 41404) },
		}},
		{ id = "selected_consumables",	text = ReadText(1001, 7849),	isorder = true,		subsections = {
			{ id = "selected_consumables_civilian",	text = "\27[order_deployobjectatposition] " .. ReadText(1001, 7847) },
			{ id = "selected_consumables_military",	text = "\27[order_deployobjectatposition] " .. ReadText(1001, 7848) },
		}},
		{ id = "shipconsole",			text = "",						isorder = false },
	},

	assignments = {
		["defence"]					= { name = ReadText(20208, 40304) },
		["positiondefence"]			= { name = ReadText(20208, 41504) },
		["attack"]					= { name = ReadText(20208, 40904) },
		["interception"]			= { name = ReadText(20208, 41004) },
		["bombardment"]				= { name = ReadText(20208, 41604) },
		["follow"]					= { name = ReadText(20208, 41304) },
		["supplyfleet"]				= { name = ReadText(20208, 40704) },
		["mining"]					= { name = ReadText(20208, 40204) },
		["trade"]					= { name = ReadText(20208, 40104) },
		["tradeforbuildstorage"]	= { name = ReadText(20208, 40804) },
		["assist"]					= { name = ReadText(20208, 41204) },
		["salvage"]					= { name = ReadText(20208, 41401) },
	},
}

-- kuertee start:
local callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	RegisterEvent("hideInteractMenu", function () menu.onCloseElement("auto") end)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	DebugError("menu_interactmenu.xpl.init - kuertee")
	RegisterEvent ("Interact_Menu_API.Add_Custom_Actions_Group_Id", menu.Add_Custom_Actions_Group_Id)
	RegisterEvent ("Interact_Menu_API.Add_Custom_Actions_Group_Text", menu.Add_Custom_Actions_Group_Text)
end
-- kuertee end

function menu.cleanup()
	menu.mode = nil
	menu.interactMenuID = nil
	menu.componentSlot = nil
	menu.connection = nil
	menu.componentOrder = nil
	menu.syncpoint = nil
	menu.syncpointorder = nil
	menu.intersectordefencegroup = nil
	menu.mission = nil
	menu.componentMissions = nil
	menu.missionoffer = nil
	menu.construction = nil
	menu.subordinategroup = nil
	menu.selectedplayerships = {}
	menu.selectedotherobjects = {}
	menu.selectedplayerdeployables = {}
	menu.playerSquad = {}
	menu.removedOccupiedPlayerShip = nil
	menu.showPlayerInteractions = nil
	menu.offsetcomponent = nil
	menu.offset = nil
	menu.mouseX = nil
	menu.mouseY = nil
	menu.dockingbayReserveTime = nil
	menu.isdockedship = nil
	menu.shipswithcurrentcommander = {}
	menu.groupShips = {}

	menu.subsection = nil
	menu.pendingSubSection = nil
	menu.possibleorders = {}
	menu.numdockingpossible = nil
	menu.numremovableorders = nil
	menu.numwaitingforsignal = nil
	menu.numdockingatplayerpossible = nil
	menu.numshipswithcommander = nil
	menu.actions = {}
	menu.holomapcolor = {}
	menu.texts = {}
	menu.colors = {}

	menu.contentTable = nil
	menu.currentOverTable = nil
	menu.selectedRows = {}
	menu.topRows = {}
	menu.mouseOutBox = {}

	Helper.ffiClearNewHelper()
end

-- perform helpers

function menu.orderAssignCommander(component, commander, assignment, group)
	if (not C.IsOrderSelectableFor("AssignCommander", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	local orderindex = C.CreateOrder(component, "AssignCommander", false)
	if orderindex > 0 then
		-- commander
		SetOrderParam(component, orderindex, 1, nil, ConvertStringToLuaID(tostring(commander)))
		-- assignment
		SetOrderParam(component, orderindex, 2, nil, assignment)
		-- subordinategroup
		SetOrderParam(component, orderindex, 3, nil, group)
		-- setgroupassignment
		SetOrderParam(component, orderindex, 4, nil, true)
		-- cancelorders
		SetOrderParam(component, orderindex, 5, nil, true)
		-- response
		SetOrderParam(component, orderindex, 6, nil, true)

		C.EnableOrder(component, orderindex)
		if orderindex ~= 1 then
			C.AdjustOrder(component, orderindex, 1, true, false, false)
		end
	end
end

function menu.orderAttack(component, target, clear, immediate)
	if (not C.IsOrderSelectableFor("Attack", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder3(component, "Attack", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderAttackInRange(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("AttackInRange", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "AttackInRange", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderAttackSurfaceElements(component, target, targetclasses, clear)
	if (not C.IsOrderSelectableFor("Attack", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end

	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		-- primarytarget
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		-- disable
		SetOrderParam(component, orderidx, 8, nil, true)
		-- disablehullpercentagethreshold
		SetOrderParam(component, orderidx, 9, nil, 100)
		-- behaviortargetclasses
		SetOrderParam(component, orderidx, 16, nil, targetclasses)
		-- debugchance
		--SetOrderParam(component, orderidx, 25, nil, 100)
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderCollect(component, drop, sector, offset, clear)
	if (not C.IsOrderSelectableFor("Collect", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Collect", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, 0, ConvertStringToLuaID(tostring(drop)) )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectDeployable(component, deployable, sector, offset, clear)
	if (not C.IsOrderSelectableFor("CollectDeployables", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDeployables", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(deployable)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectLockbox(component, lockbox, clear)
	if (not C.IsOrderSelectableFor("CollectLockbox", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectLockbox", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, 0, ConvertStringToLuaID(tostring(lockbox)) )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectRadius(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("CollectDropsInRadius", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDropsInRadius", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderDeployAtPosition(component, sector, offset, macro, amount, clear)
	if (not C.IsOrderSelectableFor("DeployObjectAtPosition", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "DeployObjectAtPosition", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		SetOrderParam(component, orderidx, 2, 0, macro )
		SetOrderParam(component, orderidx, 3, 0, amount )

		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderDeployToStation(component, station, clear)
	if (not C.IsOrderSelectableFor("DeployToStation", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateDeployToStationOrder(component)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(station)))
		C.EnableOrder(component, orderidx)
	end
end

function menu.orderDepositInventoryAtHQ(component, clear)
	if (not C.IsOrderSelectableFor("DepositInventory", component)) or (not GetComponentData(ConvertStringTo64Bit(tostring(component)), "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "DepositInventory", false)
	if orderidx > 0 then
		-- we can optionally set a destination here, but we only support transferring inventory items to/from the player HQ at the moment using this method. order defaults to deposit at the player HQ, if it exists.
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderDock(component, target, clear, ventureplatform)
	if (not C.IsOrderSelectableFor("DockAndWait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "DockAndWait", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		if ventureplatform then
			SetOrderParam(component, orderidx, 5, nil, ConvertStringToLuaID(tostring(ventureplatform)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderExplore(component, sectororgate, sector, offset, clear)
	if (not C.IsOrderSelectableFor("Explore", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Explore", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(sectororgate)) )
		if C.IsComponentClass(sectororgate, "sector") or (C.IsComponentClass(sectororgate, "gate") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			SetOrderParam(component, orderidx, 2, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderExploreUpdate(component, sectororgate, sector, offset, clear)
	if (not C.IsOrderSelectableFor("ExploreUpdate", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "ExploreUpdate", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(sectororgate)) )
		if C.IsComponentClass(sectororgate, "sector") or (C.IsComponentClass(sectororgate, "gate") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			SetOrderParam(component, orderidx, 2, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderFollow(component, targetobject, clear)
	if (not C.IsOrderSelectableFor("Follow", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Follow", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(targetobject)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderGetSupplies(component, clear)
	if (not C.IsOrderSelectableFor("GetSupplies", component)) or (not GetComponentData(ConvertStringTo64Bit(tostring(component)), "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "GetSupplies", false)
	if orderidx > 0 then
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderMining(component, ware, sector, offset, clear)
	if (not C.IsOrderSelectableFor("MiningPlayer", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx
	if GetWareCapacity(component, ware, true) > 0 then
		orderidx = C.CreateOrder(component, "MiningPlayer", false)
		if orderidx > 0 then
			SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
			SetOrderParam(component, orderidx, 3, nil, ware)
			C.EnableOrder(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderMoveWait(component, sector, offset, targetobject, playerprecise, clear)
	if (not C.IsOrderSelectableFor("MoveWait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx
	if not C.IsComponentClass(targetobject, "sector") then
		orderidx = C.CreateOrder(component, "MoveToObject", false)
		if orderidx > 0 then
			SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(targetobject)))
		end
	else
		orderidx = C.CreateOrder(component, "MoveWait", false)
		if orderidx > 0 then
			SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
			if playerprecise then
				SetOrderParam(component, orderidx, 5, nil, true)
			end
		end
	end
	if orderidx > 0 then
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderPlayerDockToTrade(component, target, clear)
	if (not C.IsOrderSelectableFor("Player_DockToTrade", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Player_DockToTrade", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderProtect(component, target, clear)
	if (not C.IsOrderSelectableFor("ProtectStation", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "ProtectStation", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderRemove(ship, removedefaultorder, removeassignment, removedockorder)
	local numorders = C.GetNumOrders(ship)
	local currentorders = ffi.new("Order[?]", numorders)
	numorders = C.GetOrders(currentorders, numorders, ship)
	local assigncommanderfound = false
	for i = numorders, 1, -1 do
		local isdocked, isdocking = GetComponentData(ConvertStringTo64Bit(tostring(ship)), "isdocked", "isdocking")
		local orderdef = ffi.string(currentorders[i - 1].orderdef)
		if (i == 1) and ((orderdef == "DockAndWait") and (isdocked or isdocking)) and (not removedockorder) then
			-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
		elseif (not removeassignment) and (not assigncommanderfound) and (orderdef == "AssignCommander") then
			-- keep the last assign commander order unless we are removing assignments
			assigncommanderfound = true
		else
			C.RemoveOrder(ship, i, false, false)
		end
	end
	if removedefaultorder then
		C.ResetOrderLoop(ship)
		local currentdefaultorder = ffi.new("Order")
		if C.GetDefaultOrder(currentdefaultorder, ship) then
			if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
				C.CreateOrder(ship, "Wait", true)
				C.EnablePlannedDefaultOrder(ship, false)
			end
		end
	end
	if removeassignment then
		C.RemoveCommander2(ship)
		C.CreateOrder(ship, "Wait", true)
		C.EnablePlannedDefaultOrder(ship, false)
	end
end

function menu.orderSalvageCollect(component, target, clear)
	if (not C.IsOrderSelectableFor("SalvageCollect", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageCollect", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageCrush(component, target, clear)
	if (not C.IsOrderSelectableFor("SalvageCrush", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageCrush", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageDeliver(component, target, tradeoffer, amount, clear)
	if (not C.IsOrderSelectableFor("SalvageDeliver", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	AddTradeToShipQueue(tradeoffer, ConvertStringTo64Bit(tostring(component)), amount, false, true)
end

function menu.orderSalvageDeliver_NoTrade(component, target, clear)
	if (not C.IsOrderSelectableFor("SalvageDeliver_NoTrade", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageDeliver_NoTrade", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageInRadius(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("SalvageInRadius", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageInRadius", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderStopAndHoldFire(component, clear, immediate)
	if (not C.IsOrderSelectableFor("Wait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end

	-- ship will stop and hold fire.
	-- params: 1: timeout, 2: allowdocked, 3: holdfire, 4: debugchance
	local orderidx = C.CreateOrder3(component, "Wait", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, clear and 0 or 3600)
		SetOrderParam(component, orderidx, 3, nil, true)
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderTacticalAttack(component, target, clear, immediate)
	if (not C.IsOrderSelectableFor("TacticalOrder", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder3(component, "TacticalOrder", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderWithdrawAndHold(component, clear, immediate)
	if (not C.IsOrderSelectableFor("MoveWait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end

	local pos = ffi.new("UIPosRot")
	pos = C.GetObjectPositionInSector(component)
	local sectorid = GetComponentData(component, "sectorid")
	if sectorid then
		sectorid = ConvertIDTo64Bit(sectorid)
	end

	-- ship will hold fire and withdraw from combat, then hold position.
	-- params: 1: destination, 2: timeout, 3: withdraw, 4: debugchance
	local orderidx = C.CreateOrder3(component, "MoveWait", false, immediate, immediate)
	if orderidx > 0 then
		-- HACK: MoveWait requires a destination but does not use it when $withdraw is true
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sectorid)), {pos.x, pos.y, pos.z} })
		SetOrderParam(component, orderidx, 2, nil, clear and 0 or 3600)
		SetOrderParam(component, orderidx, 3, nil, true)
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderWithdrawFromCombat(component, clear, immediate, attacker)
	local convertedComponent = ConvertStringTo64Bit(tostring(component))
	if (not C.IsOrderSelectableFor("Flee", convertedComponent)) or (not GetComponentData(convertedComponent, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(convertedComponent)
	end

	-- ship will hold fire and withdraw from combat.
	-- params: 1: method ('boost','maneuver','highway','dock'), 2: return, 3: donotdrop, 4: deploydistraction, 5: holdfire, 6: attacker, 7: maxboostdistance, 8: maxboostduration, 9: log, 10: debugchance
	local orderidx = C.CreateOrder3(convertedComponent, "Flee", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(convertedComponent, orderidx, 1, nil, 'boost')
		SetOrderParam(convertedComponent, orderidx, 3, nil, true)
		SetOrderParam(convertedComponent, orderidx, 4, nil, true)
		if attacker then
			SetOrderParam(convertedComponent, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
		end
		C.EnableOrder(convertedComponent, orderidx)
		if immediate then
			menu.setOrderImmediate(convertedComponent, orderidx)
		end
	end

	return orderidx
end

-- other helpers

function menu.plotCourse(object, offset)
	local convertedObject = ConvertStringToLuaID(tostring(object))
	if (object == C.GetPlayerControlledShipID()) then
		return -- no plot course to playership or when menu.mode is set
	end

	if IsSameComponent(GetActiveGuidanceMissionComponent(), convertedObject) then
		C.EndGuidance()
	else
		if offset == nil then
			offset = ffi.new("UIPosRot", 0)
		elseif C.IsComponentClass(object, "sector") then
			object = C.GetZoneAt(object, offset)
		end
		C.SetGuidance(object, offset)
	end
end

function menu.canCollectCrates(haspilot)
	local iscapship = false
	local hascollector = false
	if haspilot then
		for _, ship in ipairs(menu.selectedplayerships) do
			iscapship = C.IsComponentClass(ship, "ship_l") or C.IsComponentClass(ship, "ship_xl")
			if iscapship then
				hascollector = (C.GetNumStoredUnits(ship, "transport", false) > 0)
			end

			if not iscapship or hascollector then
				break
			end
		end
	end

	local active = haspilot and (not iscapship or hascollector)
	local reason = ""
	if iscapship and not hascollector then
		reason = ReadText(1026, 20014)
	elseif not haspilot then
		reason = ReadText(1026, 7830)
	end
	--print("menu.canCollectCrates. active: " .. tostring(active) .. ", mouseovertext: " .. tostring(reason))
	return active, reason
end

function menu.canSalvage(haspilot)
	local istug = false
	local hasbuilder = false
	if haspilot then
		for _, ship in ipairs(menu.selectedplayerships) do
			istug = (GetComponentData(ship, "shiptype") == "tug")
			if not istug then
				hasbuilder = (C.GetNumStoredUnits(ship, "build", false) > 0)
			end

			if istug or hasbuilder then
				break
			end
		end
	end

	local active = haspilot and (istug or hasbuilder)
	local reason = ""
	if not istug and not hasbuilder then
		reason = ReadText(1026, 20029)
	elseif not haspilot then
		reason = ReadText(1026, 7830)
	end
	--print("menu.canSalvage. active: " .. tostring(active) .. ", mouseovertext: " .. tostring(reason))
	return active, reason
end

function menu.getCanCancelConstructionCount()
	local count = 0
	for _, id in ipairs(menu.construction.ids) do
		if C.CanCancelConstruction(menu.componentSlot.component, id) then
			count = count + 1
		end
	end
	return count
end

-- widget scripts

function menu.buttonActivateDeployables(isactive)
	for _, deployable in ipairs(menu.selectedplayerdeployables) do
		if GetComponentData(deployable, "isactive") == isactive then
			C.ActivateObject(deployable, not isactive)
		end
	end
	menu.onCloseElement("close")
end

function menu.buttonSelfDestructDeployables(selecteddeployable)
	if selecteddeployable then
		C.SelfDestructComponent(selecteddeployable)
	else
		for _, deployable in ipairs(menu.selectedplayerdeployables) do
			C.SelfDestructComponent(deployable)
		end
	end
	menu.onCloseElement("close")
end

function menu.buttonArmTurrets(armed)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isplayerownedtarget = GetComponentData(convertedComponent, "isplayerowned")
	
	if isplayerownedtarget and C.IsComponentClass(menu.componentSlot.component, "ship") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isdeployable")) then
		C.SetAllTurretsArmed(menu.componentSlot.component, armed)
	end
	for _, ship in ipairs(menu.selectedplayerships) do
		C.SetAllTurretsArmed(ship, armed)
	end

	menu.onCloseElement("close")
end

function menu.buttonAssignCommander(assignment, group)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isplayerownedtarget = GetComponentData(convertedComponent, "isplayerowned")

	if menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown)) then
		local playeroccupiedship = C.GetPlayerOccupiedShipID()
		local oldassignment = ffi.string(C.GetSubordinateGroupAssignment(playeroccupiedship, group))
		if assignment == "positiondefence" and oldassignment ~= "positiondefence" then
			Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(playeroccupiedship)), group)
		end

		C.ResetOrderLoop(menu.componentSlot.component)
		menu.orderAssignCommander(convertedComponent, playeroccupiedship, assignment, group)
	else
		if C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local oldassignment = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, group))
			if assignment == "positiondefence" and oldassignment ~= "positiondefence" then
				Helper.setIntersectorDefence(convertedComponent, group)
			end

			for _, ship in ipairs(menu.selectedplayerships) do
				if (convertedComponent ~= ship) and isplayerownedtarget then
					local skip = false
					if not GetComponentData(ship, "assignedpilot") then
						skip = true
					elseif GetComponentData(ship, "primarypurpose") == "mine" then
						if assignment == "tradeforbuildstorage" then
							skip = true
						end
					else
						if assignment == "mining" then
							skip = true
						end
					end
					if not skip then
						C.ResetOrderLoop(ship)
						menu.orderAssignCommander(ship, menu.componentSlot.component, assignment, group)
					end
				end
			end
		end
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonAttack(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderAttack(ship, menu.componentSlot.component, clear, false)
	end

	menu.onCloseElement("close")
end

function menu.buttonAttackInRange()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderAttackInRange(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonAttackMultiple(clear)
	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "attackmultiple", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), clear })
		menu.cleanup()
	end
end

function menu.buttonAttackSurfaceElements(target, targetclass, clear)
	local targetclasses = {}
	if targetclass == "all" then
		if C.IsComponentClass(menu.componentSlot.component, "station") then
			targetclasses = {"turret", "shieldgenerator"}
		else
			targetclasses = {"engine", "turret", "shieldgenerator"}
		end
	else
		targetclasses = {targetclass}
	end

	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderAttackSurfaceElements(ship, target, targetclasses, clear)
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonBoard()
	local selectedplayerships = {table.unpack(menu.selectedplayerships)}
	if menu.removedOccupiedPlayerShip then
		table.insert(selectedplayerships, menu.removedOccupiedPlayerShip)
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "boardingcontext", {ConvertStringTo64Bit(tostring(menu.componentSlot.component)), selectedplayerships} }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.interactMenuCallbacks.returnToMenu("boardingcontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), selectedplayerships } )
		Helper.resetInteractMenuCallbacks()
		menu.cleanup()
	end
end

function menu.buttonCancelConstruction()
	C.CancelConstruction(menu.componentSlot.component, menu.construction.id)
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonCancelAllConstruction()
	for _, id in ipairs(menu.construction.ids) do
		if C.CanCancelConstruction(menu.componentSlot.component, id) then
			C.CancelConstruction(menu.componentSlot.component, id)
		end
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonChangeAssignment(assignment, group)
	if assignment == "positiondefence" then
		Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), group)
	end

	if menu.shipswithcurrentcommander and #menu.shipswithcurrentcommander > 0 then
		for _, ship in ipairs(menu.shipswithcurrentcommander) do
			menu.orderAssignCommander(ship, menu.componentSlot.component, assignment, group)
		end
	elseif menu.groupShips and #menu.groupShips > 0 then
		for _, shipentry in ipairs(menu.groupShips) do
			menu.orderAssignCommander(ConvertIDTo64Bit(shipentry.component), menu.componentSlot.component, assignment, group)
		end
	else
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		menu.orderAssignCommander(convertedComponent, GetCommander(convertedComponent), assignment, group)
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonChangeLogo()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'changelogocontext', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "changelogocontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } )
		menu.cleanup()
	end
end

function menu.buttonChangeOverrideOrder(idstring, attacker)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))

	-- remove all override orders
	local numorders = C.GetNumOrders(menu.componentSlot.component)
	local currentorders = ffi.new("Order2[?]", numorders)
	numorders = C.GetOrders2(currentorders, numorders, menu.componentSlot.component)
	for i = numorders, 1, -1 do
		if currentorders[i - 1].isoverride then
			C.RemoveOrder(menu.componentSlot.component, i, false, false)
		end
	end

	local orderidx
	if idstring == "Flee" then
		orderidx = C.CreateOrder3(menu.componentSlot.component, "Flee", false, true, true)
		if orderidx > 0 then
			SetOrderParam(convertedComponent, orderidx, 1, nil, 'boost')
			SetOrderParam(convertedComponent, orderidx, 3, nil, true)
			SetOrderParam(convertedComponent, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(convertedComponent, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Attack" then
		orderidx = C.CreateOrder3(menu.componentSlot.component, "Attack", false, true, true)
		if orderidx > 0 then
			if attacker then
				SetOrderParam(convertedComponent, orderidx, 1, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Wait" then
		orderidx = C.CreateOrder3(menu.componentSlot.component, "Wait", false, true, true)
		if orderidx > 0 then
			SetOrderParam(convertedComponent, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(convertedComponent, orderidx, 5, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	end

	if orderidx > 0 then
		C.EnableOrder(menu.componentSlot.component, orderidx)
		local newidx = 1
		if not C.AdjustOrder(menu.componentSlot.component, orderidx, newidx, true, false, true) then
			newidx = 2
		end
		C.AdjustOrder(menu.componentSlot.component, orderidx, newidx, true, false, false)
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonClaim(selectedship)
	C.ClaimShip(selectedship, menu.componentSlot.component)
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refreshcrew")
		menu.cleanup()
	end
end

function menu.buttonCollect()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollect(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonCollectDeployable(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollectDeployable(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonCollectDeployables(clear)
	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "collectdeployables", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), clear })
		menu.cleanup()
	end
end

function menu.buttonCollectLockbox()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollectLockbox(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonCollectRadius()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollectRadius(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonComm()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		local entities = Helper.getSuitableControlEntities(convertedComponent, true)
		Helper.closeMenuForNewConversation(menu, "default", entities[1], convertedComponent, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "comm", ConvertStringTo64Bit(tostring(menu.componentSlot.component)))
		menu.cleanup()
	end
end

function menu.buttonCrewTransfer(othership)
	local ship = ConvertStringTo64Bit(tostring(menu.componentSlot.component))

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "crewtransfercontext", { othership, ship } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "crewtransfercontext", { othership, ship } )
		menu.cleanup()
	end
end

function menu.buttonDeliverWares(missionid)
	SignalObject(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "ware_mission_delivery", ConvertStringToLuaID(tostring(missionid)))
	menu.onCloseElement("close")
end

function menu.buttonDeploy(type, macro, amount)
	if type == "mine" then
		for i = 1, amount do
			C.LaunchMine(menu.componentSlot.component, macro)
		end
	elseif type == "navbeacon" then
		for i = 1, amount do
			C.LaunchNavBeacon(menu.componentSlot.component, macro)
		end
	elseif type == "satellite" then
		for i = 1, amount do
			C.LaunchSatellite(menu.componentSlot.component, macro)
		end
	elseif type == "lasertower" then
		for i = 1, amount do
			C.LaunchLaserTower(menu.componentSlot.component, macro)
		end
	elseif type == "resourceprobe" then
		for i = 1, amount do
			C.LaunchResourceProbe(menu.componentSlot.component, macro)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonDeployAtPosition(type, macro, amount)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderDeployAtPosition(ship, menu.offsetcomponent, menu.offset, macro, amount)
	end

	menu.onCloseElement("close")
end

function menu.buttonDeployToStation(selectedbuilder, clear, target)
	if not C.IsBuilderBusy(selectedbuilder) then
		local convertedBuilder = ConvertStringTo64Bit(tostring(selectedbuilder))
		if not GetComponentData(convertedBuilder, "isplayerowned") then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney >= fee then
				TransferPlayerMoneyTo(fee, convertedBuilder)
			else
				return
			end
		end

		local station = target or menu.componentSlot.component
		if C.IsComponentClass(menu.componentSlot.component, "buildstorage") then
			station = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "basestation")) or 0
		end
		menu.orderDeployToStation(convertedBuilder, station, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonDepositInventoryAtHQ()
	menu.orderDepositInventoryAtHQ(menu.componentSlot.component, clear)

	menu.onCloseElement("close")
end

function menu.buttonDock(clear, ventureplatform)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local convertedVenturePlatform = ventureplatform and ConvertStringTo64Bit(tostring(ventureplatform))
	for _, ship in ipairs(menu.selectedplayerships) do
		if IsDockingPossible(ship, convertedComponent, convertedVenturePlatform) then
			menu.orderDock(ship, menu.componentSlot.component, clear, ventureplatform)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonDockAtPlayer(clear)
	local playercontainer = C.GetPlayerContainerID()
	local convertedComponent = ConvertStringTo64Bit(tostring(playercontainer))
	for _, ship in ipairs(menu.selectedplayerships) do
		if IsDockingPossible(ship, convertedComponent) then
			if C.GetContextByClass(ship, "container", false) == playercontainer then
				if (not C.IsShipAtExternalDock(ship)) and (not C.IsShipBeingRetrieved(ship)) then
					C.RequestShipFromInternalStorage2(ship, false, C.GetPlayerID())
				end
			else
				menu.orderDock(ship, playercontainer, clear)
			end
		end
	end
	if C.GetContextByClass(menu.componentSlot.component, "container", false) == playercontainer then
		if (not C.IsShipAtExternalDock(menu.componentSlot.component)) and (not C.IsShipBeingRetrieved(menu.componentSlot.component)) then
			C.RequestShipFromInternalStorage2(menu.componentSlot.component, false, C.GetPlayerID())
		end
	else
		menu.orderDock(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), playercontainer, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonDockRequest()
	local dockcontainer = menu.componentSlot.component
	if C.IsComponentClass(menu.componentSlot.component, "dockingbay") then
		dockcontainer = C.GetContextByClass(dockcontainer, "container", false)
	end

	C.RequestDockAt(dockcontainer, false)

	menu.onCloseElement("close")
end

function menu.buttonDropInventory(pilot)
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "dropwarescontext", { "inventory", ConvertStringToLuaID(tostring(pilot)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "dropwarescontext", { "inventory", pilot } )
		menu.cleanup()
	end
end

function menu.buttonEndGuidance()
	C.EndGuidance()
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh" )
		menu.cleanup()
	end
end

function menu.buttonExplore(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderExplore(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonExploreUpdate(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderExploreUpdate(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonExternal()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
	local target = 0
	if C.IsComponentClass(menu.componentSlot.component, "highway") then
		local issuperhighway, entrygate = GetComponentData(convertedComponent, "issuperhighway", "entrygate")
		if issuperhighway then
			target = ConvertIDTo64Bit(entrygate)
		else
			target = menu.componentSlot.component
		end
	else
		target = menu.componentSlot.component
	end
	local targetsector = C.GetContextByClass(target, "sector", false)
	if (target ~= C.GetPlayerControlledShipID()) and (playersector == targetsector) then
		local success = C.SetSofttarget(menu.componentSlot.component, "")
		if success then
			PlaySound("ui_target_set")
			C.SetPlayerCameraTargetView(target, true)
		else
			PlaySound("ui_target_set_fail")
		end
	else
		PlaySound("ui_target_set_fail")
	end

	menu.onCloseElement("close")
end

function menu.buttonFlee(attacker, clear)
	menu.orderWithdrawFromCombat(menu.componentSlot.component, clear, true, attacker)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderWithdrawFromCombat(ship, clear, true, attacker)
	end

	menu.onCloseElement("close")
end

function menu.buttonFollow(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderFollow(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonFormationShape(shape, subordinates)
	local info = C.SetFormationShape(menu.componentSlot.component, shape)
	shape = ffi.string(info.shape)

	if (shape ~= "") then
		for i = #subordinates, 1, -1 do
			local subordinate = ConvertIDTo64Bit(subordinates[i])

			local numorders = C.GetNumOrders(subordinate)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, subordinate)
			local paramoffset = 0
			for j = 1, numorders do
				if (ffi.string(currentorders[0].orderdef) == "Escort") then
					paramoffset = 0
				elseif (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
					paramoffset = 1
				end
				if (ffi.string(currentorders[0].orderdef) == "Escort") or (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
					SetOrderParam(subordinate, j, paramoffset + 2, nil, shape) -- shape
					SetOrderParam(subordinate, j, paramoffset + 3, nil, info.radius) -- radius
					SetOrderParam(subordinate, j, paramoffset + 4, nil, info.rollMembers) -- rollmembers
					SetOrderParam(subordinate, j, paramoffset + 5, nil, info.rollFormation) -- rollformation
					SetOrderParam(subordinate, j, paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
				end
			end

			local currentdefaultorder = ffi.new("Order")
			if C.GetDefaultOrder(currentdefaultorder, subordinate) then
				if (ffi.string(currentdefaultorder.orderdef) == "Escort") then
					paramoffset = 0
				elseif (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
					paramoffset = 1
				end
				if (ffi.string(currentdefaultorder.orderdef) == "Escort") or (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
					SetOrderParam(subordinate, "default", paramoffset + 2, nil, shape) -- shape
					SetOrderParam(subordinate, "default", paramoffset + 3, nil, info.radius) -- radius
					SetOrderParam(subordinate, "default", paramoffset + 4, nil, info.rollMembers) -- rollmembers
					SetOrderParam(subordinate, "default", paramoffset + 5, nil, info.rollFormation) -- rollformation
					SetOrderParam(subordinate, "default", paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
				end
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonGetSupplies()
	menu.orderGetSupplies(menu.componentSlot.component, clear)

	menu.onCloseElement("close")
end

function menu.buttonGuidance(useoffset)
	if useoffset then 
		menu.plotCourse(menu.offsetcomponent, menu.offset)
	else 
		menu.plotCourse(menu.componentSlot.component, nil)
	end 

	menu.onCloseElement("close")
end

function menu.buttonInfo()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "info", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) })
		menu.cleanup()
	end
end

function menu.buttonLiveStream()
	C.SetPlayerCameraCinematicView(menu.componentSlot.component)
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "close")
		menu.cleanup()
	end
end

function menu.buttonSetInterSectorDefence(groups, reset)
	local sectorid = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "sectorid")
	local pos = C.GetObjectPositionInSector(menu.componentSlot.component)

	for i = 1, 10 do
		if reset or groups[i] then
			Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), i, reset, sectorid, pos)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSubordinateGroupInterSectorDefence(group, reset)
	Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), group, reset)
	menu.onCloseElement("close")
end

function menu.buttonEncyclopedia()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local macro, ismodule = GetComponentData(convertedComponent, "macro", "ismodule")

	local mode, library, id, object
	if C.IsComponentClass(menu.componentSlot.component, "sector") then
		mode = "Galaxy"
		library = ""
		object = ConvertStringToLuaID(tostring(menu.componentSlot.component))
	else
		mode = ismodule and "Stations" or "Ships"
		library = GetMacroData(macro, "infolibrary")
		id = macro
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, mode, library, id, object }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "EncyclopediaMenu", { 0, 0, mode, library, id, object } })
		menu.cleanup()
	end
end

function menu.buttonMarkAsHostile()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "markashostile", { menu.componentSlot.component } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "markashostile", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) })
		menu.cleanup()
	end
end

function menu.buttonMining(ware, clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderMining(ship, ware, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonMissionSetInactive()
	C.SetActiveMission(0)

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMissionSetActive(missionid)
	C.SetActiveMission(missionid)
	PlaySound("ui_mission_set_active")

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMissionAbort(missionid)
	C.AbortMission(missionid)

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMissionShow(missionid)
	local missiondetails = C.GetMissionIDDetails(missionid)
	local entry = {
		["missionGroup"] = {},
		["maintype"] = ffi.string(missiondetails.mainType),
	}
	if missiondetails.threadMissionID ~= 0 then
		local missionGroup = C.GetMissionGroupDetails(missiondetails.threadMissionID)
		entry.missionGroup.id = ffi.string(missionGroup.id)
		entry.missionGroup.name = ffi.string(missionGroup.name)
	else
		local missionGroup = C.GetMissionGroupDetails(missionid)
		entry.missionGroup.id = ffi.string(missionGroup.id)
		entry.missionGroup.name = ffi.string(missionGroup.name)
	end
	
	local mode
	if entry.maintype == "upkeep" then
		mode = "upkeep"
	else
		if entry.maintype == "guidance" then
			DebugError("menu.buttonMissionShow(): Trying to show guidance mission. [Florian]")
		else
			mode = "plot"
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "mission", mode, ConvertStringTo64Bit(tostring(missionid)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "mission", { mode, ConvertStringTo64Bit(tostring(missionid)) })
		menu.cleanup()
	end
end

function menu.buttonShowUpkeepMissions()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "mission", "upkeep", tostring(menu.componentSlot.component), true } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "mission", { "upkeep", tostring(menu.componentSlot.component), true })
		menu.cleanup()
	end
end

function menu.buttonMissionBriefing(missionid, isoffer)
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), isoffer }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), isoffer } })
		menu.cleanup()
	end
end

function menu.buttonMissionAccept(offerid)
	local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, rewardmoney, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, abortable, guidancedisabled, associatedcomponent, alertLevel, offeractor, offercomponent = GetMissionOfferDetails(ConvertStringToLuaID(menu.missionoffer))

	SignalObject(offeractor, "accept", ConvertStringToLuaID(tostring(offerid)))

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "missionaccepted", { offerid })
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMoveWait(clear)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local target = 0
	local playerprecise = (#menu.selectedplayerships == 1)
	if C.IsComponentClass(menu.componentSlot.component, "highway") then
		local issuperhighway, entrygate = GetComponentData(convertedComponent, "issuperhighway", "entrygate")
		if issuperhighway then
			target = ConvertIDTo64Bit(entrygate)
		else
			target = menu.componentSlot.component
		end
	else
		target = menu.componentSlot.component
	end
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderMoveWait(ship, menu.offsetcomponent, menu.offset, target, playerprecise, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadAttackPlayerTarget(clear)
	local playertarget = ConvertIDTo64Bit(GetPlayerTarget())
	if (playertarget ~= 0) then
		for ship in pairs(menu.playerSquad) do
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(ship, hasloop)
			if not hasloop[0] then
				menu.orderAttack(ship, playertarget, clear, true)
				--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to attack " .. ffi.string(C.GetComponentName(playertarget)) .. " " .. tostring(playertarget))
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadStopAndHoldFire(clear)
	for ship in pairs(menu.playerSquad) do
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ship, hasloop)
		if not hasloop[0] then
			menu.orderStopAndHoldFire(ship, clear, true)
			--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to halt and stop firing.")
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadWithdrawAndHold(clear)
	for ship in pairs(menu.playerSquad) do
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ship, hasloop)
		if not hasloop[0] then
			menu.orderWithdrawAndHold(ship, clear, true)
			--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to withdraw from combat and hold position.")
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadWithdrawFromCombat(clear)
	for ship in pairs(menu.playerSquad) do
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ship, hasloop)
		if not hasloop[0] then
			menu.orderWithdrawFromCombat(ship, clear, true)
			--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to withdraw from combat.")
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPerformPlayerAction(id, type)
	C.PerformCompSlotPlayerAction(menu.componentSlot, id)
	AddUITriggeredEvent(menu.name, "perform", type)
	menu.onCloseElement("close", nil, false)
end

function menu.buttonPlayerDockToTrade(clear)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	for _, ship in ipairs(menu.selectedplayerships) do
		if IsDockingPossible(ship, convertedComponent, nil, true) then
			menu.orderPlayerDockToTrade(ship, menu.componentSlot.component, clear)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonProceedWithOrders()
	SignalObject(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "playerownedship_proceed")
	for _, ship in ipairs(menu.selectedplayerships) do
		SignalObject(ship, "playerownedship_proceed")
	end
	menu.onCloseElement("close")
end

function menu.buttonProtect(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderProtect(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonPutIntoStorage(container, ship)
	if C.IsShipAtExternalDock(ship) then
		C.PutShipIntoStorage(container, ship)
	else
		C.RequestShipFromInternalStorage2(ship, false, C.GetPlayerID())
	end

	menu.onCloseElement("close")
end

function menu.buttonRecallSubordinates(component, subordinates, level)
	if not level then
		level = 1
	end

	if not component then
		DebugError("menu.buttonRecallSubordinates(): " .. tostring(component) .. " is not a valid component.")
	elseif not subordinates or #subordinates < 1 then
		DebugError("menu.buttonRecallSubordinates(): tried to recall subordinates on " .. tostring(component) .. " that has no subordinates.")
	else
		C.SetAllDronesArmed(component, false)
		for i = #subordinates, 1, -1 do
			local subordinate = ConvertIDTo64Bit(subordinates[i])
			local numorders = C.GetNumOrders(subordinate)
			for j = numorders, 1, -1 do
				C.RemoveOrder(subordinate, j, false, false)
			end

			local subsubordinates = GetSubordinates(subordinates[i])
			if #subsubordinates > 0 then
				menu.buttonRecallSubordinates(subordinate, subsubordinates, level + 1)
			end
		end
	end

	if level == 1 then
		menu.onCloseElement("close")
	end
end

function menu.buttonRemoveAllOrders(removedefaultorder, removeassignment, removedockorder)
	menu.orderRemove(menu.componentSlot.component, removedefaultorder, removeassignment, removedockorder)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderRemove(ship, removedefaultorder, removeassignment, removedockorder)
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonRemoveAssignment(removeall)
	C.RemoveCommander2(menu.componentSlot.component)
	C.CreateOrder(menu.componentSlot.component, "Wait", true)
	C.EnablePlannedDefaultOrder(menu.componentSlot.component, false)
	if removeall then
		for _, ship in ipairs(menu.selectedplayerships) do
			C.RemoveCommander2(ship)
			C.CreateOrder(ship, "Wait", true)
			C.EnablePlannedDefaultOrder(ship, false)
		end
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonRemoveOrder()
	if menu.componentOrder then
		C.RemoveOrder(menu.componentSlot.component, menu.componentOrder.queueidx, false, false)
	elseif menu.syncpointorder then
		C.RemoveOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, false, false)
	end
	menu.onCloseElement("close")
end

function menu.buttonRename(isfleet)
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'renamecontext', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "renamecontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet } )
		menu.cleanup()
	end
end

function menu.buttonRequestShip()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "PlatformUndockMenu", { 0, 0, C.GetContextByClass(menu.componentSlot.component, "container", false), "requestship", { menu.isdockedship and C.GetContextByClass(menu.componentSlot.component, "dockingbay", false) or menu.componentSlot.component } }, true)
		menu.cleanup()
	end
end

function menu.buttonSalvageCollect(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		if GetComponentData(ship, "shiptype") == "tug" then
			menu.orderSalvageCollect(ship, menu.componentSlot.component, clear)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageCrush(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		if GetComponentData(ship, "shiptype") == "compactor" then
			menu.orderSalvageCrush(ship, menu.componentSlot.component, clear)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageDeliver(clear, ware, tradeoffer)
	for _, ship in ipairs(menu.selectedplayerships) do
		local towedobject = C.GetTowedObject(ship)
		if towedobject ~= 0 then
			local recyclingwares = GetComponentData(ConvertStringTo64Bit(tostring(towedobject)), "recyclingwares")
			if #recyclingwares > 0 then
				if ware == recyclingwares[1].ware then
					menu.orderSalvageDeliver(ship, menu.componentSlot.component, tradeoffer, recyclingwares[1].amount, clear)
				end
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageDeliver_NoTrade()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderSalvageDeliver_NoTrade(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageInRadius()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderSalvageInRadius(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonSyncPointAutoRelease()
	if menu.syncpointorder then
		C.SetSyncPointAutoReleaseFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, not C.GetSyncPointAutoReleaseFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, true), false)
	elseif menu.syncpoint then
		C.SetSyncPointAutoRelease(menu.syncpoint, not C.GetSyncPointAutoRelease(menu.syncpoint, true), false)
	end
end

function menu.buttonTacticalAttack(ships, clear)
	for _, ship in ipairs(ships) do
		menu.orderTacticalAttack(ship, menu.componentSlot.component, clear, false)
	end

	menu.onCloseElement("close")
end

function menu.buttonTriggerSyncPoint()
	if menu.syncpointorder then
		C.ReleaseOrderSyncPointFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx)
	elseif menu.syncpoint then
		C.ReleaseOrderSyncPoint(menu.syncpoint)
	end
	menu.onCloseElement("close")
end

function menu.buttonUpgrade(clear)
	local shiptrader = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "shiptrader")
	if shiptrader then
		if menu.shown then
			if menu.interactMenuID then
				C.NotifyInteractMenuHidden(menu.interactMenuID, true)
			end
			Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, ConvertStringToLuaID(tostring(menu.componentSlot.component)), "upgrade", menu.selectedplayerships }, true)
			menu.cleanup()
		else
			Helper.resetUpdateHandler()
			Helper.clearFrame(menu, config.layer)
			Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "ShipConfigurationMenu", { 0, 0, ConvertStringToLuaID(tostring(menu.componentSlot.component)), "upgrade", menu.selectedplayerships } })
			menu.cleanup()
		end
	else
		DebugError("menu.buttonUpgrade(): unable to retrieve ship trader of " .. ffi.string(C.GetComponentName(menu.componentSlot.component)) .. ".")
	end
end

function menu.buttonPaintMod()
	local found = false
	local ships = {}
	if menu.shown then
		table.insert(ships, menu.componentSlot.component)
	else
		for _, ship in ipairs(menu.selectedplayerships) do
			table.insert(ships, ship)
			if ship == menu.componentSlot.component then
				found = true
			end
		end
		if not found then
			table.insert(ships, menu.componentSlot.component)
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "modify", { true, ships } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "ShipConfigurationMenu", { 0, 0, nil, "modify", { true, ships } } })
		menu.cleanup()
	end
end

function menu.buttonSelectSubordinateGroup()
	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "selectsubordinates", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), menu.subordinategroup })
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonSellShips()
	local isshipyard, iswharf = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isshipyard", "iswharf")
	local sellableships = {}
	for _, ship in ipairs(menu.selectedplayerships) do
		if C.CanContainerBuildShip(menu.componentSlot.component, ship) and GetComponentData(ship, "issellable") then
			table.insert(sellableships, ship)
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "sellships", { ConvertStringToLuaID(tostring(menu.componentSlot.component)), sellableships, menu.frameX, menu.frameY } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "sellships", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), sellableships, menu.frameX, menu.frameY })
		menu.cleanup()
	end
end

function menu.buttonShipConfig(mode)
	local shiptrader = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "shiptrader")
	if shiptrader then
		if menu.shown then
			if menu.interactMenuID then
				C.NotifyInteractMenuHidden(menu.interactMenuID, true)
			end
			Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, menu.componentSlot.component, mode }, true)
			menu.cleanup()
		else
			Helper.resetUpdateHandler()
			Helper.clearFrame(menu, config.layer)
			Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "ShipConfigurationMenu", { 0, 0, menu.componentSlot.component, mode } })
			menu.cleanup()
		end
	else
		DebugError("menu.buttonShipConfig(): unable to retrieve ship trader of " .. ffi.string(C.GetComponentName(menu.componentSlot.component)) .. ".")
	end
end

function menu.buttonStationConfig()
	local station = menu.componentSlot.component
	if C.IsComponentClass(menu.componentSlot.component, "buildstorage") then
		station = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "basestation")) or 0
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, station }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "StationConfigurationMenu", { 0, 0, station } })
		menu.cleanup()
	end
end

function menu.buttonStationOverview()
	local station = menu.componentSlot.component
	if C.IsComponentClass(menu.componentSlot.component, "buildstorage") then
		station = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "basestation")) or 0
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, station }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "StationOverviewMenu", { 0, 0, station } })
		menu.cleanup()
	end
end

function menu.buttonTeleport()
	local isplayerownedtarget = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isplayerowned")

	C.TeleportPlayerTo(menu.componentSlot.component, false, menu.mode == "shipconsole", (menu.mode == "shipconsole") and isplayerownedtarget)
	menu.onCloseElement("close")
end

function menu.buttonTrade(wareexchange, tradepartner, loop)
	tradepartner = tradepartner or ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	trader = (#menu.selectedplayerships == 1) and ConvertStringTo64Bit(tostring(menu.selectedplayerships[1])) or nil

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'tradecontext', { tradepartner, nil, wareexchange, nil, loop, trader } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "tradecontext", { tradepartner, nil, wareexchange, loop, trader } )
		menu.cleanup()
	end
end

function menu.buttonTravelMode(activate)
	if activate then
		C.StartPlayerActivity("travel")
	else
		C.StopPlayerActivity(GetPlayerActivity())
	end
	menu.onCloseElement("close")
end

function menu.buttonVenturePatron()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'venturepatroninfo', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "venturepatroninfo", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } )
		menu.cleanup()
	end
end

function menu.buttonVentureReportShip()
	local convertedcomponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local venturetransactionid = GetComponentData(convertedcomponent, "venturetransactionid")
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "ship", "Offensive ship name", nil, nil, venturetransactionid } }, true) -- hardcoded text only visible in venture server moderator interface
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "venturereport", { "ship", "Offensive ship name", nil, nil, venturetransactionid } )
		menu.cleanup()
	end
end

function menu.buttonVentureReportUser()
	local convertedcomponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local userid = GetComponentData(convertedcomponent, "ventureuserid")
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "user", "Offensive ship name", nil, nil, nil, userid } }, true) -- hardcoded text only visible in venture server moderator interface
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "venturereport", { "user", "Offensive ship name", nil, nil, nil, userid } )
		menu.cleanup()
	end
end

-- cheats

function menu.buttonOwnerCheat()
	C.MakePlayerOwnerOf(menu.componentSlot.component)
	if C.IsComponentClass(menu.componentSlot.component, "ship") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isdeployable")) then
		C.CreateOrder(menu.componentSlot.component, "Wait", true)
		C.EnablePlannedDefaultOrder(menu.componentSlot.component, false)
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonSatelliteCheat()
	local macro = GetWareData("satellite_mk2", "component")
	C.SpawnObjectAtPos(macro, menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.buttonNavBeaconCheat()
	local macro = GetWareData("waypointmarker_01", "component")
	C.SpawnObjectAtPos(macro, menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.buttonResourceProbeCheat()
	local macro = GetWareData("resourceprobe_01", "component")
	C.SpawnObjectAtPos(macro, menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.buttonWarpCheat()
	C.MovePlayerToSectorPos(menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.checkboxSubordinateGroupAttackOnSight(group, checked)
	C.SetSubordinateGroupAttackOnSight(menu.componentSlot.component, group, checked)
end

function menu.checkboxSubordinateGroupResupplyAtFleet(group, checked)
	C.SetSubordinateGroupResupplyAtFleet(menu.componentSlot.component, group, checked)
end

function menu.checkboxSubordinateGroupReinforceFleet(group, checked)
	C.SetSubordinateGroupReinforceFleet(menu.componentSlot.component, group, checked)
end

-- interact menu hooks

function menu.showInteractMenu(param)
	AddUITriggeredEvent(menu.name, "")
	menu.componentSlot = ffi.new("UIComponentSlot")
	menu.componentSlot.component = ConvertStringTo64Bit(tostring(param.component))
	AddUITriggeredEvent(menu.name, "id", ConvertStringTo64Bit(tostring(menu.componentSlot.component)))
	local connection = "connectionui"
	menu.connection = Helper.ffiNewString(connection)	-- store string here to keep it alive during lifetime of menu.componentSlot
	menu.componentSlot.connection = menu.connection
	menu.componentOrder = param.order
	menu.syncpoint = param.syncpoint
	menu.syncpointorder = param.syncpointorder
	menu.intersectordefencegroup = param.intersectordefencegroup
	menu.mission = param.mission
	menu.componentMissions = param.componentmissions
	menu.missionoffer = param.missionoffer
	menu.construction = param.construction
	menu.subordinategroup = param.subordinategroup
	menu.selectedplayerships = param.playerships
	menu.selectedotherobjects = param.otherobjects
	menu.selectedplayerdeployables = param.playerdeployables
	menu.playerSquad = menu.getPlayerSquad()
	menu.offsetcomponent = param.offsetcomponent
	menu.offset = param.offset
	menu.mouseX = param.mouseX
	menu.mouseY = param.mouseY

	menu.processSelectedPlayerShips()

	menu.display()
end

function menu.onShowMenu(_, _, serializedArg)
	C.SetTrackedMenuFullscreen(menu.name, false)
	if menu.param and (menu.param[3] == "shipconsole") then
		menu.mode = "shipconsole"
		menu.interactMenuID = nil
		menu.componentSlot = ffi.new("UIComponentSlot")
		menu.componentSlot.component = ConvertIDTo64Bit(menu.param[4])
		local connection = "connectionui"
		menu.connection = Helper.ffiNewString(connection)	-- store string here to keep it alive during lifetime of menu.componentSlot
		menu.componentSlot.connection = menu.connection
		menu.isdockedship = menu.param[5] == 1
	else
		menu.interactMenuID = tonumber(string.match(serializedArg, "%d+"))
		serializedArg = string.sub(serializedArg, string.find(serializedArg, ";") + 1)
		menu.componentSlot = ffi.new("UIComponentSlot")
		menu.componentSlot.component = ConvertStringTo64Bit(string.match(serializedArg, "%d+"))
		local connection = string.sub(serializedArg, string.find(serializedArg, ";") + 1)
		menu.connection = Helper.ffiNewString(connection)	-- store string here to keep it alive during lifetime of menu.componentSlot
		menu.componentSlot.connection = menu.connection
		-- Handle mission offers
		local _, _, _, _, _, _, _, _, _, _, missionOfferID = GetMissionOfferAtConnection(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), connection)
		if missionOfferID ~= nil then
			menu.missionoffer = tostring(missionOfferID)
		end
	end
	AddUITriggeredEvent(menu.name, "id", ConvertStringTo64Bit(tostring(menu.componentSlot.component)))

	local occupiedPlayerShip = C.GetPlayerOccupiedShipID()
	local toplevelcontainer = C.GetTopLevelContainer(C.GetPlayerID())
	if occupiedPlayerShip ~= 0 then
		menu.selectedplayerships = { ConvertStringTo64Bit(tostring(occupiedPlayerShip)) }
	elseif (menu.mode ~= "shipconsole") and (toplevelcontainer ~= 0) and C.IsComponentClass(toplevelcontainer, "ship") and GetComponentData(ConvertStringTo64Bit(tostring(toplevelcontainer)), "isplayerowned") then
		menu.selectedplayerships = { ConvertStringTo64Bit(tostring(toplevelcontainer)) }
	else
		menu.selectedplayerships = {}
	end
	menu.selectedotherobjects = {}
	menu.selectedplayerdeployables = {}
	menu.processSelectedPlayerShips()
	menu.playerSquad = menu.getPlayerSquad()

	if menu.interactMenuID then
		C.NotifyInteractMenuShown(menu.interactMenuID)
	end

	menu.display()
end

function menu.onShowMenuSound()
	-- no sound
end

-- displaying the menu

function menu.display()
	menu.width = Helper.scaleX(config.width)

	local posX, posY = GetLocalMousePosition()
	if menu.mode == "shipconsole" then
		posX, posY = -menu.width / 2, 0
	end
	if posX == nil then
		-- gamepad case
		if menu.mouseX ~= nil then
			posX = menu.mouseX + Helper.viewWidth / 2
			posY = menu.mouseY + Helper.viewHeight / 2
		else
			local pos = C.GetCompSlotScreenPos(menu.componentSlot)
			posX = pos.x + Helper.viewWidth / 2
			posY = pos.y + Helper.viewHeight / 2
		end
	else
		posX = posX + Helper.viewWidth / 2
		posY = Helper.viewHeight / 2 - posY
	end
	menu.posX = posX
	menu.posY = posY

	menu.holomapcolor = Helper.getHoloMapColors()
	menu.prepareTexts()
	if not menu.prepareActions() then
		-- no actions found
		menu.onCloseElement("close")
		return
	end

	menu.draw()
end

function menu.draw()
	local width = menu.width
	if menu.subsection then
		width = 2 * width + Helper.borderSize
	end
	
	menu.frameX = math.max(0, menu.posX)
	menu.frameY = math.max(0, menu.posY)
	menu.frame = Helper.createFrameHandle(menu, {
		x = menu.frameX,
		y = 0,
		width = width + Helper.scrollbarWidth,
		layer = config.layer,
		standardButtons = { close = true },
		standardButtonX = Helper.scrollbarWidth,
		autoFrameHeight = true,
		closeOnUnhandledClick = true,
		playerControls = true,
		startAnimation = false,
	})
	local frame = menu.frame

	local content_position = "left"
	local subsection_position = "right"
	if menu.subsection then
		if frame.properties.x + menu.width > Helper.viewWidth then
			-- content table is at the right border -> subsection table goes to the left
			menu.frameX = Helper.viewWidth - width - config.border
			content_position = "right"
			subsection_position = "left"
		elseif frame.properties.x + width > Helper.viewWidth then
			-- not enough space for the subsection table -> subsection table goes to the left
			menu.frameX = frame.properties.x - menu.width - Helper.borderSize
			content_position = "right"
			subsection_position = "left"
		else
			frame.properties.standardButtonX = frame.properties.standardButtonX + menu.width + Helper.borderSize
		end
	else
		if frame.properties.x + menu.width > Helper.viewWidth then
			menu.frameX = Helper.viewWidth - menu.width - config.border
		end
	end
	frame.properties.x = menu.frameX

	Helper.removeAllWidgetScripts(menu, config.layer)
	local contentTable = menu.createContentTable(frame, content_position)
	local subsectionTable
	if menu.subsection then
		subsectionTable = menu.createSubSectionTable(frame, subsection_position)
	end

	local height = contentTable:getFullHeight()
	local subsectionHeight = 0
	if menu.frameY + height > Helper.viewHeight then
		menu.frameY = math.max(0, Helper.viewHeight - height - config.border)
	else
		if menu.mode == "shipconsole" then
			menu.frameY = Helper.viewHeight / 2 - height / 2
		end
	end
	frame.properties.y = menu.frameY
	if menu.subsection then
		subsectionHeight = subsectionTable:getFullHeight()
		if frame.properties.y + menu.subsection.y + subsectionHeight > Helper.viewHeight then
			subsectionTable.properties.y = menu.subsection.y - subsectionHeight + (config.rowHeight + Helper.borderSize)
			if subsectionTable.properties.y < 0 then
				local diff = -subsectionTable.properties.y
				menu.frameY = frame.properties.y - diff
				frame.properties.y = menu.frameY
				frame.properties.standardButtonY = diff
				contentTable.properties.y = diff
				subsectionTable.properties.y = 0
			end
		else
			subsectionTable.properties.y = menu.subsection.y
		end
	end

	menu.mouseOutBox = {
		x1 =   frame.properties.x -  Helper.viewWidth / 2                                      - config.mouseOutRange,
		x2 =   frame.properties.x -  Helper.viewWidth / 2 + width                              + config.mouseOutRange,
		y1 = - frame.properties.y + Helper.viewHeight / 2                                      + config.mouseOutRange,
		y2 = - frame.properties.y + Helper.viewHeight / 2 - frame:getUsedHeight()              - config.mouseOutRange
	}
	
	frame:display()
end

function menu.addSectionTitle(ftable, section, first)
	if first and (#menu.selectedplayerships > 0) then
		return 0
	end

	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local commander
	if (convertedComponent ~= 0) and C.IsComponentClass(menu.componentSlot.component, "controllable") then
		commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
	end

	local height = 0
	if section.text ~= "" then
		local addspacing = not first
		if section.id == "main_assignments_subsections" then
			addspacing = false
			if menu.subordinategroup then
				addspacing = true
			elseif menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown)) then
				if (not commander) or (commander == 0) then
					addspacing = true
				end
			end
		end
		if addspacing then
			local row = ftable:addEmptyRow(config.rowHeight / 2)
			height = height + row:getHeight() + Helper.borderSize
		end
		local text = section.text
		if section.showloop and (menu.numorderloops > 0) then
			text = utf8.char(8734) .. " " .. text
		end

		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		if section.id == "main_assignments" then
			row[1]:createText(string.format(text, menu.texts.commanderShortName), { font = Helper.standardFontBold, mouseOverText = menu.texts.commanderName, titleColor = Helper.defaultSimpleBackgroundColor })
			row[4]:createText("[" .. GetComponentData(convertedComponent, "assignmentname") .. "]", { font = Helper.standardFontBold, halign = "right", height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
		elseif section.id == "main_assignments_subsections" then
			if menu.subordinategroup then
				local selectiontext = menu.texts.selectedName
				local fullselectiontext = menu.texts.selectedFullNames
				if menu.groupShips and (#menu.groupShips > 0) then
					selectiontext = GetComponentData(menu.groupShips[1].component, "name")
					if #menu.groupShips > 1 then
						selectiontext = string.format(ReadText(1001, 7801), #menu.groupShips)
					end
					local color = menu.holomapcolor.playercolor
					local first = true
					fullselectiontext = ""
					for _, shipentry in ipairs(menu.groupShips) do
						fullselectiontext = fullselectiontext .. (first and "" or "\n") .. string.format("\027#FF%02x%02x%02x#%s", color.r, color.g, color.b, shipentry.name .. " (" .. shipentry.objectid .. ")")
						first = false
					end
				end
				row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = fullselectiontext, titleColor = Helper.defaultSimpleBackgroundColor })
				row[4]:createText(selectiontext, { font = Helper.standardFontBold, halign = "right", color = menu.holomapcolor.playercolor, mouseOverText = fullselectiontext, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
			elseif menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown)) then
				if (not commander) or (commander == 0) then
					row[1]:setColSpan(5):createText(ReadText(1010, 1), { font = Helper.standardFontBold, mouseOverText = fullselectiontext, titleColor = Helper.defaultSimpleBackgroundColor })
				end
			end
		elseif section.id == "player_interaction" then
			if not first then
				row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = text .. " " .. menu.texts.targetName, titleColor = Helper.defaultSimpleBackgroundColor })
				row[4]:createText(menu.texts.targetBaseName or menu.texts.targetShortName, { font = Helper.standardFontBold, halign = "right", color = menu.colors.target, mouseOverText = text .. " " .. menu.texts.targetName, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
			end
		elseif (section.id == "selected_orders_all") or (section.id == "selected_assignments_all") then
			row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = menu.texts.selectedFullNamesAll, titleColor = Helper.defaultSimpleBackgroundColor })
			row[4]:createText(menu.texts.selectedNameAll, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = menu.texts.selectedFullNamesAll, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
		elseif (section.id == "selected_orders") or (section.id == "trade_orders") then
			row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = menu.texts.selectedFullNames, titleColor = Helper.defaultSimpleBackgroundColor })
			row[4]:createText(menu.texts.selectedName, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = menu.texts.selectedFullNames, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
		elseif (section.id == "selected_assignments") or (section.id == "selected_change_assignments") then
			local selectiontext = menu.texts.selectedName
			local fullselectiontext = menu.texts.selectedFullNames

			if section.id == "selected_change_assignments" then
				if menu.shipswithcurrentcommander and (#menu.shipswithcurrentcommander > 0) then
					selectiontext = GetComponentData(menu.shipswithcurrentcommander[1], "name")
					if #menu.shipswithcurrentcommander > 1 then
						selectiontext = string.format(ReadText(1001, 7801), #menu.shipswithcurrentcommander)
					end
					local color = menu.holomapcolor.playercolor
					local first = true
					fullselectiontext = ""
					for _, ship in ipairs(menu.shipswithcurrentcommander) do
						fullselectiontext = fullselectiontext .. (first and "" or "\n") .. string.format("\027#FF%02x%02x%02x#%s", color.r, color.g, color.b, GetComponentData(ship, "name") .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")")
						first = false
					end
				end
			end

			row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = fullselectiontext, titleColor = Helper.defaultSimpleBackgroundColor })
			row[4]:createText(selectiontext, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = fullselectiontext, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
		elseif section.id == "overrideorderoption" then
			row[1]:createText("\27R" .. text, { font = Helper.standardFontBold, mouseOverText = menu.texts.selectedFullNames, titleColor = Helper.defaultSimpleBackgroundColor })
			row[4]:createText(menu.texts.overrideordername, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = menu.texts.selectedFullNames, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
		else
			row[1]:setColSpan(5):createText(text, { font = Helper.standardFontBold, height = Helper.subHeaderHeight, titleColor = Helper.defaultSimpleBackgroundColor })
		end
		height = height + row:getHeight() + Helper.borderSize
	elseif section.id == "shipconsole" then
		if not first then
			local row = ftable:addEmptyRow(config.rowHeight / 2)
			height = height + row:getHeight() + Helper.borderSize
			local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
			row[1]:setColSpan(5):createText(ffi.string(C.GetComponentName(menu.isdockedship and C.GetContextByClass(menu.componentSlot.component, "dockingbay", false) or menu.componentSlot.component)), Helper.headerRowCenteredProperties)
			height = height + row:getHeight() + Helper.borderSize
		end
	end
	return height
end

function menu.createContentTable(frame, position)
	local x = 0
	if position == "right" then
		x = menu.width + Helper.borderSize
	end

	local ftable = frame:addTable(5, { tabOrder = menu.subsection and 2 or 1, x = x, width = menu.width, backgroundID = "solid", backgroundColor = Helper.color.semitransparent, highlightMode = "off" })
	ftable:setDefaultCellProperties("text",   { minRowHeight = config.rowHeight, fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultCellProperties("button", { height = config.rowHeight })
	ftable:setDefaultCellProperties("checkbox", { height = config.rowHeight, width = config.rowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = config.entryFontSize, x = config.entryX })

	local text = menu.texts.targetShortName
	local color = menu.colors.target
	if menu.construction then
		text = menu.texts.constructionName
	end

	local modetext = ReadText(1001, 7804)
	if (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.mission) and (not menu.missionoffer) then
		if (not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0) then
			if #menu.actions["selected_orders_all"] > 0 then
				modetext = ReadText(1001, 7804)
				text = menu.texts.selectedNameAll
			elseif #menu.actions["selected_orders"] > 0 then
				modetext = ReadText(1001, 7804)
				text = menu.texts.selectedName
			elseif #menu.actions["trade_orders"] > 0 then
				modetext = ReadText(1001, 7861)
				text = menu.texts.selectedName
			elseif #menu.actions["selected_assignments_all"] > 0 then
				modetext = ReadText(1001, 7886)
				text = menu.texts.selectedNameAll
			else
				-- fallback if no section is used (aka no interaction possible)
				text = menu.texts.selectedName
			end
			if menu.numorderloops > 0 then
				modetext = utf8.char(8734) .. " " .. modetext
			end
			color = menu.colors.selected
		elseif (#menu.selectedplayerships == 0) and (#menu.selectedotherobjects > 0) then
			modetext = ReadText(1001, 7804)
			text = menu.texts.otherName
			color = menu.colors.selected
		elseif (#menu.ventureships > 0) and (#menu.selectedplayerships == 0) then
			text = menu.texts.ventureName
			color = menu.colors.venture
		end
	end
	if text == nil then
		DebugError("Interact title text is nil [Florian]" ..
			"\n   targetShortName: " ..tostring(menu.texts.targetShortName) ..
			"\n   construction: " .. tostring(menu.construction) ..
			"\n   constructionName: " .. tostring(menu.texts.constructionName) ..
			"\n   selectedNameAll: " .. tostring(menu.texts.selectedNameAll) ..
			"\n   selectedName: " .. tostring(menu.texts.selectedName) ..
			"\n   otherName: " .. tostring(menu.texts.otherName) ..
			"\n   ventureName: " .. tostring(menu.texts.ventureName) ..
			"\n   #menu.selectedplayerships: " .. tostring(#menu.selectedplayerships) ..
			"\n   #menu.selectedotherobjects: " .. tostring(#menu.selectedotherobjects) ..
			"\n   #menu.ventureships: " .. tostring(#menu.ventureships) ..
			"\n   showPlayerInteractions: " .. tostring(menu.showPlayerInteractions) ..
			"\n   syncpoint: " .. tostring(menu.syncpoint) ..
			"\n   syncpointorder: " .. tostring(menu.syncpointorder) ..
			"\n   intersectordefencegroup: " .. tostring(menu.intersectordefencegroup) ..
			"\n   mission: " .. tostring(menu.mission) ..
			"\n   missionoffer: " .. tostring(menu.missionoffer) ..
			"\n   #menu.actions['selected_orders_all']: " .. tostring(#menu.actions["selected_orders_all"]) ..
			"\n   #menu.actions['selected_orders']: " .. tostring(#menu.actions["selected_orders"]) ..
			"\n   #menu.actions['trade_orders']: " .. tostring(#menu.actions["trade_orders"]) ..
			"\n   #menu.actions['selected_assignments_all']: " .. tostring(#menu.actions["selected_assignments_all"])
		)
		text = ""
	end

	-- need a min width here, otherwise column 3 gets a negative width if the mode text would fit into column 2
	local modetextwidth = math.ceil(math.max(0.2 * menu.width + 2 * Helper.borderSize, C.GetTextWidth(" " .. modetext .. " ", Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true))))
	local bordericonsize = Helper.scaleX(Helper.headerRow1Height)
	local borderwidth = math.ceil(math.max(bordericonsize, (menu.width - modetextwidth - 2 * Helper.borderSize) / 2))
	borderwidth = math.max(borderwidth, Helper.scaleX(config.rowHeight) + Helper.borderSize + 1)

	ftable:setColWidth(1, config.rowHeight)
	ftable:setColWidth(2, borderwidth - Helper.scaleX(config.rowHeight) - Helper.borderSize, false)
	ftable:setColWidth(4, math.ceil(0.4 * menu.width - borderwidth - Helper.borderSize), false)
	ftable:setColWidth(5, borderwidth, false)
	ftable:setDefaultBackgroundColSpan(1, 4)
	ftable:setDefaultColSpan(1, 3)
	ftable:setDefaultColSpan(4, 2)

	local height = 0
	if (((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) or ((#menu.selectedplayerships == 0) and (#menu.selectedotherobjects > 0))) and (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.mission) and (not menu.missionoffer) then
		-- modemarker
		local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
		row[1]:setBackgroundColSpan(5):setColSpan(2):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = borderwidth - bordericonsize + Helper.borderSize, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor })
		row[4]:setColSpan(1)
		row[3]:setColSpan(2)
		local width = row[3]:getColSpanWidth() + Helper.scrollbarWidth + Helper.borderSize
		row[3]:createIcon("solid", { height = bordericonsize, width = width, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor }):setText(modetext, { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = math.ceil((width- Helper.borderSize) / 2) })
		row[5]:setColSpan(1):createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Helper.defaultTitleTrapezoidBackgroundColor })
		height = height + row:getHeight() + Helper.borderSize
	end
	-- title
	local row = ftable:addRow(false, { bgColor = Helper.color.transparent })
	text = TruncateText(text, Helper.standardFontBold, Helper.scaleFont(Helper.standardFontBold, Helper.headerRow1FontSize), menu.width - Helper.scaleX(Helper.standardButtonWidth) - 2 * config.entryX)
	row[1]:setColSpan(5):createText(text, Helper.headerRowCenteredProperties)
	row[1].properties.color = color
	height = height + row:getHeight() + Helper.borderSize
	if (menu.subordinategroup or menu.intersectordefencegroup) and (#menu.selectedplayerships == 0) then
		row[1].properties.titleColor = nil
		local row = ftable:addRow(nil, { bgColor = Helper.color.transparent })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 8398), ReadText(20401, menu.subordinategroup or menu.intersectordefencegroup)), Helper.headerRowCenteredProperties)
		row[1].properties.color = color
	end

	-- kuertee start: distance tool
	if Helper.distanceTool_distance then
		local kuertee_dist = Helper.distanceTool_distance / 1000.0
		kuertee_dist = math.floor (kuertee_dist * 100 + 0.5) / 100
		row = ftable:addRow (false, {bgColor = Helper.color.transparent})
		local kuertee_text = ReadText (1001, 2957) .. ReadText (1001, 120) .. " " .. tostring (kuertee_dist) .. " " .. ReadText (1001, 108) -- Distance colon space X space km
		row [1]:setColSpan (5):createText (kuertee_text, {halign = "center"})
	end
	-- kuertee end

	-- entries
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isonlinetarget, isplayerownedtarget
	if convertedComponent ~= 0 then
		isonlinetarget, isplayerownedtarget = GetComponentData(convertedComponent, "isonlineobject", "isplayerowned")
	end

	local skipped = false
	if (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.mission) and (not menu.missionoffer) then
		if (#menu.selectedplayerships == 0) and (#menu.selectedotherobjects > 0) then
			-- show the player that they cannot do anything with their selection
			menu.noopreason = {}
			for _, selectedcomponent in ipairs(menu.selectedotherobjects) do
				if C.IsRealComponentClass(selectedcomponent, "ship") then
					local selected64 = ConvertStringTo64Bit(tostring(selectedcomponent))
					if GetComponentData(selected64, "isplayerowned") then
						if IsComponentConstruction(selected64) then
							-- player ship in construction
							menu.noopreason[1] = ReadText(1001, 11106)
						end
					else
						-- npc ship
						menu.noopreason[2] = ReadText(1001, 7852)
					end
				else
					-- station case
					menu.noopreason[3] = ReadText(1001, 11104)
				end
			end
			local reason = ""
			if menu.noopreason[1] then
				reason = menu.noopreason[1]
			end
			if menu.noopreason[2] then
				if reason ~= "" then
					reason = reason .. "\n"
				end
				reason = reason .. menu.noopreason[2]
			elseif menu.noopreason[3] then
				if reason ~= "" then
					reason = reason .. "\n"
				end
				reason = reason .. menu.noopreason[3]
			end

			local row = ftable:addRow(true, { bgColor = Helper.color.darkgrey })
			row[1]:setColSpan(5):createText(reason, { wordwrap = true, color = Helper.color.grey })
			skipped = true
		elseif isonlinetarget and isplayerownedtarget then
			local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.darkgrey })
			row[1]:setColSpan(5):createText(ReadText(1001, 7868), { wordwrap = true, color = Helper.color.grey })
			skipped = true
		elseif (#menu.ventureships > 0) and (#menu.selectedplayerships == 0) then
			local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.darkgrey })
			row[1]:setColSpan(5):createText(ReadText(1001, 7868), { wordwrap = true, color = Helper.color.grey })
			skipped = true
		elseif (menu.numorderloops > 0) and (#menu.selectedplayerships ~= menu.numorderloops) then
			local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.darkgrey })
			row[1]:setColSpan(5):createText(ReadText(1001, 11108), { wordwrap = true, color = Helper.color.grey })
			skipped = true
		elseif (menu.numorderloops > 1) then
			local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.darkgrey })
			row[1]:setColSpan(5):createText(ReadText(1001, 11109), { wordwrap = true, color = Helper.color.grey })
			skipped = true
		end
	end
	if not skipped then
		local first = true
		for _, section in ipairs(config.sections) do
			local pass = false
			if menu.showPlayerInteractions then
				if section.isplayerinteraction or (menu.shown and (not section.isorder)) then
					pass = true
				end
			elseif (section.isorder == nil) or (section.isorder == (#menu.selectedplayerships > 0)) then
				pass = true
			end

			if pass then
				if section.subsections then
					local hastitle = false
					for _, subsection in ipairs(section.subsections) do
						if (#menu.actions[subsection.id] > 0) or menu.forceSubSection[subsection.id] then
							if not hastitle then
								height = height + menu.addSectionTitle(ftable, section, first)
								first = false
								hastitle = true
							end
							local data = { id = subsection.id, y = height }
							local row = ftable:addRow(data, { bgColor = Helper.color.transparent })
							local iconHeight = Helper.scaleY(config.rowHeight)
							local button = row[1]:setColSpan(5):createButton({
								bgColor = #menu.actions[subsection.id] > 0 and Helper.color.transparent or Helper.color.darkgrey,
								highlightColor = #menu.actions[subsection.id] > 0 and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
								mouseOverText = (#menu.actions[subsection.id] > 0) and "" or menu.forceSubSection[subsection.id],
								helpOverlayID = subsection.helpOverlayID,
								helpOverlayText = subsection.helpOverlayText,
								helpOverlayHighlightOnly = subsection.helpOverlayHighlightOnly,
							}):setText((subsection.orderid and menu.orderIconText(subsection.orderid) or "") .. subsection.text, { color = Helper.color.white }):setIcon("table_arrow_inv_right", { scaling = false, width = iconHeight, height = iconHeight, x = menu.width - iconHeight })
							row[1].handlers.onClick = function () return menu.handleSubSectionOption(data, true) end
							height = height + row:getHeight() + Helper.borderSize
						end
					end
				elseif #menu.actions[section.id] > 0 then
					height = height + menu.addSectionTitle(ftable, section, first)
					first = false
					local availabletextwidth
					if (section.id == "main") or (section.id == "selected_orders") or (section.id == "trade_orders") or (section.id == "selected_assignments") or (section.id == "player_interaction") or (section.id == "trade") then
						local maxtextwidth = 0
						for _, entry in ipairs(menu.actions[section.id]) do
							if not entry.hidetarget then
								maxtextwidth = math.max(maxtextwidth, C.GetTextWidth(entry.text .. " ", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.entryFontSize, true)))
							end
						end
						availabletextwidth = menu.width - maxtextwidth - 2 * Helper.scaleX(config.entryX) - Helper.borderSize
					end

					for _, entry in ipairs(menu.actions[section.id]) do
						if entry.active == nil then
							entry.active = true
						end
						local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
						if entry.checkbox ~= nil then
							row[1]:setColSpan(1):createCheckBox(entry.checkbox, { active = entry.active, mouseOverText = entry.mouseOverText })
							row[1].properties.uiTriggerID = entry.type
							row[2]:setColSpan(4):createText(entry.text, {
								color = entry.active and Helper.color.white or Helper.color.lightgrey,
								mouseOverText = entry.mouseOverText,
								helpOverlayID = entry.helpOverlayID,
								helpOverlayText = entry.helpOverlayText,
								helpOverlayHighlightOnly = entry.helpOverlayHighlightOnly,
							})
						else
							local button = row[1]:setColSpan(5):createButton({
								bgColor = entry.active and Helper.color.transparent or Helper.color.darkgrey,
								highlightColor = entry.active and Helper.defaultButtonHighlightColor or Helper.defaultUnselectableButtonHighlightColor,
								mouseOverText = entry.mouseOverText,
								helpOverlayID = entry.helpOverlayID,
								helpOverlayText = entry.helpOverlayText,
								helpOverlayHighlightOnly = entry.helpOverlayHighlightOnly,
							}):setText(entry.text, { color = entry.active and Helper.color.white or Helper.color.lightgrey })
							button.properties.uiTriggerID = entry.type
							if (section.id == "selected_orders") or (section.id == "trade_orders") or (section.id == "selected_assignments") or (section.id == "player_interaction") or (section.id == "trade") then
								if not entry.hidetarget then
									local text2 = ""
									if entry.text2 then
										text2 = entry.text2
									else
										if ((section.id == "trade_orders") or (section.id == "trade") or (section.id == "player_interaction")) and entry.buildstorage then
											text2 = menu.texts.buildstorageName
										else
											text2 = menu.texts.targetBaseName or menu.texts.targetShortName
										end
									end
									text2 = TruncateText(text2, button.properties.text.font, Helper.scaleFont(button.properties.text.font, button.properties.text.fontsize, button.properties.scaling), availabletextwidth)
									button:setText2(text2, { halign = "right", color = menu.colors.target })
									if (entry.mouseOverText == nil) or (entry.mouseOverText == "") then
										button.properties.mouseOverText = entry.text .. " " .. (entry.buildstorage and menu.texts.buildstorageFullName or menu.texts.targetName)
									end
								end
							elseif (section.id == "main") then
								if entry.text2 then
									local text2 = entry.text2
									text2 = TruncateText(text2, button.properties.text.font, Helper.scaleFont(button.properties.text.font, button.properties.text.fontsize, button.properties.scaling), availabletextwidth)
									button:setText2(text2, { halign = "right", color = menu.colors.target })
								end
							end
						end
						if entry.active then
							row[1].handlers.onClick = entry.script
						end
						height = height + row:getHeight() + Helper.borderSize
					end
				end
			end
		end
		if first then
			local row = ftable:addRow(true, { bgColor = Helper.color.transparent })
			local button = row[1]:setColSpan(5):createButton({ active = false, bgColor = Helper.color.darkgrey }):setText("---", { halign = "center", color = Helper.color.red })
		end
	end

	ftable:setSelectedRow(menu.selectedRows.contentTable)
	ftable:setTopRow(menu.topRows.contentTable)
	menu.selectedRows.contentTable = nil
	menu.topRows.contentTable = nil

	return ftable
end

function menu.createSubSectionTable(frame, position)
	local x = 0
	if position == "right" then
		x = menu.width + Helper.borderSize
	end

	local ftable = frame:addTable(2, { tabOrder = 1, x = x, width = menu.width, backgroundID = "solid", backgroundColor = Helper.color.semitransparent, highlightMode = "off" })
	ftable:setDefaultCellProperties("text",   { minRowHeight = config.rowHeight, fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultCellProperties("button", { height = config.rowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = config.entryFontSize, x = config.entryX })
	ftable:setColWidthPercent(2, 40)
	ftable:setDefaultBackgroundColSpan(1, 2)

	for _, entry in ipairs(menu.actions[menu.subsection.id]) do
		if entry.active == nil then
			entry.active = true
		end
		row = ftable:addRow(true, { bgColor = Helper.color.transparent })
		local maxtextwidth = 0
		if entry.text2 then
			maxtextwidth = C.GetTextWidth(entry.text2 .. " ", entry.text2font or Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.entryFontSize, true))
		end
		local availabletextwidth = menu.width - maxtextwidth - 2 * Helper.scaleX(config.entryX) - Helper.borderSize

		local button = row[1]:setColSpan(2):createButton({
			active = entry.active,
			bgColor = entry.active and Helper.color.transparent or Helper.color.darkgrey,
			helpOverlayID = entry.helpOverlayID,
			helpOverlayText = entry.helpOverlayText,
			helpOverlayHighlightOnly = entry.helpOverlayHighlightOnly,
		})
		button.properties.uiTriggerID = entry.type
		local text = TruncateText(entry.text, button.properties.text.font, Helper.scaleFont(button.properties.text.font, button.properties.text.fontsize, button.properties.scaling), availabletextwidth)
		if entry.mouseOverText then
			button.properties.mouseOverText = entry.mouseOverText
		elseif text ~= entry.text then
			button.properties.mouseOverText = entry.text
		end
		button:setText(text, { color = entry.active and Helper.color.white or Helper.color.lightgrey })
		row[1].handlers.onClick = entry.script
		if entry.text2 then
			button:setText2(entry.text2, { halign = "right", color = entry.active and Helper.color.white or Helper.color.lightgrey, font = entry.text2font or Helper.standardFont }) 
		end
	end

	return ftable
end

-- helpers

function menu.getPlayerSquad()
	local playerSquad = {}

	local playerOccupiedShip = C.GetPlayerOccupiedShipID()
	if (playerOccupiedShip ~= 0) then
		local locplayersubordinates = GetSubordinates(ConvertStringTo64Bit(tostring(playerOccupiedShip)), nil, true)
		for _, subordinate in ipairs(locplayersubordinates) do
			playerSquad[ConvertIDTo64Bit(subordinate)] = true
			--print("inserting: " .. ConvertIDTo64Bit(subordinate))
		end
	end

	return playerSquad
end

function menu.getSubordinatesInGroups(commander, isstation)
	local groups = {}
	for group = 1, isstation and 5 or 10 do
		local locassignment = ffi.string(C.GetSubordinateGroupAssignment(commander, group))
		if locassignment ~= "" then
			--groups[group] = { assignment = locassignment, subordinates = {} }

			local numsubordinates = C.GetNumSubordinatesOfGroup(commander, group)
			if numsubordinates > 0 then
				local subordinates = ffi.new("UniverseID[?]", numsubordinates)
				numsubordinates = C.GetSubordinatesOfGroup(subordinates, numsubordinates, commander, group)
				if numsubordinates > 0 then
					groups[group] = { assignment = locassignment, subordinates = {} }
					for i = 0, numsubordinates - 1 do
						--print(tostring(ConvertStringToLuaID(tostring(subordinates[i]))))
						local component = ConvertStringToLuaID(tostring(subordinates[i]))
						table.insert(groups[group].subordinates, { component = component, name = GetComponentData(component, "name"), objectid = ffi.string(C.GetObjectIDCode(subordinates[i])) })
					end
					table.sort(groups[group].subordinates, Helper.sortNameAndObjectID)
				end
			end
		end
	end
	return groups
end

function menu.setOrderImmediate(component, orderidx)
	local newidx = 1
	if not C.AdjustOrder(component, orderidx, newidx, true, false, true) then
		newidx = 2
	end
	C.AdjustOrder(component, orderidx, newidx, true, false, false)
end

function menu.handleSubSectionOption(data, skipdelay)
	if type(data) == "table" then
		if ((not menu.pendingSubSection) and ((not menu.subsection) or (menu.subsection.id ~= data.id))) or (menu.pendingSubSection and ((type(menu.pendingSubSection) ~= "table") or (menu.pendingSubSection.id ~= data.id))) then
			if #menu.actions[data.id] > 0 then
				if skipdelay then
					menu.subsection = data
				else
					if (not menu.subsection) or (menu.subsection.id ~= data.id) then
						menu.pendingSubSection = data
					else
						menu.pendingSubSection = nil
					end
				end
			else
				if skipdelay then
					menu.subsection = nil
				else
					menu.pendingSubSection = -1
				end
			end
			if skipdelay then
				menu.pendingSubSection = nil
				menu.refresh = true
			else
				menu.lastSubSectionTime = getElapsedTime()
			end
		end
	else
		if type(menu.subsection) == "table" then
			if skipdelay then
				menu.subsection = nil
				menu.pendingSubSection = nil
				menu.refresh = true
			else
				menu.pendingSubSection = -1
				menu.lastSubSectionTime = getElapsedTime()
			end
		end
	end
end

function menu.processSelectedPlayerShips()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isplayerownedtarget, istargetatdockrelation, istargetdockingenabled = false, false, false
	if convertedComponent ~= 0 then
		isplayerownedtarget, istargetatdockrelation, istargetdockingenabled = GetComponentData(convertedComponent, "isplayerowned", "isdock", "isdockingenabled")
	end
	local playercontainer = C.GetPlayerContainerID()
	local convertedPlayerContainer
	if playercontainer ~= 0 then
		convertedPlayerContainer = ConvertStringTo64Bit(tostring(playercontainer))
	end
	local occupiedPlayerShip = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))

	menu.possibleorders = {
		["Attack"] = false,
		["AttackInRange"] = false,
		["Board"] = false,
		["Collect"] = false,
		["CollectDeployables"] = false,
		["CollectDropsInRadius"] = false,
		["CollectLockbox"] = false,
		["DeployObjectAtPosition"] = false,
		["DockAndWait"] = false,
		["Explore"] = false,
		["ExploreUpdate"] = false,
		["Flee"] = false,
		["Follow"] = false,
		["MiningPlayer"] = false,
		["MoveWait"] = false,
		["Player_DockToTrade"] = false,
		["ProtectStation"] = false,
		["Repair"] = false,
		["SalvageCrush"] = false,
		["SalvageCollect"] = false,
		["SalvageDeliver"] = false,
		["SalvageDeliver_NoTrade"] = false,
		["SalvageInRadius"] = false,
		["TacticalOrder"] = false,
	}
	menu.orderdefs = {}
	menu.loopableorders = {}
	local n = C.GetNumOrderDefinitions()
	local buf = ffi.new("OrderDefinition[?]", n)
	n = C.GetOrderDefinitions(buf, n)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		menu.orderdefs[id] = { icon = ffi.string(buf[i].icon), description = ffi.string(buf[i].description) }
		menu.loopableorders[id] = C.IsOrderLoopable(id)
	end

	menu.numdockingpossible = 0
	menu.numassignableships = 0
	menu.numassignableminingships = 0
	menu.numassignableresupplyships = 0
	menu.numassignabletugs = 0
	menu.numremovableorders = 0
	menu.numremovabledefaultorders = 0
	menu.numwaitingforsignal = 0
	menu.numdockingatplayerpossible = 0
	menu.numshipswithcommander = 0
	menu.numhaveturret = 0
	menu.ventureships = {}
	menu.numorderloops = 0
	menu.dockingerrors = {}
	menu.shipswithcurrentcommander = {}

	for i = #menu.selectedplayerships, 1, -1 do
		local ship = menu.selectedplayerships[i]
		
		local isdocked, isdocking, hasturret, isonlineobject = GetComponentData(ship, "isdocked", "isdocking", "hasturret", "isonlineobject")
		if (not C.IsUnit(ship)) and (not isonlineobject) then
			local commander = ConvertIDTo64Bit(GetCommander(ship))
			-- check commander
			if commander then
				menu.numshipswithcommander = menu.numshipswithcommander + 1
				if commander == convertedComponent then
					table.insert(menu.shipswithcurrentcommander, ship)
				end
			end
			-- check turrets
			if hasturret then
				menu.numhaveturret = menu.numhaveturret + 1
			end
			-- check order removal
			local numorders = C.GetNumOrders(ship)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, ship)
			for i = numorders, 1, -1 do
				if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
					-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
				else
					if C.RemoveOrder(ship, i, false, true) then
						menu.numremovableorders = menu.numremovableorders + 1
						break
					end
					local currentdefaultorder = ffi.new("Order")
					if C.GetDefaultOrder(currentdefaultorder, ship) then
						if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
							menu.numremovabledefaultorders = menu.numremovabledefaultorders + 1
							break
						end
					end
					if commander and (commander ~= 0) and (commander ~= occupiedPlayerShip) then
						menu.numremovabledefaultorders = menu.numremovabledefaultorders + 1
						break
					end
				end
			end
		end

		if ship == menu.componentSlot.component then
			table.remove(menu.selectedplayerships, i)
		elseif C.IsUnit(ship) then
			table.remove(menu.selectedplayerships, i)
		elseif isonlineobject then
			table.insert(menu.ventureships, ship)
			table.remove(menu.selectedplayerships, i)
		else
			-- Check orders
			for orderid, value in pairs(menu.possibleorders) do
				if not value then
					if C.IsOrderSelectableFor(orderid, ship) then
						menu.possibleorders[orderid] = true
					end
				end
			end

			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(ship, hasloop)
			if hasloop[0] then
				menu.numorderloops = menu.numorderloops + 1
			end

			-- Check assignments
			if isplayerownedtarget and C.IsComponentClass(menu.componentSlot.component, "controllable") and GetComponentData(ship, "assignedpilot") then
				if commander ~= convertedComponent and C.CanAcceptSubordinate(menu.componentSlot.component, ship) then
					menu.numassignableships = menu.numassignableships + 1
					if GetComponentData(ship, "primarypurpose") == "mine" then
						menu.numassignableminingships = menu.numassignableminingships + 1
					elseif GetComponentData(ship, "shiptype") == "resupplier" then
						menu.numassignableresupplyships = menu.numassignableresupplyships + 1
					elseif GetComponentData(ship, "shiptype") == "tug" then
						menu.numassignabletugs = menu.numassignabletugs + 1
					end
				end
			end

			-- Check docking
			if (convertedComponent ~= 0) and C.IsComponentClass(menu.componentSlot.component, "container") then
				if IsDockingPossible(ship, convertedComponent) then
					menu.numdockingpossible = menu.numdockingpossible + 1
				elseif not istargetatdockrelation then
					menu.dockingerrors[1] = ReadText(1026, 7825)
				elseif not istargetdockingenabled then
					menu.dockingerrors[2] = ReadText(1026, 7843)
				else
					menu.dockingerrors[3] = ReadText(1026, 7824)
				end
			end
			if (playercontainer ~= 0) and IsDockingPossible(ship, convertedPlayerContainer) and (GetComponentData(ship, "assignedpilot") ~= nil) then
				menu.numdockingatplayerpossible = menu.numdockingatplayerpossible + 1
			end

			-- check for waiting for signal
			local numorders = C.GetNumOrders(ship)
			if numorders > 0 then
				local orderparams = GetOrderParams(ship, 1)
				local iswaitingforsignal = false
				for i, param in ipairs(orderparams) do
					if param.name == "releasesignal" and type(param.value) == "table" and param.value[1] == "playerownedship_proceed" then
						menu.numwaitingforsignal = menu.numwaitingforsignal + 1
						break
					end
				end
			end
		end
	end
	menu.hasPlayerShipPilot = false
	if (#menu.selectedplayerships == 1) and (menu.selectedplayerships[1] == occupiedPlayerShip) then
		menu.showPlayerInteractions = true
	else
		for i, ship in ipairs(menu.selectedplayerships) do
			if ship == occupiedPlayerShip then
				menu.removedOccupiedPlayerShip = occupiedPlayerShip
				table.remove(menu.selectedplayerships, i)
			end
			if GetComponentData(ship, "assignedpilot") then
				menu.hasPlayerShipPilot = true
			end
		end
	end

	if isplayerownedtarget and C.IsComponentClass(menu.componentSlot.component, "ship") then
		if (playercontainer ~= 0) and (convertedComponent ~= 0) and IsDockingPossible(convertedComponent, convertedPlayerContainer) and (GetComponentData(convertedComponent, "assignedpilot") ~= nil) then
			menu.numdockingatplayerpossible = menu.numdockingatplayerpossible + 1
		end
	end

	for i = #menu.selectedotherobjects, 1, -1 do
		local ship = menu.selectedotherobjects[i]
		if ship == menu.componentSlot.component then
			table.remove(menu.selectedotherobjects, i)
			break
		end
	end
end

function menu.prepareSections()
	menu.actions = {}
	for _, section in ipairs(config.sections) do
		if section.subsections then

			-- kuertee start: add section initializer
			menu.actions[section.id] = {}
			-- kuertee end: add section initializer

			for _, subsection in ipairs(section.subsections) do
				menu.actions[subsection.id] = {}
			end
		else
			menu.actions[section.id] = {}
		end
	end
end

function menu.insertInteractionContent(section, entry)
	if menu.actions[section] then

		if entry.orderid then
			if menu.numorderloops > 0 then
				if not menu.loopableorders[entry.orderid] then
					entry.active = false
					entry.mouseOverText = ReadText(1026, 7851)
				end
			end
			if entry.active ~= false then
				if not menu.hasPlayerShipPilot then
					entry.active = false
					entry.mouseOverText = ReadText(1026, 7830)
				end
			end

			entry.mouseOverText = menu.orderdefs[entry.orderid].description .. (((entry.mouseOverText ~= nil) and (entry.mouseOverText ~= "")) and ("\n\n" .. entry.mouseOverText) or "")
		end

		table.insert(menu.actions[section], entry)
	else
		DebugError("The requested context section is not defined: '" .. section .. "' [Florian]")
	end
end

config.consumables = {
	{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites },
	{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons },
	{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes },
	{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers },
	{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines },
}

function menu.addConsumableEntry(basesection, consumabledata, object, callback)
	local numconsumable = consumabledata.getnum(object)
	if numconsumable > 0 then
		local consumables = ffi.new("AmmoData[?]", numconsumable)
		numconsumable = consumabledata.getdata(consumables, numconsumable, object)
		for j = 0, numconsumable - 1 do
			if consumables[j].amount > 0 then
				local macro = ffi.string(consumables[j].macro)
				menu.insertInteractionContent(basesection .. "_" .. consumabledata.type, { type = consumabledata.type, text = GetMacroData(macro, "name"), text2 = "(" .. consumables[j].amount .. ")", script = function () return callback(consumabledata.id, macro, 1) end })
			end
		end
	end
end

function menu.insertAssignSubActions(section, assignment, callback, groups, isstation, unique, currentgroup, mouseovertextadd)
	local groupexists = false
	if unique then
		for i = 1, isstation and 5 or 10 do
			if groups[i] and (groups[i].assignment == assignment) then
				-- found a matching group
				groupexists = true
				break
			end
		end
	end
	for i = 1, isstation and 5 or 10 do
		if groups[i] then
			local active = (groups[i].assignment == assignment) or ((i == menu.subordinategroup) and ((not unique) or (not groupexists)))
			local mouseovertext = ""
			if active then
				for i, subordinateentry in ipairs(groups[i].subordinates) do
					mouseovertext = mouseovertext .. ((i > 1) and "\n" or "") .. Helper.convertColorToText(menu.holomapcolor.playercolor) .. subordinateentry.name .. " (" .. subordinateentry.objectid .. ")"
				end
				if mouseovertextadd and (mouseovertextadd ~= "") then
					mouseovertext = mouseovertextadd .. ((mouseovertext ~= "") and "\n\n" or "") .. mouseovertext
				end
			else
				mouseovertext = ReadText(1026, 7839) .. "\n" .. (config.assignments[groups[i].assignment] and config.assignments[groups[i].assignment].name or "")
			end

			local currenttext = ""
			if i == currentgroup then
				currenttext = " [" .. ReadText(1001, 7899) .. "]"
			end

			menu.insertInteractionContent(section, { type = "assign", text = ReadText(20401, i) .. currenttext, text2 = ((#groups[i].subordinates > 0) and Helper.convertColorToText(menu.holomapcolor.playercolor) or "") .. ((#groups[i].subordinates > 1) and string.format(ReadText(1001, 7898), #groups[i].subordinates) or (#groups[i].subordinates == 1) and ReadText(1001, 7897) or ReadText(1001, 7896)), script = function () callback(assignment, i) end, active = active, mouseOverText = mouseovertext })
		else
			local active = ((not unique) or (not groupexists)) and (assignment ~= "positiondefence")
			local mouseovertext = ""
			if not active then
				if assignment == "positiondefence" then
					mouseovertext = ReadText(1026, 7863)
				else
					mouseovertext = ReadText(1026, 7840)
				end
			end
			if active then
				if mouseovertextadd and (mouseovertextadd ~= "") then
					mouseovertext = mouseovertextadd .. ((mouseovertext ~= "") and "\n\n" or "") .. mouseovertext
				end
			end
			menu.insertInteractionContent(section, { type = "assign", text = ReadText(20401, i), text2 = ReadText(1001, 7896), script = function () callback(assignment, i) end, active = active, mouseOverText = mouseovertext })
		end
	end
end

function menu.insertLuaAction(actiontype, istobedisplayed)
	local convertedComponent = menu.data.convertedComponent
	local isplayerownedtarget = menu.data.isplayerownedtarget
	local istargetinplayersquad = menu.data.istargetinplayersquad
	local istargetplayeroccupiedship = menu.data.istargetplayeroccupiedship
	local hastargetpilot = menu.data.hastargetpilot
	
	if actiontype == "armturrets" then
		if istobedisplayed and (menu.numhaveturret > 0) then
			local allarmed = true
			local hasturret = GetComponentData(convertedComponent, "hasturret")
			if hasturret then
				allarmed = menu.areTurretsArmed(menu.componentSlot.component)
			end
			if allarmed then
				for _, ship in ipairs(menu.selectedplayerships) do
					local hasturret = GetComponentData(ship, "hasturret")
					if hasturret and (not menu.areTurretsArmed(ship)) then
						allarmed = false
						break
					end
				end
			end

			menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "interaction", { type = actiontype, text = allarmed and ReadText(1001, 11102) or ReadText(1001, 11101), script = function () return menu.buttonArmTurrets(not allarmed) end })
		end
	elseif actiontype == "assign" then
		if (menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown))) and C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local isplayerowned = GetComponentData(convertedComponent, "isplayerowned")
			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			if isplayerowned and (not commander) or (commander == 0) then
				local occupiedplayership = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
				if occupiedplayership and (occupiedplayership ~= 0) and (occupiedplayership ~= menu.componentSlot.component) and C.CanAcceptSubordinate(occupiedplayership, menu.componentSlot.component) then
					local subordinates = GetSubordinates(occupiedplayership)
					local groups = menu.getSubordinatesInGroups(occupiedplayership, false)

					-- defence
					menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonAssignCommander, groups, false, false)
					-- position defence
					local commandershiptype = GetComponentData(occupiedplayership, "shiptype")
					local parentcommander = ConvertIDTo64Bit(GetCommander(occupiedplayership))
					local isfleetcommander = (not parentcommander) and (#subordinates > 0)
					if (commandershiptype == "carrier") and isfleetcommander then
						menu.insertAssignSubActions("main_assignments_positiondefence", "positiondefence", menu.buttonAssignCommander, groups, false, false)
					end
					-- supplyfleet
					if GetComponentData(convertedComponent, "shiptype") == "resupplier" then
						menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonAssignCommander, groups, false, true)
					end
					menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonAssignCommander, groups, false)
					menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonAssignCommander, groups, false)
					menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonAssignCommander, groups, false)
					menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonAssignCommander, groups, false, true)
					local buf = ffi.new("Order")
					if C.GetDefaultOrder(buf, occupiedplayership) then
						menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonAssignCommander, groups, false, true)
					end
				end
			end
		elseif menu.numassignableships > 0 then
			local subordinates = GetSubordinates(convertedComponent)

			local isstation = C.IsComponentClass(menu.componentSlot.component, "station")
			local isship = C.IsComponentClass(menu.componentSlot.component, "ship")
			local groups = menu.getSubordinatesInGroups(menu.componentSlot.component, isstation)
			-- defence
			menu.insertAssignSubActions("selected_assignments_defence", "defence", menu.buttonAssignCommander, groups, isstation, isstation)
			-- supplyfleet
			if menu.numassignableresupplyships > 0 then
				menu.insertAssignSubActions("selected_assignments_supplyfleet", "supplyfleet", menu.buttonAssignCommander, groups, isstation, true)
			end
			if isstation then
				-- trading
				menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignCommander, groups, isstation, true, nil, (menu.numassignableminingships > 0) and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8609)) or "")
				-- mining
				if menu.numassignableminingships > 0 then
					menu.insertAssignSubActions("selected_assignments_mining", "mining", menu.buttonAssignCommander, groups, isstation, true)
				end
				-- trading for buildstorage
				local numnonminingships = menu.numassignableships - menu.numassignableminingships
				if numnonminingships > 0 then
					menu.insertAssignSubActions("selected_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonAssignCommander, groups, isstation, true)
				end
				if menu.numassignabletugs > 0 then
					menu.insertAssignSubActions("selected_assignments_salvage", "salvage", menu.buttonAssignCommander, groups, isstation, true)
				end
			elseif isship then
				-- position defence
				local shiptype = GetComponentData(convertedComponent, "shiptype")
				local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
				local isfleetcommander = (not commander) and (#subordinates > 0)
				if (shiptype == "carrier") and isfleetcommander then
					menu.insertAssignSubActions("selected_assignments_positiondefence", "positiondefence", menu.buttonAssignCommander, groups, isstation)
				end
				menu.insertAssignSubActions("selected_assignments_attack", "attack", menu.buttonAssignCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_interception", "interception", menu.buttonAssignCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_bombardment", "bombardment", menu.buttonAssignCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_follow", "follow", menu.buttonAssignCommander, groups, isstation, true)
				local buf = ffi.new("Order")
				if C.GetDefaultOrder(buf, menu.componentSlot.component) then
					menu.insertAssignSubActions("selected_assignments_assist", "assist", menu.buttonAssignCommander, groups, isstation, true)
				end
				if shiptype == "resupplier" then
					menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignCommander, groups, isstation, true)
				end
			end
		end
	elseif actiontype == "attack" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Attack"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Attack") .. ReadText(1001, 7815), helpOverlayID = "interactmenu_attack", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonAttack(false) end, orderid = "Attack" })
		end
	elseif actiontype == "attackinrange" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["AttackInRange"] then
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("AttackInRange") .. ReadText(1041, 631), helpOverlayID = "interactmenu_attackinrange", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonAttackInRange(false) end, hidetarget = true, orderid = "AttackInRange" } )
			end
		end
	elseif actiontype == "attackmultiple" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Attack"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Attack") .. ReadText(1001, 7816), helpOverlayID = "interactmenu_attackmultiple", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonAttackMultiple(false) end, hidetarget = true, orderid = "Attack" })
		end
	elseif actiontype == "attackplayertarget" then
		if (istargetinplayersquad or istargetplayeroccupiedship) and GetPlayerTarget() then
			--print("player target: " .. tostring(GetPlayerTarget()))
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7869), helpOverlayID = "interactmenu_attackplayertarget", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonPlayerSquadAttackPlayerTarget(false) end, hidetarget = true })	-- Fleet: Attack my target
		end
	elseif actiontype == "disable" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Attack"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "defensible") and (C.IsComponentClass(menu.componentSlot.component, "ship_l") or C.IsComponentClass(menu.componentSlot.component, "ship_xl") or C.IsComponentClass(menu.componentSlot.component, "station")) then
			menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11129), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "all", false) end, active = true, orderid = "Attack" })
			menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11132), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "turret", false) end, active = true, orderid = "Attack" })
			menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11131), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "shieldgenerator", false) end, active = true, orderid = "Attack" })
			if C.IsComponentClass(menu.componentSlot.component, "ship") then
				menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11130), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "engine", false) end, active = true, orderid = "Attack" })
			end
		end
	elseif actiontype == "board" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Board"] and (not isplayerownedtarget) and (C.IsComponentClass(menu.componentSlot.component, "ship_l") or C.IsComponentClass(menu.componentSlot.component, "ship_xl")) and (GetComponentData(convertedComponent, "owner") ~= "ownerless") then
			menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "selected_orders", { type = actiontype, text = menu.orderIconText("Board") .. ReadText(1001, 7842), helpOverlayID = "interactmenu_board", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function() return menu.buttonBoard() end, orderid = (not menu.showPlayerInteractions) and "Board" or nil })
		end
	elseif actiontype == "build" then
		if (#menu.selectedplayerships == 1) and isplayerownedtarget and (GetComponentData(menu.selectedplayerships[1], "primarypurpose") == "build") and (menu.numorderloops == 0) then
			local buildstorage
			if C.IsRealComponentClass(menu.componentSlot.component, "station") then
				buildstorage = ConvertIDTo64Bit(GetComponentData(convertedComponent, "buildstorage")) or 0
			else
				buildstorage = convertedComponent
			end
			local constructionvessels = {}
			Helper.ffiVLA(constructionvessels, "UniverseID", C.GetNumAssignedConstructionVessels, C.GetAssignedConstructionVessels, buildstorage)
			local mouseovertext
			if #constructionvessels > 0 then
				mouseovertext = ReadText(1026, 7821)
			elseif C.IsBuilderBusy(menu.selectedplayerships[1]) then
				mouseovertext = ReadText(1026, 7820)
			elseif not menu.hasPlayerShipPilot then
				mouseovertext = ReadText(1026, 7830)
			end
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = ReadText(1001, 7833), helpOverlayID = "interactmenu_build", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDeployToStation(menu.selectedplayerships[1], true) end, active = (#constructionvessels == 0) and (not C.IsBuilderBusy(menu.selectedplayerships[1])) and menu.hasPlayerShipPilot, mouseOverText = mouseovertext })
		end
	elseif actiontype == "buildships" then
		local canbuildships, shiptrader, isdock = GetComponentData(convertedComponent, "canbuildships", "shiptrader", "isdock")
		if canbuildships then
			-- don't show option for npcs if they are missing the shiptrader, but do for player objects
			if shiptrader or isplayerownedtarget then
				local active = true
				local mouseovertext = ""
				if not isdock then
					active = false
					mouseovertext = ReadText(1026, 8014)
				elseif shiptrader == nil then
					active = false
					mouseovertext = ReadText(1026, 7827)
				end
				menu.insertInteractionContent("main", { type = actiontype, text = isplayerownedtarget and ReadText(1001, 7875) or ReadText(1001, 7838), helpOverlayID = "interactmenu_buildship", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonShipConfig("purchase") end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "changeformation" then
		if istobedisplayed and IsComponentOperational(convertedComponent) then
			local subordinates = GetSubordinates(convertedComponent)
			if #subordinates > 0 then
				local n = C.GetNumFormationShapes()
				local buf = ffi.new("UIFormationInfo[?]", n)
				n = C.GetFormationShapes(buf, n)
				local formationshapes = {}
				for i = 0, n - 1 do
					table.insert(formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape), requiredSkill = buf[i].requiredSkill * 3 })
				end
				table.sort(formationshapes, Helper.sortName)
				local pilot = ConvertIDTo64Bit(GetComponentData(convertedComponent, "assignedpilot"))
				local isplayer = pilot == C.GetPlayerID()
				local adjustedskill = (pilot and (pilot ~= 0)) and math.floor(C.GetEntityCombinedSkill(pilot, nil, isplayer and "playerpilot" or "aipilot") * 15 / 100) or 0
				for _, data in ipairs(formationshapes) do
					menu.insertInteractionContent("formationshape", { type = actiontype, text = data.name, text2 = ((data.requiredSkill <= adjustedskill) and Helper.convertColorToText(Helper.color.brightyellow) or Helper.convertColorToText(Helper.color.grey)) .. Helper.displaySkill(data.requiredSkill), helpOverlayID = "interactmenu_changeformation", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFormationShape(data.shape, subordinates) end, active = data.requiredSkill <= adjustedskill })
				end
			end
		end
	elseif (actiontype == "claim") then
		if istobedisplayed and (#menu.selectedplayerships == 1) and C.IsComponentClass(menu.componentSlot.component, "ship") then
			local canbeclaimed, isdefendingfromboardingoperation = GetComponentData(convertedComponent, "canbeclaimed", "isdefendingfromboardingoperation")
			if canbeclaimed and (not isdefendingfromboardingoperation) then
				local isdocked, hasavailablemarines, maxradarrange = GetComponentData(menu.selectedplayerships[1], "isdocked", "hasavailablemarines", "maxradarrange")
				local active, mouseovertext = true, ""
				if not hasavailablemarines then
					active = false
					mouseovertext = ReadText(1026, 7822)
				elseif C.GetDistanceBetween(menu.componentSlot.component, menu.selectedplayerships[1]) > maxradarrange then
					active = false
					mouseovertext = ReadText(1026, 7802)
				elseif isdocked then
					active = false
					mouseovertext = ReadText(1026, 7817)
				end
				menu.insertInteractionContent((not menu.showPlayerInteractions) and "selected_orders" or "interaction", { type = actiontype, text = ReadText(1010, 5), helpOverlayID = "interactmenu_claim", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonClaim(menu.selectedplayerships[1]) end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "configurestation" then
		if istobedisplayed then
			menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 7809), helpOverlayID = "interactmenu_configurestation", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStationConfig })
		end
	elseif actiontype == "collect" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["Collect"] and menu.componentSlot.component and C.IsComponentClass(menu.componentSlot.component, "drop") then
			local active, mouseovertext = menu.canCollectCrates(menu.hasPlayerShipPilot)
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Collect") .. ReadText(1001, 7867), helpOverlayID = "interactmenu_collect", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollect(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "Collect" } )
		end
	elseif actiontype == "collectdeployable" then
		if (#menu.selectedplayerships > 0) and isplayerownedtarget and menu.possibleorders["CollectDeployables"] and menu.componentSlot.component and GetComponentData(convertedComponent, "isdeployable") then
			local active, mouseovertext = menu.canCollectCrates(menu.hasPlayerShipPilot)
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("CollectDeployables") .. ReadText(1001, 11103), helpOverlayID = "interactmenu_collect_deployable", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectDeployable(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "CollectDeployables" } )
		end
	elseif actiontype == "collectdeployables" then
		if istobedisplayed and isplayerownedtarget and (not istargetplayeroccupiedship) and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) then
			if menu.mode ~= "shipconsole" then
				local active, mouseovertext = menu.canCollectCrates(hastargetpilot)
				if menu.data.hastargetorderloop and (not menu.loopableorders["CollectDeployables"]) then
					active = false
					mouseovertext = ReadText(1026, 7851)
				end
				mouseovertext = ReadText(1041, 692) .. (((mouseOverText ~= nil) and (mouseOverText ~= "")) and ("\n\n" .. mouseOverText) or "")
				menu.insertInteractionContent("main_orders", { type = actiontype, text = menu.orderIconText("CollectDeployables") .. ReadText(1001, 7885), helpOverlayID = "interactmenu_collectdeployables", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectDeployables(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext } )
			end
		end
	elseif actiontype == "collectlockbox" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["CollectLockbox"] and menu.componentSlot.component and C.IsComponentClass(menu.componentSlot.component, "lockbox") then
			-- these variables are used to determine if the button should be active and must be initialized to false because the button activates if nil.
			local isnotcapship = false
			local hasactiveguns = false
			local hasinactiveguns = false
			for _, ship in ipairs(menu.selectedplayerships) do
				-- we need to make sure that at least one ship in the selection has all of the requirements. selection will be further filtered down when the orders on the individual ships start.
				isnotcapship = not C.IsComponentClass(ship, "ship_l") and not C.IsComponentClass(ship, "ship_xl")

				--uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
				local activedpstable = ffi.new("DPSData[?]", 6)
				local numtotalquadrants = C.GetDefensibleDPS(activedpstable, ship, true, true, true, false, false, false, false)
				hasactiveguns = activedpstable[0].dps > 0

				local inactivedpstable = ffi.new("DPSData[?]", 6)
				local numtotalquadrants = C.GetDefensibleDPS(inactivedpstable, ship, true, true, true, false, false, false, true)
				hasinactiveguns = inactivedpstable[0].dps > 0

				if isnotcapship and hasactiveguns then
					break
				end
			end

			local active = isnotcapship and hasactiveguns and menu.hasPlayerShipPilot
			local mouseovertext
			if not isnotcapship then
				mouseovertext = ReadText(1026, 20039)
			elseif not menu.hasPlayerShipPilot then
				mouseovertext = ReadText(1026, 7801)
			elseif not hasactiveguns then
				if hasinactiveguns then
					mouseovertext = ReadText(1026, 7847)
				else
					mouseovertext = ReadText(1026, 20040)
				end
			end

			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("CollectLockbox") .. ReadText(1041, 661), helpOverlayID = "interactmenu_collectlockbox", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectLockbox(false) end, active = active, hidetarget = true, mouseOverText = mouseovertext, orderid = "CollectLockbox" } )
		end
	elseif actiontype == "collectspace" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["CollectDropsInRadius"] then
				local active, mouseovertext = menu.canCollectCrates(menu.hasPlayerShipPilot)
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("CollectDropsInRadius") .. ReadText(1001, 7866), helpOverlayID = "interactmenu_collectspace", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectRadius(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "CollectDropsInRadius" } )
			end
		end
	elseif actiontype == "salvagespace" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["SalvageInRadius"] then
				local active, mouseovertext = menu.canSalvage(menu.hasPlayerShipPilot)
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageInRadius") .. ReadText(1041, 871), helpOverlayID = "interactmenu_salvagespace", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageInRadius(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "SalvageInRadius" } )
			end
		end
	elseif actiontype == "crewtransfer" then
		if (#menu.selectedplayerships == 1) and GetComponentData(convertedComponent, "isdock") and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (not C.IsComponentClass(convertedComponent, "ship_xs")) and (C.GetPeopleCapacity(convertedComponent, "", true) > 0) then
			if not GetComponentData(menu.selectedplayerships[1], "isdeployable") then
				if C.IsComponentClass(menu.componentSlot.component, "container") then
					if C.IsComponentClass(menu.componentSlot.component, "station") or isplayerownedtarget then
						local active = true
						local mouseovertext = ""
						if C.IsComponentClass(menu.componentSlot.component, "station") then
							if isplayerownedtarget then
								local tradenpc, shiptrader, isshipyard, iswharf, isequipmentdock = GetComponentData(convertedComponent, "tradenpc", "shiptrader", "isshipyard", "iswharf", "isequipmentdock")
								local canhavetrainees = C.CanControllableHaveAnyTrainees(menu.componentSlot.component)
								if (tradenpc ~= nil) and ((not (isshipyard or iswharf or isequipmentdock)) or (shiptrader ~= nil)) and (not canhavetrainees) then
									active = false
									mouseovertext = ReadText(1026, 3249)
								end
							else
								local nummissionnpcrequests = C.GetNumRequestedMissionNPCs(menu.componentSlot.component)
								active = nummissionnpcrequests > 0
								mouseovertext = active and "" or ReadText(1026, 3248)
							end
						end
						menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "selected_orders", { type = actiontype, text = menu.orderIconText("CrewExchange") .. ReadText(1001, 7880), helpOverlayID = "interactmenu_crewtransfer", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCrewTransfer(menu.selectedplayerships[1]) end, active = active, mouseOverText = mouseovertext })
					end
				end
			end
		end
	elseif actiontype == "deliverwares" then
		if istobedisplayed and IsComponentOperational(convertedComponent) then
			local nummissionwarerequests = C.GetNumRequestedMissionWares(menu.componentSlot.component)
			local requestbuf = ffi.new("MissionWareDeliveryCounts[?]", nummissionwarerequests)
			nummissionwarerequests = C.GetRequestedMissionWares(requestbuf, nummissionwarerequests, menu.componentSlot.component)
			if nummissionwarerequests == 1 then
				local request = requestbuf[0]

				local buf = ffi.new("MissionWareDeliveryInfo[1]")
				buf[0].numwares = request.numwares
				buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", request.numwares)
				C.GetMissionDeliveryWares(buf, request.missionid)

				local wares = {}
				for i = 0, buf[0].numwares - 1 do
					table.insert(wares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
				end

				local missiondetails = C.GetMissionIDDetails(request.missionid)

				local active = true
				local mouseovertext = ffi.string(missiondetails.missionName)
				local cargo = GetComponentData(convertedComponent, "cargo") or {}
				for _, entry in ipairs(wares) do
					if (cargo[entry.ware] or 0) == 0 then
						active = false
						mouseovertext = mouseovertext .. "\n\27R" .. ReadText(1026, 3406)
						break
					end
				end
				local missionid = request.missionid
				menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = ReadText(1001, 3423), helpOverlayID = "interactmenu_deliverwares", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDeliverWares(missionid) end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "deployhere" then
		if istobedisplayed and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (not menu.data.hastargetorderloop) then
			if menu.mode ~= "shipconsole" then
				-- force sub section and assume we have no deployables
				menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7818)
				menu.forceSubSection["consumables_military"] = ReadText(1026, 7819)
				-- check if we have deploables
				for _, entry in ipairs(config.consumables) do
					local numconsumable = entry.getnum(menu.componentSlot.component)
					if numconsumable > 0 then
						local consumables = ffi.new("AmmoData[?]", numconsumable)
						numconsumable = entry.getdata(consumables, numconsumable, menu.componentSlot.component)
						for j = 0, numconsumable - 1 do
							if consumables[j].amount > 0 then
								-- clear force if we do have deployables, enabling the isdocked check to set it's own force reason
								menu.forceSubSection["consumables_" .. entry.type] = nil
								break
							end
						end
					end
				end

				local isdocked = GetComponentData(convertedComponent, "isdocked")
				local isinhighway = C.GetContextByClass(menu.componentSlot.component, "highway", false) ~= 0
				if (not isdocked) and (not isinhighway) and (hastargetpilot or istargetplayeroccupiedship) then
					for _, entry in ipairs(config.consumables) do
						menu.addConsumableEntry("consumables", entry, menu.componentSlot.component, menu.buttonDeploy)
					end
				else
					-- only force if not previously forced (i.e. no deployables is a more important reason than being docked)
					if not menu.forceSubSection["consumables_civilian"] then
						if (not hastargetpilot) and (not istargetplayeroccupiedship) then
							menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7801)
						elseif isinhighway then
							menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7845)
						else
							menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7817)
						end
					end
					if not menu.forceSubSection["consumables_military"] then
						if (not hastargetpilot) and (not istargetplayeroccupiedship) then
							menu.forceSubSection["consumables_military"] = ReadText(1026, 7801)
						elseif isinhighway then
							menu.forceSubSection["consumables_military"] = ReadText(1026, 7845)
						else
							menu.forceSubSection["consumables_military"] = ReadText(1026, 7817)
						end
					end
				end
			end
		end
	elseif actiontype == "deployat" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if (#menu.selectedplayerships == 1) and menu.possibleorders["DeployObjectAtPosition"] and (menu.numorderloops == 0) then
				-- force sub section and assume we have no deployables
				menu.forceSubSection["selected_consumables_civilian"] = ReadText(1026, 7818)
				menu.forceSubSection["selected_consumables_military"] = ReadText(1026, 7819)
				-- check if we have deploables
				for _, entry in ipairs(config.consumables) do
					local numconsumable = entry.getnum(menu.selectedplayerships[1])
					if numconsumable > 0 then
						local consumables = ffi.new("AmmoData[?]", numconsumable)
						numconsumable = entry.getdata(consumables, numconsumable, menu.selectedplayerships[1])
						for j = 0, numconsumable - 1 do
							if consumables[j].amount > 0 then
								-- clear force if we do have deployables, enabling the isdocked check to set it's own force reason
								menu.forceSubSection["selected_consumables_" .. entry.type] = nil
								break
							end
						end
					end
				end
				if menu.hasPlayerShipPilot then
					for _, entry in ipairs(config.consumables) do
						menu.addConsumableEntry("selected_consumables", entry, menu.selectedplayerships[1], menu.buttonDeployAtPosition)
					end
				else
					-- only force if not previously forced (i.e. no deployables is a more important reason than no pilot)
					if not menu.forceSubSection["selected_consumables_civilian"] then
						menu.forceSubSection["selected_consumables_civilian"] = ReadText(1026, 7830)
					end
					if not menu.forceSubSection["selected_consumables_military"] then
						menu.forceSubSection["selected_consumables_military"] = ReadText(1026, 7830)
					end
				end
			end
		end
	elseif actiontype == "depositinventory" then
		if istobedisplayed and isplayerownedtarget and (not istargetplayeroccupiedship) and (not C.IsUnit(convertedComponent)) and (not GetComponentData(convertedComponent, "isdeployable")) then
			local stationhqlist = {}
			Helper.ffiVLA(stationhqlist, "UniverseID", C.GetNumHQs, C.GetHQs, "player")
			-- show the button once the player gets the HQ since that's a bigger state change.
			if #stationhqlist > 0 then
				local inventory = {}
				local pilot = ConvertIDTo64Bit(GetComponentData(convertedComponent, "pilot"))
				if pilot and (pilot ~= 0) then
					-- NB: button requires that convertedComponent have a pilot, that that pilot have stuff in his or her pockets, and that the player has an HQ. Otherwise, show the button but keep it inactive.
					inventory = GetInventory(pilot)
				end

				menu.insertInteractionContent("main_orders", { type = actiontype, text = menu.orderIconText("DepositInventory") .. ReadText(1041, 651), helpOverlayID = "interactmenu_depositinventory", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDepositInventoryAtHQ() end, active = (next(inventory) ~= nil) and hastargetpilot, mouseOverText = (not hastargetpilot) and ReadText(1026, 7801) or ReadText(1026, 7829) })
			end
		end
	elseif actiontype == "dockat" then
		if menu.possibleorders["DockAndWait"] then
			local isalreadydocked = true
			for _, ship in ipairs(menu.selectedplayerships) do
				local parentcontainer = C.GetContextByClass(ship, "container", false)
				if parentcontainer ~= 0 then
					if parentcontainer == menu.componentSlot.component then
						-- check if the ship is at a venture dock
						local parentdockingbay = C.GetContextByClass(ship, "dockarea", false)
						local ventureplatforms = {}
						Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, menu.componentSlot.component)
						for _, platform in ipairs(ventureplatforms) do
							local docks = {}
							Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
							for _, dock in ipairs(docks) do
								if dock == parentdockingbay then
									isalreadydocked = false
									break
								end
							end
							if not isalreadydocked then
								break
							end
						end
						if isalreadydocked then
							-- if there is another order on the queue allow adding the new dock order
							local numorders = C.GetNumOrders(ship)
							if numorders > 0 then
								local currentorders = ffi.new("Order[?]", numorders)
								numorders = C.GetOrders(currentorders, numorders, ship)
								for i = 0, numorders - 1 do
									local orderdef = ffi.string(currentorders[i].orderdef)
									local params = GetOrderParams(ConvertStringTo64Bit(tostring(ship)), i + 1)
									if ((orderdef ~= "DockAndWait") and (orderdef ~= "DockAt")) or (ConvertIDTo64Bit(params[1].value) ~= convertedComponent) then
										isalreadydocked = false
										break
									end
								end
							end
						end
					else
						isalreadydocked = false
						break
					end
				else
					isalreadydocked = false
					break
				end
			end
			local active = (not isalreadydocked) and (menu.numdockingpossible > 0)
			local mouseovertext = ""
			if menu.numdockingpossible == 0 then
				local orderedKeys = Helper.orderedKeys(menu.dockingerrors)
				if orderedKeys[1] then
					mouseovertext = menu.dockingerrors[orderedKeys[1]]
				end
			elseif isalreadydocked then
				mouseovertext = ReadText(1026, 7846)
			end

			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("DockAndWait") .. ReadText(1041, 451), helpOverlayID = "interactmenu_dockat", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDock(false) end, active = active, mouseOverText = mouseovertext, orderid = "DockAndWait" })
		end
	elseif actiontype == "dockatplayer" then
		if istobedisplayed and (not istargetplayeroccupiedship) and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (menu.numorderloops == 0) and (not menu.data.hastargetorderloop) then
			if menu.mode ~= "shipconsole" then
				local playercontainer = C.GetPlayerContainerID()
				if playercontainer ~= 0 then
					local convertedPlayerContainer = ConvertStringTo64Bit(tostring(playercontainer))
					if isplayerownedtarget then
						local allinstorage = true
						local allexternallydocked = true
						if C.GetContextByClass(menu.componentSlot.component, "container", false) ~= playercontainer then
							allexternallydocked = false
							allinstorage = false
						elseif (not C.IsShipAtExternalDock(menu.componentSlot.component)) and (not C.IsShipBeingRetrieved(menu.componentSlot.component)) then
							allexternallydocked = false
						end
						if allinstorage or allexternallydocked then
							for _, ship in ipairs(menu.selectedplayerships) do
								if C.GetContextByClass(ship, "container", false) ~= playercontainer then
									allexternallydocked = false
									allinstorage = false
									break
								elseif (not C.IsShipAtExternalDock(ship)) and (not C.IsShipBeingRetrieved(ship)) then
									allexternallydocked = false
								end
							end
						end

						local active = true
						local mouseovertext = ReadText(1026, 20043)
						local isdock, hasshipdockingbays = GetComponentData(convertedPlayerContainer, "isdock", "hasshipdockingbays")
						if allexternallydocked then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7838)
						elseif not hasshipdockingbays then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7837)
						elseif not hastargetpilot then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7801)
						elseif menu.numdockingatplayerpossible == 0 then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7836)
						elseif not isdock then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7825)
						end

						menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = menu.orderIconText("DockAndWait") .. (allinstorage and ReadText(1001, 7890) or ReadText(1001, 7837)), helpOverlayID = "interactmenu_dockatplayer", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDockAtPlayer(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext })
					end
				end
			end
		end
	elseif actiontype == "dockrequest" then
		local isshiporstation = C.IsComponentClass(menu.componentSlot.component, "ship") or C.IsComponentClass(menu.componentSlot.component, "station")
		local isdockingbay = C.IsComponentClass(menu.componentSlot.component, "dockingbay")
		if menu.showPlayerInteractions and (isshiporstation or isdockingbay) and (not GetComponentData(convertedComponent, "isdeployable")) and (isdockingbay or (not C.IsUnit(convertedComponent))) then
			local dockcontainer = convertedComponent
			if isdockingbay then
				dockcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(dockcontainer, "container", false)))
			end
			local mouseovertext = ffi.string(C.GetMappedInputName("INPUT_ACTION_DOCK_ACTION"))
			if IsDockingPossible(ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())), dockcontainer) then
				local dockrequestreason = ffi.string(C.RequestDockAtReason(dockcontainer, true))
				-- "granted" -> OK
				-- "queued" -> OK
				-- "impossible" -> Should be handled by IsDockingPossible() or the container is wrong or the player does not exist or the playercontrolled object does not exist
				if dockrequestreason == "denied" then -- DOCKINGREQUEST_DENIED
					local isdockingenabled = GetComponentData(dockcontainer, "isdockingenabled")
					if isdockingenabled then
						mouseovertext = ReadText(1026, 7825)
					else
						mouseovertext = ReadText(1026, 7843)
					end
				elseif dockrequestreason == "toofar" then -- DOCKINGREQUEST_TOOFAR
					mouseovertext = ReadText(1026, 7809)
				elseif dockrequestreason == "alreadydocked" then
					mouseovertext = ReadText(1026, 7857)
				end
			else
				mouseovertext = ReadText(1026, 7824)
			end
			menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = (menu.showPlayerInteractions and (not menu.shown)) and ReadText(1001, 7845) or ReadText(1001, 7888), helpOverlayID = "interactmenu_dockrequest", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonDockRequest, active = C.RequestDockAt(dockcontainer, true), mouseOverText = mouseovertext })
		end
	elseif actiontype == "dropinventory" then
		if istobedisplayed then
			local pilot = ConvertIDTo64Bit(GetComponentData(convertedComponent, "pilot"))
			if pilot and (pilot ~= 0) then
				local inventory = GetInventory(pilot)
				if next(inventory) then
					local onlineitems = OnlineGetUserItems()

					local sortedWares = {}
					for ware, entry in pairs(inventory) do
						local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
						if (not ispersonalupgrade) and (not onlineitems[ware]) then
							table.insert(sortedWares, { ware = ware, name = entry.name, amount = entry.amount })
						end
					end
					if #sortedWares > 0 then
						menu.insertInteractionContent("main_orders", { type = actiontype, text = ReadText(1001, 7878), helpOverlayID = "interactmenu_dropinventory", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDropInventory(pilot) end })
					end
				end
			end
		end
	elseif actiontype == "encyclopedia" then
		menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 2416), helpOverlayID = "interactmenu_encyclopedia", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonEncyclopedia })
	elseif actiontype == "explore" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["Explore"] and menu.componentSlot.component and (C.IsComponentClass(menu.componentSlot.component, "sector") or C.IsComponentClass(menu.componentSlot.component, "highwayentrygate") or C.IsComponentClass(menu.componentSlot.component, "highway") or (C.IsComponentClass(menu.componentSlot.component, "gate") and GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Explore") .. ReadText(1001, 7828), helpOverlayID = "interactmenu_explore", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonExplore(false) end, orderid = "Explore" })
		end
	elseif actiontype == "exploreupdate" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["ExploreUpdate"] and menu.componentSlot.component and (C.IsComponentClass(menu.componentSlot.component, "sector") or C.IsComponentClass(menu.componentSlot.component, "highwayentrygate") or C.IsComponentClass(menu.componentSlot.component, "highway") or (C.IsComponentClass(menu.componentSlot.component, "gate") and GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("ExploreUpdate") .. ReadText(1001, 7829), helpOverlayID = "interactmenu_exploreupdate", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonExploreUpdate(false) end, orderid = "ExploreUpdate" })
		end
	elseif actiontype == "flee" then
		if istobedisplayed and (not istargetplayeroccupiedship) and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			local firstorder
			local n = C.GetNumOrders(menu.componentSlot.component)
			local buf = ffi.new("Order2[?]", n)
			n = C.GetOrders2(buf, n, menu.componentSlot.component)
			if n > 0 then
				firstorder = {}
				firstorder.state = ffi.string(buf[0].state)
				firstorder.statename = ffi.string(buf[0].statename)
				firstorder.orderdef = ffi.string(buf[0].orderdef)
				firstorder.actualparams = tonumber(buf[0].actualparams)
				firstorder.enabled = buf[0].enabled
				firstorder.isinfinite = buf[0].isinfinite
				firstorder.issyncpointreached = buf[0].issyncpointreached
				firstorder.istemporder = buf[0].istemporder
				firstorder.isoverride = buf[0].isoverride

				local orderdefinition = ffi.new("OrderDefinition")
				if firstorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, firstorder.orderdef) then
					firstorder.orderdef = {}
					firstorder.orderdef.id = ffi.string(orderdefinition.id)
					firstorder.orderdef.icon = ffi.string(orderdefinition.icon)
					firstorder.orderdef.name = ffi.string(orderdefinition.name)
				else
					firstorder.orderdef = { id = "", icon = "", name = "" }
				end
			end
			
			if (menu.showPlayerInteractions or (#menu.selectedplayerships == 0)) and firstorder and firstorder.isoverride then
				firstorder.params = GetOrderParams(convertedComponent, 1)

				menu.texts.overrideordername = firstorder.orderdef.name
				local attacker
				if firstorder.orderdef.id == "Flee" then
					if firstorder.params[6] and firstorder.params[6].value then
						local value = ConvertIDTo64Bit(firstorder.params[6].value)
						if value ~= 0 then
							attacker = value
						end
					end
				elseif firstorder.orderdef.id == "Attack" then
					if firstorder.params[1] and firstorder.params[1].value and (firstorder.params[1].type == "object") and (firstorder.params[1].value ~= 0) then
						attacker = firstorder.params[1].value
					end
				elseif firstorder.orderdef.id == "Wait" then
					if firstorder.params[5] and firstorder.params[5].value then
						local value = ConvertIDTo64Bit(firstorder.params[5].value)
						if value ~= 0 then
							attacker = value
						end
					end
				end

				local overrideOrderOptions = {}
					menu.insertInteractionContent("overrideorder", { type = "overrideorder", text = (firstorder.orderdef.id == "Attack") and firstorder.orderdef.name or ReadText(1001, 11228), script = function () return menu.buttonChangeOverrideOrder("Attack", attacker) end, active = (attacker ~= nil) and (firstorder.orderdef.id ~= "Attack"), mouseOverText = ReadText(1026, 3234) })
					menu.insertInteractionContent("overrideorder", { type = "overrideorder", text = (firstorder.orderdef.id == "Flee")   and firstorder.orderdef.name or ReadText(1001, 11220), script = function () return menu.buttonChangeOverrideOrder("Flee", attacker) end,   active = (attacker ~= nil) and (firstorder.orderdef.id ~= "Flee"),   mouseOverText = ReadText(1026, 3232) })
					menu.insertInteractionContent("overrideorder", { type = "overrideorder", text = (firstorder.orderdef.id == "Wait")   and firstorder.orderdef.name or ReadText(1001, 11247), script = function () return menu.buttonChangeOverrideOrder("Wait", attacker) end,   active = (attacker ~= nil) and (firstorder.orderdef.id ~= "Wait"),   mouseOverText = ReadText(1026, 3245) })
			else
				local curtime = GetCurTime()

				local hasbeenattacked = false
				local attacker

				local attackinfo = C.GetLastAttackInfo(menu.componentSlot.component)
				if attackinfo.time + 120 >= curtime then
					hasbeenattacked = true
					attacker = attackinfo.attacker
				end
				for _, ship in ipairs(menu.selectedplayerships) do
					local attackinfo = C.GetLastAttackInfo(ship)
					if attackinfo.time + 120 >= curtime then
						hasbeenattacked = true
						if not attacker then
							attacker = attackinfo.attacker
						end
					end
				end

				local active = true
				local mouseovertext = ""
				if (not hastargetpilot) and (not menu.hasPlayerShipPilot) then
					active = false
					mouseovertext = ReadText(1026, 7830)
				elseif not hasbeenattacked then
					active = false
					mouseovertext = ReadText(1026, 7842)
				end
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = menu.orderIconText("Flee") .. ReadText(1041, 551), helpOverlayID = "interactmenu_flee", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFlee(attacker, false) end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "fleetlogo" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 11133), script = menu.buttonChangeLogo })
		end
	elseif actiontype == "fleetrename" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 7895), script = function () return menu.buttonRename(true) end })
		end
	elseif actiontype == "flyto" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["MoveWait"] then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("MoveWait") .. ReadText(1041, 251), helpOverlayID = "interactmenu_flyto", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonMoveWait(false) end, orderid = "MoveWait" })
		end
	elseif actiontype == "follow" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["Follow"] then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Follow") .. ReadText(1001, 7988), helpOverlayID = "interactmenu_follow", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFollow(false) end, orderid = "Follow" })
		end
	elseif actiontype == "getsupplies" then
		if istobedisplayed and isplayerownedtarget and GetComponentData(convertedComponent, "issupplyship") then
			local active = true
			local mouseovertext = ReadText(1041, 622)
			if menu.hastargetorderloop and (not menu.loopableorders["GetSupplies"]) then
				active = false
				mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7851)
			elseif not hastargetpilot then
				active = false
				mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7801)
			end
			menu.insertInteractionContent("main_orders", { type = actiontype, text = menu.orderIconText("GetSupplies") .. ReadText(1041, 621), script = function () return menu.buttonGetSupplies() end, active = active, mouseOverText = mouseovertext, helpOverlayID = "interact_getsupplies", helpOverlayText = " ", helpOverlayHighlightOnly = true })
		end
	elseif actiontype == "guidance" then
		if (not istargetplayeroccupiedship) and (menu.mode ~= "shipconsole") then
			local text = ReadText(1001, 3256)
			local useoffset = false
			if C.IsComponentClass(menu.componentSlot.component, "sector") then
				text = ReadText(1001, 3242)
				useoffset = true
			end
			menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = IsSameComponent(GetActiveGuidanceMissionComponent(), convertedComponent) and ReadText(1001, 3243) or text, helpOverlayID = "interactmenu_guidance", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonGuidance(useoffset) end, mouseOverText = ffi.string(C.GetMappedInputName("INPUT_ACTION_TOGGLE_GUIDANCE")) })
		end
	elseif actiontype == "hire" then
		if GetComponentData(convertedComponent, "primarypurpose") == "build" then
			local stations = GetContainedStationsByOwner("player", nil, true)
			for i = #stations, 1, -1 do
				local buildstorage = GetComponentData(stations[i], "buildstorage")
				if not C.DoesConstructionSequenceRequireBuilder(ConvertIDTo64Bit(stations[i])) then
					table.remove(stations, i)
				elseif C.GetNumAssignedConstructionVessels(ConvertIDTo64Bit(buildstorage)) > 0 then
					table.remove(stations, i)
				end
			end
			if #stations > 0 then
				local section = isplayerownedtarget and "assigningbuilder" or "hiringbuilder"
				local playermoney = GetPlayerMoney()
				local fee = tonumber(C.GetBuilderHiringFee())
				if (not isplayerownedtarget) and (playermoney < fee) then
					menu.forceSubSection[section] = ReadText(1001, 2966)
				elseif GetComponentData(convertedComponent, "isenemy")  then
					menu.forceSubSection[section] = ReadText(1026, 8014)
				elseif C.IsBuilderBusy(menu.componentSlot.component) then
					menu.forceSubSection[section] = ReadText(1026, 7820)
				else
					local mouseover = (not isplayerownedtarget) and (((fee > playermoney) and "\027R" or "\027G") .. ReadText(1001, 7940) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101) .. "\027X") or ""
					for i, station in ipairs(stations) do
						local station64 = ConvertIDTo64Bit(station)
						menu.insertInteractionContent(section, { type = actiontype, text = Helper.convertColorToText(menu.holomapcolor.playercolor) .. ffi.string(C.GetComponentName(station64)) .. " (" .. ffi.string(C.GetObjectIDCode(station64)) .. ")", helpOverlayID = "interactmenu_hire", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDeployToStation(menu.componentSlot.component, false, station64) end, mouseOverText = mouseover })
					end
				end
			end
		end
	elseif actiontype == "intersectordefence" then
		local shiptype = GetComponentData(convertedComponent, "shiptype")
		local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
		local subordinates = GetSubordinates(convertedComponent)
		local isfleetcommander = (not commander) and (#subordinates > 0)
		local hasintersectorgroup = C.HasSubordinateAssignment(convertedComponent, "positiondefence")
		if (#menu.selectedplayerships == 0) and istobedisplayed and (shiptype == "carrier") and (isfleetcommander or hasintersectorgroup) then
			--local subordinates = GetSubordinates(convertedComponent)
			local groups = menu.getSubordinatesInGroups(convertedComponent, C.IsComponentClass(convertedComponent, "station"))

			menu.insertInteractionContent("interaction", { type = actiontype, text = hasintersectorgroup and ReadText(1001, 11135) or ReadText(1001, 11134), script = function () return menu.buttonSetInterSectorDefence(groups, hasintersectorgroup) end })
		end
	elseif actiontype == "livestream" then
		if (menu.mode ~= "shipconsole") then
			local active = true
			local mouseovertext = ffi.string(C.GetMappedInputName("INPUT_ACTION_CINEMATIC_CAMERA"))
			local isinternallystored, isinnormalspace, isinliveview, isfriend, isally = GetComponentData(convertedComponent, "isinternallystored", "isinnormalspace", "isinliveview", "isfriend", "isally")
			if isinternallystored then
				active = false
				mouseovertext = ReadText(1026, 7811)
			elseif not isinnormalspace then
				active = false
				mouseovertext = ReadText(1026, 7809)
			elseif not isinliveview then
				local ismilitary = false
				if C.IsComponentClass(convertedComponent, "station") then
					local iswharf, isshipyard, isdefencestation, istradestation = GetComponentData(convertedComponent, "iswharf", "isshipyard", "isdefencestation", "istradestation")
					--print("iswharf: " .. tostring(iswharf) .. ", isshipyard: " .. tostring(isshipyard) .. ", isdefencestation: " .. tostring(isdefencestation))
					ismilitary = (iswharf or isshipyard or isdefencestation) and not istradestation
				elseif C.IsComponentClass(convertedComponent, "ship") then 
					local purpose = GetComponentData(convertedComponent, "primarypurpose")
					ismilitary = (purpose == "fight" or purpose == "auxiliary")
				end
				if not isally and ismilitary then
					active = false
					mouseovertext = ReadText(20218, 17)
				elseif not isfriend then
					active = false
					mouseovertext = ReadText(20218, 15)
				end
			elseif not C.CanSetPlayerCameraCinematicView() then
				active = false
				mouseovertext = ReadText(1001, 9408)
			end
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 12217), script = menu.buttonLiveStream, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "logicalstationoverview" then
		menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001,8401), helpOverlayID = "interactmenu_logicalstationoverview", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStationOverview })
	elseif actiontype == "manageassignments" then
		if istobedisplayed and IsComponentOperational(convertedComponent) and not C.IsUnit(convertedComponent) then
			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			if commander and commander ~= 0 then
				menu.insertInteractionContent("main_assignments", { type = actiontype, text = ReadText(1001, 7810), script = function () menu.buttonRemoveAssignment() end })
				local currentgroup, purpose, shiptype = GetComponentData(convertedComponent, "subordinategroup", "primarypurpose", "shiptype")
				local subordinates = GetSubordinates(commander)

				local isstation = C.IsComponentClass(commander, "station")
				local isship = C.IsComponentClass(commander, "ship")
				local groups = menu.getSubordinatesInGroups(commander, isstation)
				-- defence
				menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonChangeAssignment, groups, isstation, isstation, currentgroup)
				-- supplyfleet
				if shiptype == "resupplier" then
					menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
				end
				if isstation then
					-- trading
					menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, currentgroup, (purpose == "mine") and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8608)) or "")
					if purpose == "mine" then
						-- mining
						menu.insertAssignSubActions("main_assignments_mining", "mining", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					else
						-- tarding for buildstorage
						menu.insertAssignSubActions("main_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
					if purpose == "salvage" then
						menu.insertAssignSubActions("main_assignments_salvage", "salvage", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
				elseif isship then
					-- position defence
					local shiptype = GetComponentData(commander, "shiptype")
					local parentcommander = ConvertIDTo64Bit(GetCommander(commander))
					local isfleetcommander = (not parentcommander) and (#subordinates > 0)
					if (shiptype == "carrier") and isfleetcommander then
						menu.insertAssignSubActions("main_assignments_positiondefence", "positiondefence", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					end
					menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					local buf = ffi.new("Order")
					if C.GetDefaultOrder(buf, commander) then
						menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
					if shiptype == "resupplier" then
						menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
				end
			end
			if menu.numshipswithcommander > 1 then
				menu.insertInteractionContent("selected_assignments_all", { type = actiontype, text = ReadText(1001, 7887), script = function () menu.buttonRemoveAssignment(true) end })
			end
			-- manage multiple selected ships with the interacted object as commander
			if (menu.numassignableships == 0) and (#menu.shipswithcurrentcommander > 0) then
				local subordinates = GetSubordinates(convertedComponent)

				local allresupplier = true
				local allmining = true
				local allnomining = true
				local alltugs = true
				for _, ship in ipairs(menu.shipswithcurrentcommander) do
					local purpose, shiptype = GetComponentData(ship, "primarypurpose", "shiptype")
					if shiptype ~= "resupplier" then
						allresupplier = false
					end
					if purpose == "mine" then
						allnomining = false
					end
					if purpose ~= "mine" then
						allmining = false
					end
					if shiptype ~= "tug" then
						alltugs = false
					end
				end

				local isstation = C.IsComponentClass(menu.componentSlot.component, "station")
				local isship = C.IsComponentClass(menu.componentSlot.component, "ship")
				local groups = menu.getSubordinatesInGroups(menu.componentSlot.component, isstation)
				-- defence
				menu.insertAssignSubActions("selected_change_assignments_defence", "defence", menu.buttonChangeAssignment, groups, isstation, isstation)
				-- supplyfleet
				if allresupplier then
					menu.insertAssignSubActions("selected_change_assignments_supplyfleet", "supplyfleet", menu.buttonChangeAssignment, groups, isstation, true)
				end
				if isstation then
					-- trading
					menu.insertAssignSubActions("selected_change_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, nil, (not allnomining) and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8609)) or "")
					if allmining then
						-- mining
						menu.insertAssignSubActions("selected_change_assignments_mining", "mining", menu.buttonChangeAssignment, groups, isstation, true)
					elseif allnomining then
						-- trading for buildstorage
						menu.insertAssignSubActions("selected_change_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonChangeAssignment, groups, isstation, true)
					end
					if alltugs then
						menu.insertAssignSubActions("selected_change_assignments_salvage", "salvage", menu.buttonChangeAssignment, groups, isstation, true)
					end
				elseif isship then
					-- position defence
					local shiptype = GetComponentData(convertedComponent, "shiptype")
					local parentcommander = ConvertIDTo64Bit(GetCommander(convertedComponent))
					local isfleetcommander = (not parentcommander) and (#subordinates > 0)
					if (shiptype == "carrier") and isfleetcommander then
						menu.insertAssignSubActions("selected_change_assignments_positiondefence", "positiondefence", menu.buttonChangeAssignment, groups, isstation, nil)
					end
					menu.insertAssignSubActions("selected_change_assignments_attack", "attack", menu.buttonChangeAssignment, groups, isstation, nil)
					menu.insertAssignSubActions("selected_change_assignments_interception", "interception", menu.buttonChangeAssignment, groups, isstation, nil)
					menu.insertAssignSubActions("selected_change_assignments_bombardment", "bombardment", menu.buttonChangeAssignment, groups, isstation, nil)
					menu.insertAssignSubActions("selected_change_assignments_follow", "follow", menu.buttonChangeAssignment, groups, isstation, true)
					local buf = ffi.new("Order")
					if C.GetDefaultOrder(buf, menu.componentSlot.component) then
						menu.insertAssignSubActions("selected_change_assignments_assist", "assist", menu.buttonChangeAssignment, groups, isstation, true)
					end
					if shiptype == "resupplier" then
						menu.insertAssignSubActions("selected_change_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true)
					end
				end
			end
		end
	elseif actiontype == "markashostile" then
		if (menu.mode ~= "shipconsole") and (not GetComponentData(convertedComponent, "isreallyplayerowned")) then
			local active = true
			local mouseovertext = ""
			if GetComponentData(convertedComponent, "ishostile") then
				active = false
				mouseovertext = ReadText(1026, 7853)
			end
			menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = ReadText(1001, 11114), helpOverlayID = "interactmenu_markashostile", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonMarkAsHostile, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "mining" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["MiningPlayer"] then
			if menu.offsetcomponent and (menu.offsetcomponent ~= 0) and C.IsComponentClass(menu.offsetcomponent, "sector") then
				local pos = ffi.new("Coord3D", { x = menu.offset.x, y = menu.offset.y, z = menu.offset.z })
				local nummineables = C.GetNumMineablesAtSectorPos(menu.offsetcomponent, pos)
				local mineables = ffi.new("YieldInfo[?]", nummineables)
				nummineables = C.GetMineablesAtSectorPos(mineables, nummineables, menu.offsetcomponent, pos)
				local miningwares = {}
				for i = 0, nummineables - 1 do
					if mineables[i].amount > 10 then
						local ware = ffi.string(mineables[i].wareid)
						table.insert(miningwares, { ware = ware, name = GetWareData(ware, "name"), amount = 0 })
						local entry = miningwares[#miningwares]
						for _, ship in ipairs(menu.selectedplayerships) do
							if GetWareCapacity(ship, ware, true) > 0 then
								entry.amount = entry.amount + 1
							end
						end
					end
				end
				table.sort(miningwares, Helper.sortName)
				local found = false
				for _, entry in ipairs(miningwares) do
					if entry.amount > 0 then
						found = true
						menu.insertInteractionContent("mining", { type = actiontype, text = entry.name, text2 = Helper.convertColorToText(menu.holomapcolor.playercolor) .. ((entry.amount == 1) and ReadText(1001, 7851) or string.format(ReadText(1001, 7801), entry.amount)), helpOverlayID = "interactmenu_mining", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonMining(entry.ware, false) end, orderid = "MiningPlayer" })
					end
				end
				if not found then
					menu.forceSubSection["mining"] = ReadText(1026, 7823)
				end
			end
		end
	elseif actiontype == "paintmod" then
		if istobedisplayed then
			menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "interaction", { type = actiontype, text = ReadText(1001, 7859), helpOverlayID = "interactmenu_paintmod", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonPaintMod })
		end
	elseif actiontype == "player_docktotrade" then
		local tradeoffers = GetTradeList(convertedComponent)
		if not isplayerownedtarget and menu.possibleorders["Player_DockToTrade"] and (#tradeoffers == 0) and GetComponentData(convertedComponent, "isdock") and (menu.numdockingpossible > 0) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Player_DockToTrade") .. ReadText(1001, 7858), helpOverlayID = "interactmenu_docktotrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonPlayerDockToTrade(false) end, orderid = "Player_DockToTrade" })	-- Dock to trade
		end
	elseif actiontype == "proceedwithorders" then
		if istobedisplayed and isplayerownedtarget then
			local iswaitingforsignal = false
			local numorders = C.GetNumOrders(menu.componentSlot.component)
			if numorders > 0 then
				local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), 1)
				for i, param in ipairs(orderparams) do
					if param.name == "releasesignal" and type(param.value) == "table" and param.value[1] == "playerownedship_proceed" then
						iswaitingforsignal = true
						break
					end
				end
			end

			local infotext = ""
			if iswaitingforsignal then
				if menu.numwaitingforsignal == 0 then
					-- only the currently targeted ship is affected, show nothing
					infotext = ""
				else
					-- target ship and selected ships
					infotext = " \27G(" .. menu.texts.targetShortName .. " + " .. ((menu.numwaitingforsignal == 1) and ReadText(1001, 7851) or string.format(ReadText(1001, 7801), menu.numwaitingforsignal)) .. ")"
				end
			elseif menu.numwaitingforsignal > 0 then
				infotext = " \27G(" .. ((menu.numwaitingforsignal == 1) and ReadText(1001, 7851) or string.format(ReadText(1001, 7801), menu.numwaitingforsignal)) .. ")"
			end
			if iswaitingforsignal or (menu.numwaitingforsignal > 0) then
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0) and (menu.numremovableorders > 0)) and "selected_orders" or "main_orders", { type = actiontype, text = ReadText(1002, 2033) .. infotext, helpOverlayID = "interactmenu_proceedwithorders", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonProceedWithOrders, hidetarget = true })
			end
		end
	elseif actiontype == "protectstation" then
		if #menu.selectedplayerships > 0 and isplayerownedtarget and menu.possibleorders["ProtectStation"] then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("ProtectStation") .. ReadText(1001, 7989), helpOverlayID = "interactmenu_protectstation", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonProtect(false) end, orderid = "ProtectStation" })
		end
	elseif actiontype == "putintostorage" then
		local isdocked = GetComponentData(convertedComponent, "isdocked")
		if istobedisplayed and isdocked then
			local container = C.GetContextByClass(menu.componentSlot.component, "container", false)
			if container ~= 0 then
				-- check if the ship is at a venture dock
				local isatventuredock = false
				local parentdockingbay = C.GetContextByClass(menu.componentSlot.component, "dockarea", false)
				local ventureplatforms = {}
				Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, container)
				for _, platform in ipairs(ventureplatforms) do
					local docks = {}
					Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
					for _, dock in ipairs(docks) do
						if dock == parentdockingbay then
							isatventuredock = true
							break
						end
					end
					if isatventuredock then
						break
					end
				end
				if not isatventuredock then
					local text = ReadText(1001, 11107)
					local active = true
					local mouseovertext = ""
					if not C.IsShipAtExternalDock(menu.componentSlot.component) then
						text = ReadText(1001, 7890)
						if C.IsShipBeingRetrieved(menu.componentSlot.component) then
							active = false
							mouseovertext = ReadText(1026, 7858)
						end
					elseif not C.HasContainerFreeInternalShipStorage(container, menu.componentSlot.component) then
						active = false
						mouseovertext = ReadText(1026, 7849)
					elseif not C.CanPutShipIntoStorage(container, menu.componentSlot.component) then
						active = false
						mouseovertext = ReadText(1026, 7850)
					end

					menu.insertInteractionContent("interaction", { type = actiontype, text = text, script = function () return menu.buttonPutIntoStorage(container, menu.componentSlot.component) end, active = active, mouseOverText = mouseovertext })
				end
			end
		end
	elseif actiontype == "recallsubs" then
		if istobedisplayed and C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local subordinates = GetSubordinates(convertedComponent)
			if #subordinates > 0 then
				menu.insertInteractionContent("main_orders", { type = actiontype, text = ReadText(1001, 7830), helpOverlayID = "interactmenu_recallsubs", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRecallSubordinates(menu.componentSlot.component, subordinates) end })
			end
		end
	elseif actiontype == "removeallorders" then
		if istobedisplayed and (not GetComponentData(convertedComponent, "isdeployable")) and not C.IsUnit(convertedComponent) then
			local hasremoveableorders = false
			local hasdockandwaitorder = false
			local numorders = C.GetNumOrders(menu.componentSlot.component)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
			for i = numorders, 1, -1 do
				local isdocked, isdocking = GetComponentData(convertedComponent, "isdocked", "isdocking")
				if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
					-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
					hasdockandwaitorder = true
				else
					if C.RemoveOrder(menu.componentSlot.component, i, false, true) then
						hasremoveableorders = true
						break
					end
				end
			end

			local buf = ffi.new("Order")
			if C.GetDefaultOrder(buf, menu.componentSlot.component) and (numorders == 1) and hasdockandwaitorder then
				local mouseovertext = ReadText(1026, 7841)
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = ReadText(1001, 11117), helpOverlayID = "interactmenu_resumeduties", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(false, false, true) end, active = active, mouseOverText = mouseovertext, hidetarget = true })
			else
				local active = hasremoveableorders or (menu.numremovableorders > 0)
				local mouseovertext = active and ReadText(1026, 7841) or ReadText(1026, 7833)
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = ReadText(1001, 7832), helpOverlayID = "interactmenu_removeallorders", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(false, false) end, active = active, mouseOverText = mouseovertext, hidetarget = true })
			end
		end
	elseif actiontype == "removeallordersandwait" then
		if istobedisplayed and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and not C.IsUnit(convertedComponent) then
			local hasremoveableorders = false
			local numorders = C.GetNumOrders(menu.componentSlot.component)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
			for i = numorders, 1, -1 do
				local isdocked, isdocking = GetComponentData(convertedComponent, "isdocked", "isdocking")
				if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
					-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
				else
					if C.RemoveOrder(menu.componentSlot.component, i, false, true) then
						hasremoveableorders = true
						break
					end
				end
			end
			local currentdefaultorder = ffi.new("Order")
			if C.GetDefaultOrder(currentdefaultorder, menu.componentSlot.component) then
				if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
					hasremoveableorders = true
				end
			end
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(menu.componentSlot.component, hasloop)
			if hasloop[0] then
				hasremoveableorders = true
			end

			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			if commander and (commander ~= 0) and (commander ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))) then
				hasremoveableorders = true
			end

			local numremovableorders = math.max(menu.numremovableorders, menu.numremovabledefaultorders)
			local active = hasremoveableorders or (numremovableorders > 0)
			local mouseovertext = active and ReadText(1026, 7834) or ReadText(1026, 7835)
			menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = ReadText(1001, 7889), helpOverlayID = "interactmenu_removeallordersandwait", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(true, true) end, active = active, hidetarget = true, mouseOverText = mouseovertext })
		end
	elseif actiontype == "rename" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 1114), script = function () return menu.buttonRename(false) end })
		end
	elseif actiontype == "salvagecollect" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["SalvageCollect"] and C.CanBeTowed(menu.componentSlot.component) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageCollect") .. ReadText(1041, 801), helpOverlayID = "interactmenu_salvagecollect", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageCollect(false) end, orderid = "SalvageCollect" })
		end
	elseif actiontype == "salvagecrush" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["SalvageCrush"] and C.CanBeDismantled(menu.componentSlot.component) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageCrush") .. ReadText(1041, 831), helpOverlayID = "interactmenu_salvagecrush", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageCrush(false) end, orderid = "SalvageCrush" })
		end
	elseif actiontype == "salvagedeliver" then
		if (menu.possibleorders["SalvageDeliver"] or menu.possibleorders["SalvageDeliver_NoTrade"]) and C.HasContainerProcessingModule(menu.componentSlot.component) and (not GetComponentData(convertedComponent, "isenemy")) then
			local hastowingship = false
			local ware
			local hasloop = ffi.new("bool[1]", 0)
			for _, ship in ipairs(menu.selectedplayerships) do
				if (GetComponentData(ship, "shiptype") == "tug") then
					C.GetOrderQueueFirstLoopIdx(ship, hasloop)
					if hasloop[0] then
						break
					end
				end
				local towedobject = C.GetTowedObject(ship)
				if towedobject ~= 0 then
					local recyclingwares = GetComponentData(ConvertStringTo64Bit(tostring(towedobject)), "recyclingwares")
					if #recyclingwares > 0 then
						hastowingship = true
						ware = recyclingwares[1].ware
						break
					end
				end
			end

			if hastowingship or hasloop[0] then
				local active = true
				if hasloop[0] then
					menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageDeliver_NoTrade") .. ReadText(1041, 811), helpOverlayID = "interactmenu_salvagedeliver", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageDeliver_NoTrade(false) end, active = active, orderid = "SalvageDeliver_NoTrade" })
				else
					local tradeoffers = GetTradesForWare(convertedComponent, ware, true)
					if #tradeoffers == 0 then
						active = false
						mouseovertext = ReadText(1001, 2973)
					end
					menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageDeliver") .. ReadText(1041, 811), helpOverlayID = "interactmenu_salvagedeliver", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageDeliver(false, ware, tradeoffers[1]) end, orderid = "SalvageDeliver", active = active, mouseOverText = mouseovertext })
				end
			end
		end
	elseif (actiontype == "selfdestruct") then
		if GetComponentData(convertedComponent, "isdeployable") then
			local selecteddeployable = convertedComponent
			if #menu.selectedplayerdeployables > 0 then
				selecteddeployable = nil
			end
			menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 11127), script = function () return menu.buttonSelfDestructDeployables(selecteddeployable) end })
		end
	elseif actiontype == "sellships" then
		if #menu.selectedplayerships > 0 then
			if not isplayerownedtarget then
				local shiptrader, isdock, iswharf, isshipyard = GetComponentData(convertedComponent, "shiptrader", "isdock", "iswharf", "isshipyard")
				if shiptrader and isdock and (iswharf or isshipyard) then
					local cansell = false
					for _, ship in ipairs(menu.selectedplayerships) do
						if C.CanContainerBuildShip(menu.componentSlot.component, ship) and GetComponentData(ship, "issellable") then
							cansell = true
							break
						end
					end
					if cansell then
						menu.insertInteractionContent("selected_orders", { type = actiontype, text = (#menu.selectedplayerships == 1) and ReadText(1001, 7855) or ReadText(1001, 7856), helpOverlayID = "interactmenu_sellships", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonSellShips })
					end
				end
			end
		end
	elseif actiontype == "showupkeep" then
		if istobedisplayed then
			local found = false
			local numMissions = GetNumMissions()
			for i = 1, numMissions do
				local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, alertLevel = GetMissionDetails(i)
				
				if maintype == "upkeep" then
					if associatedcomponent then
						local rawcontainer = C.GetContextByRealClass(ConvertIDTo64Bit(associatedcomponent), "container", true)
						if rawcontainer ~= 0 then
							local container = ConvertStringTo64Bit(tostring(rawcontainer))
							if container == menu.componentSlot.component then
								found = true
								break
							end
						end
					end
				end
			end

			if found then
				menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 11123), script = menu.buttonShowUpkeepMissions })
			end
		end
	elseif actiontype == "singletrade" then
		if (#menu.selectedplayerships > 0) and (menu.numorderloops > 0) then
			local active = menu.hasPlayerShipPilot
			local mouseovertext = (not menu.hasPlayerShipPilot) and ReadText(1026, 7830) or ""

			local hasbuy, hassell
			local tradeoffers = GetTradeList(convertedComponent, menu.selectedplayerships[1], false)
			for _, tradedata in pairs(tradeoffers) do
				if tradedata.isselloffer then
					hassell = true
				end
				if tradedata.isbuyoffer then
					hasbuy = true
				end
				if hassell and hasbuy then
					break
				end
			end
			if hassell then
				menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleBuy")  .. ReadText(1001, 11112), script = function () return menu.buttonTrade(false, nil, "SingleBuy") end,  active = active, mouseOverText = mouseovertext })
			end
			if hasbuy then
				menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleSell") .. ReadText(1001, 11113), script = function () return menu.buttonTrade(false, nil, "SingleSell") end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "stopandholdfire" then
		if istargetinplayersquad or istargetplayeroccupiedship then
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7870), helpOverlayID = "interactmenu_stopandholdfire", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonPlayerSquadStopAndHoldFire(true) end, hidetarget = true })	-- Fleet: Stop and hold fire
		end
	elseif actiontype == "tacticalattack" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["TacticalOrder"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			local fleetcommanders = {}
			for _, ship in ipairs(menu.selectedplayerships) do
				local commander = ConvertIDTo64Bit(GetCommander(ship))
				local subordinates = GetSubordinates(ship)
				if (not commander) and (#subordinates > 0) then
					table.insert(fleetcommanders, ship)
				end
			end
			if #fleetcommanders > 0 then
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("TacticalOrder") .. ReadText(1041, 731), helpOverlayID = "interactmenu_tacticalattack", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonTacticalAttack(fleetcommanders, false) end, orderid = "TacticalOrder" })
			end
		end
	elseif actiontype == "targetview" then
		if menu.mode ~= "shipconsole" then
			local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
			local target = 0
			if C.IsComponentClass(menu.componentSlot.component, "highway") then
				local issuperhighway, entrygate = GetComponentData(convertedComponent, "issuperhighway", "entrygate")
				if issuperhighway then
					target = ConvertIDTo64Bit(entrygate)
				else
					target = menu.componentSlot.component
				end
			else
				target = menu.componentSlot.component
			end
			local targetsector = C.GetContextByClass(target, "sector", false)
			local active = true
			local mouseovertext = ffi.string(C.GetMappedInputName("INPUT_ACTION_TARGET_VIEW"))
			if GetComponentData(convertedComponent, "isdockedinternally") then
				active = false
				mouseovertext = ReadText(1026, 7811)
			elseif (not C.IsPlayerCameraTargetViewPossible(target, true)) or (playersector ~= targetsector) then
				active = false
				mouseovertext = ReadText(1026, 7809)
			elseif target == C.GetPlayerControlledShipID() then
				active = false
				mouseovertext = ReadText(1026, 7810)
			end
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 7807), script = menu.buttonExternal, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "teleport" then
		local isally, isdeployable = GetComponentData(convertedComponent, "isally", "isdeployable")
		if (isplayerownedtarget or (C.IsComponentClass(menu.componentSlot.component, "station") and isally)) and (not isdeployable) and (not C.IsUnit(menu.componentSlot.component)) then
			if menu.componentSlot.component ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) then
				local active = false
				local mouseovertext = ffi.string(C.GetMappedInputName("INPUT_ACTION_TELEPORT_ACTION"))
				local teleportrequest = ffi.string(C.CanTeleportPlayerTo(menu.componentSlot.component, false, (menu.mode == "shipconsole") and isplayerownedtarget))
				if teleportrequest == "granted" then
					active = true
				elseif teleportrequest == "instorage" then
					mouseovertext = ReadText(1026, 7811)
				elseif teleportrequest == "malfunction" then
					mouseovertext = ReadText(1026, 7812)
				elseif teleportrequest == "research" then
					mouseovertext = ReadText(1026, 7813)
				elseif teleportrequest == "range" then
					mouseovertext = ReadText(1026, 7814)
				elseif teleportrequest == "size" then
					mouseovertext = ReadText(1026, 7815)
				elseif teleportrequest == "slot" then
					mouseovertext = ReadText(1026, 7816)
				end
				menu.insertInteractionContent("interaction", { type = actiontype, text = (menu.mode == "shipconsole") and ReadText(1001, 7854) or ReadText(1001, 7808), helpOverlayID = "interactmenu_teleport", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonTeleport, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "travelmode" then
		if istobedisplayed then
			local active = true
			local mouseovertext = ""
			if not C.CanStartTravelMode(menu.componentSlot.component) then
				active = false
				mouseovertext = ReadText(1026, 7855)
			end
			local currentactivity = GetPlayerActivity()

			menu.insertInteractionContent("interaction", { type = actiontype, text = (currentactivity == "travel") and ReadText(1001, 11116) or ReadText(1001, 11115), script = function () return menu.buttonTravelMode(currentactivity ~= "travel") end })
		end
	elseif actiontype == "upgrade" then
		local shiptrader, isdock, issupplyship = GetComponentData(convertedComponent, "shiptrader", "isdock", "issupplyship")
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Repair"] and isdock and (C.IsComponentClass(menu.componentSlot.component, "station") or issupplyship) and (menu.numorderloops == 0) then
			local active = false
			local haspilot = false
			for _, ship in ipairs(menu.selectedplayerships) do
				local pilot = GetComponentData(ship, "assignedpilot")
				if pilot then
					haspilot = true
					if C.CanContainerEquipShip(menu.componentSlot.component, ship) or (isplayerownedtarget and C.CanContainerSupplyShip(menu.componentSlot.component, ship)) then
						active = true
						break
					end
				end
			end
			-- don't show option for npcs if they are missing the shiptrader, but do for player objects
			if (C.IsComponentClass(menu.componentSlot.component, "station") and shiptrader) or isplayerownedtarget then
				local mouseovertext
				if not shiptrader then
					active = false
					mouseovertext = ReadText(1026, 7827)
				elseif not haspilot then
					-- no one has a pilot, show that
					mouseovertext = ReadText(1026, 7830)
				elseif (not active) and (#menu.selectedplayerships > 0) then
					-- if the option is inactive, all ships are either capships or not, so only check the first one
					if C.IsComponentClass(menu.selectedplayerships[1], "ship_l") or C.IsComponentClass(menu.selectedplayerships[1], "ship_xl") then
						mouseovertext = issupplyship and ReadText(1026, 7828) or ReadText(1026, 7805)
					else
						mouseovertext = ReadText(1026, 7804)
					end
				end
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Repair") .. (issupplyship and ReadText(1001, 7876) or ReadText(1001, 7826)), helpOverlayID = "interactmenu_upgrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonUpgrade(true) end, active = active, mouseOverText = mouseovertext, orderid = "Repair" })
			end
		end
	elseif actiontype == "upgradeships" then
		local shiptrader, isdock, issupplyship = GetComponentData(convertedComponent, "shiptrader", "isdock", "issupplyship")
		local dockedships = {}
		if C.IsComponentClass(menu.componentSlot.component, "container") then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.componentSlot.component, "player")
		end
		if isdock and (C.IsComponentClass(menu.componentSlot.component, "station") or issupplyship) then
			local active = false
			for _, ship in ipairs(dockedships) do
				if C.CanContainerEquipShip(menu.componentSlot.component, ship) or (isplayerownedtarget and C.CanContainerSupplyShip(menu.componentSlot.component, ship)) then
					active = true
					break
				end
			end
			-- don't show option for npcs if they are missing the shiptrader, but do for player objects
			if (C.IsComponentClass(menu.componentSlot.component, "station") and shiptrader) or isplayerownedtarget then
				local mouseovertext
				if not shiptrader then
					active = false
					mouseovertext = ReadText(1026, 7827)
				elseif not active then
					if #dockedships > 0 then
						-- if the option is inactive, all ships are either capships or not, so only check the first one
						if C.IsComponentClass(dockedships[1], "ship_l") or C.IsComponentClass(dockedships[1], "ship_xl") then
							mouseovertext = ReadText(1026, 7807)
						else
							mouseovertext = ReadText(1026, 7806)
						end
					else
						mouseovertext = ReadText(1026, 7808)
					end
				end
				menu.insertInteractionContent("main", { type = actiontype, text = issupplyship and ReadText(1001, 7877) or ReadText(1001, 7841), helpOverlayID = "interactmenu_upgradeships", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonShipConfig("upgrade") end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "venturedockat" then
		if menu.possibleorders["DockAndWait"] and GetComponentData(convertedComponent, "isdock") then
			local ventureplatforms = {}
			Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, menu.componentSlot.component)
			for _, platform in ipairs(ventureplatforms) do
				local currentdockareas = {}
				local hasdock = false
				local notdocked = false
				for i = #menu.selectedplayerships, 1, -1 do
					local ship = menu.selectedplayerships[i]
					if C.IsComponentClass(menu.componentSlot.component, "container") then
						local parentdockingbay = C.GetContextByClass(ship, "dockarea", false)
						if parentdockingbay ~= 0 then
							table.insert(currentdockareas, parentdockingbay)
						else
							notdocked = true
						end
						if C.HasVenturerDock(menu.componentSlot.component, ship, platform) then
							hasdock = true
						end
					end
				end
				if hasdock then
					local docks = {}
					local dockindex = {}
					Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
					local counts = {
						["XL_L"] = 0,
						["M_S"] = 0,
					}
					for _, dock in ipairs(docks) do
						dockindex[tostring(dock)] = true
						local docksizes = GetComponentData(ConvertStringTo64Bit(tostring(dock)), "docksizes")
						-- docksizes always return the biggest possible size of a dockingbay contained in the dockarea
						counts["XL_L"] = counts["XL_L"] + (docksizes.docks_xl or 0) + (docksizes.docks_l or 0)
						counts["M_S"]  = counts["M_S"]  + (docksizes.docks_m or 0)  + (docksizes.docks_s or 0)
					end
					local dockstring = ""
					if counts["XL_L"] > 0 then
						if dockstring ~= "" then
							dockstring = dockstring .. " "
						end
						dockstring = dockstring .. "[" .. counts["XL_L"] .. ReadText(1001, 42) .. " " .. ReadText(1001, 7863) .. "]"
					end
					if counts["M_S"] > 0 then
						if dockstring ~= "" then
							dockstring = dockstring .. " "
						end
						dockstring = dockstring .. "[" .. counts["M_S"] .. ReadText(1001, 42) .. " " .. ReadText(1001, 7864) .. "]"
					end

					local isalreadydocked = true
					if notdocked then
						-- some ship is not docked at all
						isalreadydocked = false
					else
						for _, dockarea in ipairs(currentdockareas) do
							if not dockindex[tostring(dockarea)] then
								-- some ship is not docked at this platform
								isalreadydocked = false
								break
							end
						end
					end
					local active = not isalreadydocked
					local mouseovertext = ""
					if isalreadydocked then
						mouseovertext = ReadText(1026, 7846)
					end

					menu.insertInteractionContent("venturedock", { type = actiontype, text = ffi.string(C.GetComponentName(platform)), text2 = dockstring, helpOverlayID = "interactmenu_ventureatdock", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDock(false, platform) end, active = active, mouseOverText = mouseovertext, orderid = "DockAndWait" })
				end
			end
		end
	elseif actiontype == "venturepatron" then
		menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 11802), script = menu.buttonVenturePatron })
	elseif actiontype == "venturereportname" then
		menu.insertInteractionContent("venturereport", { type = actiontype, text = ReadText(1001, 12114), script = menu.buttonVentureReportShip })
	elseif actiontype == "venturereportusername" then
		menu.insertInteractionContent("venturereport", { type = actiontype, text = ReadText(1001, 12111), script = menu.buttonVentureReportUser })
	elseif actiontype == "wareexchange" then
		if (#menu.selectedplayerships > 0) and isplayerownedtarget and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (menu.numorderloops == 0) then
			local hasrealship = false
			for _, ship in ipairs(menu.selectedplayerships) do
				if not GetComponentData(ship, "isdeployable") then
					hasrealship = true
					break
				end
			end
			if hasrealship then
				local active = menu.showPlayerInteractions or menu.hasPlayerShipPilot
				local mouseovertext = (not active) and ReadText(1026, 7830) or ""
				if menu.showPlayerInteractions then
					local occupiedship = C.GetPlayerOccupiedShipID()
					if C.GetCommonContext(occupiedship, menu.componentSlot.component, true, true, C.GetContextByClass(occupiedship, "zone", false), false) == 0 then
						active = false
						mouseovertext = ReadText(1026, 7856)
					elseif not GetComponentData(convertedComponent, "assignedaipilot") then
						active = false
						mouseovertext = ReadText(1026, 7830)
					end
				end

				if C.IsComponentClass(menu.componentSlot.component, "container") then
					menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "trade_orders", { type = actiontype, text = menu.orderIconText("TradeExchange") .. ReadText(1001, 7820), script = function () return menu.buttonTrade(true) end, active = active, mouseOverText = mouseovertext })
				end
				if menu.buildstorage then
					menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "trade_orders", { type = actiontype, text = menu.orderIconText("TradeExchange") .. ReadText(1001, 7820), script = function () return menu.buttonTrade(true, menu.buildstorage) end, buildstorage = true, active = active, mouseOverText = mouseovertext })
				end
			end
		end
	elseif actiontype == "withdrawandhold" then
		if istargetinplayersquad or istargetplayeroccupiedship then
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7871), script = function () return menu.buttonPlayerSquadWithdrawAndHold(true) end, hidetarget = true })	-- Fleet: Withdraw and hold
		end
	elseif actiontype == "withdrawfromcombat" then
		if istargetinplayersquad or istargetplayeroccupiedship then
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7872), script = function () return menu.buttonPlayerSquadWithdrawFromCombat(true) end, hidetarget = true })	-- Fleet: Withdraw from combat
		end
	elseif actiontype == "cheat_satellite" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Place satellite", script = menu.buttonSatelliteCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_navbeacon" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Place nav beacon", script = menu.buttonNavBeaconCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_resourceprobe" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Place resource probe", script = menu.buttonResourceProbeCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_takeownership" then
		if not isplayerownedtarget then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Take ownership", script = menu.buttonOwnerCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_warp" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Warp here", script = menu.buttonWarpCheat }) -- (cheat only)
		end
	else
		DebugError("Unknown LuaAction type '" .. actiontype .. "'! [Florian]")
	end
end

function menu.prepareData()
	menu.data = {}
	menu.data.convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	menu.data.istargetinplayersquad = false
	menu.data.istargetplayeroccupiedship = false
	menu.data.hastargetpilot = false
	if (menu.data.convertedComponent ~= 0) then
		menu.data.isplayerownedtarget = GetComponentData(menu.data.convertedComponent, "isplayerowned")
		menu.data.istargetinplayersquad = menu.playerSquad[menu.data.convertedComponent]
		--print("istargetinplayersquad: " .. tostring(menu.data.istargetinplayersquad) .. ", commander: " .. tostring(GetCommander(menu.data.convertedComponent)) .. ", occupiedship: " .. ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())))

		menu.data.istargetplayeroccupiedship = (ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) == menu.data.convertedComponent)
		--print("istargetplayeroccupiedship: " .. tostring(menu.data.istargetplayeroccupiedship) .. ", occupiedship: " .. ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) .. ", convertedComponent: " .. tostring(menu.data.convertedComponent))

		menu.data.hastargetpilot = GetComponentData(menu.data.convertedComponent, "assignedpilot") ~= nil

		if C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(menu.componentSlot.component, hasloop)
			menu.data.hastargetorderloop = hasloop[0]
		end
	end
end

function menu.prepareActions()
	menu.checkPlayerActivity = nil
	menu.forceSubSection = {}
	menu.prepareSections()

	menu.prepareData()
	local convertedComponent = menu.data.convertedComponent
	
	local hasanydisplayed = false
	-- player actions
	if (not menu.componentOrder) and (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.construction) and (not menu.mission) and (not menu.missionoffer) and (not menu.subordinategroup) and (menu.mode ~= "shipconsole" or (menu.isdockedship)) then
		local isknown = C.IsObjectKnown(menu.componentSlot.component)
		local n = C.GetNumCompSlotPlayerActions(menu.componentSlot)
		if n == 0 then
			return false
		end
		local buf = ffi.new("UIAction[?]", n)
		n = C.GetCompSlotPlayerActions(buf, n, menu.componentSlot)
		for i = 0, n - 1 do
			local entry = {}
			entry.id = buf[i].id
			entry.text = ffi.string(buf[i].text)
			entry.active = buf[i].ispossible
			local actiontype = ffi.string(buf[i].type)
			if (not menu.shown) and (actiontype == "containertrade") then
				entry.script = function () return menu.buttonTrade(false) end
			elseif (not menu.shown) and (actiontype == "info") then
				entry.script = menu.buttonInfo
				entry.helpOverlayID = "interactmenu_info"
				entry.helpOverlayText = " "
				entry.helpOverlayHighlightOnly = true
			elseif (not menu.shown) and (actiontype == "comm") then
				entry.script = menu.buttonComm
			else
				entry.script = function () return menu.buttonPerformPlayerAction(entry.id, actiontype) end
			end

			local istobedisplayed = buf[i].istobedisplayed
			hasanydisplayed = hasanydisplayed or istobedisplayed

			local basetype, luatype = string.match(actiontype, "(.+);(.+)")
			if isknown or (actiontype == "info") or (luatype == "guidance") then
				if basetype == "lua" then
					menu.insertLuaAction(luatype, istobedisplayed)
				elseif istobedisplayed then
					if actiontype == "containertrade" then
						if (not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0) then
							if C.IsComponentClass(menu.componentSlot.component, "container") then
								entry.active = entry.active and menu.hasPlayerShipPilot
								entry.mouseOverText = (not menu.hasPlayerShipPilot) and ReadText(1026, 7830) or ""
								if menu.numorderloops == 0 then
									entry.text = menu.orderIconText("TradePerform") .. entry.text
									menu.insertInteractionContent("trade_orders", entry)
								else
									local hasbuy, hassell
									local tradeoffers = GetTradeList(convertedComponent, menu.selectedplayerships[1], false)
									for _, tradedata in pairs(tradeoffers) do
										if tradedata.isselloffer then
											hassell = true
										end
										if tradedata.isbuyoffer then
											hasbuy = true
										end
										if hassell and hasbuy then
											break
										end
									end
									if hassell then
										menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleBuy")  .. ReadText(1001, 11110), script = function () return menu.buttonTrade(false, nil, "SingleBuy") end,  active = entry.active, mouseOverText = entry.mouseOverText })
									end
									if hasbuy then
										menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleSell") .. ReadText(1001, 11111), script = function () return menu.buttonTrade(false, nil, "SingleSell") end, active = entry.active, mouseOverText = entry.mouseOverText })
									end
								end
							end
							if menu.buildstorage then
								if menu.numorderloops == 0 then
									menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("TradePerform") .. ReadText(1001, 7819), script = function () return menu.buttonTrade(false, menu.buildstorage) end, buildstorage = true, active = menu.hasPlayerShipPilot, mouseOverText = (not menu.hasPlayerShipPilot) and ReadText(1026, 7830) or "" })
								else
									menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleSell") .. ReadText(1001, 11111), script = function () return menu.buttonTrade(false, menu.buildstorage, "SingleSell") end, buildstorage = true, active = entry.active, mouseOverText = entry.mouseOverText })
								end
							end
						else
							entry.text = ReadText(1001, 1113)
							if C.IsComponentClass(menu.componentSlot.component, "container") then
								entry.text = menu.orderIconText("TradePerform") .. entry.text
								menu.insertInteractionContent("trade", entry)
							end
							if menu.buildstorage then
								menu.insertInteractionContent("trade", { text = menu.orderIconText("TradePerform") .. ReadText(1001, 1113), script = function () return menu.buttonTrade(false, menu.buildstorage) end, buildstorage = true })
							end
						end
					elseif actiontype == "hack" then
						if menu.showPlayerInteractions then
							menu.insertInteractionContent("player_interaction", entry)
						end
					elseif actiontype == "scan" then
						if menu.showPlayerInteractions then
							if not entry.active then
								if GetPlayerActivity() ~= "scan" then
									entry.mouseOverText = ReadText(1026, 7803)
								else
									entry.mouseOverText = ReadText(1026, 7809)
								end
							else
								entry.mouseOverText = ffi.string(C.GetMappedInputName("INPUT_ACTION_SCAN_ACTION"))
							end
							entry.helpOverlayID = "interactmenu_scan"
							entry.helpOverlayText = " "
							entry.helpOverlayHighlightOnly = true
							menu.checkPlayerActivity = true
							menu.insertInteractionContent("player_interaction", entry)
						end
					elseif (actiontype == "comm") then
						if not entry.active then
							if C.IsComponentClass(menu.componentSlot.component, "controllable") and GetControlEntity(convertedComponent) then
								entry.mouseOverText = ReadText(1026, 7802)
							else
								entry.mouseOverText = ReadText(1026, 7801)
							end
						else
							entry.mouseOverText = ffi.string(C.GetMappedInputName("INPUT_ACTION_COMM_ACTION"))
						end
						menu.insertInteractionContent("interaction", entry)
					elseif (actiontype == "detach") then
						if GetComponentData(convertedComponent, "isdeployable") and (#menu.selectedplayerdeployables > 1) then
							local isactive = GetComponentData(convertedComponent, "isactive")
							menu.insertInteractionContent("main", { text = isactive and ReadText(1001, 7883) or ReadText(1001, 7882), text2 = string.format(ReadText(1001, 7884), #menu.selectedplayerdeployables), helpOverlayID = "interactmenu_detach", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonActivateDeployables(isactive) end,  })
						else
							entry.helpOverlayID = "interactmenu_deactivatesatellite"
							entry.helpOverlayText = " "
							entry.helpOverlayHighlightOnly = true
							menu.checkPlayerActivity = true
							menu.insertInteractionContent("main", entry)
						end
					elseif (actiontype == "info") then
						entry.mouseOverText = ffi.string(C.GetMappedInputName("INPUT_ACTION_INFO_ACTION"))
						menu.insertInteractionContent("main", entry)
					elseif (actiontype == "matchspeed") then
						if not entry.active then
							entry.mouseOverText = ReadText(1026, 7802)
						else
							entry.mouseOverText = ffi.string(C.GetMappedInputName("INPUT_STATE_MATCH_SPEED"))
						end
						menu.insertInteractionContent("main", entry)
					elseif actiontype == "tow" then
						if not entry.active then
							if not C.CanBeTowed(menu.componentSlot.component) then
								entry.mouseOverText = ReadText(1026, 7859)
							else
								entry.mouseOverText = ReadText(1026, 7814)
							end
						end
						menu.insertInteractionContent("main", entry)
					elseif (actiontype == "ejectrecyclable") then
						local scrapbuffer = GetComponentData(convertedComponent, "scrapbuffer")
						entry.mouseOverText = ReadText(20201, 6801) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(scrapbuffer, true, 0, true)
						menu.insertInteractionContent("main_orders", entry)
					else
						menu.insertInteractionContent("main", entry)
					end
				end
			end
		end

		for _, entries in pairs(menu.actions) do
			if #entries > 0 then
				hasanydisplayed = true
			end
		end

		if menu.componentMissions and (type(menu.componentMissions) == "table") then
			for _, missionid in ipairs(menu.componentMissions) do
				local missiondetails = C.GetMissionIDDetails(missionid)
				if ffi.string(missiondetails.mainType) ~= "guidance" then
					menu.insertInteractionContent("main", { text = ReadText(1001, 7850) .. " (" .. ffi.string(missiondetails.missionName) .. ")", script = function () return menu.buttonMissionShow(missionid) end, active = true })
				end
			end
		end
	end

	if menu.componentOrder then
		hasanydisplayed = true
		-- orders (not action based at all)
		menu.insertInteractionContent("order", { type = "removethisorder", text = ReadText(1001, 7831), helpOverlayID = "interactmenu_removethisorder", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonRemoveOrder, active = (menu.componentOrder.queueidx > 0) and C.RemoveOrder(menu.componentSlot.component, menu.componentOrder.queueidx, false, true), mouseOverText = (menu.componentOrder.queueidx == 0) and ReadText(1026, 7844) or "" })
		-- Remove all orders
		local hasremoveableorders = false
		local numorders = C.GetNumOrders(menu.componentSlot.component)
		local currentorders = ffi.new("Order[?]", numorders)
		numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
		for i = numorders, 1, -1 do
			local isdocked, isdocking = GetComponentData(convertedComponent, "isdocked", "isdocking")
			if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
				-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
			else
				if C.RemoveOrder(menu.componentSlot.component, i, false, true) then
					hasremoveableorders = true
					break
				end
			end
		end
		local mouseovertext = hasremoveableorders and ReadText(1026, 7841) or ReadText(1026, 7833)
		menu.insertInteractionContent("order", { type = "removeallorders", text = ReadText(1001, 7832), script = function () return menu.buttonRemoveAllOrders(false, false) end, active = hasremoveableorders, mouseOverText = mouseovertext })

		local currentdefaultorder = ffi.new("Order")
		if C.GetDefaultOrder(currentdefaultorder, menu.componentSlot.component) then
			if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
				hasremoveableorders = true
			end
		end
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.componentSlot.component, hasloop)
		if hasloop[0] then
			hasremoveableorders = true
		end

		local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
		if commander and (commander ~= 0) and (commander ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))) then
			hasremoveableorders = true
		end
		mouseovertext = hasremoveableorders and ReadText(1026, 7834) or ReadText(1026, 7835)
		menu.insertInteractionContent("order", { type = "removeallordersandwait", text = ReadText(1001, 7874), script = function () return menu.buttonRemoveAllOrders(true, true) end, active = hasremoveableorders, mouseOverText = mouseovertext })
	elseif menu.syncpoint then
		hasanydisplayed = true
		menu.insertInteractionContent("syncpoint", { type = "triggersyncpoint", text = ReadText(1001, 3232), script = function () return menu.buttonTriggerSyncPoint() end, active = C.GetNumObjectsWithSyncPoint(menu.syncpoint, true) > 0 })
		menu.insertInteractionContent("syncpoint", { type = "syncpointrelease", text = function () return ReadText(1001, 11297) .. ReadText(1001, 120) .. " " .. (C.GetSyncPointAutoRelease(menu.syncpoint, true) and ReadText(1001, 2617) or ReadText(1001, 2618)) end, script = function () return menu.buttonSyncPointAutoRelease() end })
	elseif menu.syncpointorder then
		hasanydisplayed = true
		menu.insertInteractionContent("order", { type = "removethisorder", text = ReadText(1001, 7831), helpOverlayID = "interactmenu_removethisorder", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonRemoveOrder, active = (menu.syncpointorder.queueidx > 0) and C.RemoveOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, false, true), mouseOverText = (menu.syncpointorder.queueidx == 0) and ReadText(1026, 7844) or "" })
		menu.insertInteractionContent("syncpoint", { type = "triggersyncpoint", text = ReadText(1001, 3232), script = function () return menu.buttonTriggerSyncPoint() end, active = C.GetNumObjectsWithSyncPointFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, true) > 0 })
		menu.insertInteractionContent("syncpoint", { type = "syncpointrelease", text = function () return ReadText(1001, 11297) .. ReadText(1001, 120) .. " " .. (C.GetSyncPointAutoReleaseFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, true) and ReadText(1001, 2617) or ReadText(1001, 2618)) end, script = function () return menu.buttonSyncPointAutoRelease() end })
	elseif menu.intersectordefencegroup then
		hasanydisplayed = true
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11137), script = function () return menu.buttonSubordinateGroupInterSectorDefence(menu.intersectordefencegroup, true) end })
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11138), checkbox = C.ShouldSubordinateGroupAttackOnSight(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupAttackOnSight(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7860) })
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11139), checkbox = C.ShouldSubordinateGroupResupplyAtFleet(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupResupplyAtFleet(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7861) })
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11140), checkbox = C.ShouldSubordinateGroupReinforceFleet(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupReinforceFleet(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7862) })
	elseif menu.mission then
		hasanydisplayed = true
		local missiondetails = C.GetMissionIDDetails(menu.mission)
		if ffi.string(missiondetails.mainType) == "guidance" then
			menu.insertInteractionContent("guidance", { text = ReadText(1001, 3243), script = menu.buttonEndGuidance, active = true })
		else
			local active = menu.mission == C.GetActiveMissionID()
			local buf = {}
			Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, menu.mission)
			for _, submission in ipairs(buf) do
				if submission == C.GetActiveMissionID() then
					active = true
				end
			end

			menu.insertInteractionContent("guidance", { text = active and ReadText(1001, 3413) or ReadText(1001, 3406), script = active and menu.buttonMissionSetInactive or (function () return menu.buttonMissionSetActive(menu.mission) end), active = true })

			local active = missiondetails.abortable
			if missiondetails.threadMissionID ~= 0 then
				local details = C.GetMissionIDDetails(missiondetails.threadMissionID)
				active = active and (ffi.string(details.threadType) ~= "sequential")
			end

			menu.insertInteractionContent("guidance", { text = ReadText(1001, 3407), script = function () return menu.buttonMissionAbort(menu.mission) end, active = active })
			--menu.insertInteractionContent("guidance", { text = ReadText(1001, 7850), script = function () return menu.buttonMissionShow(menu.mission) end, active = true })
			local missionid = menu.mission
			if missiondetails.threadMissionID ~= 0 then
				missionid = ConvertStringTo64Bit(tostring(missiondetails.threadMissionID))
			end
			menu.insertInteractionContent("guidance", { text = ReadText(1001, 3326), script = function () return menu.buttonMissionBriefing(missionid, false) end, active = true })
		end
	elseif menu.missionoffer then
		hasanydisplayed = true
		local active = true
		local mouseovertext
		if C.IsMissionLimitReached(false, false, false) then
			active = false
			mouseovertext = ReadText(1026, 3242)
		end
		menu.insertInteractionContent("guidance", { text = ReadText(1001, 57), script = function () return menu.buttonMissionAccept(menu.missionoffer) end, active = active, mouseOverText = mouseovertext })
		menu.insertInteractionContent("guidance", { text = ReadText(1001, 3326), script = function () return menu.buttonMissionBriefing(menu.missionoffer, true) end, active = true })
	elseif menu.construction then
		hasanydisplayed = true
		-- construction (not action based at all)
		menu.insertInteractionContent("main", { text = ReadText(1001, 7853), script = menu.buttonCancelConstruction, active = C.CanCancelConstruction(menu.componentSlot.component, menu.construction.id) and ((menu.construction.factionid == "player") or GetComponentData(convertedComponent, "isplayerowned")) })
		if menu.construction.amount and (menu.construction.amount > 1) then
			local cancelcount = menu.getCanCancelConstructionCount()
			menu.insertInteractionContent("main", { text = ReadText(1041, 10022), text2 = (cancelcount > 0) and (cancelcount .. ReadText(1001, 42) .. " " .. GetMacroData(menu.construction.macro, "name")) or "", script = menu.buttonCancelAllConstruction, active = (cancelcount > 1) and ((menu.construction.factionid == "player") or GetComponentData(convertedComponent, "isplayerowned")) })
		end
	elseif menu.subordinategroup then
		hasanydisplayed = true
		-- subordinate group (not action based at all)
		local isplayerowned = GetComponentData(convertedComponent, "isplayerowned")
		local groups = menu.getSubordinatesInGroups(menu.componentSlot.component, C.IsComponentClass(menu.componentSlot.component, "station"))
		menu.groupShips = {}
		if groups[menu.subordinategroup] and #groups[menu.subordinategroup].subordinates then
			menu.groupShips = groups[menu.subordinategroup].subordinates
		end

		local allresupplier = true
		local allmining = true
		local allnomining = true
		local alltugs = true
		for _, shipentry in ipairs(menu.groupShips) do
			local purpose, shiptype = GetComponentData(shipentry.component, "primarypurpose", "shiptype")
			if shiptype ~= "resupplier" then
				allresupplier = false
			end
			if purpose == "mine" then
				allnomining = false
			end
			if purpose ~= "mine" then
				allmining = false
			end
			if shiptype ~= "tug" then
				alltugs = false
			end
		end

		if isplayerowned then
			-- select
			menu.insertInteractionContent("main", { text = ReadText(1001, 11100), script = menu.buttonSelectSubordinateGroup })
			-- inter-sector defense
			local shiptype = GetComponentData(convertedComponent, "shiptype")
			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			local subordinates = GetSubordinates(convertedComponent)
			local isfleetcommander = (not commander) and (#subordinates > 0)
			if (#menu.selectedplayerships == 0) and (shiptype == "carrier") and isfleetcommander then
				local isintersectorgroup = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, menu.subordinategroup)) == "positiondefence"
				menu.insertInteractionContent("main", { text = isintersectorgroup and ReadText(1001, 11137) or ReadText(1001, 11136), script = function () return menu.buttonSubordinateGroupInterSectorDefence(menu.subordinategroup, isintersectorgroup) end })
			end
			-- manage assignments
			local isstation = C.IsComponentClass(menu.componentSlot.component, "station")
			local isship = C.IsComponentClass(menu.componentSlot.component, "ship")
			-- defence
			menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonChangeAssignment, groups, isstation, isstation)
			-- supplyfleet
			if allresupplier then
				menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonChangeAssignment, groups, isstation, true)
			end
			if isstation then
				-- trading
				menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, nil, (not allnomining) and (Helper.convertColorToText(Helper.color.warningorange) .. ReadText(1026, 8607)) or "")
				if allmining then
					-- mining
					menu.insertAssignSubActions("main_assignments_mining", "mining", menu.buttonChangeAssignment, groups, isstation, true)
				elseif allnomining then
					-- trading for buildstorage
					menu.insertAssignSubActions("main_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonChangeAssignment, groups, isstation, true)
				end
				if alltugs then
					menu.insertAssignSubActions("main_assignments_salvage", "salvage", menu.buttonChangeAssignment, groups, isstation, true)
				end
			elseif isship then
				menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonChangeAssignment, groups, isstation, nil)
				menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonChangeAssignment, groups, isstation, nil)
				menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonChangeAssignment, groups, isstation, nil)
				menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonChangeAssignment, groups, isstation, true)
				local buf = ffi.new("Order")
				if C.GetDefaultOrder(buf, menu.componentSlot.component) then
					menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonChangeAssignment, groups, isstation, true)
				end
				if GetComponentData(convertedComponent, "shiptype") == "resupplier" then
					menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true)
				end
			end

			local assignment = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, menu.subordinategroup))
			menu.insertInteractionContent("selected_orders", { text = ReadText(1001, 11122), text2 = string.format(ReadText(1001, 8398), ReadText(20401, menu.subordinategroup)), script = function () return menu.buttonAssignCommander(assignment, menu.subordinategroup) end })
		else
			menu.insertInteractionContent("main", { text = ReadText(1001, 7852), active = false })
		end
	end
	if menu.mode == "shipconsole" then
		hasanydisplayed = true
		-- ship console at dockingbay (not action based at all)
		local shipconsoleparent = menu.isdockedship and C.GetContextByClass(menu.componentSlot.component, "dockingbay", false) or menu.componentSlot.component
		local hasdockingbayref = C.IsComponentClass(shipconsoleparent, "dockingbay")
		local iscontainer = C.IsComponentClass(shipconsoleparent, "container")
		local container = iscontainer and shipconsoleparent or C.GetContextByClass(shipconsoleparent, "container", false)
		local dockedships = {}
		Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, container, "player")
		local hasinternalstorage = false
		for _, dockedship in ipairs(dockedships) do
			if not C.IsShipAtExternalDock(dockedship) then
				if hasdockingbayref then
					hasinternalstorage = C.CanDockAtDockingBay(dockedship, shipconsoleparent)
				else
					hasinternalstorage = C.TakeShipFromInternalStorage(dockedship, false, true)
				end
				if hasinternalstorage then
					break
				end
			end
		end
		menu.insertInteractionContent("shipconsole", { text = ReadText(1001, 7879), script = menu.buttonRequestShip, active = hasinternalstorage and (not iscontainer), mouseOverText = (not hasinternalstorage) and ReadText(1026, 7831) or (iscontainer and ReadText(1026, 7832) or "") })
	end
	return hasanydisplayed
end

function menu.prepareTexts()
	menu.texts = {}
	menu.colors = {}

	if menu.componentSlot.component ~= 0 then
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		menu.buildstorage = ConvertIDTo64Bit(GetComponentData(convertedComponent, "buildstorage"))
		local playerObject = C.GetPlayerObjectID()

		local idcode = ""
		if C.IsComponentClass(menu.componentSlot.component, "object") then
			idcode = " (" .. ffi.string(C.GetObjectIDCode(menu.componentSlot.component)) .. ")"
		end
		local sectorprefix = ""
		if C.IsComponentClass(menu.componentSlot.component, "sector") then
			sectorprefix = ReadText(20001, 201) .. ReadText(1001, 120) .. " "
		end
		local gatedestination = ""
		if C.IsComponentClass(menu.componentSlot.component, "gate") then
			local gatedestinationid = GetComponentData(convertedComponent, "destination")
			if gatedestinationid then
				gatedestinationid = ConvertStringTo64Bit(tostring(GetComponentData(gatedestinationid, "sectorid")))
				gatedestination = ReadText(1001, 120) .. " " .. Helper.unlockInfo(GetComponentData(convertedComponent, "isactive") and C.IsInfoUnlockedForPlayer(gatedestinationid, "name"), ffi.string(C.GetComponentName(gatedestinationid)))
			end
			idcode = ""
		end
		local iswreck = C.IsComponentWrecked(menu.componentSlot.component)
		local name_unlocked = IsInfoUnlockedForPlayer(convertedComponent, "name")
		menu.texts.targetShortName = iswreck and ReadText(1001, 27) or Helper.unlockInfo(name_unlocked, ffi.string(C.GetComponentName(menu.componentSlot.component)))
		menu.texts.targetName = sectorprefix .. Helper.unlockInfo(name_unlocked, ffi.string(C.GetComponentName(menu.componentSlot.component)) .. gatedestination .. idcode)
		local isplayerowned, isenemy, ishostile = GetComponentData(convertedComponent, "isplayerowned", "isenemy", "ishostile")
		menu.colors.target = Helper.color.white
		if iswreck then
			menu.colors.target = Helper.color.grey
		elseif isplayerowned then
			menu.colors.target = (menu.componentSlot.component == playerObject) and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
		elseif ishostile then
			menu.colors.target = menu.holomapcolor.hostilecolor
		elseif isenemy then
			menu.colors.target = menu.holomapcolor.enemycolor
		end
		menu.texts.targetName = string.format("\027#FF%02x%02x%02x#%s", menu.colors.target.r, menu.colors.target.g, menu.colors.target.b, menu.texts.targetName)
		if C.IsComponentClass(menu.componentSlot.component, "ship") then
			menu.texts.targetBaseName = Helper.unlockInfo(name_unlocked, GetComponentData(convertedComponent, "basename"))
		end

		if menu.construction then
			if menu.construction.component ~= 0 then
				menu.texts.constructionName = ffi.string(C.GetComponentName(menu.construction.component))
			elseif menu.construction.macro ~= "" then
				menu.texts.constructionName = GetMacroData(menu.construction.macro, "name")
			end
		end

		if C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			if commander and commander ~= 0 then
				menu.texts.commanderShortName = Helper.unlockInfo(IsInfoUnlockedForPlayer(commander, "name"), ffi.string(C.GetComponentName(commander)))
				local idcode = ""
				if C.IsComponentClass(commander, "object") then
					idcode = " (" .. ffi.string(C.GetObjectIDCode(commander)) .. ")"
				end
				menu.texts.commanderName = sectorprefix .. Helper.unlockInfo(IsInfoUnlockedForPlayer(commander, "name"), ffi.string(C.GetComponentName(commander)) .. idcode)
				menu.colors.commander = GetComponentData(commander, "isplayerowned") and ((commander == playerObject) and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor) or Helper.color.white
				menu.texts.commanderShortName = string.format("\027#FF%02x%02x%02x#%s", menu.colors.commander.r, menu.colors.commander.g, menu.colors.commander.b, menu.texts.commanderShortName)
				menu.texts.commanderName = string.format("\027#FF%02x%02x%02x#%s", menu.colors.commander.r, menu.colors.commander.g, menu.colors.commander.b, menu.texts.commanderName)
			end
		end
	
		menu.texts.selectedFullNames = ""
		if #menu.selectedplayerships > 0 then
			menu.texts.selectedName = GetComponentData(menu.selectedplayerships[1], "name")
			if #menu.selectedplayerships > 1 then
				menu.texts.selectedName = string.format(ReadText(1001, 7801), #menu.selectedplayerships)
			end
			menu.colors.selected = (menu.selectedplayerships[1] == playerObject) and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
			local first = true
			for _, selectedcomponent in ipairs(menu.selectedplayerships) do
				local isCurrentPlayerObject = (selectedcomponent == playerObject)
				local color = isCurrentPlayerObject and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
				menu.texts.selectedFullNames = menu.texts.selectedFullNames .. (first and "" or "\n") .. string.format("\027#FF%02x%02x%02x#%s", color.r, color.g, color.b, GetComponentData(selectedcomponent, "name") .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")" .. (isCurrentPlayerObject and (" (" .. ReadText(1001, 7836) .. ")") or ""))
				first = false
			end
		end
		-- count the interacted object here too
		if isplayerowned and C.IsRealComponentClass(menu.componentSlot.component, "ship") then
			menu.texts.selectedNameAll = string.format(ReadText(1001, 7801), #menu.selectedplayerships + 1)
			local isCurrentPlayerObject = (convertedComponent == playerObject)
			local color = isCurrentPlayerObject and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
			menu.texts.selectedFullNamesAll = menu.texts.selectedFullNames .. "\n" .. string.format("\027#FF%02x%02x%02x#%s", color.r, color.g, color.b, GetComponentData(convertedComponent, "name") .. " (" .. ffi.string(C.GetObjectIDCode(convertedComponent)) .. ")" .. ((isCurrentPlayerObject) and (" (" .. ReadText(1001, 7836) .. ")") or ""))
		end

		if #menu.selectedotherobjects > 0 then
			menu.texts.otherName = GetComponentData(menu.selectedotherobjects[1], "name")
			if #menu.selectedotherobjects > 1 then
				menu.texts.otherName = string.format(ReadText(1001, 11105), #menu.selectedotherobjects)
			end
			menu.texts.otherFullNames = ""
			local first = true
			for _, selectedcomponent in ipairs(menu.selectedotherobjects) do
				local color = Helper.color.white
				menu.texts.otherFullNames = menu.texts.otherFullNames .. (first and "" or "\n") .. string.format("\027#FF%02x%02x%02x#%s", color.r, color.g, color.b, GetComponentData(selectedcomponent, "name") .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")")
				first = false
			end
		end

		if menu.buildstorage then
			local name_unlocked = IsInfoUnlockedForPlayer(menu.buildstorage, "name")
			menu.texts.buildstorageName = Helper.unlockInfo(name_unlocked, ffi.string(C.GetComponentName(menu.buildstorage)))
			menu.texts.buildstorageFullName = Helper.convertColorToText(menu.colors.target) .. menu.texts.buildstorageName .. " (" .. ffi.string(C.GetObjectIDCode(menu.buildstorage)) .. ")"
		end

		menu.texts.ventureName = ""
		menu.colors.venture = Helper.color.green
		if #menu.ventureships > 0 then
			menu.texts.ventureName = GetComponentData(menu.ventureships[1], "name")
			if #menu.ventureships > 1 then
				menu.texts.ventureName = string.format(ReadText(1001, 7801), #menu.ventureships)
			end
		end
	elseif menu.syncpoint then
		menu.texts.targetShortName = ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. Helper.getSyncPointName(menu.syncpoint)
	elseif menu.mission then
		local missiondetails = C.GetMissionIDDetails(menu.mission)
		menu.texts.targetShortName = ffi.string(missiondetails.missionName)
	elseif menu.missionoffer then
		menu.texts.targetShortName = GetMissionOfferDetails(ConvertStringToLuaID(menu.missionoffer))
	end
end

function menu.areTurretsArmed(defensible)
	local turrets = {}
	local numslots = tonumber(C.GetNumUpgradeSlots(defensible, "", "turret"))
	for j = 1, numslots do
		local groupinfo = C.GetUpgradeSlotGroup(defensible, "", "turret", j)
		if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
			local current = C.GetUpgradeSlotCurrentComponent(defensible, "turret", j)
			if current ~= 0 then
				table.insert(turrets, current)
			end
		end
	end

	local turretgroups = {}
	local n = C.GetNumUpgradeGroups(defensible, "")
	local buf = ffi.new("UpgradeGroup2[?]", n)
	n = C.GetUpgradeGroups2(buf, n, defensible, "")
	for i = 0, n - 1 do
		if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
			local group = { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }
			local groupinfo = C.GetUpgradeGroupInfo2(defensible, "", group.context, group.path, group.group, "turret")
			if (groupinfo.count > 0) then
				group.operational = groupinfo.operational
				group.currentmacro = ffi.string(groupinfo.currentmacro)
				group.slotsize = ffi.string(groupinfo.slotsize)
				table.insert(turretgroups, group)
			end
		end
	end

	local alldisarmed = true
	for i, turret in ipairs(turrets) do
		if C.IsWeaponArmed(turret) then
			alldisarmed = false
			break
		end
	end
	for i, group in ipairs(turretgroups) do
		if group.operational > 0 then
			if C.IsTurretGroupArmed(defensible, group.context, group.path, group.group) then
				alldisarmed = false
				break
			end
		end
	end
	return not alldisarmed
end

function menu.orderIconText(orderid)
	if menu.orderdefs[orderid] and (menu.orderdefs[orderid].icon ~= "") then
		return "\27[" .. menu.orderdefs[orderid].icon .. "] "
	end
	return ""
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	local curTime = getElapsedTime()
	if menu.mode ~= "shipconsole" then
		if (GetControllerInfo() ~= "gamepad") or C.IsMouseEmulationActive() then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.onCloseElement("close")
				return
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.onCloseElement("close")
				return
			end
		end
	elseif C.IsComponentClass(menu.componentSlot.component, "dockingbay") then
		if (not menu.dockingbayReserveTime) or (menu.dockingbayReserveTime < curTime) then
			C.SetDockingBayReservation(menu.componentSlot.component, 5.0)
			menu.dockingbayReserveTime = curTime + 4.0
		end
	end

	if menu.checkPlayerActivity then
		local playerActivity = GetPlayerActivity()
		if playerActivity ~= menu.currentActivity then
			if (playerActivity == "scan") or (menu.currentActivity == "scan") then
				if not menu.prepareActions() then
					-- no actions found
					menu.onCloseElement("close")
					return
				end
				menu.refresh = true
			end
			menu.currentActivity = playerActivity
		end
	end

	if menu.pendingSubSection and (menu.lastSubSectionTime + config.subsectionDelay < curTime) then
		if menu.pendingSubSection == -1 then
			menu.subsection = nil
		else
			menu.subsection = menu.pendingSubSection
		end
		menu.pendingSubSection = nil
		menu.refresh = true
	end

	if menu.refresh then
		menu.refresh = nil
		menu.lock = curTime
		menu.selectedRows.contentTable = Helper.currentTableRow[menu.contentTable]
		menu.topRows.contentTable = GetTopRow(menu.contentTable)
		menu.draw()
		return
	end
	if menu.lock and (menu.lock + 0.1 < curTime) then
		menu.lock = nil
	end

	menu.frame:update()
end


-- helper hooks

function menu.onButtonOver(uitable, row, col, button)
	if uitable == menu.contentTable then
		local data = menu.rowDataMap[uitable][row]
		if (not menu.lock) or (menu.subsection and (type(data) == "table") and (menu.subsection.id ~= data.id)) then
			menu.handleSubSectionOption(data, false)
		else
			menu.lock = nil
		end
	end
end

function menu.onCloseElement(dueToClose, layer, allowAutoMenu)
	if dueToClose == "back" then
		if menu.subsection then
			menu.subsection = nil
			menu.refresh = true
			return
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenu(menu, dueToClose, allowAutoMenu, false)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.interactMenuCallbacks.onTableMouseOut(menu.currentOverTable)
		Helper.resetInteractMenuCallbacks()
		menu.cleanup()
	end
end

function menu.onRowChanged()
	menu.lock = getElapsedTime()
end

function menu.onTableMouseOut(uitable, row)
	menu.pendingSubSection = nil
	if not menu.shown then
		Helper.interactMenuCallbacks.onTableMouseOut(uitable, row)
	end
end

function menu.onTableMouseOver(uitable, row)
	if not menu.shown then
		menu.currentOverTable = uitable
		Helper.interactMenuCallbacks.onTableMouseOver(uitable, row)
	end
end

function menu.viewCreated(layer, ...)
	menu.contentTable = ...
end

-- kuetee start:
function menu.registerCallback (callbackName, callbackFunction)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	-- available callbacks:
	-- none yet
	--
	if callbacks [callbackName] == nil then
		callbacks [callbackName] = {}
	end
	table.insert (callbacks [callbackName], callbackFunction)
end

local newCustomGroupId
local newCustomGroupText
function menu.Add_Custom_Actions_Group_Id(_, id)
	newCustomGroupId = id
	if newCustomGroupId and newCustomGroupText then
		menu.Add_Custom_Actions_Group(newCustomGroupId, newCustomGroupText)
		newCustomGroupId = nil
		newCustomGroupText = nil
	end
end

function menu.Add_Custom_Actions_Group_Text(_, text)
	newCustomGroupText = text
	if newCustomGroupId and newCustomGroupText then
		menu.Add_Custom_Actions_Group(newCustomGroupId, newCustomGroupText)
		newCustomGroupId = nil
		newCustomGroupText = nil
	end
end

function menu.Add_Custom_Actions_Group(id, text)
	local customActionsSection
	local customActionsSection_isFound = false
	local customActionsSection_isAddTo = string.find(id, "actions_")
	local customOrdersSection
	local customOrdersSection_isFound = false
	local customOrdersSection_isAddTo = string.find(id, "orders_")
	if (not customActionsSection_isAddTo) and (not customOrdersSection_isAddTo) then
		customActionsSection_isAddTo = true
		customOrdersSection_isAddTo = true
	end
	Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_Group id: " .. tostring(id) .. " text: " .. tostring(text))
	for _, section in ipairs(config.sections) do
		if section.id == "custom_actions" or section.id == "custom_orders" then
			Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_Group    section.id: ", section.id)
			if section.id == "custom_actions" then
				customActionsSection = section
			else
				customOrdersSection = section
			end
			for _, subsection in ipairs(section.subsections) do
				Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_Group        subsection.id: ", subsection.id)
				if subsection.id == id then
					if section.id == "custom_actions" then
						customActionsSection_isFound = true
					else
						customOrdersSection_isFound = true
					end
					Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_Group customActionsSection.subsections", customActionsSection.subsections)
				end
			end
		end
	end
	Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_GroupcustomActionsSection_isFound: ", customActionsSection_isFound)
	Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_GroupcustomOrdersSection_isFound: ", customOrdersSection_isFound)
	if customActionsSection and customActionsSection_isAddTo and (not customActionsSection_isFound) then
		table.insert (customActionsSection.subsections, {id = id, text = text})
		Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_Group customActionsSection.subsections", customActionsSection.subsections)
	end
	if customOrdersSection and customOrdersSection_isAddTo and (not customOrdersSection_isFound) then
		table.insert (customOrdersSection.subsections, {id = id, text = text})
		Helper.debugText("menu_interactmenu.xpl.Add_Custom_Actions_Group customOrdersSection.subsections", customOrdersSection.subsections)
	end
end
-- kuertee end

init()
-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.local ffi = require ("ffi")
local C = ffi.C
local Lib = require ("extensions.sn_mod_support_apis.lua_interface").Library
local topLevelMenu = Lib.Get_Egosoft_Menu ("TopLevelMenu")
local menu = topLevelMenu
local newFuncs = {}
local kHUD = {}
local isInited
local function init ()
	DebugError ("kuertee_hud.init")
	if not isInited then
		isInited = true
		topLevelMenu.registerCallback ("createInfoFrame_on_before_frame_display", newFuncs.createInfoFrame_on_before_frame_display)
	end
end
function newFuncs.createInfoFrame_on_before_frame_display (frame)
	if not topLevelMenu.showTabs then
		kHUD.createTables (frame)
	end
end
function kHUD.createTables (frame)
	-- set frame properties
	frame.properties.width = Helper.viewWidth
	frame.properties.x = 0
	local yBottom = 0
	-- get top level arrows
	local ftable
	local topLevelArrowsTable
	for i = 1, #frame.content do
		if frame.content [i].type == "table" then
			topLevelArrowsTable = frame.content [i]
			break
		end
	end
	topLevelArrowsTable.properties.x = frame.properties.width / 2 - topLevelMenu.width / 2
	yBottom = topLevelArrowsTable.properties.y + topLevelArrowsTable:getFullHeight ()
	-- Lib.Print_Table (topLevelArrowsTable)
	-- create new HUDs
	local lastTableYBottom
	if false then
		-- create kHUD label table for test purposes
		ftable = frame:addTable (
			1,
			{
				width = 100,
				height = 100,
				x = 0,
				y = 0,
				scaling = true
			}
		)
		local row = ftable:addRow (false, {bgColor = Helper.color.transparent60})
		row [1]:createText ("kHUD", {halign = "center", color = Helper.standardColor})
	end
	local ftableIndex = #frame.content + 1
	if topLevelMenu.callbacks ["kHUD_add_HUD_tables"] then
		for i, callback in ipairs (topLevelMenu.callbacks ["kHUD_add_HUD_tables"]) do
			result = callback (frame)
			if result then
				for i, ftable in ipairs (result.ftables) do
					ftableIndex = ftableIndex + 1
				end
			end
		end
	end
end
init ()
﻿-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.function init()
	AddUITriggeredEvent ("UIXInteractMenu", "loaded")
end
init()
﻿-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.﻿-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.﻿-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.﻿-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.-- purposely empty. file left for backward compatibility with mods that try to load this custom lua file.